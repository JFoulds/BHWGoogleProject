# This file automatically generated by protocol-compiler from location/country/telephonenumber.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

class TelephoneNumber(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 3546500 

  _TypeId_NAMES = {
    3546500: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.country_code_ = 0
    self.national_prefix_ = ""
    self.area_code_ = ""
    self.number_ = []
    self.extension_ = ""
    self.has_country_code_ = 0
    self.has_national_prefix_ = 0
    self.has_area_code_ = 0
    self.has_extension_ = 0
    if contents is not None: self.MergeFromString(contents)

  def country_code(self): return self.country_code_

  def set_country_code(self, x):
    self.has_country_code_ = 1
    self.country_code_ = x

  def clear_country_code(self):
    self.has_country_code_ = 0
    self.country_code_ = 0

  def has_country_code(self): return self.has_country_code_

  def national_prefix(self): return self.national_prefix_

  def set_national_prefix(self, x):
    self.has_national_prefix_ = 1
    self.national_prefix_ = x

  def clear_national_prefix(self):
    self.has_national_prefix_ = 0
    self.national_prefix_ = ""

  def has_national_prefix(self): return self.has_national_prefix_

  def area_code(self): return self.area_code_

  def set_area_code(self, x):
    self.has_area_code_ = 1
    self.area_code_ = x

  def clear_area_code(self):
    self.has_area_code_ = 0
    self.area_code_ = ""

  def has_area_code(self): return self.has_area_code_

  def number_size(self): return len(self.number_)
  def number_list(self): return self.number_

  def number(self, i):
    return self.number_[i]

  def set_number(self, i, x):
    self.number_[i] = x

  def add_number(self, x):
    self.number_.append(x)

  def clear_number(self):
    self.number_ = []

  def extension(self): return self.extension_

  def set_extension(self, x):
    self.has_extension_ = 1
    self.extension_ = x

  def clear_extension(self):
    self.has_extension_ = 0
    self.extension_ = ""

  def has_extension(self): return self.has_extension_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_country_code()): self.set_country_code(x.country_code())
    if (x.has_national_prefix()): self.set_national_prefix(x.national_prefix())
    if (x.has_area_code()): self.set_area_code(x.area_code())
    for i in xrange(x.number_size()): self.add_number(x.number(i))
    if (x.has_extension()): self.set_extension(x.extension())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'TelephoneNumber', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'TelephoneNumber')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'TelephoneNumber', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'TelephoneNumber', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'TelephoneNumber', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_country_code_ != x.has_country_code_: return 0
    if self.has_country_code_ and self.country_code_ != x.country_code_: return 0
    if self.has_national_prefix_ != x.has_national_prefix_: return 0
    if self.has_national_prefix_ and self.national_prefix_ != x.national_prefix_: return 0
    if self.has_area_code_ != x.has_area_code_: return 0
    if self.has_area_code_ and self.area_code_ != x.area_code_: return 0
    if len(self.number_) != len(x.number_): return 0
    for e1, e2 in zip(self.number_, x.number_):
      if e1 != e2: return 0
    if self.has_extension_ != x.has_extension_: return 0
    if self.has_extension_ and self.extension_ != x.extension_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_country_code_): n += 1 + self.lengthVarInt64(self.country_code_)
    if (self.has_national_prefix_): n += 1 + self.lengthString(len(self.national_prefix_))
    if (self.has_area_code_): n += 1 + self.lengthString(len(self.area_code_))
    n += 1 * len(self.number_)
    for i in xrange(len(self.number_)): n += self.lengthString(len(self.number_[i]))
    if (self.has_extension_): n += 1 + self.lengthString(len(self.extension_))
    return n + 0

  def Clear(self):
    self.clear_country_code()
    self.clear_national_prefix()
    self.clear_area_code()
    self.clear_number()
    self.clear_extension()

  def OutputUnchecked(self, out):
    if (self.has_country_code_):
      out.putVarInt32(8)
      out.putVarInt32(self.country_code_)
    if (self.has_national_prefix_):
      out.putVarInt32(18)
      out.putPrefixedString(self.national_prefix_)
    if (self.has_area_code_):
      out.putVarInt32(26)
      out.putPrefixedString(self.area_code_)
    for i in xrange(len(self.number_)):
      out.putVarInt32(34)
      out.putPrefixedString(self.number_[i])
    if (self.has_extension_):
      out.putVarInt32(42)
      out.putPrefixedString(self.extension_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_country_code(d.getVarInt32())
        continue
      if tt == 18:
        self.set_national_prefix(d.getPrefixedString())
        continue
      if tt == 26:
        self.set_area_code(d.getPrefixedString())
        continue
      if tt == 34:
        self.add_number(d.getPrefixedString())
        continue
      if tt == 42:
        self.set_extension(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_country_code_: res+=prefix+("country_code: %s\n" % self.DebugFormatInt32(self.country_code_))
    if self.has_national_prefix_: res+=prefix+("national_prefix: %s\n" % self.DebugFormatString(self.national_prefix_))
    if self.has_area_code_: res+=prefix+("area_code: %s\n" % self.DebugFormatString(self.area_code_))
    cnt=0
    for e in self.number_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("number%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_extension_: res+=prefix+("extension: %s\n" % self.DebugFormatString(self.extension_))
    return res

  kcountry_code = 1
  knational_prefix = 2
  karea_code = 3
  knumber = 4
  kextension = 5

  _TEXT = (
   "ErrorCode",  #   0
   "country_code",  #   1
   "national_prefix",  #   2
   "area_code",  #   3
   "number",  #   4
   "extension",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x26,
    0x6c,
    0x6f,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2f,
    0x63,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x72,
    0x79,
    0x2f,
    0x74,
    0x65,
    0x6c,
    0x65,
    0x70,
    0x68,
    0x6f,
    0x6e,
    0x65,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0f,
    0x54,
    0x65,
    0x6c,
    0x65,
    0x70,
    0x68,
    0x6f,
    0x6e,
    0x65,
    0x4e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x13,
    0x1a,
    0x0c,
    0x63,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x72,
    0x79,
    0x5f,
    0x63,
    0x6f,
    0x64,
    0x65,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x6e,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x6c,
    0x5f,
    0x70,
    0x72,
    0x65,
    0x66,
    0x69,
    0x78,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x61,
    0x72,
    0x65,
    0x61,
    0x5f,
    0x63,
    0x6f,
    0x64,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x65,
    0x78,
    0x74,
    0x65,
    0x6e,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0x84,
    0xbb,
    0xd8,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['TelephoneNumber']
