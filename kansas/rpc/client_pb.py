# This file automatically generated by protocol-compiler from kansas/rpc/client.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python
try:
  __import__('google3.net.rpc.python.rpc_internals')
  __import__('google3.net.rpc.python.pywraprpc')
  import sys
  rpc_internals = sys.modules.get('google3.net.rpc.python.rpc_internals')
  pywraprpc = sys.modules.get('google3.net.rpc.python.pywraprpc')
  _client_stub_base_class = rpc_internals.StubbyRPCBaseStub
except ImportError:
  _client_stub_base_class = object

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

class ResponseCodes(ProtocolBuffer.ProtocolMessage):

  OK           =    0 
  BAD_REQUEST  =    1 
  BAD_VERSIONINFO_DEPRECATED =    2 
  NO_SUCH_USER =    3 
  BACKEND_FAILURE =    4 
  APPLICATION_REJECTED =    5 
  USER_REJECTED =    6 
  UNSUPPORTED_SERVICE =    7 
  QUOTA_EXCEEDED =    8 
  USER_IS_DELETED =    9 
  DEADLINE_EXCEEDED =   10 
  DATATYPE_ERROR =   11 
  RESULT_TOO_LARGE =   12 
  PARTIAL_FAILURE =   13 
  NUM_MESSAGE_CODES =   14 

  _MessageResponseCode_NAMES = {
    0: "OK",
    1: "BAD_REQUEST",
    2: "BAD_VERSIONINFO_DEPRECATED",
    3: "NO_SUCH_USER",
    4: "BACKEND_FAILURE",
    5: "APPLICATION_REJECTED",
    6: "USER_REJECTED",
    7: "UNSUPPORTED_SERVICE",
    8: "QUOTA_EXCEEDED",
    9: "USER_IS_DELETED",
    10: "DEADLINE_EXCEEDED",
    11: "DATATYPE_ERROR",
    12: "RESULT_TOO_LARGE",
    13: "PARTIAL_FAILURE",
    14: "NUM_MESSAGE_CODES",
  }

  def MessageResponseCode_Name(cls, x): return cls._MessageResponseCode_NAMES.get(x, "")
  MessageResponseCode_Name = classmethod(MessageResponseCode_Name)


  SUCCESS      =    0 
  DATATYPE_NOT_FOUND =    1 
  PERMISSION_DENIED =    2 
  DATATYPE_NOT_RECORDED =    3 
  NOT_CONSISTENT =    4 
  MAX_WIDTH_EXCEEDED =    5 
  UNPARSEABLE  =    6 
  NUM_ELEMENT_CODES =    7 

  _ElementResponseCode_NAMES = {
    0: "SUCCESS",
    1: "DATATYPE_NOT_FOUND",
    2: "PERMISSION_DENIED",
    3: "DATATYPE_NOT_RECORDED",
    4: "NOT_CONSISTENT",
    5: "MAX_WIDTH_EXCEEDED",
    6: "UNPARSEABLE",
    7: "NUM_ELEMENT_CODES",
  }

  def ElementResponseCode_Name(cls, x): return cls._ElementResponseCode_NAMES.get(x, "")
  ElementResponseCode_Name = classmethod(ElementResponseCode_Name)

  def __init__(self, contents=None):
    pass
    if contents is not None: self.MergeFromString(contents)


  def MergeFrom(self, x):
    assert x is not self

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.ResponseCodes', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.ResponseCodes')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.ResponseCodes', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.ResponseCodes', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.ResponseCodes', s)


  def Equals(self, x):
    if x is self: return 1
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    return n + 0

  def Clear(self):
    pass

  def OutputUnchecked(self, out):
    pass

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    return res


  _TEXT = (
   "ErrorCode",  #   0
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x14,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x43,
    0x6f,
    0x64,
    0x65,
    0x73,
    0x73,
    0x7a,
    0x13,
    0x4d,
    0x65,
    0x73,
    0x73,
    0x61,
    0x67,
    0x65,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x43,
    0x6f,
    0x64,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x02,
    0x4f,
    0x4b,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x42,
    0x41,
    0x44,
    0x5f,
    0x52,
    0x45,
    0x51,
    0x55,
    0x45,
    0x53,
    0x54,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x1a,
    0x42,
    0x41,
    0x44,
    0x5f,
    0x56,
    0x45,
    0x52,
    0x53,
    0x49,
    0x4f,
    0x4e,
    0x49,
    0x4e,
    0x46,
    0x4f,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x4e,
    0x4f,
    0x5f,
    0x53,
    0x55,
    0x43,
    0x48,
    0x5f,
    0x55,
    0x53,
    0x45,
    0x52,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x42,
    0x41,
    0x43,
    0x4b,
    0x45,
    0x4e,
    0x44,
    0x5f,
    0x46,
    0x41,
    0x49,
    0x4c,
    0x55,
    0x52,
    0x45,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x14,
    0x41,
    0x50,
    0x50,
    0x4c,
    0x49,
    0x43,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x52,
    0x45,
    0x4a,
    0x45,
    0x43,
    0x54,
    0x45,
    0x44,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x55,
    0x53,
    0x45,
    0x52,
    0x5f,
    0x52,
    0x45,
    0x4a,
    0x45,
    0x43,
    0x54,
    0x45,
    0x44,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x13,
    0x55,
    0x4e,
    0x53,
    0x55,
    0x50,
    0x50,
    0x4f,
    0x52,
    0x54,
    0x45,
    0x44,
    0x5f,
    0x53,
    0x45,
    0x52,
    0x56,
    0x49,
    0x43,
    0x45,
    0x98,
    0x01,
    0x07,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x51,
    0x55,
    0x4f,
    0x54,
    0x41,
    0x5f,
    0x45,
    0x58,
    0x43,
    0x45,
    0x45,
    0x44,
    0x45,
    0x44,
    0x98,
    0x01,
    0x08,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x55,
    0x53,
    0x45,
    0x52,
    0x5f,
    0x49,
    0x53,
    0x5f,
    0x44,
    0x45,
    0x4c,
    0x45,
    0x54,
    0x45,
    0x44,
    0x98,
    0x01,
    0x09,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x44,
    0x45,
    0x41,
    0x44,
    0x4c,
    0x49,
    0x4e,
    0x45,
    0x5f,
    0x45,
    0x58,
    0x43,
    0x45,
    0x45,
    0x44,
    0x45,
    0x44,
    0x98,
    0x01,
    0x0a,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x44,
    0x41,
    0x54,
    0x41,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x45,
    0x52,
    0x52,
    0x4f,
    0x52,
    0x98,
    0x01,
    0x0b,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x52,
    0x45,
    0x53,
    0x55,
    0x4c,
    0x54,
    0x5f,
    0x54,
    0x4f,
    0x4f,
    0x5f,
    0x4c,
    0x41,
    0x52,
    0x47,
    0x45,
    0x98,
    0x01,
    0x0c,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x50,
    0x41,
    0x52,
    0x54,
    0x49,
    0x41,
    0x4c,
    0x5f,
    0x46,
    0x41,
    0x49,
    0x4c,
    0x55,
    0x52,
    0x45,
    0x98,
    0x01,
    0x0d,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x4e,
    0x55,
    0x4d,
    0x5f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x43,
    0x4f,
    0x44,
    0x45,
    0x53,
    0x98,
    0x01,
    0x0e,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x13,
    0x45,
    0x6c,
    0x65,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x43,
    0x6f,
    0x64,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x53,
    0x55,
    0x43,
    0x43,
    0x45,
    0x53,
    0x53,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x44,
    0x41,
    0x54,
    0x41,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x4e,
    0x4f,
    0x54,
    0x5f,
    0x46,
    0x4f,
    0x55,
    0x4e,
    0x44,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x50,
    0x45,
    0x52,
    0x4d,
    0x49,
    0x53,
    0x53,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x44,
    0x45,
    0x4e,
    0x49,
    0x45,
    0x44,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x15,
    0x44,
    0x41,
    0x54,
    0x41,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x4e,
    0x4f,
    0x54,
    0x5f,
    0x52,
    0x45,
    0x43,
    0x4f,
    0x52,
    0x44,
    0x45,
    0x44,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x4e,
    0x4f,
    0x54,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x53,
    0x49,
    0x53,
    0x54,
    0x45,
    0x4e,
    0x54,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x4d,
    0x41,
    0x58,
    0x5f,
    0x57,
    0x49,
    0x44,
    0x54,
    0x48,
    0x5f,
    0x45,
    0x58,
    0x43,
    0x45,
    0x45,
    0x44,
    0x45,
    0x44,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x55,
    0x4e,
    0x50,
    0x41,
    0x52,
    0x53,
    0x45,
    0x41,
    0x42,
    0x4c,
    0x45,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x4e,
    0x55,
    0x4d,
    0x5f,
    0x45,
    0x4c,
    0x45,
    0x4d,
    0x45,
    0x4e,
    0x54,
    0x5f,
    0x43,
    0x4f,
    0x44,
    0x45,
    0x53,
    0x98,
    0x01,
    0x07,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class UserKeyProto(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 1867521 

  _TypeId_NAMES = {
    1867521: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.service_ = ""
    self.id_ = ""
    self.has_service_ = 0
    self.has_id_ = 0
    if contents is not None: self.MergeFromString(contents)

  def service(self): return self.service_

  def set_service(self, x):
    self.has_service_ = 1
    self.service_ = x

  def clear_service(self):
    self.has_service_ = 0
    self.service_ = ""

  def has_service(self): return self.has_service_

  def id(self): return self.id_

  def set_id(self, x):
    self.has_id_ = 1
    self.id_ = x

  def clear_id(self):
    self.has_id_ = 0
    self.id_ = ""

  def has_id(self): return self.has_id_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_service()): self.set_service(x.service())
    if (x.has_id()): self.set_id(x.id())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.UserKeyProto', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.UserKeyProto')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.UserKeyProto', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.UserKeyProto', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.UserKeyProto', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_service_ != x.has_service_: return 0
    if self.has_service_ and self.service_ != x.service_: return 0
    if self.has_id_ != x.has_id_: return 0
    if self.has_id_ and self.id_ != x.id_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_service_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: service not set.')
    if (not self.has_id_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: id not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.service_))
    n += self.lengthString(len(self.id_))
    return n + 2

  def Clear(self):
    self.clear_service()
    self.clear_id()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.service_)
    out.putVarInt32(18)
    out.putPrefixedString(self.id_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_service(d.getPrefixedString())
        continue
      if tt == 18:
        self.set_id(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_service_: res+=prefix+("Service: %s\n" % self.DebugFormatString(self.service_))
    if self.has_id_: res+=prefix+("Id: %s\n" % self.DebugFormatString(self.id_))
    return res

  kService = 1
  kId = 2

  _TEXT = (
   "ErrorCode",  #   0
   "Service",  #   1
   "Id",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x13,
    0x1a,
    0x07,
    0x53,
    0x65,
    0x72,
    0x76,
    0x69,
    0x63,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x02,
    0x49,
    0x64,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0x81,
    0xfe,
    0x71,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class RequestHeader(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.versioninfo_ = ""
    self.applicationid_ = ""
    self.applicationdata_ = ""
    self.internaluser_ = 0
    self.proxieduser_ = ""
    self.tablerestrict_ = []
    self.has_user_ = 0
    self.has_versioninfo_ = 0
    self.has_applicationid_ = 0
    self.has_applicationdata_ = 0
    self.has_internaluser_ = 0
    self.has_proxieduser_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def versioninfo(self): return self.versioninfo_

  def set_versioninfo(self, x):
    self.has_versioninfo_ = 1
    self.versioninfo_ = x

  def clear_versioninfo(self):
    self.has_versioninfo_ = 0
    self.versioninfo_ = ""

  def has_versioninfo(self): return self.has_versioninfo_

  def applicationid(self): return self.applicationid_

  def set_applicationid(self, x):
    self.has_applicationid_ = 1
    self.applicationid_ = x

  def clear_applicationid(self):
    self.has_applicationid_ = 0
    self.applicationid_ = ""

  def has_applicationid(self): return self.has_applicationid_

  def applicationdata(self): return self.applicationdata_

  def set_applicationdata(self, x):
    self.has_applicationdata_ = 1
    self.applicationdata_ = x

  def clear_applicationdata(self):
    self.has_applicationdata_ = 0
    self.applicationdata_ = ""

  def has_applicationdata(self): return self.has_applicationdata_

  def internaluser(self): return self.internaluser_

  def set_internaluser(self, x):
    self.has_internaluser_ = 1
    self.internaluser_ = x

  def clear_internaluser(self):
    self.has_internaluser_ = 0
    self.internaluser_ = 0

  def has_internaluser(self): return self.has_internaluser_

  def proxieduser(self): return self.proxieduser_

  def set_proxieduser(self, x):
    self.has_proxieduser_ = 1
    self.proxieduser_ = x

  def clear_proxieduser(self):
    self.has_proxieduser_ = 0
    self.proxieduser_ = ""

  def has_proxieduser(self): return self.has_proxieduser_

  def tablerestrict_size(self): return len(self.tablerestrict_)
  def tablerestrict_list(self): return self.tablerestrict_

  def tablerestrict(self, i):
    return self.tablerestrict_[i]

  def set_tablerestrict(self, i, x):
    self.tablerestrict_[i] = x

  def add_tablerestrict(self, x):
    self.tablerestrict_.append(x)

  def clear_tablerestrict(self):
    self.tablerestrict_ = []


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_versioninfo()): self.set_versioninfo(x.versioninfo())
    if (x.has_applicationid()): self.set_applicationid(x.applicationid())
    if (x.has_applicationdata()): self.set_applicationdata(x.applicationdata())
    if (x.has_internaluser()): self.set_internaluser(x.internaluser())
    if (x.has_proxieduser()): self.set_proxieduser(x.proxieduser())
    for i in xrange(x.tablerestrict_size()): self.add_tablerestrict(x.tablerestrict(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.RequestHeader', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.RequestHeader')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.RequestHeader', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.RequestHeader', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.RequestHeader', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_versioninfo_ != x.has_versioninfo_: return 0
    if self.has_versioninfo_ and self.versioninfo_ != x.versioninfo_: return 0
    if self.has_applicationid_ != x.has_applicationid_: return 0
    if self.has_applicationid_ and self.applicationid_ != x.applicationid_: return 0
    if self.has_applicationdata_ != x.has_applicationdata_: return 0
    if self.has_applicationdata_ and self.applicationdata_ != x.applicationdata_: return 0
    if self.has_internaluser_ != x.has_internaluser_: return 0
    if self.has_internaluser_ and self.internaluser_ != x.internaluser_: return 0
    if self.has_proxieduser_ != x.has_proxieduser_: return 0
    if self.has_proxieduser_ and self.proxieduser_ != x.proxieduser_: return 0
    if len(self.tablerestrict_) != len(x.tablerestrict_): return 0
    for e1, e2 in zip(self.tablerestrict_, x.tablerestrict_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_applicationid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: applicationid not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    if (self.has_versioninfo_): n += 1 + self.lengthString(len(self.versioninfo_))
    n += self.lengthString(len(self.applicationid_))
    if (self.has_applicationdata_): n += 1 + self.lengthString(len(self.applicationdata_))
    if (self.has_internaluser_): n += 2
    if (self.has_proxieduser_): n += 1 + self.lengthString(len(self.proxieduser_))
    n += 1 * len(self.tablerestrict_)
    for i in xrange(len(self.tablerestrict_)): n += self.lengthString(len(self.tablerestrict_[i]))
    return n + 2

  def Clear(self):
    self.clear_user()
    self.clear_versioninfo()
    self.clear_applicationid()
    self.clear_applicationdata()
    self.clear_internaluser()
    self.clear_proxieduser()
    self.clear_tablerestrict()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    if (self.has_versioninfo_):
      out.putVarInt32(18)
      out.putPrefixedString(self.versioninfo_)
    out.putVarInt32(26)
    out.putPrefixedString(self.applicationid_)
    if (self.has_applicationdata_):
      out.putVarInt32(34)
      out.putPrefixedString(self.applicationdata_)
    if (self.has_internaluser_):
      out.putVarInt32(40)
      out.putBoolean(self.internaluser_)
    if (self.has_proxieduser_):
      out.putVarInt32(50)
      out.putPrefixedString(self.proxieduser_)
    for i in xrange(len(self.tablerestrict_)):
      out.putVarInt32(58)
      out.putPrefixedString(self.tablerestrict_[i])

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 18:
        self.set_versioninfo(d.getPrefixedString())
        continue
      if tt == 26:
        self.set_applicationid(d.getPrefixedString())
        continue
      if tt == 34:
        self.set_applicationdata(d.getPrefixedString())
        continue
      if tt == 40:
        self.set_internaluser(d.getBoolean())
        continue
      if tt == 50:
        self.set_proxieduser(d.getPrefixedString())
        continue
      if tt == 58:
        self.add_tablerestrict(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_versioninfo_: res+=prefix+("VersionInfo: %s\n" % self.DebugFormatString(self.versioninfo_))
    if self.has_applicationid_: res+=prefix+("ApplicationId: %s\n" % self.DebugFormatString(self.applicationid_))
    if self.has_applicationdata_: res+=prefix+("ApplicationData: %s\n" % self.DebugFormatString(self.applicationdata_))
    if self.has_internaluser_: res+=prefix+("InternalUser: %s\n" % self.DebugFormatBool(self.internaluser_))
    if self.has_proxieduser_: res+=prefix+("ProxiedUser: %s\n" % self.DebugFormatString(self.proxieduser_))
    cnt=0
    for e in self.tablerestrict_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("TableRestrict%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    return res

  kUser = 1
  kVersionInfo = 2
  kApplicationId = 3
  kApplicationData = 4
  kInternalUser = 5
  kProxiedUser = 6
  kTableRestrict = 7

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "VersionInfo",  #   2
   "ApplicationId",  #   3
   "ApplicationData",  #   4
   "InternalUser",  #   5
   "ProxiedUser",  #   6
   "TableRestrict",  #   7
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.STRING,  #   7

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x14,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x56,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x49,
    0x64,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x49,
    0x6e,
    0x74,
    0x65,
    0x72,
    0x6e,
    0x61,
    0x6c,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x50,
    0x72,
    0x6f,
    0x78,
    0x69,
    0x65,
    0x64,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x54,
    0x61,
    0x62,
    0x6c,
    0x65,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x20,
    0x07,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ResponseHeader(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.versioninfovalid_ = 0
    self.versioninfo_ = ""
    self.has_versioninfovalid_ = 0
    self.has_versioninfo_ = 0
    if contents is not None: self.MergeFromString(contents)

  def versioninfovalid(self): return self.versioninfovalid_

  def set_versioninfovalid(self, x):
    self.has_versioninfovalid_ = 1
    self.versioninfovalid_ = x

  def clear_versioninfovalid(self):
    self.has_versioninfovalid_ = 0
    self.versioninfovalid_ = 0

  def has_versioninfovalid(self): return self.has_versioninfovalid_

  def versioninfo(self): return self.versioninfo_

  def set_versioninfo(self, x):
    self.has_versioninfo_ = 1
    self.versioninfo_ = x

  def clear_versioninfo(self):
    self.has_versioninfo_ = 0
    self.versioninfo_ = ""

  def has_versioninfo(self): return self.has_versioninfo_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_versioninfovalid()): self.set_versioninfovalid(x.versioninfovalid())
    if (x.has_versioninfo()): self.set_versioninfo(x.versioninfo())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.ResponseHeader', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.ResponseHeader')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.ResponseHeader', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.ResponseHeader', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.ResponseHeader', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_versioninfovalid_ != x.has_versioninfovalid_: return 0
    if self.has_versioninfovalid_ and self.versioninfovalid_ != x.versioninfovalid_: return 0
    if self.has_versioninfo_ != x.has_versioninfo_: return 0
    if self.has_versioninfo_ and self.versioninfo_ != x.versioninfo_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_versioninfovalid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: versioninfovalid not set.')
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_versioninfo_): n += 1 + self.lengthString(len(self.versioninfo_))
    return n + 2

  def Clear(self):
    self.clear_versioninfovalid()
    self.clear_versioninfo()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putBoolean(self.versioninfovalid_)
    if (self.has_versioninfo_):
      out.putVarInt32(18)
      out.putPrefixedString(self.versioninfo_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_versioninfovalid(d.getBoolean())
        continue
      if tt == 18:
        self.set_versioninfo(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_versioninfovalid_: res+=prefix+("VersionInfoValid: %s\n" % self.DebugFormatBool(self.versioninfovalid_))
    if self.has_versioninfo_: res+=prefix+("VersionInfo: %s\n" % self.DebugFormatString(self.versioninfo_))
    return res

  kVersionInfoValid = 1
  kVersionInfo = 2

  _TEXT = (
   "ErrorCode",  #   0
   "VersionInfoValid",  #   1
   "VersionInfo",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x15,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x13,
    0x1a,
    0x10,
    0x56,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x56,
    0x61,
    0x6c,
    0x69,
    0x64,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x56,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class LookupRequest_DataLimits(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.maxrecords_ = 0
    self.mintimestampusec_ = 0
    self.maxtimestampusec_ = 0
    self.has_maxrecords_ = 0
    self.has_mintimestampusec_ = 0
    self.has_maxtimestampusec_ = 0
    if contents is not None: self.MergeFromString(contents)

  def maxrecords(self): return self.maxrecords_

  def set_maxrecords(self, x):
    self.has_maxrecords_ = 1
    self.maxrecords_ = x

  def clear_maxrecords(self):
    self.has_maxrecords_ = 0
    self.maxrecords_ = 0

  def has_maxrecords(self): return self.has_maxrecords_

  def mintimestampusec(self): return self.mintimestampusec_

  def set_mintimestampusec(self, x):
    self.has_mintimestampusec_ = 1
    self.mintimestampusec_ = x

  def clear_mintimestampusec(self):
    self.has_mintimestampusec_ = 0
    self.mintimestampusec_ = 0

  def has_mintimestampusec(self): return self.has_mintimestampusec_

  def maxtimestampusec(self): return self.maxtimestampusec_

  def set_maxtimestampusec(self, x):
    self.has_maxtimestampusec_ = 1
    self.maxtimestampusec_ = x

  def clear_maxtimestampusec(self):
    self.has_maxtimestampusec_ = 0
    self.maxtimestampusec_ = 0

  def has_maxtimestampusec(self): return self.has_maxtimestampusec_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_maxrecords()): self.set_maxrecords(x.maxrecords())
    if (x.has_mintimestampusec()): self.set_mintimestampusec(x.mintimestampusec())
    if (x.has_maxtimestampusec()): self.set_maxtimestampusec(x.maxtimestampusec())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.LookupRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.LookupRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.LookupRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.LookupRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.LookupRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_maxrecords_ != x.has_maxrecords_: return 0
    if self.has_maxrecords_ and self.maxrecords_ != x.maxrecords_: return 0
    if self.has_mintimestampusec_ != x.has_mintimestampusec_: return 0
    if self.has_mintimestampusec_ and self.mintimestampusec_ != x.mintimestampusec_: return 0
    if self.has_maxtimestampusec_ != x.has_maxtimestampusec_: return 0
    if self.has_maxtimestampusec_ and self.maxtimestampusec_ != x.maxtimestampusec_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_maxrecords_): n += 1 + self.lengthVarInt64(self.maxrecords_)
    if (self.has_mintimestampusec_): n += 1 + self.lengthVarInt64(self.mintimestampusec_)
    if (self.has_maxtimestampusec_): n += 1 + self.lengthVarInt64(self.maxtimestampusec_)
    return n + 0

  def Clear(self):
    self.clear_maxrecords()
    self.clear_mintimestampusec()
    self.clear_maxtimestampusec()

  def OutputUnchecked(self, out):
    if (self.has_maxrecords_):
      out.putVarInt32(40)
      out.putVarInt32(self.maxrecords_)
    if (self.has_mintimestampusec_):
      out.putVarInt32(88)
      out.putVarInt64(self.mintimestampusec_)
    if (self.has_maxtimestampusec_):
      out.putVarInt32(96)
      out.putVarInt64(self.maxtimestampusec_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 36: break
      if tt == 40:
        self.set_maxrecords(d.getVarInt32())
        continue
      if tt == 88:
        self.set_mintimestampusec(d.getVarInt64())
        continue
      if tt == 96:
        self.set_maxtimestampusec(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_maxrecords_: res+=prefix+("MaxRecords: %s\n" % self.DebugFormatInt32(self.maxrecords_))
    if self.has_mintimestampusec_: res+=prefix+("MinTimestampUsec: %s\n" % self.DebugFormatInt64(self.mintimestampusec_))
    if self.has_maxtimestampusec_: res+=prefix+("MaxTimestampUsec: %s\n" % self.DebugFormatInt64(self.maxtimestampusec_))
    return res

class LookupRequest_Data(ProtocolBuffer.ProtocolMessage):

  PREFER_LATEST =    1 
  REQUIRE_LATEST =    2 
  REQUIRE_COMPLETE =    3 

  _ConsistencyRequirement_NAMES = {
    1: "PREFER_LATEST",
    2: "REQUIRE_LATEST",
    3: "REQUIRE_COMPLETE",
  }

  def ConsistencyRequirement_Name(cls, x): return cls._ConsistencyRequirement_NAMES.get(x, "")
  ConsistencyRequirement_Name = classmethod(ConsistencyRequirement_Name)

  def __init__(self, contents=None):
    self.type_ = ""
    self.subtype_ = ""
    self.fetchsubtypeprefix_ = 0
    self.fetchsubtyperegexp_ = 0
    self.limits_ = None
    self.consistencyrequirement_ = 1
    self.has_type_ = 0
    self.has_subtype_ = 0
    self.has_fetchsubtypeprefix_ = 0
    self.has_fetchsubtyperegexp_ = 0
    self.has_limits_ = 0
    self.has_consistencyrequirement_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_

  def subtype(self): return self.subtype_

  def set_subtype(self, x):
    self.has_subtype_ = 1
    self.subtype_ = x

  def clear_subtype(self):
    self.has_subtype_ = 0
    self.subtype_ = ""

  def has_subtype(self): return self.has_subtype_

  def fetchsubtypeprefix(self): return self.fetchsubtypeprefix_

  def set_fetchsubtypeprefix(self, x):
    self.has_fetchsubtypeprefix_ = 1
    self.fetchsubtypeprefix_ = x

  def clear_fetchsubtypeprefix(self):
    self.has_fetchsubtypeprefix_ = 0
    self.fetchsubtypeprefix_ = 0

  def has_fetchsubtypeprefix(self): return self.has_fetchsubtypeprefix_

  def fetchsubtyperegexp(self): return self.fetchsubtyperegexp_

  def set_fetchsubtyperegexp(self, x):
    self.has_fetchsubtyperegexp_ = 1
    self.fetchsubtyperegexp_ = x

  def clear_fetchsubtyperegexp(self):
    self.has_fetchsubtyperegexp_ = 0
    self.fetchsubtyperegexp_ = 0

  def has_fetchsubtyperegexp(self): return self.has_fetchsubtyperegexp_

  def limits(self):
    if self.limits_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.limits_ is None: self.limits_ = LookupRequest_DataLimits()
      finally:
        self.lazy_init_lock_.release()
    return self.limits_

  def mutable_limits(self): self.has_limits_ = 1; return self.limits()

  def clear_limits(self):
    #Warning: this method does not acquire the lock.
    self.has_limits_ = 0;
    if self.limits_ is not None: self.limits_.Clear()

  def has_limits(self): return self.has_limits_

  def consistencyrequirement(self): return self.consistencyrequirement_

  def set_consistencyrequirement(self, x):
    self.has_consistencyrequirement_ = 1
    self.consistencyrequirement_ = x

  def clear_consistencyrequirement(self):
    self.has_consistencyrequirement_ = 0
    self.consistencyrequirement_ = 1

  def has_consistencyrequirement(self): return self.has_consistencyrequirement_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_subtype()): self.set_subtype(x.subtype())
    if (x.has_fetchsubtypeprefix()): self.set_fetchsubtypeprefix(x.fetchsubtypeprefix())
    if (x.has_fetchsubtyperegexp()): self.set_fetchsubtyperegexp(x.fetchsubtyperegexp())
    if (x.has_limits()): self.mutable_limits().MergeFrom(x.limits())
    if (x.has_consistencyrequirement()): self.set_consistencyrequirement(x.consistencyrequirement())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.LookupRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.LookupRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.LookupRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.LookupRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.LookupRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_subtype_ != x.has_subtype_: return 0
    if self.has_subtype_ and self.subtype_ != x.subtype_: return 0
    if self.has_fetchsubtypeprefix_ != x.has_fetchsubtypeprefix_: return 0
    if self.has_fetchsubtypeprefix_ and self.fetchsubtypeprefix_ != x.fetchsubtypeprefix_: return 0
    if self.has_fetchsubtyperegexp_ != x.has_fetchsubtyperegexp_: return 0
    if self.has_fetchsubtyperegexp_ and self.fetchsubtyperegexp_ != x.fetchsubtyperegexp_: return 0
    if self.has_limits_ != x.has_limits_: return 0
    if self.has_limits_ and self.limits_ != x.limits_: return 0
    if self.has_consistencyrequirement_ != x.has_consistencyrequirement_: return 0
    if self.has_consistencyrequirement_ and self.consistencyrequirement_ != x.consistencyrequirement_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (self.has_limits_ and not self.limits_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.type_))
    if (self.has_subtype_): n += 1 + self.lengthString(len(self.subtype_))
    if (self.has_fetchsubtypeprefix_): n += 2
    if (self.has_fetchsubtyperegexp_): n += 2
    if (self.has_limits_): n += 2 + self.limits_.ByteSize()
    if (self.has_consistencyrequirement_): n += 1 + self.lengthVarInt64(self.consistencyrequirement_)
    return n + 1

  def Clear(self):
    self.clear_type()
    self.clear_subtype()
    self.clear_fetchsubtypeprefix()
    self.clear_fetchsubtyperegexp()
    self.clear_limits()
    self.clear_consistencyrequirement()

  def OutputUnchecked(self, out):
    out.putVarInt32(26)
    out.putPrefixedString(self.type_)
    if (self.has_limits_):
      out.putVarInt32(35)
      self.limits_.OutputUnchecked(out)
      out.putVarInt32(36)
    if (self.has_consistencyrequirement_):
      out.putVarInt32(64)
      out.putVarInt32(self.consistencyrequirement_)
    if (self.has_subtype_):
      out.putVarInt32(106)
      out.putPrefixedString(self.subtype_)
    if (self.has_fetchsubtypeprefix_):
      out.putVarInt32(112)
      out.putBoolean(self.fetchsubtypeprefix_)
    if (self.has_fetchsubtyperegexp_):
      out.putVarInt32(120)
      out.putBoolean(self.fetchsubtyperegexp_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 26:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 35:
        self.mutable_limits().TryMerge(d)
        continue
      if tt == 64:
        self.set_consistencyrequirement(d.getVarInt32())
        continue
      if tt == 106:
        self.set_subtype(d.getPrefixedString())
        continue
      if tt == 112:
        self.set_fetchsubtypeprefix(d.getBoolean())
        continue
      if tt == 120:
        self.set_fetchsubtyperegexp(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    if self.has_subtype_: res+=prefix+("SubType: %s\n" % self.DebugFormatString(self.subtype_))
    if self.has_fetchsubtypeprefix_: res+=prefix+("FetchSubTypePrefix: %s\n" % self.DebugFormatBool(self.fetchsubtypeprefix_))
    if self.has_fetchsubtyperegexp_: res+=prefix+("FetchSubTypeRegexp: %s\n" % self.DebugFormatBool(self.fetchsubtyperegexp_))
    if self.has_limits_:
      res+=prefix+"Limits {\n"
      res+=self.limits_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_consistencyrequirement_: res+=prefix+("ConsistencyRequirement: %s\n" % self.DebugFormatInt32(self.consistencyrequirement_))
    return res

class LookupRequest_MetaData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = ""
    self.has_type_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.LookupRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.LookupRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.LookupRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.LookupRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.LookupRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.type_))
    return n + 1

  def Clear(self):
    self.clear_type()

  def OutputUnchecked(self, out):
    out.putVarInt32(82)
    out.putPrefixedString(self.type_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 76: break
      if tt == 82:
        self.set_type(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    return res

class LookupRequest(ProtocolBuffer.ProtocolMessage):

  NO_CACHEFILL =    0 
  CACHEFILL    =    1 

  _CachefillEnum_NAMES = {
    0: "NO_CACHEFILL",
    1: "CACHEFILL",
  }

  def CachefillEnum_Name(cls, x): return cls._CachefillEnum_NAMES.get(x, "")
  CachefillEnum_Name = classmethod(CachefillEnum_Name)

  def __init__(self, contents=None):
    self.header_ = RequestHeader()
    self.cachefill_ = 0
    self.cacheagelimitmsec_ = 0
    self.data_ = []
    self.metadata_ = []
    self.allowpartialfailures_ = 0
    self.has_header_ = 0
    self.has_cachefill_ = 0
    self.has_cacheagelimitmsec_ = 0
    self.has_allowpartialfailures_ = 0
    if contents is not None: self.MergeFromString(contents)

  def header(self): return self.header_

  def mutable_header(self): self.has_header_ = 1; return self.header_

  def clear_header(self):self.has_header_ = 0; self.header_.Clear()

  def has_header(self): return self.has_header_

  def cachefill(self): return self.cachefill_

  def set_cachefill(self, x):
    self.has_cachefill_ = 1
    self.cachefill_ = x

  def clear_cachefill(self):
    self.has_cachefill_ = 0
    self.cachefill_ = 0

  def has_cachefill(self): return self.has_cachefill_

  def cacheagelimitmsec(self): return self.cacheagelimitmsec_

  def set_cacheagelimitmsec(self, x):
    self.has_cacheagelimitmsec_ = 1
    self.cacheagelimitmsec_ = x

  def clear_cacheagelimitmsec(self):
    self.has_cacheagelimitmsec_ = 0
    self.cacheagelimitmsec_ = 0

  def has_cacheagelimitmsec(self): return self.has_cacheagelimitmsec_

  def data_size(self): return len(self.data_)
  def data_list(self): return self.data_

  def data(self, i):
    return self.data_[i]

  def mutable_data(self, i):
    return self.data_[i]

  def add_data(self):
    x = LookupRequest_Data()
    self.data_.append(x)
    return x

  def clear_data(self):
    self.data_ = []
  def metadata_size(self): return len(self.metadata_)
  def metadata_list(self): return self.metadata_

  def metadata(self, i):
    return self.metadata_[i]

  def mutable_metadata(self, i):
    return self.metadata_[i]

  def add_metadata(self):
    x = LookupRequest_MetaData()
    self.metadata_.append(x)
    return x

  def clear_metadata(self):
    self.metadata_ = []
  def allowpartialfailures(self): return self.allowpartialfailures_

  def set_allowpartialfailures(self, x):
    self.has_allowpartialfailures_ = 1
    self.allowpartialfailures_ = x

  def clear_allowpartialfailures(self):
    self.has_allowpartialfailures_ = 0
    self.allowpartialfailures_ = 0

  def has_allowpartialfailures(self): return self.has_allowpartialfailures_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_header()): self.mutable_header().MergeFrom(x.header())
    if (x.has_cachefill()): self.set_cachefill(x.cachefill())
    if (x.has_cacheagelimitmsec()): self.set_cacheagelimitmsec(x.cacheagelimitmsec())
    for i in xrange(x.data_size()): self.add_data().CopyFrom(x.data(i))
    for i in xrange(x.metadata_size()): self.add_metadata().CopyFrom(x.metadata(i))
    if (x.has_allowpartialfailures()): self.set_allowpartialfailures(x.allowpartialfailures())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.LookupRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.LookupRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.LookupRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.LookupRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.LookupRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_header_ != x.has_header_: return 0
    if self.has_header_ and self.header_ != x.header_: return 0
    if self.has_cachefill_ != x.has_cachefill_: return 0
    if self.has_cachefill_ and self.cachefill_ != x.cachefill_: return 0
    if self.has_cacheagelimitmsec_ != x.has_cacheagelimitmsec_: return 0
    if self.has_cacheagelimitmsec_ and self.cacheagelimitmsec_ != x.cacheagelimitmsec_: return 0
    if len(self.data_) != len(x.data_): return 0
    for e1, e2 in zip(self.data_, x.data_):
      if e1 != e2: return 0
    if len(self.metadata_) != len(x.metadata_): return 0
    for e1, e2 in zip(self.metadata_, x.metadata_):
      if e1 != e2: return 0
    if self.has_allowpartialfailures_ != x.has_allowpartialfailures_: return 0
    if self.has_allowpartialfailures_ and self.allowpartialfailures_ != x.allowpartialfailures_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_header_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: header not set.')
    elif not self.header_.IsInitialized(debug_strs): initialized = 0
    for i in xrange(len(self.data_)):
      if (not self.data_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.metadata_)):
      if (not self.metadata_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.header_.ByteSize())
    if (self.has_cachefill_): n += 2 + self.lengthVarInt64(self.cachefill_)
    if (self.has_cacheagelimitmsec_): n += 2 + self.lengthVarInt64(self.cacheagelimitmsec_)
    n += 2 * len(self.data_)
    for i in xrange(len(self.data_)): n += self.data_[i].ByteSize()
    n += 2 * len(self.metadata_)
    for i in xrange(len(self.metadata_)): n += self.metadata_[i].ByteSize()
    if (self.has_allowpartialfailures_): n += 3
    return n + 1

  def Clear(self):
    self.clear_header()
    self.clear_cachefill()
    self.clear_cacheagelimitmsec()
    self.clear_data()
    self.clear_metadata()
    self.clear_allowpartialfailures()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.header_.ByteSize())
    self.header_.OutputUnchecked(out)
    for i in xrange(len(self.data_)):
      out.putVarInt32(19)
      self.data_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    for i in xrange(len(self.metadata_)):
      out.putVarInt32(75)
      self.metadata_[i].OutputUnchecked(out)
      out.putVarInt32(76)
    if (self.has_allowpartialfailures_):
      out.putVarInt32(128)
      out.putBoolean(self.allowpartialfailures_)
    if (self.has_cachefill_):
      out.putVarInt32(136)
      out.putVarInt32(self.cachefill_)
    if (self.has_cacheagelimitmsec_):
      out.putVarInt32(144)
      out.putVarInt64(self.cacheagelimitmsec_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_header().TryMerge(tmp)
        continue
      if tt == 19:
        self.add_data().TryMerge(d)
        continue
      if tt == 75:
        self.add_metadata().TryMerge(d)
        continue
      if tt == 128:
        self.set_allowpartialfailures(d.getBoolean())
        continue
      if tt == 136:
        self.set_cachefill(d.getVarInt32())
        continue
      if tt == 144:
        self.set_cacheagelimitmsec(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_header_:
      res+=prefix+"Header <\n"
      res+=self.header_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_cachefill_: res+=prefix+("Cachefill: %s\n" % self.DebugFormatInt32(self.cachefill_))
    if self.has_cacheagelimitmsec_: res+=prefix+("CacheAgeLimitMsec: %s\n" % self.DebugFormatInt64(self.cacheagelimitmsec_))
    cnt=0
    for e in self.data_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Data%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.metadata_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("MetaData%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_allowpartialfailures_: res+=prefix+("AllowPartialFailures: %s\n" % self.DebugFormatBool(self.allowpartialfailures_))
    return res

  kHeader = 1
  kCachefill = 17
  kCacheAgeLimitMsec = 18
  kDataGroup = 2
  kDataType = 3
  kDataSubType = 13
  kDataFetchSubTypePrefix = 14
  kDataFetchSubTypeRegexp = 15
  kDataLimitsGroup = 4
  kDataLimitsMaxRecords = 5
  kDataLimitsMinTimestampUsec = 11
  kDataLimitsMaxTimestampUsec = 12
  kDataConsistencyRequirement = 8
  kMetaDataGroup = 9
  kMetaDataType = 10
  kAllowPartialFailures = 16

  _TEXT = (
   "ErrorCode",  #   0
   "Header",  #   1
   "Data",  #   2
   "Type",  #   3
   "Limits",  #   4
   "MaxRecords",  #   5
   None,  #   6
   None,  #   7
   "ConsistencyRequirement",  #   8
   "MetaData",  #   9
   "Type",  #  10
   "MinTimestampUsec",  #  11
   "MaxTimestampUsec",  #  12
   "SubType",  #  13
   "FetchSubTypePrefix",  #  14
   "FetchSubTypeRegexp",  #  15
   "AllowPartialFailures",  #  16
   "Cachefill",  #  17
   "CacheAgeLimitMsec",  #  18
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STARTGROUP,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.MAX_TYPE,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.STARTGROUP,  #   9

   ProtocolBuffer.Encoder.STRING,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

   ProtocolBuffer.Encoder.NUMERIC,  #  12

   ProtocolBuffer.Encoder.STRING,  #  13

   ProtocolBuffer.Encoder.NUMERIC,  #  14

   ProtocolBuffer.Encoder.NUMERIC,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

   ProtocolBuffer.Encoder.NUMERIC,  #  17

   ProtocolBuffer.Encoder.NUMERIC,  #  18

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x14,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x4c,
    0x6f,
    0x6f,
    0x6b,
    0x75,
    0x70,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x06,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x14,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x43,
    0x61,
    0x63,
    0x68,
    0x65,
    0x66,
    0x69,
    0x6c,
    0x6c,
    0x20,
    0x11,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x43,
    0x61,
    0x63,
    0x68,
    0x65,
    0x41,
    0x67,
    0x65,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x4d,
    0x73,
    0x65,
    0x63,
    0x20,
    0x12,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x0d,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x53,
    0x75,
    0x62,
    0x54,
    0x79,
    0x70,
    0x65,
    0x50,
    0x72,
    0x65,
    0x66,
    0x69,
    0x78,
    0x20,
    0x0e,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x03,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x53,
    0x75,
    0x62,
    0x54,
    0x79,
    0x70,
    0x65,
    0x52,
    0x65,
    0x67,
    0x65,
    0x78,
    0x70,
    0x20,
    0x0f,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x03,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x73,
    0x20,
    0x04,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x73,
    0x2e,
    0x4d,
    0x61,
    0x78,
    0x52,
    0x65,
    0x63,
    0x6f,
    0x72,
    0x64,
    0x73,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x08,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x73,
    0x2e,
    0x4d,
    0x69,
    0x6e,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x55,
    0x73,
    0x65,
    0x63,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x08,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x73,
    0x2e,
    0x4d,
    0x61,
    0x78,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x55,
    0x73,
    0x65,
    0x63,
    0x20,
    0x0c,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x08,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x69,
    0x73,
    0x74,
    0x65,
    0x6e,
    0x63,
    0x79,
    0x52,
    0x65,
    0x71,
    0x75,
    0x69,
    0x72,
    0x65,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x31,
    0x60,
    0x03,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x31,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x09,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x0a,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x41,
    0x6c,
    0x6c,
    0x6f,
    0x77,
    0x50,
    0x61,
    0x72,
    0x74,
    0x69,
    0x61,
    0x6c,
    0x46,
    0x61,
    0x69,
    0x6c,
    0x75,
    0x72,
    0x65,
    0x73,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x0d,
    0x43,
    0x61,
    0x63,
    0x68,
    0x65,
    0x66,
    0x69,
    0x6c,
    0x6c,
    0x45,
    0x6e,
    0x75,
    0x6d,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x4e,
    0x4f,
    0x5f,
    0x43,
    0x41,
    0x43,
    0x48,
    0x45,
    0x46,
    0x49,
    0x4c,
    0x4c,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x43,
    0x41,
    0x43,
    0x48,
    0x45,
    0x46,
    0x49,
    0x4c,
    0x4c,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x16,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x69,
    0x73,
    0x74,
    0x65,
    0x6e,
    0x63,
    0x79,
    0x52,
    0x65,
    0x71,
    0x75,
    0x69,
    0x72,
    0x65,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x80,
    0x01,
    0x03,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x50,
    0x52,
    0x45,
    0x46,
    0x45,
    0x52,
    0x5f,
    0x4c,
    0x41,
    0x54,
    0x45,
    0x53,
    0x54,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x52,
    0x45,
    0x51,
    0x55,
    0x49,
    0x52,
    0x45,
    0x5f,
    0x4c,
    0x41,
    0x54,
    0x45,
    0x53,
    0x54,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x52,
    0x45,
    0x51,
    0x55,
    0x49,
    0x52,
    0x45,
    0x5f,
    0x43,
    0x4f,
    0x4d,
    0x50,
    0x4c,
    0x45,
    0x54,
    0x45,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class LookupResponse_DataItem(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.subtype_ = ""
    self.timestampusec_ = 0
    self.value_ = ""
    self.has_subtype_ = 0
    self.has_timestampusec_ = 0
    self.has_value_ = 0
    if contents is not None: self.MergeFromString(contents)

  def subtype(self): return self.subtype_

  def set_subtype(self, x):
    self.has_subtype_ = 1
    self.subtype_ = x

  def clear_subtype(self):
    self.has_subtype_ = 0
    self.subtype_ = ""

  def has_subtype(self): return self.has_subtype_

  def timestampusec(self): return self.timestampusec_

  def set_timestampusec(self, x):
    self.has_timestampusec_ = 1
    self.timestampusec_ = x

  def clear_timestampusec(self):
    self.has_timestampusec_ = 0
    self.timestampusec_ = 0

  def has_timestampusec(self): return self.has_timestampusec_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_subtype()): self.set_subtype(x.subtype())
    if (x.has_timestampusec()): self.set_timestampusec(x.timestampusec())
    if (x.has_value()): self.set_value(x.value())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.LookupResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.LookupResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.LookupResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.LookupResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.LookupResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_subtype_ != x.has_subtype_: return 0
    if self.has_subtype_ and self.subtype_ != x.subtype_: return 0
    if self.has_timestampusec_ != x.has_timestampusec_: return 0
    if self.has_timestampusec_ and self.timestampusec_ != x.timestampusec_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_timestampusec_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: timestampusec not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_subtype_): n += 2 + self.lengthString(len(self.subtype_))
    n += self.lengthVarInt64(self.timestampusec_)
    n += self.lengthString(len(self.value_))
    return n + 2

  def Clear(self):
    self.clear_subtype()
    self.clear_timestampusec()
    self.clear_value()

  def OutputUnchecked(self, out):
    out.putVarInt32(66)
    out.putPrefixedString(self.value_)
    out.putVarInt32(120)
    out.putVarInt64(self.timestampusec_)
    if (self.has_subtype_):
      out.putVarInt32(130)
      out.putPrefixedString(self.subtype_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 52: break
      if tt == 66:
        self.set_value(d.getPrefixedString())
        continue
      if tt == 120:
        self.set_timestampusec(d.getVarInt64())
        continue
      if tt == 130:
        self.set_subtype(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_subtype_: res+=prefix+("SubType: %s\n" % self.DebugFormatString(self.subtype_))
    if self.has_timestampusec_: res+=prefix+("TimestampUsec: %s\n" % self.DebugFormatInt64(self.timestampusec_))
    if self.has_value_: res+=prefix+("Value: %s\n" % self.DebugFormatString(self.value_))
    return res

class LookupResponse_Data(ProtocolBuffer.ProtocolMessage):

  CONSISTENT   =    1 
  NOT_CONSISTENT =    2 
  UNKNOWN      =    3 

  _ConsistencyStatus_NAMES = {
    1: "CONSISTENT",
    2: "NOT_CONSISTENT",
    3: "UNKNOWN",
  }

  def ConsistencyStatus_Name(cls, x): return cls._ConsistencyStatus_NAMES.get(x, "")
  ConsistencyStatus_Name = classmethod(ConsistencyStatus_Name)

  def __init__(self, contents=None):
    self.responsecode_ = 0
    self.errormessage_ = ""
    self.type_ = ""
    self.consistencystatus_ = 0
    self.item_ = []
    self.has_responsecode_ = 0
    self.has_errormessage_ = 0
    self.has_type_ = 0
    self.has_consistencystatus_ = 0
    if contents is not None: self.MergeFromString(contents)

  def responsecode(self): return self.responsecode_

  def set_responsecode(self, x):
    self.has_responsecode_ = 1
    self.responsecode_ = x

  def clear_responsecode(self):
    self.has_responsecode_ = 0
    self.responsecode_ = 0

  def has_responsecode(self): return self.has_responsecode_

  def errormessage(self): return self.errormessage_

  def set_errormessage(self, x):
    self.has_errormessage_ = 1
    self.errormessage_ = x

  def clear_errormessage(self):
    self.has_errormessage_ = 0
    self.errormessage_ = ""

  def has_errormessage(self): return self.has_errormessage_

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_

  def consistencystatus(self): return self.consistencystatus_

  def set_consistencystatus(self, x):
    self.has_consistencystatus_ = 1
    self.consistencystatus_ = x

  def clear_consistencystatus(self):
    self.has_consistencystatus_ = 0
    self.consistencystatus_ = 0

  def has_consistencystatus(self): return self.has_consistencystatus_

  def item_size(self): return len(self.item_)
  def item_list(self): return self.item_

  def item(self, i):
    return self.item_[i]

  def mutable_item(self, i):
    return self.item_[i]

  def add_item(self):
    x = LookupResponse_DataItem()
    self.item_.append(x)
    return x

  def clear_item(self):
    self.item_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_responsecode()): self.set_responsecode(x.responsecode())
    if (x.has_errormessage()): self.set_errormessage(x.errormessage())
    if (x.has_type()): self.set_type(x.type())
    if (x.has_consistencystatus()): self.set_consistencystatus(x.consistencystatus())
    for i in xrange(x.item_size()): self.add_item().CopyFrom(x.item(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.LookupResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.LookupResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.LookupResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.LookupResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.LookupResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_responsecode_ != x.has_responsecode_: return 0
    if self.has_responsecode_ and self.responsecode_ != x.responsecode_: return 0
    if self.has_errormessage_ != x.has_errormessage_: return 0
    if self.has_errormessage_ and self.errormessage_ != x.errormessage_: return 0
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_consistencystatus_ != x.has_consistencystatus_: return 0
    if self.has_consistencystatus_ and self.consistencystatus_ != x.consistencystatus_: return 0
    if len(self.item_) != len(x.item_): return 0
    for e1, e2 in zip(self.item_, x.item_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_responsecode_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: responsecode not set.')
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (not self.has_consistencystatus_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: consistencystatus not set.')
    for i in xrange(len(self.item_)):
      if (not self.item_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.responsecode_)
    if (self.has_errormessage_): n += 2 + self.lengthString(len(self.errormessage_))
    n += self.lengthString(len(self.type_))
    n += self.lengthVarInt64(self.consistencystatus_)
    n += 2 * len(self.item_)
    for i in xrange(len(self.item_)): n += self.item_[i].ByteSize()
    return n + 3

  def Clear(self):
    self.clear_responsecode()
    self.clear_errormessage()
    self.clear_type()
    self.clear_consistencystatus()
    self.clear_item()

  def OutputUnchecked(self, out):
    out.putVarInt32(24)
    out.putVarInt32(self.responsecode_)
    out.putVarInt32(34)
    out.putPrefixedString(self.type_)
    out.putVarInt32(40)
    out.putVarInt32(self.consistencystatus_)
    for i in xrange(len(self.item_)):
      out.putVarInt32(51)
      self.item_[i].OutputUnchecked(out)
      out.putVarInt32(52)
    if (self.has_errormessage_):
      out.putVarInt32(138)
      out.putPrefixedString(self.errormessage_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 24:
        self.set_responsecode(d.getVarInt32())
        continue
      if tt == 34:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 40:
        self.set_consistencystatus(d.getVarInt32())
        continue
      if tt == 51:
        self.add_item().TryMerge(d)
        continue
      if tt == 138:
        self.set_errormessage(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_responsecode_: res+=prefix+("ResponseCode: %s\n" % self.DebugFormatInt32(self.responsecode_))
    if self.has_errormessage_: res+=prefix+("ErrorMessage: %s\n" % self.DebugFormatString(self.errormessage_))
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    if self.has_consistencystatus_: res+=prefix+("ConsistencyStatus: %s\n" % self.DebugFormatInt32(self.consistencystatus_))
    cnt=0
    for e in self.item_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Item%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

class LookupResponse_MetaData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = ""
    self.writesubscribed_ = 0
    self.writesubscribedexpiration_ = 0
    self.readsubscribed_ = 0
    self.has_type_ = 0
    self.has_writesubscribed_ = 0
    self.has_writesubscribedexpiration_ = 0
    self.has_readsubscribed_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_

  def writesubscribed(self): return self.writesubscribed_

  def set_writesubscribed(self, x):
    self.has_writesubscribed_ = 1
    self.writesubscribed_ = x

  def clear_writesubscribed(self):
    self.has_writesubscribed_ = 0
    self.writesubscribed_ = 0

  def has_writesubscribed(self): return self.has_writesubscribed_

  def writesubscribedexpiration(self): return self.writesubscribedexpiration_

  def set_writesubscribedexpiration(self, x):
    self.has_writesubscribedexpiration_ = 1
    self.writesubscribedexpiration_ = x

  def clear_writesubscribedexpiration(self):
    self.has_writesubscribedexpiration_ = 0
    self.writesubscribedexpiration_ = 0

  def has_writesubscribedexpiration(self): return self.has_writesubscribedexpiration_

  def readsubscribed(self): return self.readsubscribed_

  def set_readsubscribed(self, x):
    self.has_readsubscribed_ = 1
    self.readsubscribed_ = x

  def clear_readsubscribed(self):
    self.has_readsubscribed_ = 0
    self.readsubscribed_ = 0

  def has_readsubscribed(self): return self.has_readsubscribed_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_writesubscribed()): self.set_writesubscribed(x.writesubscribed())
    if (x.has_writesubscribedexpiration()): self.set_writesubscribedexpiration(x.writesubscribedexpiration())
    if (x.has_readsubscribed()): self.set_readsubscribed(x.readsubscribed())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.LookupResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.LookupResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.LookupResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.LookupResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.LookupResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_writesubscribed_ != x.has_writesubscribed_: return 0
    if self.has_writesubscribed_ and self.writesubscribed_ != x.writesubscribed_: return 0
    if self.has_writesubscribedexpiration_ != x.has_writesubscribedexpiration_: return 0
    if self.has_writesubscribedexpiration_ and self.writesubscribedexpiration_ != x.writesubscribedexpiration_: return 0
    if self.has_readsubscribed_ != x.has_readsubscribed_: return 0
    if self.has_readsubscribed_ and self.readsubscribed_ != x.readsubscribed_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (not self.has_writesubscribed_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: writesubscribed not set.')
    if (not self.has_readsubscribed_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: readsubscribed not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.type_))
    if (self.has_writesubscribedexpiration_): n += 1 + self.lengthVarInt64(self.writesubscribedexpiration_)
    return n + 5

  def Clear(self):
    self.clear_type()
    self.clear_writesubscribed()
    self.clear_writesubscribedexpiration()
    self.clear_readsubscribed()

  def OutputUnchecked(self, out):
    out.putVarInt32(82)
    out.putPrefixedString(self.type_)
    out.putVarInt32(88)
    out.putBoolean(self.writesubscribed_)
    if (self.has_writesubscribedexpiration_):
      out.putVarInt32(96)
      out.putVarInt64(self.writesubscribedexpiration_)
    out.putVarInt32(104)
    out.putBoolean(self.readsubscribed_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 76: break
      if tt == 82:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 88:
        self.set_writesubscribed(d.getBoolean())
        continue
      if tt == 96:
        self.set_writesubscribedexpiration(d.getVarInt64())
        continue
      if tt == 104:
        self.set_readsubscribed(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    if self.has_writesubscribed_: res+=prefix+("WriteSubscribed: %s\n" % self.DebugFormatBool(self.writesubscribed_))
    if self.has_writesubscribedexpiration_: res+=prefix+("WriteSubscribedExpiration: %s\n" % self.DebugFormatInt64(self.writesubscribedexpiration_))
    if self.has_readsubscribed_: res+=prefix+("ReadSubscribed: %s\n" % self.DebugFormatBool(self.readsubscribed_))
    return res

class LookupResponse(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.header_ = ResponseHeader()
    self.data_ = []
    self.metadata_ = []
    self.has_header_ = 0
    if contents is not None: self.MergeFromString(contents)

  def header(self): return self.header_

  def mutable_header(self): self.has_header_ = 1; return self.header_

  def clear_header(self):self.has_header_ = 0; self.header_.Clear()

  def has_header(self): return self.has_header_

  def data_size(self): return len(self.data_)
  def data_list(self): return self.data_

  def data(self, i):
    return self.data_[i]

  def mutable_data(self, i):
    return self.data_[i]

  def add_data(self):
    x = LookupResponse_Data()
    self.data_.append(x)
    return x

  def clear_data(self):
    self.data_ = []
  def metadata_size(self): return len(self.metadata_)
  def metadata_list(self): return self.metadata_

  def metadata(self, i):
    return self.metadata_[i]

  def mutable_metadata(self, i):
    return self.metadata_[i]

  def add_metadata(self):
    x = LookupResponse_MetaData()
    self.metadata_.append(x)
    return x

  def clear_metadata(self):
    self.metadata_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_header()): self.mutable_header().MergeFrom(x.header())
    for i in xrange(x.data_size()): self.add_data().CopyFrom(x.data(i))
    for i in xrange(x.metadata_size()): self.add_metadata().CopyFrom(x.metadata(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.LookupResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.LookupResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.LookupResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.LookupResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.LookupResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_header_ != x.has_header_: return 0
    if self.has_header_ and self.header_ != x.header_: return 0
    if len(self.data_) != len(x.data_): return 0
    for e1, e2 in zip(self.data_, x.data_):
      if e1 != e2: return 0
    if len(self.metadata_) != len(x.metadata_): return 0
    for e1, e2 in zip(self.metadata_, x.metadata_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_header_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: header not set.')
    elif not self.header_.IsInitialized(debug_strs): initialized = 0
    for i in xrange(len(self.data_)):
      if (not self.data_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.metadata_)):
      if (not self.metadata_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.header_.ByteSize())
    n += 2 * len(self.data_)
    for i in xrange(len(self.data_)): n += self.data_[i].ByteSize()
    n += 2 * len(self.metadata_)
    for i in xrange(len(self.metadata_)): n += self.metadata_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_header()
    self.clear_data()
    self.clear_metadata()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.data_)):
      out.putVarInt32(19)
      self.data_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    for i in xrange(len(self.metadata_)):
      out.putVarInt32(75)
      self.metadata_[i].OutputUnchecked(out)
      out.putVarInt32(76)
    out.putVarInt32(114)
    out.putVarInt32(self.header_.ByteSize())
    self.header_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 19:
        self.add_data().TryMerge(d)
        continue
      if tt == 75:
        self.add_metadata().TryMerge(d)
        continue
      if tt == 114:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_header().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_header_:
      res+=prefix+"Header <\n"
      res+=self.header_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.data_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Data%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.metadata_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("MetaData%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kHeader = 14
  kDataGroup = 2
  kDataResponseCode = 3
  kDataErrorMessage = 17
  kDataType = 4
  kDataConsistencyStatus = 5
  kDataItemGroup = 6
  kDataItemSubType = 16
  kDataItemTimestampUsec = 15
  kDataItemValue = 8
  kMetaDataGroup = 9
  kMetaDataType = 10
  kMetaDataWriteSubscribed = 11
  kMetaDataWriteSubscribedExpiration = 12
  kMetaDataReadSubscribed = 13

  _TEXT = (
   "ErrorCode",  #   0
   None,  #   1
   "Data",  #   2
   "ResponseCode",  #   3
   "Type",  #   4
   "ConsistencyStatus",  #   5
   "Item",  #   6
   None,  #   7
   "Value",  #   8
   "MetaData",  #   9
   "Type",  #  10
   "WriteSubscribed",  #  11
   "WriteSubscribedExpiration",  #  12
   "ReadSubscribed",  #  13
   "Header",  #  14
   "TimestampUsec",  #  15
   "SubType",  #  16
   "ErrorMessage",  #  17
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.MAX_TYPE,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.STARTGROUP,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.STARTGROUP,  #   9

   ProtocolBuffer.Encoder.STRING,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

   ProtocolBuffer.Encoder.NUMERIC,  #  12

   ProtocolBuffer.Encoder.NUMERIC,  #  13

   ProtocolBuffer.Encoder.STRING,  #  14

   ProtocolBuffer.Encoder.NUMERIC,  #  15

   ProtocolBuffer.Encoder.STRING,  #  16

   ProtocolBuffer.Encoder.STRING,  #  17

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x15,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x4c,
    0x6f,
    0x6f,
    0x6b,
    0x75,
    0x70,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x13,
    0x1a,
    0x06,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x20,
    0x0e,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x15,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x43,
    0x6f,
    0x64,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x45,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x4d,
    0x65,
    0x73,
    0x73,
    0x61,
    0x67,
    0x65,
    0x20,
    0x11,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x69,
    0x73,
    0x74,
    0x65,
    0x6e,
    0x63,
    0x79,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x49,
    0x74,
    0x65,
    0x6d,
    0x20,
    0x06,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x49,
    0x74,
    0x65,
    0x6d,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x10,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x06,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x49,
    0x74,
    0x65,
    0x6d,
    0x2e,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x55,
    0x73,
    0x65,
    0x63,
    0x20,
    0x0f,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x60,
    0x06,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x49,
    0x74,
    0x65,
    0x6d,
    0x2e,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x06,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x09,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x0a,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x57,
    0x72,
    0x69,
    0x74,
    0x65,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x64,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x22,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x57,
    0x72,
    0x69,
    0x74,
    0x65,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x64,
    0x45,
    0x78,
    0x70,
    0x69,
    0x72,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x0c,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x52,
    0x65,
    0x61,
    0x64,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x64,
    0x20,
    0x0d,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    0x73,
    0x7a,
    0x11,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x69,
    0x73,
    0x74,
    0x65,
    0x6e,
    0x63,
    0x79,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x80,
    0x01,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x43,
    0x4f,
    0x4e,
    0x53,
    0x49,
    0x53,
    0x54,
    0x45,
    0x4e,
    0x54,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x4e,
    0x4f,
    0x54,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x53,
    0x49,
    0x53,
    0x54,
    0x45,
    0x4e,
    0x54,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x55,
    0x4e,
    0x4b,
    0x4e,
    0x4f,
    0x57,
    0x4e,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class SetRequest_Data(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = ""
    self.subtype_ = ""
    self.value_ = ""
    self.timestampusec_ = 0
    self.has_type_ = 0
    self.has_subtype_ = 0
    self.has_value_ = 0
    self.has_timestampusec_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_

  def subtype(self): return self.subtype_

  def set_subtype(self, x):
    self.has_subtype_ = 1
    self.subtype_ = x

  def clear_subtype(self):
    self.has_subtype_ = 0
    self.subtype_ = ""

  def has_subtype(self): return self.has_subtype_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_

  def timestampusec(self): return self.timestampusec_

  def set_timestampusec(self, x):
    self.has_timestampusec_ = 1
    self.timestampusec_ = x

  def clear_timestampusec(self):
    self.has_timestampusec_ = 0
    self.timestampusec_ = 0

  def has_timestampusec(self): return self.has_timestampusec_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_subtype()): self.set_subtype(x.subtype())
    if (x.has_value()): self.set_value(x.value())
    if (x.has_timestampusec()): self.set_timestampusec(x.timestampusec())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.SetRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.SetRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.SetRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.SetRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.SetRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_subtype_ != x.has_subtype_: return 0
    if self.has_subtype_ and self.subtype_ != x.subtype_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    if self.has_timestampusec_ != x.has_timestampusec_: return 0
    if self.has_timestampusec_ and self.timestampusec_ != x.timestampusec_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.type_))
    if (self.has_subtype_): n += 1 + self.lengthString(len(self.subtype_))
    n += self.lengthString(len(self.value_))
    if (self.has_timestampusec_): n += 1 + self.lengthVarInt64(self.timestampusec_)
    return n + 2

  def Clear(self):
    self.clear_type()
    self.clear_subtype()
    self.clear_value()
    self.clear_timestampusec()

  def OutputUnchecked(self, out):
    out.putVarInt32(26)
    out.putPrefixedString(self.type_)
    out.putVarInt32(34)
    out.putPrefixedString(self.value_)
    if (self.has_timestampusec_):
      out.putVarInt32(88)
      out.putVarInt64(self.timestampusec_)
    if (self.has_subtype_):
      out.putVarInt32(98)
      out.putPrefixedString(self.subtype_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 26:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 34:
        self.set_value(d.getPrefixedString())
        continue
      if tt == 88:
        self.set_timestampusec(d.getVarInt64())
        continue
      if tt == 98:
        self.set_subtype(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    if self.has_subtype_: res+=prefix+("SubType: %s\n" % self.DebugFormatString(self.subtype_))
    if self.has_value_: res+=prefix+("Value: %s\n" % self.DebugFormatString(self.value_))
    if self.has_timestampusec_: res+=prefix+("TimestampUsec: %s\n" % self.DebugFormatInt64(self.timestampusec_))
    return res

class SetRequest_MetaData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = ""
    self.writesubscribed_ = 0
    self.writesubscribedexpiration_ = 0
    self.readsubscribed_ = 0
    self.has_type_ = 0
    self.has_writesubscribed_ = 0
    self.has_writesubscribedexpiration_ = 0
    self.has_readsubscribed_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_

  def writesubscribed(self): return self.writesubscribed_

  def set_writesubscribed(self, x):
    self.has_writesubscribed_ = 1
    self.writesubscribed_ = x

  def clear_writesubscribed(self):
    self.has_writesubscribed_ = 0
    self.writesubscribed_ = 0

  def has_writesubscribed(self): return self.has_writesubscribed_

  def writesubscribedexpiration(self): return self.writesubscribedexpiration_

  def set_writesubscribedexpiration(self, x):
    self.has_writesubscribedexpiration_ = 1
    self.writesubscribedexpiration_ = x

  def clear_writesubscribedexpiration(self):
    self.has_writesubscribedexpiration_ = 0
    self.writesubscribedexpiration_ = 0

  def has_writesubscribedexpiration(self): return self.has_writesubscribedexpiration_

  def readsubscribed(self): return self.readsubscribed_

  def set_readsubscribed(self, x):
    self.has_readsubscribed_ = 1
    self.readsubscribed_ = x

  def clear_readsubscribed(self):
    self.has_readsubscribed_ = 0
    self.readsubscribed_ = 0

  def has_readsubscribed(self): return self.has_readsubscribed_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_writesubscribed()): self.set_writesubscribed(x.writesubscribed())
    if (x.has_writesubscribedexpiration()): self.set_writesubscribedexpiration(x.writesubscribedexpiration())
    if (x.has_readsubscribed()): self.set_readsubscribed(x.readsubscribed())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.SetRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.SetRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.SetRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.SetRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.SetRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_writesubscribed_ != x.has_writesubscribed_: return 0
    if self.has_writesubscribed_ and self.writesubscribed_ != x.writesubscribed_: return 0
    if self.has_writesubscribedexpiration_ != x.has_writesubscribedexpiration_: return 0
    if self.has_writesubscribedexpiration_ and self.writesubscribedexpiration_ != x.writesubscribedexpiration_: return 0
    if self.has_readsubscribed_ != x.has_readsubscribed_: return 0
    if self.has_readsubscribed_ and self.readsubscribed_ != x.readsubscribed_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.type_))
    if (self.has_writesubscribed_): n += 2
    if (self.has_writesubscribedexpiration_): n += 1 + self.lengthVarInt64(self.writesubscribedexpiration_)
    if (self.has_readsubscribed_): n += 2
    return n + 1

  def Clear(self):
    self.clear_type()
    self.clear_writesubscribed()
    self.clear_writesubscribedexpiration()
    self.clear_readsubscribed()

  def OutputUnchecked(self, out):
    out.putVarInt32(58)
    out.putPrefixedString(self.type_)
    if (self.has_writesubscribed_):
      out.putVarInt32(64)
      out.putBoolean(self.writesubscribed_)
    if (self.has_writesubscribedexpiration_):
      out.putVarInt32(72)
      out.putVarInt64(self.writesubscribedexpiration_)
    if (self.has_readsubscribed_):
      out.putVarInt32(80)
      out.putBoolean(self.readsubscribed_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 52: break
      if tt == 58:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 64:
        self.set_writesubscribed(d.getBoolean())
        continue
      if tt == 72:
        self.set_writesubscribedexpiration(d.getVarInt64())
        continue
      if tt == 80:
        self.set_readsubscribed(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    if self.has_writesubscribed_: res+=prefix+("WriteSubscribed: %s\n" % self.DebugFormatBool(self.writesubscribed_))
    if self.has_writesubscribedexpiration_: res+=prefix+("WriteSubscribedExpiration: %s\n" % self.DebugFormatInt64(self.writesubscribedexpiration_))
    if self.has_readsubscribed_: res+=prefix+("ReadSubscribed: %s\n" % self.DebugFormatBool(self.readsubscribed_))
    return res

class SetRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.header_ = RequestHeader()
    self.data_ = []
    self.metadata_ = []
    self.has_header_ = 0
    if contents is not None: self.MergeFromString(contents)

  def header(self): return self.header_

  def mutable_header(self): self.has_header_ = 1; return self.header_

  def clear_header(self):self.has_header_ = 0; self.header_.Clear()

  def has_header(self): return self.has_header_

  def data_size(self): return len(self.data_)
  def data_list(self): return self.data_

  def data(self, i):
    return self.data_[i]

  def mutable_data(self, i):
    return self.data_[i]

  def add_data(self):
    x = SetRequest_Data()
    self.data_.append(x)
    return x

  def clear_data(self):
    self.data_ = []
  def metadata_size(self): return len(self.metadata_)
  def metadata_list(self): return self.metadata_

  def metadata(self, i):
    return self.metadata_[i]

  def mutable_metadata(self, i):
    return self.metadata_[i]

  def add_metadata(self):
    x = SetRequest_MetaData()
    self.metadata_.append(x)
    return x

  def clear_metadata(self):
    self.metadata_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_header()): self.mutable_header().MergeFrom(x.header())
    for i in xrange(x.data_size()): self.add_data().CopyFrom(x.data(i))
    for i in xrange(x.metadata_size()): self.add_metadata().CopyFrom(x.metadata(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.SetRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.SetRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.SetRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.SetRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.SetRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_header_ != x.has_header_: return 0
    if self.has_header_ and self.header_ != x.header_: return 0
    if len(self.data_) != len(x.data_): return 0
    for e1, e2 in zip(self.data_, x.data_):
      if e1 != e2: return 0
    if len(self.metadata_) != len(x.metadata_): return 0
    for e1, e2 in zip(self.metadata_, x.metadata_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_header_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: header not set.')
    elif not self.header_.IsInitialized(debug_strs): initialized = 0
    for i in xrange(len(self.data_)):
      if (not self.data_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.metadata_)):
      if (not self.metadata_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.header_.ByteSize())
    n += 2 * len(self.data_)
    for i in xrange(len(self.data_)): n += self.data_[i].ByteSize()
    n += 2 * len(self.metadata_)
    for i in xrange(len(self.metadata_)): n += self.metadata_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_header()
    self.clear_data()
    self.clear_metadata()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.header_.ByteSize())
    self.header_.OutputUnchecked(out)
    for i in xrange(len(self.data_)):
      out.putVarInt32(19)
      self.data_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    for i in xrange(len(self.metadata_)):
      out.putVarInt32(51)
      self.metadata_[i].OutputUnchecked(out)
      out.putVarInt32(52)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_header().TryMerge(tmp)
        continue
      if tt == 19:
        self.add_data().TryMerge(d)
        continue
      if tt == 51:
        self.add_metadata().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_header_:
      res+=prefix+"Header <\n"
      res+=self.header_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.data_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Data%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.metadata_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("MetaData%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kHeader = 1
  kDataGroup = 2
  kDataType = 3
  kDataSubType = 12
  kDataValue = 4
  kDataTimestampUsec = 11
  kMetaDataGroup = 6
  kMetaDataType = 7
  kMetaDataWriteSubscribed = 8
  kMetaDataWriteSubscribedExpiration = 9
  kMetaDataReadSubscribed = 10

  _TEXT = (
   "ErrorCode",  #   0
   "Header",  #   1
   "Data",  #   2
   "Type",  #   3
   "Value",  #   4
   None,  #   5
   "MetaData",  #   6
   "Type",  #   7
   "WriteSubscribed",  #   8
   "WriteSubscribedExpiration",  #   9
   "ReadSubscribed",  #  10
   "TimestampUsec",  #  11
   "SubType",  #  12
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.STARTGROUP,  #   6

   ProtocolBuffer.Encoder.STRING,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.NUMERIC,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

   ProtocolBuffer.Encoder.STRING,  #  12

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x11,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x53,
    0x65,
    0x74,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x06,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x14,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x0c,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x55,
    0x73,
    0x65,
    0x63,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x06,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x07,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x06,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x57,
    0x72,
    0x69,
    0x74,
    0x65,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x64,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x06,
    0x14,
    0x13,
    0x1a,
    0x22,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x57,
    0x72,
    0x69,
    0x74,
    0x65,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x64,
    0x45,
    0x78,
    0x70,
    0x69,
    0x72,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x09,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x06,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x52,
    0x65,
    0x61,
    0x64,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x64,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x06,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class SetResponse_Data(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.responsecode_ = 0
    self.errormessage_ = ""
    self.type_ = ""
    self.subtype_ = ""
    self.timestampusec_ = 0
    self.has_responsecode_ = 0
    self.has_errormessage_ = 0
    self.has_type_ = 0
    self.has_subtype_ = 0
    self.has_timestampusec_ = 0
    if contents is not None: self.MergeFromString(contents)

  def responsecode(self): return self.responsecode_

  def set_responsecode(self, x):
    self.has_responsecode_ = 1
    self.responsecode_ = x

  def clear_responsecode(self):
    self.has_responsecode_ = 0
    self.responsecode_ = 0

  def has_responsecode(self): return self.has_responsecode_

  def errormessage(self): return self.errormessage_

  def set_errormessage(self, x):
    self.has_errormessage_ = 1
    self.errormessage_ = x

  def clear_errormessage(self):
    self.has_errormessage_ = 0
    self.errormessage_ = ""

  def has_errormessage(self): return self.has_errormessage_

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_

  def subtype(self): return self.subtype_

  def set_subtype(self, x):
    self.has_subtype_ = 1
    self.subtype_ = x

  def clear_subtype(self):
    self.has_subtype_ = 0
    self.subtype_ = ""

  def has_subtype(self): return self.has_subtype_

  def timestampusec(self): return self.timestampusec_

  def set_timestampusec(self, x):
    self.has_timestampusec_ = 1
    self.timestampusec_ = x

  def clear_timestampusec(self):
    self.has_timestampusec_ = 0
    self.timestampusec_ = 0

  def has_timestampusec(self): return self.has_timestampusec_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_responsecode()): self.set_responsecode(x.responsecode())
    if (x.has_errormessage()): self.set_errormessage(x.errormessage())
    if (x.has_type()): self.set_type(x.type())
    if (x.has_subtype()): self.set_subtype(x.subtype())
    if (x.has_timestampusec()): self.set_timestampusec(x.timestampusec())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.SetResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.SetResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.SetResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.SetResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.SetResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_responsecode_ != x.has_responsecode_: return 0
    if self.has_responsecode_ and self.responsecode_ != x.responsecode_: return 0
    if self.has_errormessage_ != x.has_errormessage_: return 0
    if self.has_errormessage_ and self.errormessage_ != x.errormessage_: return 0
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_subtype_ != x.has_subtype_: return 0
    if self.has_subtype_ and self.subtype_ != x.subtype_: return 0
    if self.has_timestampusec_ != x.has_timestampusec_: return 0
    if self.has_timestampusec_ and self.timestampusec_ != x.timestampusec_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_responsecode_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: responsecode not set.')
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (not self.has_timestampusec_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: timestampusec not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.responsecode_)
    if (self.has_errormessage_): n += 1 + self.lengthString(len(self.errormessage_))
    n += self.lengthString(len(self.type_))
    if (self.has_subtype_): n += 1 + self.lengthString(len(self.subtype_))
    n += self.lengthVarInt64(self.timestampusec_)
    return n + 3

  def Clear(self):
    self.clear_responsecode()
    self.clear_errormessage()
    self.clear_type()
    self.clear_subtype()
    self.clear_timestampusec()

  def OutputUnchecked(self, out):
    out.putVarInt32(24)
    out.putVarInt32(self.responsecode_)
    out.putVarInt32(34)
    out.putPrefixedString(self.type_)
    out.putVarInt32(80)
    out.putVarInt64(self.timestampusec_)
    if (self.has_subtype_):
      out.putVarInt32(90)
      out.putPrefixedString(self.subtype_)
    if (self.has_errormessage_):
      out.putVarInt32(98)
      out.putPrefixedString(self.errormessage_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 24:
        self.set_responsecode(d.getVarInt32())
        continue
      if tt == 34:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 80:
        self.set_timestampusec(d.getVarInt64())
        continue
      if tt == 90:
        self.set_subtype(d.getPrefixedString())
        continue
      if tt == 98:
        self.set_errormessage(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_responsecode_: res+=prefix+("ResponseCode: %s\n" % self.DebugFormatInt32(self.responsecode_))
    if self.has_errormessage_: res+=prefix+("ErrorMessage: %s\n" % self.DebugFormatString(self.errormessage_))
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    if self.has_subtype_: res+=prefix+("SubType: %s\n" % self.DebugFormatString(self.subtype_))
    if self.has_timestampusec_: res+=prefix+("TimestampUsec: %s\n" % self.DebugFormatInt64(self.timestampusec_))
    return res

class SetResponse_MetaData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.responsecode_ = 0
    self.errormessage_ = ""
    self.type_ = ""
    self.has_responsecode_ = 0
    self.has_errormessage_ = 0
    self.has_type_ = 0
    if contents is not None: self.MergeFromString(contents)

  def responsecode(self): return self.responsecode_

  def set_responsecode(self, x):
    self.has_responsecode_ = 1
    self.responsecode_ = x

  def clear_responsecode(self):
    self.has_responsecode_ = 0
    self.responsecode_ = 0

  def has_responsecode(self): return self.has_responsecode_

  def errormessage(self): return self.errormessage_

  def set_errormessage(self, x):
    self.has_errormessage_ = 1
    self.errormessage_ = x

  def clear_errormessage(self):
    self.has_errormessage_ = 0
    self.errormessage_ = ""

  def has_errormessage(self): return self.has_errormessage_

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_responsecode()): self.set_responsecode(x.responsecode())
    if (x.has_errormessage()): self.set_errormessage(x.errormessage())
    if (x.has_type()): self.set_type(x.type())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.SetResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.SetResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.SetResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.SetResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.SetResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_responsecode_ != x.has_responsecode_: return 0
    if self.has_responsecode_ and self.responsecode_ != x.responsecode_: return 0
    if self.has_errormessage_ != x.has_errormessage_: return 0
    if self.has_errormessage_ and self.errormessage_ != x.errormessage_: return 0
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_responsecode_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: responsecode not set.')
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.responsecode_)
    if (self.has_errormessage_): n += 1 + self.lengthString(len(self.errormessage_))
    n += self.lengthString(len(self.type_))
    return n + 2

  def Clear(self):
    self.clear_responsecode()
    self.clear_errormessage()
    self.clear_type()

  def OutputUnchecked(self, out):
    out.putVarInt32(56)
    out.putVarInt32(self.responsecode_)
    out.putVarInt32(66)
    out.putPrefixedString(self.type_)
    if (self.has_errormessage_):
      out.putVarInt32(106)
      out.putPrefixedString(self.errormessage_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 52: break
      if tt == 56:
        self.set_responsecode(d.getVarInt32())
        continue
      if tt == 66:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 106:
        self.set_errormessage(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_responsecode_: res+=prefix+("ResponseCode: %s\n" % self.DebugFormatInt32(self.responsecode_))
    if self.has_errormessage_: res+=prefix+("ErrorMessage: %s\n" % self.DebugFormatString(self.errormessage_))
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    return res

class SetResponse(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.header_ = ResponseHeader()
    self.data_ = []
    self.metadata_ = []
    self.has_header_ = 0
    if contents is not None: self.MergeFromString(contents)

  def header(self): return self.header_

  def mutable_header(self): self.has_header_ = 1; return self.header_

  def clear_header(self):self.has_header_ = 0; self.header_.Clear()

  def has_header(self): return self.has_header_

  def data_size(self): return len(self.data_)
  def data_list(self): return self.data_

  def data(self, i):
    return self.data_[i]

  def mutable_data(self, i):
    return self.data_[i]

  def add_data(self):
    x = SetResponse_Data()
    self.data_.append(x)
    return x

  def clear_data(self):
    self.data_ = []
  def metadata_size(self): return len(self.metadata_)
  def metadata_list(self): return self.metadata_

  def metadata(self, i):
    return self.metadata_[i]

  def mutable_metadata(self, i):
    return self.metadata_[i]

  def add_metadata(self):
    x = SetResponse_MetaData()
    self.metadata_.append(x)
    return x

  def clear_metadata(self):
    self.metadata_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_header()): self.mutable_header().MergeFrom(x.header())
    for i in xrange(x.data_size()): self.add_data().CopyFrom(x.data(i))
    for i in xrange(x.metadata_size()): self.add_metadata().CopyFrom(x.metadata(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.SetResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.SetResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.SetResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.SetResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.SetResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_header_ != x.has_header_: return 0
    if self.has_header_ and self.header_ != x.header_: return 0
    if len(self.data_) != len(x.data_): return 0
    for e1, e2 in zip(self.data_, x.data_):
      if e1 != e2: return 0
    if len(self.metadata_) != len(x.metadata_): return 0
    for e1, e2 in zip(self.metadata_, x.metadata_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_header_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: header not set.')
    elif not self.header_.IsInitialized(debug_strs): initialized = 0
    for i in xrange(len(self.data_)):
      if (not self.data_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.metadata_)):
      if (not self.metadata_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.header_.ByteSize())
    n += 2 * len(self.data_)
    for i in xrange(len(self.data_)): n += self.data_[i].ByteSize()
    n += 2 * len(self.metadata_)
    for i in xrange(len(self.metadata_)): n += self.metadata_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_header()
    self.clear_data()
    self.clear_metadata()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.data_)):
      out.putVarInt32(19)
      self.data_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    for i in xrange(len(self.metadata_)):
      out.putVarInt32(51)
      self.metadata_[i].OutputUnchecked(out)
      out.putVarInt32(52)
    out.putVarInt32(74)
    out.putVarInt32(self.header_.ByteSize())
    self.header_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 19:
        self.add_data().TryMerge(d)
        continue
      if tt == 51:
        self.add_metadata().TryMerge(d)
        continue
      if tt == 74:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_header().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_header_:
      res+=prefix+"Header <\n"
      res+=self.header_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.data_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Data%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.metadata_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("MetaData%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kHeader = 9
  kDataGroup = 2
  kDataResponseCode = 3
  kDataErrorMessage = 12
  kDataType = 4
  kDataSubType = 11
  kDataTimestampUsec = 10
  kMetaDataGroup = 6
  kMetaDataResponseCode = 7
  kMetaDataErrorMessage = 13
  kMetaDataType = 8

  _TEXT = (
   "ErrorCode",  #   0
   None,  #   1
   "Data",  #   2
   "ResponseCode",  #   3
   "Type",  #   4
   None,  #   5
   "MetaData",  #   6
   "ResponseCode",  #   7
   "Type",  #   8
   "Header",  #   9
   "TimestampUsec",  #  10
   "SubType",  #  11
   "ErrorMessage",  #  12
   "ErrorMessage",  #  13
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.MAX_TYPE,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.STARTGROUP,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.STRING,  #  11

   ProtocolBuffer.Encoder.STRING,  #  12

   ProtocolBuffer.Encoder.STRING,  #  13

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x12,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x53,
    0x65,
    0x74,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x13,
    0x1a,
    0x06,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x15,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x43,
    0x6f,
    0x64,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x45,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x4d,
    0x65,
    0x73,
    0x73,
    0x61,
    0x67,
    0x65,
    0x20,
    0x0c,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x0b,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x55,
    0x73,
    0x65,
    0x63,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x06,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x43,
    0x6f,
    0x64,
    0x65,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x07,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x45,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x4d,
    0x65,
    0x73,
    0x73,
    0x61,
    0x67,
    0x65,
    0x20,
    0x0d,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x07,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x07,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class DeleteRequest_DataLimits(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.mintimestampusec_ = 0
    self.maxtimestampusec_ = 0
    self.has_mintimestampusec_ = 0
    self.has_maxtimestampusec_ = 0
    if contents is not None: self.MergeFromString(contents)

  def mintimestampusec(self): return self.mintimestampusec_

  def set_mintimestampusec(self, x):
    self.has_mintimestampusec_ = 1
    self.mintimestampusec_ = x

  def clear_mintimestampusec(self):
    self.has_mintimestampusec_ = 0
    self.mintimestampusec_ = 0

  def has_mintimestampusec(self): return self.has_mintimestampusec_

  def maxtimestampusec(self): return self.maxtimestampusec_

  def set_maxtimestampusec(self, x):
    self.has_maxtimestampusec_ = 1
    self.maxtimestampusec_ = x

  def clear_maxtimestampusec(self):
    self.has_maxtimestampusec_ = 0
    self.maxtimestampusec_ = 0

  def has_maxtimestampusec(self): return self.has_maxtimestampusec_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_mintimestampusec()): self.set_mintimestampusec(x.mintimestampusec())
    if (x.has_maxtimestampusec()): self.set_maxtimestampusec(x.maxtimestampusec())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.DeleteRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.DeleteRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.DeleteRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.DeleteRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.DeleteRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_mintimestampusec_ != x.has_mintimestampusec_: return 0
    if self.has_mintimestampusec_ and self.mintimestampusec_ != x.mintimestampusec_: return 0
    if self.has_maxtimestampusec_ != x.has_maxtimestampusec_: return 0
    if self.has_maxtimestampusec_ and self.maxtimestampusec_ != x.maxtimestampusec_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_mintimestampusec_): n += 1 + self.lengthVarInt64(self.mintimestampusec_)
    if (self.has_maxtimestampusec_): n += 1 + self.lengthVarInt64(self.maxtimestampusec_)
    return n + 0

  def Clear(self):
    self.clear_mintimestampusec()
    self.clear_maxtimestampusec()

  def OutputUnchecked(self, out):
    if (self.has_mintimestampusec_):
      out.putVarInt32(64)
      out.putVarInt64(self.mintimestampusec_)
    if (self.has_maxtimestampusec_):
      out.putVarInt32(72)
      out.putVarInt64(self.maxtimestampusec_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 36: break
      if tt == 64:
        self.set_mintimestampusec(d.getVarInt64())
        continue
      if tt == 72:
        self.set_maxtimestampusec(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_mintimestampusec_: res+=prefix+("MinTimestampUsec: %s\n" % self.DebugFormatInt64(self.mintimestampusec_))
    if self.has_maxtimestampusec_: res+=prefix+("MaxTimestampUsec: %s\n" % self.DebugFormatInt64(self.maxtimestampusec_))
    return res

class DeleteRequest_Data(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = ""
    self.subtype_ = ""
    self.deleteallsubtypes_ = 0
    self.limits_ = None
    self.deleteeverywhere_ = 0
    self.has_type_ = 0
    self.has_subtype_ = 0
    self.has_deleteallsubtypes_ = 0
    self.has_limits_ = 0
    self.has_deleteeverywhere_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_

  def subtype(self): return self.subtype_

  def set_subtype(self, x):
    self.has_subtype_ = 1
    self.subtype_ = x

  def clear_subtype(self):
    self.has_subtype_ = 0
    self.subtype_ = ""

  def has_subtype(self): return self.has_subtype_

  def deleteallsubtypes(self): return self.deleteallsubtypes_

  def set_deleteallsubtypes(self, x):
    self.has_deleteallsubtypes_ = 1
    self.deleteallsubtypes_ = x

  def clear_deleteallsubtypes(self):
    self.has_deleteallsubtypes_ = 0
    self.deleteallsubtypes_ = 0

  def has_deleteallsubtypes(self): return self.has_deleteallsubtypes_

  def limits(self):
    if self.limits_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.limits_ is None: self.limits_ = DeleteRequest_DataLimits()
      finally:
        self.lazy_init_lock_.release()
    return self.limits_

  def mutable_limits(self): self.has_limits_ = 1; return self.limits()

  def clear_limits(self):
    #Warning: this method does not acquire the lock.
    self.has_limits_ = 0;
    if self.limits_ is not None: self.limits_.Clear()

  def has_limits(self): return self.has_limits_

  def deleteeverywhere(self): return self.deleteeverywhere_

  def set_deleteeverywhere(self, x):
    self.has_deleteeverywhere_ = 1
    self.deleteeverywhere_ = x

  def clear_deleteeverywhere(self):
    self.has_deleteeverywhere_ = 0
    self.deleteeverywhere_ = 0

  def has_deleteeverywhere(self): return self.has_deleteeverywhere_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_subtype()): self.set_subtype(x.subtype())
    if (x.has_deleteallsubtypes()): self.set_deleteallsubtypes(x.deleteallsubtypes())
    if (x.has_limits()): self.mutable_limits().MergeFrom(x.limits())
    if (x.has_deleteeverywhere()): self.set_deleteeverywhere(x.deleteeverywhere())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.DeleteRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.DeleteRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.DeleteRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.DeleteRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.DeleteRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_subtype_ != x.has_subtype_: return 0
    if self.has_subtype_ and self.subtype_ != x.subtype_: return 0
    if self.has_deleteallsubtypes_ != x.has_deleteallsubtypes_: return 0
    if self.has_deleteallsubtypes_ and self.deleteallsubtypes_ != x.deleteallsubtypes_: return 0
    if self.has_limits_ != x.has_limits_: return 0
    if self.has_limits_ and self.limits_ != x.limits_: return 0
    if self.has_deleteeverywhere_ != x.has_deleteeverywhere_: return 0
    if self.has_deleteeverywhere_ and self.deleteeverywhere_ != x.deleteeverywhere_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (self.has_limits_ and not self.limits_.IsInitialized(debug_strs)): initialized = 0
    if (not self.has_deleteeverywhere_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: deleteeverywhere not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.type_))
    if (self.has_subtype_): n += 1 + self.lengthString(len(self.subtype_))
    if (self.has_deleteallsubtypes_): n += 2
    if (self.has_limits_): n += 2 + self.limits_.ByteSize()
    return n + 3

  def Clear(self):
    self.clear_type()
    self.clear_subtype()
    self.clear_deleteallsubtypes()
    self.clear_limits()
    self.clear_deleteeverywhere()

  def OutputUnchecked(self, out):
    out.putVarInt32(26)
    out.putPrefixedString(self.type_)
    if (self.has_limits_):
      out.putVarInt32(35)
      self.limits_.OutputUnchecked(out)
      out.putVarInt32(36)
    out.putVarInt32(56)
    out.putBoolean(self.deleteeverywhere_)
    if (self.has_subtype_):
      out.putVarInt32(82)
      out.putPrefixedString(self.subtype_)
    if (self.has_deleteallsubtypes_):
      out.putVarInt32(88)
      out.putBoolean(self.deleteallsubtypes_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 26:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 35:
        self.mutable_limits().TryMerge(d)
        continue
      if tt == 56:
        self.set_deleteeverywhere(d.getBoolean())
        continue
      if tt == 82:
        self.set_subtype(d.getPrefixedString())
        continue
      if tt == 88:
        self.set_deleteallsubtypes(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    if self.has_subtype_: res+=prefix+("SubType: %s\n" % self.DebugFormatString(self.subtype_))
    if self.has_deleteallsubtypes_: res+=prefix+("DeleteAllSubTypes: %s\n" % self.DebugFormatBool(self.deleteallsubtypes_))
    if self.has_limits_:
      res+=prefix+"Limits {\n"
      res+=self.limits_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_deleteeverywhere_: res+=prefix+("DeleteEverywhere: %s\n" % self.DebugFormatBool(self.deleteeverywhere_))
    return res

class DeleteRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.header_ = RequestHeader()
    self.data_ = []
    self.has_header_ = 0
    if contents is not None: self.MergeFromString(contents)

  def header(self): return self.header_

  def mutable_header(self): self.has_header_ = 1; return self.header_

  def clear_header(self):self.has_header_ = 0; self.header_.Clear()

  def has_header(self): return self.has_header_

  def data_size(self): return len(self.data_)
  def data_list(self): return self.data_

  def data(self, i):
    return self.data_[i]

  def mutable_data(self, i):
    return self.data_[i]

  def add_data(self):
    x = DeleteRequest_Data()
    self.data_.append(x)
    return x

  def clear_data(self):
    self.data_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_header()): self.mutable_header().MergeFrom(x.header())
    for i in xrange(x.data_size()): self.add_data().CopyFrom(x.data(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.DeleteRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.DeleteRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.DeleteRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.DeleteRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.DeleteRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_header_ != x.has_header_: return 0
    if self.has_header_ and self.header_ != x.header_: return 0
    if len(self.data_) != len(x.data_): return 0
    for e1, e2 in zip(self.data_, x.data_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_header_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: header not set.')
    elif not self.header_.IsInitialized(debug_strs): initialized = 0
    for i in xrange(len(self.data_)):
      if (not self.data_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.header_.ByteSize())
    n += 2 * len(self.data_)
    for i in xrange(len(self.data_)): n += self.data_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_header()
    self.clear_data()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.header_.ByteSize())
    self.header_.OutputUnchecked(out)
    for i in xrange(len(self.data_)):
      out.putVarInt32(19)
      self.data_[i].OutputUnchecked(out)
      out.putVarInt32(20)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_header().TryMerge(tmp)
        continue
      if tt == 19:
        self.add_data().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_header_:
      res+=prefix+"Header <\n"
      res+=self.header_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.data_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Data%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kHeader = 1
  kDataGroup = 2
  kDataType = 3
  kDataSubType = 10
  kDataDeleteAllSubTypes = 11
  kDataLimitsGroup = 4
  kDataLimitsMinTimestampUsec = 8
  kDataLimitsMaxTimestampUsec = 9
  kDataDeleteEverywhere = 7

  _TEXT = (
   "ErrorCode",  #   0
   "Header",  #   1
   "Data",  #   2
   "Type",  #   3
   "Limits",  #   4
   None,  #   5
   None,  #   6
   "DeleteEverywhere",  #   7
   "MinTimestampUsec",  #   8
   "MaxTimestampUsec",  #   9
   "SubType",  #  10
   "DeleteAllSubTypes",  #  11
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STARTGROUP,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.MAX_TYPE,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.NUMERIC,  #   9

   ProtocolBuffer.Encoder.STRING,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x14,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x06,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x14,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x0a,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x41,
    0x6c,
    0x6c,
    0x53,
    0x75,
    0x62,
    0x54,
    0x79,
    0x70,
    0x65,
    0x73,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x01,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x73,
    0x20,
    0x04,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x73,
    0x2e,
    0x4d,
    0x69,
    0x6e,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x55,
    0x73,
    0x65,
    0x63,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x05,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x73,
    0x2e,
    0x4d,
    0x61,
    0x78,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x55,
    0x73,
    0x65,
    0x63,
    0x20,
    0x09,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x05,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x45,
    0x76,
    0x65,
    0x72,
    0x79,
    0x77,
    0x68,
    0x65,
    0x72,
    0x65,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class DeleteResponse_Data(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.responsecode_ = 0
    self.errormessage_ = ""
    self.type_ = ""
    self.subtype_ = ""
    self.has_responsecode_ = 0
    self.has_errormessage_ = 0
    self.has_type_ = 0
    self.has_subtype_ = 0
    if contents is not None: self.MergeFromString(contents)

  def responsecode(self): return self.responsecode_

  def set_responsecode(self, x):
    self.has_responsecode_ = 1
    self.responsecode_ = x

  def clear_responsecode(self):
    self.has_responsecode_ = 0
    self.responsecode_ = 0

  def has_responsecode(self): return self.has_responsecode_

  def errormessage(self): return self.errormessage_

  def set_errormessage(self, x):
    self.has_errormessage_ = 1
    self.errormessage_ = x

  def clear_errormessage(self):
    self.has_errormessage_ = 0
    self.errormessage_ = ""

  def has_errormessage(self): return self.has_errormessage_

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_

  def subtype(self): return self.subtype_

  def set_subtype(self, x):
    self.has_subtype_ = 1
    self.subtype_ = x

  def clear_subtype(self):
    self.has_subtype_ = 0
    self.subtype_ = ""

  def has_subtype(self): return self.has_subtype_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_responsecode()): self.set_responsecode(x.responsecode())
    if (x.has_errormessage()): self.set_errormessage(x.errormessage())
    if (x.has_type()): self.set_type(x.type())
    if (x.has_subtype()): self.set_subtype(x.subtype())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.DeleteResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.DeleteResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.DeleteResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.DeleteResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.DeleteResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_responsecode_ != x.has_responsecode_: return 0
    if self.has_responsecode_ and self.responsecode_ != x.responsecode_: return 0
    if self.has_errormessage_ != x.has_errormessage_: return 0
    if self.has_errormessage_ and self.errormessage_ != x.errormessage_: return 0
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_subtype_ != x.has_subtype_: return 0
    if self.has_subtype_ and self.subtype_ != x.subtype_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_responsecode_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: responsecode not set.')
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.responsecode_)
    if (self.has_errormessage_): n += 1 + self.lengthString(len(self.errormessage_))
    n += self.lengthString(len(self.type_))
    if (self.has_subtype_): n += 1 + self.lengthString(len(self.subtype_))
    return n + 2

  def Clear(self):
    self.clear_responsecode()
    self.clear_errormessage()
    self.clear_type()
    self.clear_subtype()

  def OutputUnchecked(self, out):
    out.putVarInt32(24)
    out.putVarInt32(self.responsecode_)
    out.putVarInt32(34)
    out.putPrefixedString(self.type_)
    if (self.has_subtype_):
      out.putVarInt32(50)
      out.putPrefixedString(self.subtype_)
    if (self.has_errormessage_):
      out.putVarInt32(58)
      out.putPrefixedString(self.errormessage_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 24:
        self.set_responsecode(d.getVarInt32())
        continue
      if tt == 34:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 50:
        self.set_subtype(d.getPrefixedString())
        continue
      if tt == 58:
        self.set_errormessage(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_responsecode_: res+=prefix+("ResponseCode: %s\n" % self.DebugFormatInt32(self.responsecode_))
    if self.has_errormessage_: res+=prefix+("ErrorMessage: %s\n" % self.DebugFormatString(self.errormessage_))
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    if self.has_subtype_: res+=prefix+("SubType: %s\n" % self.DebugFormatString(self.subtype_))
    return res

class DeleteResponse(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.header_ = ResponseHeader()
    self.data_ = []
    self.has_header_ = 0
    if contents is not None: self.MergeFromString(contents)

  def header(self): return self.header_

  def mutable_header(self): self.has_header_ = 1; return self.header_

  def clear_header(self):self.has_header_ = 0; self.header_.Clear()

  def has_header(self): return self.has_header_

  def data_size(self): return len(self.data_)
  def data_list(self): return self.data_

  def data(self, i):
    return self.data_[i]

  def mutable_data(self, i):
    return self.data_[i]

  def add_data(self):
    x = DeleteResponse_Data()
    self.data_.append(x)
    return x

  def clear_data(self):
    self.data_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_header()): self.mutable_header().MergeFrom(x.header())
    for i in xrange(x.data_size()): self.add_data().CopyFrom(x.data(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.DeleteResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.DeleteResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.DeleteResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.DeleteResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.DeleteResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_header_ != x.has_header_: return 0
    if self.has_header_ and self.header_ != x.header_: return 0
    if len(self.data_) != len(x.data_): return 0
    for e1, e2 in zip(self.data_, x.data_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_header_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: header not set.')
    elif not self.header_.IsInitialized(debug_strs): initialized = 0
    for i in xrange(len(self.data_)):
      if (not self.data_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.header_.ByteSize())
    n += 2 * len(self.data_)
    for i in xrange(len(self.data_)): n += self.data_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_header()
    self.clear_data()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.data_)):
      out.putVarInt32(19)
      self.data_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    out.putVarInt32(42)
    out.putVarInt32(self.header_.ByteSize())
    self.header_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 19:
        self.add_data().TryMerge(d)
        continue
      if tt == 42:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_header().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_header_:
      res+=prefix+"Header <\n"
      res+=self.header_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.data_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Data%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kHeader = 5
  kDataGroup = 2
  kDataResponseCode = 3
  kDataErrorMessage = 7
  kDataType = 4
  kDataSubType = 6

  _TEXT = (
   "ErrorCode",  #   0
   None,  #   1
   "Data",  #   2
   "ResponseCode",  #   3
   "Type",  #   4
   "Header",  #   5
   "SubType",  #   6
   "ErrorMessage",  #   7
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.MAX_TYPE,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.STRING,  #   7

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x15,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x13,
    0x1a,
    0x06,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x15,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x43,
    0x6f,
    0x64,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x45,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x4d,
    0x65,
    0x73,
    0x73,
    0x61,
    0x67,
    0x65,
    0x20,
    0x07,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class MutationRequest_ModSetCell(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = ""
    self.subtype_ = ""
    self.value_ = ""
    self.timestampusec_ = 0
    self.has_type_ = 0
    self.has_subtype_ = 0
    self.has_value_ = 0
    self.has_timestampusec_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_

  def subtype(self): return self.subtype_

  def set_subtype(self, x):
    self.has_subtype_ = 1
    self.subtype_ = x

  def clear_subtype(self):
    self.has_subtype_ = 0
    self.subtype_ = ""

  def has_subtype(self): return self.has_subtype_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_

  def timestampusec(self): return self.timestampusec_

  def set_timestampusec(self, x):
    self.has_timestampusec_ = 1
    self.timestampusec_ = x

  def clear_timestampusec(self):
    self.has_timestampusec_ = 0
    self.timestampusec_ = 0

  def has_timestampusec(self): return self.has_timestampusec_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_subtype()): self.set_subtype(x.subtype())
    if (x.has_value()): self.set_value(x.value())
    if (x.has_timestampusec()): self.set_timestampusec(x.timestampusec())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.MutationRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.MutationRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.MutationRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.MutationRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.MutationRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_subtype_ != x.has_subtype_: return 0
    if self.has_subtype_ and self.subtype_ != x.subtype_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    if self.has_timestampusec_ != x.has_timestampusec_: return 0
    if self.has_timestampusec_ and self.timestampusec_ != x.timestampusec_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.type_))
    if (self.has_subtype_): n += 1 + self.lengthString(len(self.subtype_))
    n += self.lengthString(len(self.value_))
    if (self.has_timestampusec_): n += 1 + self.lengthVarInt64(self.timestampusec_)
    return n + 2

  def Clear(self):
    self.clear_type()
    self.clear_subtype()
    self.clear_value()
    self.clear_timestampusec()

  def OutputUnchecked(self, out):
    out.putVarInt32(34)
    out.putPrefixedString(self.type_)
    if (self.has_subtype_):
      out.putVarInt32(42)
      out.putPrefixedString(self.subtype_)
    out.putVarInt32(50)
    out.putPrefixedString(self.value_)
    if (self.has_timestampusec_):
      out.putVarInt32(56)
      out.putVarInt64(self.timestampusec_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 28: break
      if tt == 34:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 42:
        self.set_subtype(d.getPrefixedString())
        continue
      if tt == 50:
        self.set_value(d.getPrefixedString())
        continue
      if tt == 56:
        self.set_timestampusec(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    if self.has_subtype_: res+=prefix+("Subtype: %s\n" % self.DebugFormatString(self.subtype_))
    if self.has_value_: res+=prefix+("Value: %s\n" % self.DebugFormatString(self.value_))
    if self.has_timestampusec_: res+=prefix+("TimestampUsec: %s\n" % self.DebugFormatInt64(self.timestampusec_))
    return res

class MutationRequest_ModDeleteCell(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = ""
    self.subtype_ = ""
    self.mintimestampusec_ = 0
    self.maxtimestampusec_ = 0
    self.has_type_ = 0
    self.has_subtype_ = 0
    self.has_mintimestampusec_ = 0
    self.has_maxtimestampusec_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_

  def subtype(self): return self.subtype_

  def set_subtype(self, x):
    self.has_subtype_ = 1
    self.subtype_ = x

  def clear_subtype(self):
    self.has_subtype_ = 0
    self.subtype_ = ""

  def has_subtype(self): return self.has_subtype_

  def mintimestampusec(self): return self.mintimestampusec_

  def set_mintimestampusec(self, x):
    self.has_mintimestampusec_ = 1
    self.mintimestampusec_ = x

  def clear_mintimestampusec(self):
    self.has_mintimestampusec_ = 0
    self.mintimestampusec_ = 0

  def has_mintimestampusec(self): return self.has_mintimestampusec_

  def maxtimestampusec(self): return self.maxtimestampusec_

  def set_maxtimestampusec(self, x):
    self.has_maxtimestampusec_ = 1
    self.maxtimestampusec_ = x

  def clear_maxtimestampusec(self):
    self.has_maxtimestampusec_ = 0
    self.maxtimestampusec_ = 0

  def has_maxtimestampusec(self): return self.has_maxtimestampusec_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_subtype()): self.set_subtype(x.subtype())
    if (x.has_mintimestampusec()): self.set_mintimestampusec(x.mintimestampusec())
    if (x.has_maxtimestampusec()): self.set_maxtimestampusec(x.maxtimestampusec())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.MutationRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.MutationRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.MutationRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.MutationRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.MutationRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_subtype_ != x.has_subtype_: return 0
    if self.has_subtype_ and self.subtype_ != x.subtype_: return 0
    if self.has_mintimestampusec_ != x.has_mintimestampusec_: return 0
    if self.has_mintimestampusec_ and self.mintimestampusec_ != x.mintimestampusec_: return 0
    if self.has_maxtimestampusec_ != x.has_maxtimestampusec_: return 0
    if self.has_maxtimestampusec_ and self.maxtimestampusec_ != x.maxtimestampusec_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.type_))
    if (self.has_subtype_): n += 1 + self.lengthString(len(self.subtype_))
    if (self.has_mintimestampusec_): n += 1 + self.lengthVarInt64(self.mintimestampusec_)
    if (self.has_maxtimestampusec_): n += 1 + self.lengthVarInt64(self.maxtimestampusec_)
    return n + 1

  def Clear(self):
    self.clear_type()
    self.clear_subtype()
    self.clear_mintimestampusec()
    self.clear_maxtimestampusec()

  def OutputUnchecked(self, out):
    out.putVarInt32(74)
    out.putPrefixedString(self.type_)
    if (self.has_subtype_):
      out.putVarInt32(82)
      out.putPrefixedString(self.subtype_)
    if (self.has_mintimestampusec_):
      out.putVarInt32(88)
      out.putVarInt64(self.mintimestampusec_)
    if (self.has_maxtimestampusec_):
      out.putVarInt32(96)
      out.putVarInt64(self.maxtimestampusec_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 68: break
      if tt == 74:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 82:
        self.set_subtype(d.getPrefixedString())
        continue
      if tt == 88:
        self.set_mintimestampusec(d.getVarInt64())
        continue
      if tt == 96:
        self.set_maxtimestampusec(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    if self.has_subtype_: res+=prefix+("Subtype: %s\n" % self.DebugFormatString(self.subtype_))
    if self.has_mintimestampusec_: res+=prefix+("MinTimestampUsec: %s\n" % self.DebugFormatInt64(self.mintimestampusec_))
    if self.has_maxtimestampusec_: res+=prefix+("MaxTimestampUsec: %s\n" % self.DebugFormatInt64(self.maxtimestampusec_))
    return res

class MutationRequest_ModDeleteType(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = ""
    self.has_type_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.MutationRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.MutationRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.MutationRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.MutationRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.MutationRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.type_))
    return n + 1

  def Clear(self):
    self.clear_type()

  def OutputUnchecked(self, out):
    out.putVarInt32(114)
    out.putPrefixedString(self.type_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 108: break
      if tt == 114:
        self.set_type(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    return res

class MutationRequest_ModSubscribeType(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = ""
    self.readsubscribed_ = 0
    self.writesubscribed_ = 0
    self.writesubscribedexpiration_ = 0
    self.has_type_ = 0
    self.has_readsubscribed_ = 0
    self.has_writesubscribed_ = 0
    self.has_writesubscribedexpiration_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_

  def readsubscribed(self): return self.readsubscribed_

  def set_readsubscribed(self, x):
    self.has_readsubscribed_ = 1
    self.readsubscribed_ = x

  def clear_readsubscribed(self):
    self.has_readsubscribed_ = 0
    self.readsubscribed_ = 0

  def has_readsubscribed(self): return self.has_readsubscribed_

  def writesubscribed(self): return self.writesubscribed_

  def set_writesubscribed(self, x):
    self.has_writesubscribed_ = 1
    self.writesubscribed_ = x

  def clear_writesubscribed(self):
    self.has_writesubscribed_ = 0
    self.writesubscribed_ = 0

  def has_writesubscribed(self): return self.has_writesubscribed_

  def writesubscribedexpiration(self): return self.writesubscribedexpiration_

  def set_writesubscribedexpiration(self, x):
    self.has_writesubscribedexpiration_ = 1
    self.writesubscribedexpiration_ = x

  def clear_writesubscribedexpiration(self):
    self.has_writesubscribedexpiration_ = 0
    self.writesubscribedexpiration_ = 0

  def has_writesubscribedexpiration(self): return self.has_writesubscribedexpiration_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_readsubscribed()): self.set_readsubscribed(x.readsubscribed())
    if (x.has_writesubscribed()): self.set_writesubscribed(x.writesubscribed())
    if (x.has_writesubscribedexpiration()): self.set_writesubscribedexpiration(x.writesubscribedexpiration())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.MutationRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.MutationRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.MutationRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.MutationRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.MutationRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_readsubscribed_ != x.has_readsubscribed_: return 0
    if self.has_readsubscribed_ and self.readsubscribed_ != x.readsubscribed_: return 0
    if self.has_writesubscribed_ != x.has_writesubscribed_: return 0
    if self.has_writesubscribed_ and self.writesubscribed_ != x.writesubscribed_: return 0
    if self.has_writesubscribedexpiration_ != x.has_writesubscribedexpiration_: return 0
    if self.has_writesubscribedexpiration_ and self.writesubscribedexpiration_ != x.writesubscribedexpiration_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.type_))
    if (self.has_readsubscribed_): n += 3
    if (self.has_writesubscribed_): n += 3
    if (self.has_writesubscribedexpiration_): n += 2 + self.lengthVarInt64(self.writesubscribedexpiration_)
    return n + 2

  def Clear(self):
    self.clear_type()
    self.clear_readsubscribed()
    self.clear_writesubscribed()
    self.clear_writesubscribedexpiration()

  def OutputUnchecked(self, out):
    out.putVarInt32(138)
    out.putPrefixedString(self.type_)
    if (self.has_readsubscribed_):
      out.putVarInt32(144)
      out.putBoolean(self.readsubscribed_)
    if (self.has_writesubscribed_):
      out.putVarInt32(152)
      out.putBoolean(self.writesubscribed_)
    if (self.has_writesubscribedexpiration_):
      out.putVarInt32(160)
      out.putVarInt64(self.writesubscribedexpiration_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 132: break
      if tt == 138:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 144:
        self.set_readsubscribed(d.getBoolean())
        continue
      if tt == 152:
        self.set_writesubscribed(d.getBoolean())
        continue
      if tt == 160:
        self.set_writesubscribedexpiration(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatString(self.type_))
    if self.has_readsubscribed_: res+=prefix+("ReadSubscribed: %s\n" % self.DebugFormatBool(self.readsubscribed_))
    if self.has_writesubscribed_: res+=prefix+("WriteSubscribed: %s\n" % self.DebugFormatBool(self.writesubscribed_))
    if self.has_writesubscribedexpiration_: res+=prefix+("WriteSubscribedExpiration: %s\n" % self.DebugFormatInt64(self.writesubscribedexpiration_))
    return res

class MutationRequest_Mod(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.setcell_ = None
    self.deletecell_ = None
    self.deletetype_ = None
    self.subscribetype_ = None
    self.has_setcell_ = 0
    self.has_deletecell_ = 0
    self.has_deletetype_ = 0
    self.has_subscribetype_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def setcell(self):
    if self.setcell_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.setcell_ is None: self.setcell_ = MutationRequest_ModSetCell()
      finally:
        self.lazy_init_lock_.release()
    return self.setcell_

  def mutable_setcell(self): self.has_setcell_ = 1; return self.setcell()

  def clear_setcell(self):
    #Warning: this method does not acquire the lock.
    self.has_setcell_ = 0;
    if self.setcell_ is not None: self.setcell_.Clear()

  def has_setcell(self): return self.has_setcell_

  def deletecell(self):
    if self.deletecell_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.deletecell_ is None: self.deletecell_ = MutationRequest_ModDeleteCell()
      finally:
        self.lazy_init_lock_.release()
    return self.deletecell_

  def mutable_deletecell(self): self.has_deletecell_ = 1; return self.deletecell()

  def clear_deletecell(self):
    #Warning: this method does not acquire the lock.
    self.has_deletecell_ = 0;
    if self.deletecell_ is not None: self.deletecell_.Clear()

  def has_deletecell(self): return self.has_deletecell_

  def deletetype(self):
    if self.deletetype_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.deletetype_ is None: self.deletetype_ = MutationRequest_ModDeleteType()
      finally:
        self.lazy_init_lock_.release()
    return self.deletetype_

  def mutable_deletetype(self): self.has_deletetype_ = 1; return self.deletetype()

  def clear_deletetype(self):
    #Warning: this method does not acquire the lock.
    self.has_deletetype_ = 0;
    if self.deletetype_ is not None: self.deletetype_.Clear()

  def has_deletetype(self): return self.has_deletetype_

  def subscribetype(self):
    if self.subscribetype_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.subscribetype_ is None: self.subscribetype_ = MutationRequest_ModSubscribeType()
      finally:
        self.lazy_init_lock_.release()
    return self.subscribetype_

  def mutable_subscribetype(self): self.has_subscribetype_ = 1; return self.subscribetype()

  def clear_subscribetype(self):
    #Warning: this method does not acquire the lock.
    self.has_subscribetype_ = 0;
    if self.subscribetype_ is not None: self.subscribetype_.Clear()

  def has_subscribetype(self): return self.has_subscribetype_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_setcell()): self.mutable_setcell().MergeFrom(x.setcell())
    if (x.has_deletecell()): self.mutable_deletecell().MergeFrom(x.deletecell())
    if (x.has_deletetype()): self.mutable_deletetype().MergeFrom(x.deletetype())
    if (x.has_subscribetype()): self.mutable_subscribetype().MergeFrom(x.subscribetype())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.MutationRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.MutationRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.MutationRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.MutationRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.MutationRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_setcell_ != x.has_setcell_: return 0
    if self.has_setcell_ and self.setcell_ != x.setcell_: return 0
    if self.has_deletecell_ != x.has_deletecell_: return 0
    if self.has_deletecell_ and self.deletecell_ != x.deletecell_: return 0
    if self.has_deletetype_ != x.has_deletetype_: return 0
    if self.has_deletetype_ and self.deletetype_ != x.deletetype_: return 0
    if self.has_subscribetype_ != x.has_subscribetype_: return 0
    if self.has_subscribetype_ and self.subscribetype_ != x.subscribetype_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (self.has_setcell_ and not self.setcell_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_deletecell_ and not self.deletecell_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_deletetype_ and not self.deletetype_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_subscribetype_ and not self.subscribetype_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_setcell_): n += 2 + self.setcell_.ByteSize()
    if (self.has_deletecell_): n += 2 + self.deletecell_.ByteSize()
    if (self.has_deletetype_): n += 2 + self.deletetype_.ByteSize()
    if (self.has_subscribetype_): n += 4 + self.subscribetype_.ByteSize()
    return n + 0

  def Clear(self):
    self.clear_setcell()
    self.clear_deletecell()
    self.clear_deletetype()
    self.clear_subscribetype()

  def OutputUnchecked(self, out):
    if (self.has_setcell_):
      out.putVarInt32(27)
      self.setcell_.OutputUnchecked(out)
      out.putVarInt32(28)
    if (self.has_deletecell_):
      out.putVarInt32(67)
      self.deletecell_.OutputUnchecked(out)
      out.putVarInt32(68)
    if (self.has_deletetype_):
      out.putVarInt32(107)
      self.deletetype_.OutputUnchecked(out)
      out.putVarInt32(108)
    if (self.has_subscribetype_):
      out.putVarInt32(131)
      self.subscribetype_.OutputUnchecked(out)
      out.putVarInt32(132)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 27:
        self.mutable_setcell().TryMerge(d)
        continue
      if tt == 67:
        self.mutable_deletecell().TryMerge(d)
        continue
      if tt == 107:
        self.mutable_deletetype().TryMerge(d)
        continue
      if tt == 131:
        self.mutable_subscribetype().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_setcell_:
      res+=prefix+"SetCell {\n"
      res+=self.setcell_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_deletecell_:
      res+=prefix+"DeleteCell {\n"
      res+=self.deletecell_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_deletetype_:
      res+=prefix+"DeleteType {\n"
      res+=self.deletetype_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_subscribetype_:
      res+=prefix+"SubscribeType {\n"
      res+=self.subscribetype_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    return res

class MutationRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.header_ = RequestHeader()
    self.mod_ = []
    self.secondary_ = []
    self.timestampusec_ = 0
    self.has_header_ = 0
    self.has_timestampusec_ = 0
    if contents is not None: self.MergeFromString(contents)

  def header(self): return self.header_

  def mutable_header(self): self.has_header_ = 1; return self.header_

  def clear_header(self):self.has_header_ = 0; self.header_.Clear()

  def has_header(self): return self.has_header_

  def mod_size(self): return len(self.mod_)
  def mod_list(self): return self.mod_

  def mod(self, i):
    return self.mod_[i]

  def mutable_mod(self, i):
    return self.mod_[i]

  def add_mod(self):
    x = MutationRequest_Mod()
    self.mod_.append(x)
    return x

  def clear_mod(self):
    self.mod_ = []
  def secondary_size(self): return len(self.secondary_)
  def secondary_list(self): return self.secondary_

  def secondary(self, i):
    return self.secondary_[i]

  def set_secondary(self, i, x):
    self.secondary_[i] = x

  def add_secondary(self, x):
    self.secondary_.append(x)

  def clear_secondary(self):
    self.secondary_ = []

  def timestampusec(self): return self.timestampusec_

  def set_timestampusec(self, x):
    self.has_timestampusec_ = 1
    self.timestampusec_ = x

  def clear_timestampusec(self):
    self.has_timestampusec_ = 0
    self.timestampusec_ = 0

  def has_timestampusec(self): return self.has_timestampusec_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_header()): self.mutable_header().MergeFrom(x.header())
    for i in xrange(x.mod_size()): self.add_mod().CopyFrom(x.mod(i))
    for i in xrange(x.secondary_size()): self.add_secondary(x.secondary(i))
    if (x.has_timestampusec()): self.set_timestampusec(x.timestampusec())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.MutationRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.MutationRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.MutationRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.MutationRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.MutationRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_header_ != x.has_header_: return 0
    if self.has_header_ and self.header_ != x.header_: return 0
    if len(self.mod_) != len(x.mod_): return 0
    for e1, e2 in zip(self.mod_, x.mod_):
      if e1 != e2: return 0
    if len(self.secondary_) != len(x.secondary_): return 0
    for e1, e2 in zip(self.secondary_, x.secondary_):
      if e1 != e2: return 0
    if self.has_timestampusec_ != x.has_timestampusec_: return 0
    if self.has_timestampusec_ and self.timestampusec_ != x.timestampusec_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_header_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: header not set.')
    elif not self.header_.IsInitialized(debug_strs): initialized = 0
    for i in xrange(len(self.mod_)):
      if (not self.mod_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.header_.ByteSize())
    n += 2 * len(self.mod_)
    for i in xrange(len(self.mod_)): n += self.mod_[i].ByteSize()
    n += 2 * len(self.secondary_)
    for i in xrange(len(self.secondary_)): n += self.lengthString(len(self.secondary_[i]))
    if (self.has_timestampusec_): n += 1 + self.lengthVarInt64(self.timestampusec_)
    return n + 1

  def Clear(self):
    self.clear_header()
    self.clear_mod()
    self.clear_secondary()
    self.clear_timestampusec()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.header_.ByteSize())
    self.header_.OutputUnchecked(out)
    for i in xrange(len(self.mod_)):
      out.putVarInt32(19)
      self.mod_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    if (self.has_timestampusec_):
      out.putVarInt32(120)
      out.putVarInt64(self.timestampusec_)
    for i in xrange(len(self.secondary_)):
      out.putVarInt32(170)
      out.putPrefixedString(self.secondary_[i])

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_header().TryMerge(tmp)
        continue
      if tt == 19:
        self.add_mod().TryMerge(d)
        continue
      if tt == 120:
        self.set_timestampusec(d.getVarInt64())
        continue
      if tt == 170:
        self.add_secondary(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_header_:
      res+=prefix+"Header <\n"
      res+=self.header_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.mod_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Mod%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.secondary_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Secondary%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_timestampusec_: res+=prefix+("TimestampUsec: %s\n" % self.DebugFormatInt64(self.timestampusec_))
    return res

  kHeader = 1
  kModGroup = 2
  kModSetCellGroup = 3
  kModSetCellType = 4
  kModSetCellSubtype = 5
  kModSetCellValue = 6
  kModSetCellTimestampUsec = 7
  kModDeleteCellGroup = 8
  kModDeleteCellType = 9
  kModDeleteCellSubtype = 10
  kModDeleteCellMinTimestampUsec = 11
  kModDeleteCellMaxTimestampUsec = 12
  kModDeleteTypeGroup = 13
  kModDeleteTypeType = 14
  kModSubscribeTypeGroup = 16
  kModSubscribeTypeType = 17
  kModSubscribeTypeReadSubscribed = 18
  kModSubscribeTypeWriteSubscribed = 19
  kModSubscribeTypeWriteSubscribedExpiration = 20
  kSecondary = 21
  kTimestampUsec = 15

  _TEXT = (
   "ErrorCode",  #   0
   "Header",  #   1
   "Mod",  #   2
   "SetCell",  #   3
   "Type",  #   4
   "Subtype",  #   5
   "Value",  #   6
   "TimestampUsec",  #   7
   "DeleteCell",  #   8
   "Type",  #   9
   "Subtype",  #  10
   "MinTimestampUsec",  #  11
   "MaxTimestampUsec",  #  12
   "DeleteType",  #  13
   "Type",  #  14
   "TimestampUsec",  #  15
   "SubscribeType",  #  16
   "Type",  #  17
   "ReadSubscribed",  #  18
   "WriteSubscribed",  #  19
   "WriteSubscribedExpiration",  #  20
   "Secondary",  #  21
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STARTGROUP,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.STARTGROUP,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.STRING,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

   ProtocolBuffer.Encoder.NUMERIC,  #  12

   ProtocolBuffer.Encoder.STARTGROUP,  #  13

   ProtocolBuffer.Encoder.STRING,  #  14

   ProtocolBuffer.Encoder.NUMERIC,  #  15

   ProtocolBuffer.Encoder.STARTGROUP,  #  16

   ProtocolBuffer.Encoder.STRING,  #  17

   ProtocolBuffer.Encoder.NUMERIC,  #  18

   ProtocolBuffer.Encoder.NUMERIC,  #  19

   ProtocolBuffer.Encoder.NUMERIC,  #  20

   ProtocolBuffer.Encoder.STRING,  #  21

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x16,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x4d,
    0x75,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x06,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x14,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x14,
    0x13,
    0x1a,
    0x03,
    0x4d,
    0x6f,
    0x64,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x53,
    0x65,
    0x74,
    0x43,
    0x65,
    0x6c,
    0x6c,
    0x20,
    0x03,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x53,
    0x65,
    0x74,
    0x43,
    0x65,
    0x6c,
    0x6c,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x53,
    0x65,
    0x74,
    0x43,
    0x65,
    0x6c,
    0x6c,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x53,
    0x65,
    0x74,
    0x43,
    0x65,
    0x6c,
    0x6c,
    0x2e,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x53,
    0x65,
    0x74,
    0x43,
    0x65,
    0x6c,
    0x6c,
    0x2e,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x55,
    0x73,
    0x65,
    0x63,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x43,
    0x65,
    0x6c,
    0x6c,
    0x20,
    0x08,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x43,
    0x65,
    0x6c,
    0x6c,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x07,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x43,
    0x65,
    0x6c,
    0x6c,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x0a,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x07,
    0x14,
    0x13,
    0x1a,
    0x1f,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x43,
    0x65,
    0x6c,
    0x6c,
    0x2e,
    0x4d,
    0x69,
    0x6e,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x55,
    0x73,
    0x65,
    0x63,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x07,
    0x14,
    0x13,
    0x1a,
    0x1f,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x43,
    0x65,
    0x6c,
    0x6c,
    0x2e,
    0x4d,
    0x61,
    0x78,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x55,
    0x73,
    0x65,
    0x63,
    0x20,
    0x0c,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x07,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x0d,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x0e,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x0c,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x10,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x11,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x0e,
    0x14,
    0x13,
    0x1a,
    0x20,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x52,
    0x65,
    0x61,
    0x64,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x64,
    0x20,
    0x12,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x0e,
    0x14,
    0x13,
    0x1a,
    0x21,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x57,
    0x72,
    0x69,
    0x74,
    0x65,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x64,
    0x20,
    0x13,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x0e,
    0x14,
    0x13,
    0x1a,
    0x2b,
    0x4d,
    0x6f,
    0x64,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x57,
    0x72,
    0x69,
    0x74,
    0x65,
    0x53,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x62,
    0x65,
    0x64,
    0x45,
    0x78,
    0x70,
    0x69,
    0x72,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x14,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x0e,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x53,
    0x65,
    0x63,
    0x6f,
    0x6e,
    0x64,
    0x61,
    0x72,
    0x79,
    0x20,
    0x15,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x55,
    0x73,
    0x65,
    0x63,
    0x20,
    0x0f,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class MutationResponse(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.header_ = ResponseHeader()
    self.has_header_ = 0
    if contents is not None: self.MergeFromString(contents)

  def header(self): return self.header_

  def mutable_header(self): self.has_header_ = 1; return self.header_

  def clear_header(self):self.has_header_ = 0; self.header_.Clear()

  def has_header(self): return self.has_header_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_header()): self.mutable_header().MergeFrom(x.header())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'kansas.MutationResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'kansas.MutationResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'kansas.MutationResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'kansas.MutationResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'kansas.MutationResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_header_ != x.has_header_: return 0
    if self.has_header_ and self.header_ != x.header_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_header_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: header not set.')
    elif not self.header_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.header_.ByteSize())
    return n + 1

  def Clear(self):
    self.clear_header()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.header_.ByteSize())
    self.header_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_header().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_header_:
      res+=prefix+"Header <\n"
      res+=self.header_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

  kHeader = 1

  _TEXT = (
   "ErrorCode",  #   0
   "Header",  #   1
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x17,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x4d,
    0x75,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x13,
    0x1a,
    0x06,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x15,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x48,
    0x65,
    0x61,
    0x64,
    0x65,
    0x72,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())


class _KansasServer_ClientStub(_client_stub_base_class):
  """Makes Stubby RPC calls to a KansasServer server."""

  __slots__ = (
      '_protorpc_Lookup', '_full_name_Lookup',
      '_protorpc_Set', '_full_name_Set',
      '_protorpc_Delete', '_full_name_Delete',
      '_protorpc_Mutate', '_full_name_Mutate',
  )

  def __init__(self, rpc_stub_parameters):
    rpc_internals.StubbyRPCBaseStub.__init__(self,
                                             'KansasServer',
                                             rpc_stub_parameters)

    self._protorpc_Lookup = pywraprpc.RPC()
    self._protorpc_Lookup.set_client_logging(-1)
    self._full_name_Lookup = self._stub.GetFullMethodName(
        'Lookup')

    self._protorpc_Set = pywraprpc.RPC()
    self._protorpc_Set.set_client_logging(-1)
    self._full_name_Set = self._stub.GetFullMethodName(
        'Set')

    self._protorpc_Delete = pywraprpc.RPC()
    self._protorpc_Delete.set_client_logging(-1)
    self._full_name_Delete = self._stub.GetFullMethodName(
        'Delete')

    self._protorpc_Mutate = pywraprpc.RPC()
    self._protorpc_Mutate.set_client_logging(-1)
    self._full_name_Mutate = self._stub.GetFullMethodName(
        'Mutate')

  def Lookup(self, request, rpc=None, callback=None):
    """Make a Lookup RPC call.

    Args:
      request: a LookupRequest instance.
      rpc: Optional RPC instance to use for the call.
      callback: Optional callback. Will be called as
          callback(rpc, result). If None, the call synchronous.

    Returns:
      The LookupResponse if callback is None. Otherwise, returns None.
    """

    return self._MakeCall(rpc,
                          self._full_name_Lookup,
                          'Lookup',
                          request,
                          LookupResponse,
                          callback,
                          self._protorpc_Lookup)

  def Set(self, request, rpc=None, callback=None):
    """Make a Set RPC call.

    Args:
      request: a SetRequest instance.
      rpc: Optional RPC instance to use for the call.
      callback: Optional callback. Will be called as
          callback(rpc, result). If None, the call synchronous.

    Returns:
      The SetResponse if callback is None. Otherwise, returns None.
    """

    return self._MakeCall(rpc,
                          self._full_name_Set,
                          'Set',
                          request,
                          SetResponse,
                          callback,
                          self._protorpc_Set)

  def Delete(self, request, rpc=None, callback=None):
    """Make a Delete RPC call.

    Args:
      request: a DeleteRequest instance.
      rpc: Optional RPC instance to use for the call.
      callback: Optional callback. Will be called as
          callback(rpc, result). If None, the call synchronous.

    Returns:
      The DeleteResponse if callback is None. Otherwise, returns None.
    """

    return self._MakeCall(rpc,
                          self._full_name_Delete,
                          'Delete',
                          request,
                          DeleteResponse,
                          callback,
                          self._protorpc_Delete)

  def Mutate(self, request, rpc=None, callback=None):
    """Make a Mutate RPC call.

    Args:
      request: a MutationRequest instance.
      rpc: Optional RPC instance to use for the call.
      callback: Optional callback. Will be called as
          callback(rpc, result). If None, the call synchronous.

    Returns:
      The MutationResponse if callback is None. Otherwise, returns None.
    """

    return self._MakeCall(rpc,
                          self._full_name_Mutate,
                          'Mutate',
                          request,
                          MutationResponse,
                          callback,
                          self._protorpc_Mutate)


class KansasServer(object):
  """Base class for KansasServer Stubby servers."""

  def __init__(self):
    raise NotImplementedError('Server stubs are not supported yet. '
                              'Use KansasServer.NewStub(...) to '
                              'create a client stub')

  def NewStub(rpc_stub_parameters):
    """Creates a new KansasServer Stubby client stub.

    Args:
      rpc_stub_parameters: an RPC_StubParameter instance.
    """

    if _client_stub_base_class is object:
      raise RuntimeError('Add //net/rpc/python as a dependency to use Stubby')
    return _KansasServer_ClientStub(rpc_stub_parameters)
  NewStub = staticmethod(NewStub)

__all__ = ['ResponseCodes','UserKeyProto','RequestHeader','ResponseHeader','LookupRequest','LookupRequest_DataLimits','LookupRequest_Data','LookupRequest_MetaData','LookupResponse','LookupResponse_DataItem','LookupResponse_Data','LookupResponse_MetaData','SetRequest','SetRequest_Data','SetRequest_MetaData','SetResponse','SetResponse_Data','SetResponse_MetaData','DeleteRequest','DeleteRequest_DataLimits','DeleteRequest_Data','DeleteResponse','DeleteResponse_Data','MutationRequest','MutationRequest_ModSetCell','MutationRequest_ModDeleteCell','MutationRequest_ModDeleteType','MutationRequest_ModSubscribeType','MutationRequest_Mod','MutationResponse']
