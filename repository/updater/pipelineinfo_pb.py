# This file automatically generated by protocol-compiler from repository/updater/pipelineinfo.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

class MicroRepmap_LinkInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.url_ = ""
    self.representativeurlfp96_ = ""
    self.has_url_ = 0
    self.has_representativeurlfp96_ = 0
    if contents is not None: self.MergeFromString(contents)

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def representativeurlfp96(self): return self.representativeurlfp96_

  def set_representativeurlfp96(self, x):
    self.has_representativeurlfp96_ = 1
    self.representativeurlfp96_ = x

  def clear_representativeurlfp96(self):
    self.has_representativeurlfp96_ = 0
    self.representativeurlfp96_ = ""

  def has_representativeurlfp96(self): return self.has_representativeurlfp96_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_url()): self.set_url(x.url())
    if (x.has_representativeurlfp96()): self.set_representativeurlfp96(x.representativeurlfp96())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.MicroRepmap', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.MicroRepmap')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.MicroRepmap', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.MicroRepmap', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.MicroRepmap', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if self.has_representativeurlfp96_ != x.has_representativeurlfp96_: return 0
    if self.has_representativeurlfp96_ and self.representativeurlfp96_ != x.representativeurlfp96_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_url_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: url not set.')
    if (not self.has_representativeurlfp96_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: representativeurlfp96 not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.url_))
    n += self.lengthString(len(self.representativeurlfp96_))
    return n + 2

  def Clear(self):
    self.clear_url()
    self.clear_representativeurlfp96()

  def OutputUnchecked(self, out):
    out.putVarInt32(26)
    out.putPrefixedString(self.url_)
    out.putVarInt32(34)
    out.putPrefixedString(self.representativeurlfp96_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 26:
        self.set_url(d.getPrefixedString())
        continue
      if tt == 34:
        self.set_representativeurlfp96(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_url_: res+=prefix+("Url: %s\n" % self.DebugFormatString(self.url_))
    if self.has_representativeurlfp96_: res+=prefix+("RepresentativeUrlFp96: %s\n" % self.DebugFormatString(self.representativeurlfp96_))
    return res

class MicroRepmap(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.urlfp96_deprecated_ = ""
    self.url_ = ""
    self.timestamp_ = 0
    self.linkinfo_ = []
    self.has_urlfp96_deprecated_ = 0
    self.has_url_ = 0
    self.has_timestamp_ = 0
    if contents is not None: self.MergeFromString(contents)

  def urlfp96_deprecated(self): return self.urlfp96_deprecated_

  def set_urlfp96_deprecated(self, x):
    self.has_urlfp96_deprecated_ = 1
    self.urlfp96_deprecated_ = x

  def clear_urlfp96_deprecated(self):
    self.has_urlfp96_deprecated_ = 0
    self.urlfp96_deprecated_ = ""

  def has_urlfp96_deprecated(self): return self.has_urlfp96_deprecated_

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def timestamp(self): return self.timestamp_

  def set_timestamp(self, x):
    self.has_timestamp_ = 1
    self.timestamp_ = x

  def clear_timestamp(self):
    self.has_timestamp_ = 0
    self.timestamp_ = 0

  def has_timestamp(self): return self.has_timestamp_

  def linkinfo_size(self): return len(self.linkinfo_)
  def linkinfo_list(self): return self.linkinfo_

  def linkinfo(self, i):
    return self.linkinfo_[i]

  def mutable_linkinfo(self, i):
    return self.linkinfo_[i]

  def add_linkinfo(self):
    x = MicroRepmap_LinkInfo()
    self.linkinfo_.append(x)
    return x

  def clear_linkinfo(self):
    self.linkinfo_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_urlfp96_deprecated()): self.set_urlfp96_deprecated(x.urlfp96_deprecated())
    if (x.has_url()): self.set_url(x.url())
    if (x.has_timestamp()): self.set_timestamp(x.timestamp())
    for i in xrange(x.linkinfo_size()): self.add_linkinfo().CopyFrom(x.linkinfo(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.MicroRepmap', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.MicroRepmap')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.MicroRepmap', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.MicroRepmap', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.MicroRepmap', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_urlfp96_deprecated_ != x.has_urlfp96_deprecated_: return 0
    if self.has_urlfp96_deprecated_ and self.urlfp96_deprecated_ != x.urlfp96_deprecated_: return 0
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if self.has_timestamp_ != x.has_timestamp_: return 0
    if self.has_timestamp_ and self.timestamp_ != x.timestamp_: return 0
    if len(self.linkinfo_) != len(x.linkinfo_): return 0
    for e1, e2 in zip(self.linkinfo_, x.linkinfo_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_timestamp_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: timestamp not set.')
    for i in xrange(len(self.linkinfo_)):
      if (not self.linkinfo_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_urlfp96_deprecated_): n += 1 + self.lengthString(len(self.urlfp96_deprecated_))
    if (self.has_url_): n += 1 + self.lengthString(len(self.url_))
    n += self.lengthVarInt64(self.timestamp_)
    n += 2 * len(self.linkinfo_)
    for i in xrange(len(self.linkinfo_)): n += self.linkinfo_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_urlfp96_deprecated()
    self.clear_url()
    self.clear_timestamp()
    self.clear_linkinfo()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.timestamp_)
    for i in xrange(len(self.linkinfo_)):
      out.putVarInt32(19)
      self.linkinfo_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    if (self.has_urlfp96_deprecated_):
      out.putVarInt32(42)
      out.putPrefixedString(self.urlfp96_deprecated_)
    if (self.has_url_):
      out.putVarInt32(50)
      out.putPrefixedString(self.url_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_timestamp(d.getVarInt32())
        continue
      if tt == 19:
        self.add_linkinfo().TryMerge(d)
        continue
      if tt == 42:
        self.set_urlfp96_deprecated(d.getPrefixedString())
        continue
      if tt == 50:
        self.set_url(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_urlfp96_deprecated_: res+=prefix+("UrlFp96_DEPRECATED: %s\n" % self.DebugFormatString(self.urlfp96_deprecated_))
    if self.has_url_: res+=prefix+("Url: %s\n" % self.DebugFormatString(self.url_))
    if self.has_timestamp_: res+=prefix+("TimeStamp: %s\n" % self.DebugFormatInt32(self.timestamp_))
    cnt=0
    for e in self.linkinfo_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("LinkInfo%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kUrlFp96_DEPRECATED = 5
  kUrl = 6
  kTimeStamp = 1
  kLinkInfoGroup = 2
  kLinkInfoUrl = 3
  kLinkInfoRepresentativeUrlFp96 = 4

  _TEXT = (
   "ErrorCode",  #   0
   "TimeStamp",  #   1
   "LinkInfo",  #   2
   "Url",  #   3
   "RepresentativeUrlFp96",  #   4
   "UrlFp96_DEPRECATED",  #   5
   "Url",  #   6
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x25,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x69,
    0x70,
    0x65,
    0x6c,
    0x69,
    0x6e,
    0x65,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1e,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x4d,
    0x69,
    0x63,
    0x72,
    0x6f,
    0x52,
    0x65,
    0x70,
    0x6d,
    0x61,
    0x70,
    0x13,
    0x1a,
    0x12,
    0x55,
    0x72,
    0x6c,
    0x46,
    0x70,
    0x39,
    0x36,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x03,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x53,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x52,
    0x65,
    0x70,
    0x72,
    0x65,
    0x73,
    0x65,
    0x6e,
    0x74,
    0x61,
    0x74,
    0x69,
    0x76,
    0x65,
    0x55,
    0x72,
    0x6c,
    0x46,
    0x70,
    0x39,
    0x36,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x03,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['MicroRepmap','MicroRepmap_LinkInfo']
