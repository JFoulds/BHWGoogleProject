# This file automatically generated by protocol-compiler from repository/updater/indexselection.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

from google3.crawler.diagnostics.coverage.index_coverage_pb import IndexCoverage
class AttributeFraction(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.attribute_name_ = ""
    self.guaranteefraction_ = 0.0
    self.scorerid_ = 0
    self.minfraction_ = 0.0
    self.maxfraction_ = 1.0
    self.attribute_value_ = 0
    self.has_attribute_name_ = 0
    self.has_guaranteefraction_ = 0
    self.has_scorerid_ = 0
    self.has_minfraction_ = 0
    self.has_maxfraction_ = 0
    self.has_attribute_value_ = 0
    if contents is not None: self.MergeFromString(contents)

  def attribute_name(self): return self.attribute_name_

  def set_attribute_name(self, x):
    self.has_attribute_name_ = 1
    self.attribute_name_ = x

  def clear_attribute_name(self):
    self.has_attribute_name_ = 0
    self.attribute_name_ = ""

  def has_attribute_name(self): return self.has_attribute_name_

  def guaranteefraction(self): return self.guaranteefraction_

  def set_guaranteefraction(self, x):
    self.has_guaranteefraction_ = 1
    self.guaranteefraction_ = x

  def clear_guaranteefraction(self):
    self.has_guaranteefraction_ = 0
    self.guaranteefraction_ = 0.0

  def has_guaranteefraction(self): return self.has_guaranteefraction_

  def scorerid(self): return self.scorerid_

  def set_scorerid(self, x):
    self.has_scorerid_ = 1
    self.scorerid_ = x

  def clear_scorerid(self):
    self.has_scorerid_ = 0
    self.scorerid_ = 0

  def has_scorerid(self): return self.has_scorerid_

  def minfraction(self): return self.minfraction_

  def set_minfraction(self, x):
    self.has_minfraction_ = 1
    self.minfraction_ = x

  def clear_minfraction(self):
    self.has_minfraction_ = 0
    self.minfraction_ = 0.0

  def has_minfraction(self): return self.has_minfraction_

  def maxfraction(self): return self.maxfraction_

  def set_maxfraction(self, x):
    self.has_maxfraction_ = 1
    self.maxfraction_ = x

  def clear_maxfraction(self):
    self.has_maxfraction_ = 0
    self.maxfraction_ = 1.0

  def has_maxfraction(self): return self.has_maxfraction_

  def attribute_value(self): return self.attribute_value_

  def set_attribute_value(self, x):
    self.has_attribute_value_ = 1
    self.attribute_value_ = x

  def clear_attribute_value(self):
    self.has_attribute_value_ = 0
    self.attribute_value_ = 0

  def has_attribute_value(self): return self.has_attribute_value_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_attribute_name()): self.set_attribute_name(x.attribute_name())
    if (x.has_guaranteefraction()): self.set_guaranteefraction(x.guaranteefraction())
    if (x.has_scorerid()): self.set_scorerid(x.scorerid())
    if (x.has_minfraction()): self.set_minfraction(x.minfraction())
    if (x.has_maxfraction()): self.set_maxfraction(x.maxfraction())
    if (x.has_attribute_value()): self.set_attribute_value(x.attribute_value())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.AttributeFraction', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.AttributeFraction')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.AttributeFraction', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.AttributeFraction', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.AttributeFraction', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_attribute_name_ != x.has_attribute_name_: return 0
    if self.has_attribute_name_ and self.attribute_name_ != x.attribute_name_: return 0
    if self.has_guaranteefraction_ != x.has_guaranteefraction_: return 0
    if self.has_guaranteefraction_ and self.guaranteefraction_ != x.guaranteefraction_: return 0
    if self.has_scorerid_ != x.has_scorerid_: return 0
    if self.has_scorerid_ and self.scorerid_ != x.scorerid_: return 0
    if self.has_minfraction_ != x.has_minfraction_: return 0
    if self.has_minfraction_ and self.minfraction_ != x.minfraction_: return 0
    if self.has_maxfraction_ != x.has_maxfraction_: return 0
    if self.has_maxfraction_ and self.maxfraction_ != x.maxfraction_: return 0
    if self.has_attribute_value_ != x.has_attribute_value_: return 0
    if self.has_attribute_value_ and self.attribute_value_ != x.attribute_value_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_attribute_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: attribute_name not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.attribute_name_))
    if (self.has_guaranteefraction_): n += 9
    if (self.has_scorerid_): n += 1 + self.lengthVarInt64(self.scorerid_)
    if (self.has_minfraction_): n += 9
    if (self.has_maxfraction_): n += 9
    if (self.has_attribute_value_): n += 1 + self.lengthVarInt64(self.attribute_value_)
    return n + 1

  def Clear(self):
    self.clear_attribute_name()
    self.clear_guaranteefraction()
    self.clear_scorerid()
    self.clear_minfraction()
    self.clear_maxfraction()
    self.clear_attribute_value()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.attribute_name_)
    if (self.has_guaranteefraction_):
      out.putVarInt32(17)
      out.putDouble(self.guaranteefraction_)
    if (self.has_scorerid_):
      out.putVarInt32(24)
      out.putVarInt32(self.scorerid_)
    if (self.has_minfraction_):
      out.putVarInt32(33)
      out.putDouble(self.minfraction_)
    if (self.has_maxfraction_):
      out.putVarInt32(41)
      out.putDouble(self.maxfraction_)
    if (self.has_attribute_value_):
      out.putVarInt32(48)
      out.putVarInt64(self.attribute_value_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_attribute_name(d.getPrefixedString())
        continue
      if tt == 17:
        self.set_guaranteefraction(d.getDouble())
        continue
      if tt == 24:
        self.set_scorerid(d.getVarInt32())
        continue
      if tt == 33:
        self.set_minfraction(d.getDouble())
        continue
      if tt == 41:
        self.set_maxfraction(d.getDouble())
        continue
      if tt == 48:
        self.set_attribute_value(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_attribute_name_: res+=prefix+("Attribute_Name: %s\n" % self.DebugFormatString(self.attribute_name_))
    if self.has_guaranteefraction_: res+=prefix+("GuaranteeFraction: %s\n" % self.DebugFormat(self.guaranteefraction_))
    if self.has_scorerid_: res+=prefix+("ScorerId: %s\n" % self.DebugFormatInt32(self.scorerid_))
    if self.has_minfraction_: res+=prefix+("MinFraction: %s\n" % self.DebugFormat(self.minfraction_))
    if self.has_maxfraction_: res+=prefix+("MaxFraction: %s\n" % self.DebugFormat(self.maxfraction_))
    if self.has_attribute_value_: res+=prefix+("Attribute_Value: %s\n" % self.DebugFormatInt64(self.attribute_value_))
    return res

  kAttribute_Name = 1
  kGuaranteeFraction = 2
  kScorerId = 3
  kMinFraction = 4
  kMaxFraction = 5
  kAttribute_Value = 6

  _TEXT = (
   "ErrorCode",  #   0
   "Attribute_Name",  #   1
   "GuaranteeFraction",  #   2
   "ScorerId",  #   3
   "MinFraction",  #   4
   "MaxFraction",  #   5
   "Attribute_Value",  #   6
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.DOUBLE,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.DOUBLE,  #   4

   ProtocolBuffer.Encoder.DOUBLE,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x24,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x13,
    0x1a,
    0x0e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x5f,
    0x4e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x49,
    0x64,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x4d,
    0x69,
    0x6e,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x04,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x4d,
    0x61,
    0x78,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x05,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x5f,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class IndexSelectionArgs_LanguageConstraints_DEPRECATED(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.language_ = ""
    self.minfraction_ = 0.0
    self.maxfraction_ = 1.0
    self.has_language_ = 0
    self.has_minfraction_ = 0
    self.has_maxfraction_ = 0
    if contents is not None: self.MergeFromString(contents)

  def language(self): return self.language_

  def set_language(self, x):
    self.has_language_ = 1
    self.language_ = x

  def clear_language(self):
    self.has_language_ = 0
    self.language_ = ""

  def has_language(self): return self.has_language_

  def minfraction(self): return self.minfraction_

  def set_minfraction(self, x):
    self.has_minfraction_ = 1
    self.minfraction_ = x

  def clear_minfraction(self):
    self.has_minfraction_ = 0
    self.minfraction_ = 0.0

  def has_minfraction(self): return self.has_minfraction_

  def maxfraction(self): return self.maxfraction_

  def set_maxfraction(self, x):
    self.has_maxfraction_ = 1
    self.maxfraction_ = x

  def clear_maxfraction(self):
    self.has_maxfraction_ = 0
    self.maxfraction_ = 1.0

  def has_maxfraction(self): return self.has_maxfraction_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_language()): self.set_language(x.language())
    if (x.has_minfraction()): self.set_minfraction(x.minfraction())
    if (x.has_maxfraction()): self.set_maxfraction(x.maxfraction())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_language_ != x.has_language_: return 0
    if self.has_language_ and self.language_ != x.language_: return 0
    if self.has_minfraction_ != x.has_minfraction_: return 0
    if self.has_minfraction_ and self.minfraction_ != x.minfraction_: return 0
    if self.has_maxfraction_ != x.has_maxfraction_: return 0
    if self.has_maxfraction_ and self.maxfraction_ != x.maxfraction_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_language_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: language not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.language_))
    if (self.has_minfraction_): n += 9
    if (self.has_maxfraction_): n += 9
    return n + 1

  def Clear(self):
    self.clear_language()
    self.clear_minfraction()
    self.clear_maxfraction()

  def OutputUnchecked(self, out):
    out.putVarInt32(98)
    out.putPrefixedString(self.language_)
    if (self.has_minfraction_):
      out.putVarInt32(105)
      out.putDouble(self.minfraction_)
    if (self.has_maxfraction_):
      out.putVarInt32(113)
      out.putDouble(self.maxfraction_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 92: break
      if tt == 98:
        self.set_language(d.getPrefixedString())
        continue
      if tt == 105:
        self.set_minfraction(d.getDouble())
        continue
      if tt == 113:
        self.set_maxfraction(d.getDouble())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_language_: res+=prefix+("Language: %s\n" % self.DebugFormatString(self.language_))
    if self.has_minfraction_: res+=prefix+("MinFraction: %s\n" % self.DebugFormat(self.minfraction_))
    if self.has_maxfraction_: res+=prefix+("MaxFraction: %s\n" % self.DebugFormat(self.maxfraction_))
    return res

class IndexSelectionArgs_RegionalSpec(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.languages_ = []
    self.encodings_ = []
    self.tlds_ = []
    self.geocodes_ = []
    if contents is not None: self.MergeFromString(contents)

  def languages_size(self): return len(self.languages_)
  def languages_list(self): return self.languages_

  def languages(self, i):
    return self.languages_[i]

  def set_languages(self, i, x):
    self.languages_[i] = x

  def add_languages(self, x):
    self.languages_.append(x)

  def clear_languages(self):
    self.languages_ = []

  def encodings_size(self): return len(self.encodings_)
  def encodings_list(self): return self.encodings_

  def encodings(self, i):
    return self.encodings_[i]

  def set_encodings(self, i, x):
    self.encodings_[i] = x

  def add_encodings(self, x):
    self.encodings_.append(x)

  def clear_encodings(self):
    self.encodings_ = []

  def tlds_size(self): return len(self.tlds_)
  def tlds_list(self): return self.tlds_

  def tlds(self, i):
    return self.tlds_[i]

  def set_tlds(self, i, x):
    self.tlds_[i] = x

  def add_tlds(self, x):
    self.tlds_.append(x)

  def clear_tlds(self):
    self.tlds_ = []

  def geocodes_size(self): return len(self.geocodes_)
  def geocodes_list(self): return self.geocodes_

  def geocodes(self, i):
    return self.geocodes_[i]

  def set_geocodes(self, i, x):
    self.geocodes_[i] = x

  def add_geocodes(self, x):
    self.geocodes_.append(x)

  def clear_geocodes(self):
    self.geocodes_ = []


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.languages_size()): self.add_languages(x.languages(i))
    for i in xrange(x.encodings_size()): self.add_encodings(x.encodings(i))
    for i in xrange(x.tlds_size()): self.add_tlds(x.tlds(i))
    for i in xrange(x.geocodes_size()): self.add_geocodes(x.geocodes(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.languages_) != len(x.languages_): return 0
    for e1, e2 in zip(self.languages_, x.languages_):
      if e1 != e2: return 0
    if len(self.encodings_) != len(x.encodings_): return 0
    for e1, e2 in zip(self.encodings_, x.encodings_):
      if e1 != e2: return 0
    if len(self.tlds_) != len(x.tlds_): return 0
    for e1, e2 in zip(self.tlds_, x.tlds_):
      if e1 != e2: return 0
    if len(self.geocodes_) != len(x.geocodes_): return 0
    for e1, e2 in zip(self.geocodes_, x.geocodes_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.languages_)
    for i in xrange(len(self.languages_)): n += self.lengthString(len(self.languages_[i]))
    n += 2 * len(self.encodings_)
    for i in xrange(len(self.encodings_)): n += self.lengthString(len(self.encodings_[i]))
    n += 2 * len(self.tlds_)
    for i in xrange(len(self.tlds_)): n += self.lengthString(len(self.tlds_[i]))
    n += 2 * len(self.geocodes_)
    for i in xrange(len(self.geocodes_)): n += self.lengthVarInt64(self.geocodes_[i])
    return n + 0

  def Clear(self):
    self.clear_languages()
    self.clear_encodings()
    self.clear_tlds()
    self.clear_geocodes()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.languages_)):
      out.putVarInt32(218)
      out.putPrefixedString(self.languages_[i])
    for i in xrange(len(self.encodings_)):
      out.putVarInt32(226)
      out.putPrefixedString(self.encodings_[i])
    for i in xrange(len(self.tlds_)):
      out.putVarInt32(234)
      out.putPrefixedString(self.tlds_[i])
    for i in xrange(len(self.geocodes_)):
      out.putVarInt32(240)
      out.putVarInt32(self.geocodes_[i])

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 212: break
      if tt == 218:
        self.add_languages(d.getPrefixedString())
        continue
      if tt == 226:
        self.add_encodings(d.getPrefixedString())
        continue
      if tt == 234:
        self.add_tlds(d.getPrefixedString())
        continue
      if tt == 240:
        self.add_geocodes(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.languages_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Languages%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    cnt=0
    for e in self.encodings_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Encodings%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    cnt=0
    for e in self.tlds_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("TLDs%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    cnt=0
    for e in self.geocodes_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Geocodes%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    return res

class IndexSelectionArgs_LargeDocumentException(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.index_ = 0
    self.docsize_ = 0
    self.has_index_ = 0
    self.has_docsize_ = 0
    if contents is not None: self.MergeFromString(contents)

  def index(self): return self.index_

  def set_index(self, x):
    self.has_index_ = 1
    self.index_ = x

  def clear_index(self):
    self.has_index_ = 0
    self.index_ = 0

  def has_index(self): return self.has_index_

  def docsize(self): return self.docsize_

  def set_docsize(self, x):
    self.has_docsize_ = 1
    self.docsize_ = x

  def clear_docsize(self):
    self.has_docsize_ = 0
    self.docsize_ = 0

  def has_docsize(self): return self.has_docsize_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_index()): self.set_index(x.index())
    if (x.has_docsize()): self.set_docsize(x.docsize())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_index_ != x.has_index_: return 0
    if self.has_index_ and self.index_ != x.index_: return 0
    if self.has_docsize_ != x.has_docsize_: return 0
    if self.has_docsize_ and self.docsize_ != x.docsize_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_index_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: index not set.')
    if (not self.has_docsize_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: docsize not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.index_)
    n += self.lengthVarInt64(self.docsize_)
    return n + 4

  def Clear(self):
    self.clear_index()
    self.clear_docsize()

  def OutputUnchecked(self, out):
    out.putVarInt32(264)
    out.putVarInt32(self.index_)
    out.putVarInt32(272)
    out.putVarInt64(self.docsize_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 260: break
      if tt == 264:
        self.set_index(d.getVarInt32())
        continue
      if tt == 272:
        self.set_docsize(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_index_: res+=prefix+("Index: %s\n" % self.DebugFormatInt32(self.index_))
    if self.has_docsize_: res+=prefix+("DocSize: %s\n" % self.DebugFormatInt64(self.docsize_))
    return res

class IndexSelectionArgs_LowPageRankException(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.index_ = 0
    self.pagerank_ = 0
    self.has_index_ = 0
    self.has_pagerank_ = 0
    if contents is not None: self.MergeFromString(contents)

  def index(self): return self.index_

  def set_index(self, x):
    self.has_index_ = 1
    self.index_ = x

  def clear_index(self):
    self.has_index_ = 0
    self.index_ = 0

  def has_index(self): return self.has_index_

  def pagerank(self): return self.pagerank_

  def set_pagerank(self, x):
    self.has_pagerank_ = 1
    self.pagerank_ = x

  def clear_pagerank(self):
    self.has_pagerank_ = 0
    self.pagerank_ = 0

  def has_pagerank(self): return self.has_pagerank_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_index()): self.set_index(x.index())
    if (x.has_pagerank()): self.set_pagerank(x.pagerank())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_index_ != x.has_index_: return 0
    if self.has_index_ and self.index_ != x.index_: return 0
    if self.has_pagerank_ != x.has_pagerank_: return 0
    if self.has_pagerank_ and self.pagerank_ != x.pagerank_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_index_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: index not set.')
    if (not self.has_pagerank_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: pagerank not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.index_)
    n += self.lengthVarInt64(self.pagerank_)
    return n + 4

  def Clear(self):
    self.clear_index()
    self.clear_pagerank()

  def OutputUnchecked(self, out):
    out.putVarInt32(288)
    out.putVarInt32(self.index_)
    out.putVarInt32(296)
    out.putVarInt32(self.pagerank_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 284: break
      if tt == 288:
        self.set_index(d.getVarInt32())
        continue
      if tt == 296:
        self.set_pagerank(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_index_: res+=prefix+("Index: %s\n" % self.DebugFormatInt32(self.index_))
    if self.has_pagerank_: res+=prefix+("PageRank: %s\n" % self.DebugFormatInt32(self.pagerank_))
    return res

class IndexSelectionArgs_ContentToExpire(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.category_ = ""
    self.expiryepoch_ = ""
    self.delta_ = 0
    self.has_category_ = 0
    self.has_expiryepoch_ = 0
    self.has_delta_ = 0
    if contents is not None: self.MergeFromString(contents)

  def category(self): return self.category_

  def set_category(self, x):
    self.has_category_ = 1
    self.category_ = x

  def clear_category(self):
    self.has_category_ = 0
    self.category_ = ""

  def has_category(self): return self.has_category_

  def expiryepoch(self): return self.expiryepoch_

  def set_expiryepoch(self, x):
    self.has_expiryepoch_ = 1
    self.expiryepoch_ = x

  def clear_expiryepoch(self):
    self.has_expiryepoch_ = 0
    self.expiryepoch_ = ""

  def has_expiryepoch(self): return self.has_expiryepoch_

  def delta(self): return self.delta_

  def set_delta(self, x):
    self.has_delta_ = 1
    self.delta_ = x

  def clear_delta(self):
    self.has_delta_ = 0
    self.delta_ = 0

  def has_delta(self): return self.has_delta_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_category()): self.set_category(x.category())
    if (x.has_expiryepoch()): self.set_expiryepoch(x.expiryepoch())
    if (x.has_delta()): self.set_delta(x.delta())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_category_ != x.has_category_: return 0
    if self.has_category_ and self.category_ != x.category_: return 0
    if self.has_expiryepoch_ != x.has_expiryepoch_: return 0
    if self.has_expiryepoch_ and self.expiryepoch_ != x.expiryepoch_: return 0
    if self.has_delta_ != x.has_delta_: return 0
    if self.has_delta_ and self.delta_ != x.delta_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_category_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: category not set.')
    if (not self.has_expiryepoch_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: expiryepoch not set.')
    if (not self.has_delta_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: delta not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.category_))
    n += self.lengthString(len(self.expiryepoch_))
    n += self.lengthVarInt64(self.delta_)
    return n + 6

  def Clear(self):
    self.clear_category()
    self.clear_expiryepoch()
    self.clear_delta()

  def OutputUnchecked(self, out):
    out.putVarInt32(362)
    out.putPrefixedString(self.category_)
    out.putVarInt32(370)
    out.putPrefixedString(self.expiryepoch_)
    out.putVarInt32(376)
    out.putVarInt32(self.delta_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 356: break
      if tt == 362:
        self.set_category(d.getPrefixedString())
        continue
      if tt == 370:
        self.set_expiryepoch(d.getPrefixedString())
        continue
      if tt == 376:
        self.set_delta(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_category_: res+=prefix+("Category: %s\n" % self.DebugFormatString(self.category_))
    if self.has_expiryepoch_: res+=prefix+("ExpiryEpoch: %s\n" % self.DebugFormatString(self.expiryepoch_))
    if self.has_delta_: res+=prefix+("delta: %s\n" % self.DebugFormatInt32(self.delta_))
    return res

class IndexSelectionArgs_FiletypeConstraints(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.filetype_ = 0
    self.minfraction_ = 0.0
    self.maxfraction_ = 1.0
    self.has_filetype_ = 0
    self.has_minfraction_ = 0
    self.has_maxfraction_ = 0
    if contents is not None: self.MergeFromString(contents)

  def filetype(self): return self.filetype_

  def set_filetype(self, x):
    self.has_filetype_ = 1
    self.filetype_ = x

  def clear_filetype(self):
    self.has_filetype_ = 0
    self.filetype_ = 0

  def has_filetype(self): return self.has_filetype_

  def minfraction(self): return self.minfraction_

  def set_minfraction(self, x):
    self.has_minfraction_ = 1
    self.minfraction_ = x

  def clear_minfraction(self):
    self.has_minfraction_ = 0
    self.minfraction_ = 0.0

  def has_minfraction(self): return self.has_minfraction_

  def maxfraction(self): return self.maxfraction_

  def set_maxfraction(self, x):
    self.has_maxfraction_ = 1
    self.maxfraction_ = x

  def clear_maxfraction(self):
    self.has_maxfraction_ = 0
    self.maxfraction_ = 1.0

  def has_maxfraction(self): return self.has_maxfraction_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_filetype()): self.set_filetype(x.filetype())
    if (x.has_minfraction()): self.set_minfraction(x.minfraction())
    if (x.has_maxfraction()): self.set_maxfraction(x.maxfraction())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_filetype_ != x.has_filetype_: return 0
    if self.has_filetype_ and self.filetype_ != x.filetype_: return 0
    if self.has_minfraction_ != x.has_minfraction_: return 0
    if self.has_minfraction_ and self.minfraction_ != x.minfraction_: return 0
    if self.has_maxfraction_ != x.has_maxfraction_: return 0
    if self.has_maxfraction_ and self.maxfraction_ != x.maxfraction_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_filetype_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: filetype not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.filetype_)
    if (self.has_minfraction_): n += 10
    if (self.has_maxfraction_): n += 10
    return n + 2

  def Clear(self):
    self.clear_filetype()
    self.clear_minfraction()
    self.clear_maxfraction()

  def OutputUnchecked(self, out):
    out.putVarInt32(392)
    out.putVarInt64(self.filetype_)
    if (self.has_minfraction_):
      out.putVarInt32(401)
      out.putDouble(self.minfraction_)
    if (self.has_maxfraction_):
      out.putVarInt32(409)
      out.putDouble(self.maxfraction_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 388: break
      if tt == 392:
        self.set_filetype(d.getVarInt64())
        continue
      if tt == 401:
        self.set_minfraction(d.getDouble())
        continue
      if tt == 409:
        self.set_maxfraction(d.getDouble())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_filetype_: res+=prefix+("Filetype: %s\n" % self.DebugFormatInt64(self.filetype_))
    if self.has_minfraction_: res+=prefix+("MinFraction: %s\n" % self.DebugFormat(self.minfraction_))
    if self.has_maxfraction_: res+=prefix+("MaxFraction: %s\n" % self.DebugFormat(self.maxfraction_))
    return res

class IndexSelectionArgs_TracerConstraints(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.queuename_ = ""
    self.queueid_ = 0
    self.maxfraction_ = 0.0
    self.has_queuename_ = 0
    self.has_queueid_ = 0
    self.has_maxfraction_ = 0
    if contents is not None: self.MergeFromString(contents)

  def queuename(self): return self.queuename_

  def set_queuename(self, x):
    self.has_queuename_ = 1
    self.queuename_ = x

  def clear_queuename(self):
    self.has_queuename_ = 0
    self.queuename_ = ""

  def has_queuename(self): return self.has_queuename_

  def queueid(self): return self.queueid_

  def set_queueid(self, x):
    self.has_queueid_ = 1
    self.queueid_ = x

  def clear_queueid(self):
    self.has_queueid_ = 0
    self.queueid_ = 0

  def has_queueid(self): return self.has_queueid_

  def maxfraction(self): return self.maxfraction_

  def set_maxfraction(self, x):
    self.has_maxfraction_ = 1
    self.maxfraction_ = x

  def clear_maxfraction(self):
    self.has_maxfraction_ = 0
    self.maxfraction_ = 0.0

  def has_maxfraction(self): return self.has_maxfraction_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_queuename()): self.set_queuename(x.queuename())
    if (x.has_queueid()): self.set_queueid(x.queueid())
    if (x.has_maxfraction()): self.set_maxfraction(x.maxfraction())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_queuename_ != x.has_queuename_: return 0
    if self.has_queuename_ and self.queuename_ != x.queuename_: return 0
    if self.has_queueid_ != x.has_queueid_: return 0
    if self.has_queueid_ and self.queueid_ != x.queueid_: return 0
    if self.has_maxfraction_ != x.has_maxfraction_: return 0
    if self.has_maxfraction_ and self.maxfraction_ != x.maxfraction_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_queuename_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: queuename not set.')
    if (not self.has_queueid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: queueid not set.')
    if (not self.has_maxfraction_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: maxfraction not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.queuename_))
    n += self.lengthVarInt64(self.queueid_)
    return n + 14

  def Clear(self):
    self.clear_queuename()
    self.clear_queueid()
    self.clear_maxfraction()

  def OutputUnchecked(self, out):
    out.putVarInt32(434)
    out.putPrefixedString(self.queuename_)
    out.putVarInt32(440)
    out.putVarInt32(self.queueid_)
    out.putVarInt32(449)
    out.putDouble(self.maxfraction_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 428: break
      if tt == 434:
        self.set_queuename(d.getPrefixedString())
        continue
      if tt == 440:
        self.set_queueid(d.getVarInt32())
        continue
      if tt == 449:
        self.set_maxfraction(d.getDouble())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_queuename_: res+=prefix+("queuename: %s\n" % self.DebugFormatString(self.queuename_))
    if self.has_queueid_: res+=prefix+("queueid: %s\n" % self.DebugFormatInt32(self.queueid_))
    if self.has_maxfraction_: res+=prefix+("maxfraction: %s\n" % self.DebugFormat(self.maxfraction_))
    return res

class IndexSelectionArgs_SelectedScoreDistribitionSpec(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.bucketmax_ = []
    if contents is not None: self.MergeFromString(contents)

  def bucketmax_size(self): return len(self.bucketmax_)
  def bucketmax_list(self): return self.bucketmax_

  def bucketmax(self, i):
    return self.bucketmax_[i]

  def set_bucketmax(self, i, x):
    self.bucketmax_[i] = x

  def add_bucketmax(self, x):
    self.bucketmax_.append(x)

  def clear_bucketmax(self):
    self.bucketmax_ = []


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.bucketmax_size()): self.add_bucketmax(x.bucketmax(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.bucketmax_) != len(x.bucketmax_): return 0
    for e1, e2 in zip(self.bucketmax_, x.bucketmax_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    n += 10 * len(self.bucketmax_)
    return n + 0

  def Clear(self):
    self.clear_bucketmax()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.bucketmax_)):
      out.putVarInt32(497)
      out.putDouble(self.bucketmax_[i])

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 492: break
      if tt == 497:
        self.add_bucketmax(d.getDouble())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.bucketmax_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("BucketMax%s: %s\n" % (elm, self.DebugFormat(e)))
      cnt+=1
    return res

class IndexSelectionArgs_SubIndexComponent(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = 0
    self.percent_ = 0
    self.has_type_ = 0
    self.has_percent_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = 0

  def has_type(self): return self.has_type_

  def percent(self): return self.percent_

  def set_percent(self, x):
    self.has_percent_ = 1
    self.percent_ = x

  def clear_percent(self):
    self.has_percent_ = 0
    self.percent_ = 0

  def has_percent(self): return self.has_percent_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_percent()): self.set_percent(x.percent())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_percent_ != x.has_percent_: return 0
    if self.has_percent_ and self.percent_ != x.percent_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (not self.has_percent_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: percent not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.type_)
    n += self.lengthVarInt64(self.percent_)
    return n + 4

  def Clear(self):
    self.clear_type()
    self.clear_percent()

  def OutputUnchecked(self, out):
    out.putVarInt32(528)
    out.putVarInt32(self.type_)
    out.putVarInt32(536)
    out.putVarInt32(self.percent_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 524: break
      if tt == 528:
        self.set_type(d.getVarInt32())
        continue
      if tt == 536:
        self.set_percent(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatInt32(self.type_))
    if self.has_percent_: res+=prefix+("Percent: %s\n" % self.DebugFormatInt32(self.percent_))
    return res

class IndexSelectionArgs_MinScoreForDocs(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.min_score_ = 0.0
    self.scorerid_ = 0
    self.has_min_score_ = 0
    self.has_scorerid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def min_score(self): return self.min_score_

  def set_min_score(self, x):
    self.has_min_score_ = 1
    self.min_score_ = x

  def clear_min_score(self):
    self.has_min_score_ = 0
    self.min_score_ = 0.0

  def has_min_score(self): return self.has_min_score_

  def scorerid(self): return self.scorerid_

  def set_scorerid(self, x):
    self.has_scorerid_ = 1
    self.scorerid_ = x

  def clear_scorerid(self):
    self.has_scorerid_ = 0
    self.scorerid_ = 0

  def has_scorerid(self): return self.has_scorerid_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_min_score()): self.set_min_score(x.min_score())
    if (x.has_scorerid()): self.set_scorerid(x.scorerid())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_min_score_ != x.has_min_score_: return 0
    if self.has_min_score_ and self.min_score_ != x.min_score_: return 0
    if self.has_scorerid_ != x.has_scorerid_: return 0
    if self.has_scorerid_ and self.scorerid_ != x.scorerid_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_min_score_): n += 6
    if (self.has_scorerid_): n += 2 + self.lengthVarInt64(self.scorerid_)
    return n + 0

  def Clear(self):
    self.clear_min_score()
    self.clear_scorerid()

  def OutputUnchecked(self, out):
    if (self.has_min_score_):
      out.putVarInt32(685)
      out.putFloat(self.min_score_)
    if (self.has_scorerid_):
      out.putVarInt32(688)
      out.putVarInt32(self.scorerid_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 676: break
      if tt == 685:
        self.set_min_score(d.getFloat())
        continue
      if tt == 688:
        self.set_scorerid(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_min_score_: res+=prefix+("min_score: %s\n" % self.DebugFormatFloat(self.min_score_))
    if self.has_scorerid_: res+=prefix+("ScorerId: %s\n" % self.DebugFormatInt32(self.scorerid_))
    return res

class IndexSelectionArgs_DiscoveryMinQuota(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.fraction_ = 0.0
    self.scorerid_ = 0
    self.discoveryqueues_ = []
    self.has_fraction_ = 0
    self.has_scorerid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def fraction(self): return self.fraction_

  def set_fraction(self, x):
    self.has_fraction_ = 1
    self.fraction_ = x

  def clear_fraction(self):
    self.has_fraction_ = 0
    self.fraction_ = 0.0

  def has_fraction(self): return self.has_fraction_

  def scorerid(self): return self.scorerid_

  def set_scorerid(self, x):
    self.has_scorerid_ = 1
    self.scorerid_ = x

  def clear_scorerid(self):
    self.has_scorerid_ = 0
    self.scorerid_ = 0

  def has_scorerid(self): return self.has_scorerid_

  def discoveryqueues_size(self): return len(self.discoveryqueues_)
  def discoveryqueues_list(self): return self.discoveryqueues_

  def discoveryqueues(self, i):
    return self.discoveryqueues_[i]

  def set_discoveryqueues(self, i, x):
    self.discoveryqueues_[i] = x

  def add_discoveryqueues(self, x):
    self.discoveryqueues_.append(x)

  def clear_discoveryqueues(self):
    self.discoveryqueues_ = []


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_fraction()): self.set_fraction(x.fraction())
    if (x.has_scorerid()): self.set_scorerid(x.scorerid())
    for i in xrange(x.discoveryqueues_size()): self.add_discoveryqueues(x.discoveryqueues(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_fraction_ != x.has_fraction_: return 0
    if self.has_fraction_ and self.fraction_ != x.fraction_: return 0
    if self.has_scorerid_ != x.has_scorerid_: return 0
    if self.has_scorerid_ and self.scorerid_ != x.scorerid_: return 0
    if len(self.discoveryqueues_) != len(x.discoveryqueues_): return 0
    for e1, e2 in zip(self.discoveryqueues_, x.discoveryqueues_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_fraction_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: fraction not set.')
    if (not self.has_scorerid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: scorerid not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.scorerid_)
    n += 2 * len(self.discoveryqueues_)
    for i in xrange(len(self.discoveryqueues_)): n += self.lengthVarInt64(self.discoveryqueues_[i])
    return n + 12

  def Clear(self):
    self.clear_fraction()
    self.clear_scorerid()
    self.clear_discoveryqueues()

  def OutputUnchecked(self, out):
    out.putVarInt32(705)
    out.putDouble(self.fraction_)
    out.putVarInt32(712)
    out.putVarInt32(self.scorerid_)
    for i in xrange(len(self.discoveryqueues_)):
      out.putVarInt32(752)
      out.putVarInt32(self.discoveryqueues_[i])

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 700: break
      if tt == 705:
        self.set_fraction(d.getDouble())
        continue
      if tt == 712:
        self.set_scorerid(d.getVarInt32())
        continue
      if tt == 752:
        self.add_discoveryqueues(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_fraction_: res+=prefix+("Fraction: %s\n" % self.DebugFormat(self.fraction_))
    if self.has_scorerid_: res+=prefix+("ScorerId: %s\n" % self.DebugFormatInt32(self.scorerid_))
    cnt=0
    for e in self.discoveryqueues_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DiscoveryQueues%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    return res

class IndexSelectionArgs_DefaultLanguageGuarantees(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.fraction_ = 0.0
    self.scorerid_ = 0
    self.has_fraction_ = 0
    self.has_scorerid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def fraction(self): return self.fraction_

  def set_fraction(self, x):
    self.has_fraction_ = 1
    self.fraction_ = x

  def clear_fraction(self):
    self.has_fraction_ = 0
    self.fraction_ = 0.0

  def has_fraction(self): return self.has_fraction_

  def scorerid(self): return self.scorerid_

  def set_scorerid(self, x):
    self.has_scorerid_ = 1
    self.scorerid_ = x

  def clear_scorerid(self):
    self.has_scorerid_ = 0
    self.scorerid_ = 0

  def has_scorerid(self): return self.has_scorerid_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_fraction()): self.set_fraction(x.fraction())
    if (x.has_scorerid()): self.set_scorerid(x.scorerid())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_fraction_ != x.has_fraction_: return 0
    if self.has_fraction_ and self.fraction_ != x.fraction_: return 0
    if self.has_scorerid_ != x.has_scorerid_: return 0
    if self.has_scorerid_ and self.scorerid_ != x.scorerid_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_fraction_): n += 10
    if (self.has_scorerid_): n += 2 + self.lengthVarInt64(self.scorerid_)
    return n + 0

  def Clear(self):
    self.clear_fraction()
    self.clear_scorerid()

  def OutputUnchecked(self, out):
    if (self.has_fraction_):
      out.putVarInt32(737)
      out.putDouble(self.fraction_)
    if (self.has_scorerid_):
      out.putVarInt32(744)
      out.putVarInt32(self.scorerid_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 732: break
      if tt == 737:
        self.set_fraction(d.getDouble())
        continue
      if tt == 744:
        self.set_scorerid(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_fraction_: res+=prefix+("Fraction: %s\n" % self.DebugFormat(self.fraction_))
    if self.has_scorerid_: res+=prefix+("ScorerId: %s\n" % self.DebugFormatInt32(self.scorerid_))
    return res

class IndexSelectionArgs_DefaultCountryGuarantees(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.fraction_ = 0.0
    self.scorerid_ = 0
    self.has_fraction_ = 0
    self.has_scorerid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def fraction(self): return self.fraction_

  def set_fraction(self, x):
    self.has_fraction_ = 1
    self.fraction_ = x

  def clear_fraction(self):
    self.has_fraction_ = 0
    self.fraction_ = 0.0

  def has_fraction(self): return self.has_fraction_

  def scorerid(self): return self.scorerid_

  def set_scorerid(self, x):
    self.has_scorerid_ = 1
    self.scorerid_ = x

  def clear_scorerid(self):
    self.has_scorerid_ = 0
    self.scorerid_ = 0

  def has_scorerid(self): return self.has_scorerid_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_fraction()): self.set_fraction(x.fraction())
    if (x.has_scorerid()): self.set_scorerid(x.scorerid())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_fraction_ != x.has_fraction_: return 0
    if self.has_fraction_ and self.fraction_ != x.fraction_: return 0
    if self.has_scorerid_ != x.has_scorerid_: return 0
    if self.has_scorerid_ and self.scorerid_ != x.scorerid_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_fraction_): n += 10
    if (self.has_scorerid_): n += 2 + self.lengthVarInt64(self.scorerid_)
    return n + 0

  def Clear(self):
    self.clear_fraction()
    self.clear_scorerid()

  def OutputUnchecked(self, out):
    if (self.has_fraction_):
      out.putVarInt32(777)
      out.putDouble(self.fraction_)
    if (self.has_scorerid_):
      out.putVarInt32(784)
      out.putVarInt32(self.scorerid_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 772: break
      if tt == 777:
        self.set_fraction(d.getDouble())
        continue
      if tt == 784:
        self.set_scorerid(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_fraction_: res+=prefix+("Fraction: %s\n" % self.DebugFormat(self.fraction_))
    if self.has_scorerid_: res+=prefix+("ScorerId: %s\n" % self.DebugFormatInt32(self.scorerid_))
    return res

class IndexSelectionArgs_DomainMinCount(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.tld_ = ""
    self.count_ = 0
    self.has_tld_ = 0
    self.has_count_ = 0
    if contents is not None: self.MergeFromString(contents)

  def tld(self): return self.tld_

  def set_tld(self, x):
    self.has_tld_ = 1
    self.tld_ = x

  def clear_tld(self):
    self.has_tld_ = 0
    self.tld_ = ""

  def has_tld(self): return self.has_tld_

  def count(self): return self.count_

  def set_count(self, x):
    self.has_count_ = 1
    self.count_ = x

  def clear_count(self):
    self.has_count_ = 0
    self.count_ = 0

  def has_count(self): return self.has_count_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_tld()): self.set_tld(x.tld())
    if (x.has_count()): self.set_count(x.count())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_tld_ != x.has_tld_: return 0
    if self.has_tld_ and self.tld_ != x.tld_: return 0
    if self.has_count_ != x.has_count_: return 0
    if self.has_count_ and self.count_ != x.count_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_tld_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: tld not set.')
    if (not self.has_count_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: count not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.tld_))
    n += self.lengthVarInt64(self.count_)
    return n + 4

  def Clear(self):
    self.clear_tld()
    self.clear_count()

  def OutputUnchecked(self, out):
    out.putVarInt32(802)
    out.putPrefixedString(self.tld_)
    out.putVarInt32(808)
    out.putVarInt64(self.count_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 796: break
      if tt == 802:
        self.set_tld(d.getPrefixedString())
        continue
      if tt == 808:
        self.set_count(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_tld_: res+=prefix+("TLD: %s\n" % self.DebugFormatString(self.tld_))
    if self.has_count_: res+=prefix+("Count: %s\n" % self.DebugFormatInt64(self.count_))
    return res

class IndexSelectionArgs_ExcludedIndices(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.index_ = 0
    self.numsegments_ = 0
    self.inlockstep_ = 0
    self.languages_ = []
    self.has_index_ = 0
    self.has_numsegments_ = 0
    self.has_inlockstep_ = 0
    if contents is not None: self.MergeFromString(contents)

  def index(self): return self.index_

  def set_index(self, x):
    self.has_index_ = 1
    self.index_ = x

  def clear_index(self):
    self.has_index_ = 0
    self.index_ = 0

  def has_index(self): return self.has_index_

  def numsegments(self): return self.numsegments_

  def set_numsegments(self, x):
    self.has_numsegments_ = 1
    self.numsegments_ = x

  def clear_numsegments(self):
    self.has_numsegments_ = 0
    self.numsegments_ = 0

  def has_numsegments(self): return self.has_numsegments_

  def inlockstep(self): return self.inlockstep_

  def set_inlockstep(self, x):
    self.has_inlockstep_ = 1
    self.inlockstep_ = x

  def clear_inlockstep(self):
    self.has_inlockstep_ = 0
    self.inlockstep_ = 0

  def has_inlockstep(self): return self.has_inlockstep_

  def languages_size(self): return len(self.languages_)
  def languages_list(self): return self.languages_

  def languages(self, i):
    return self.languages_[i]

  def set_languages(self, i, x):
    self.languages_[i] = x

  def add_languages(self, x):
    self.languages_.append(x)

  def clear_languages(self):
    self.languages_ = []


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_index()): self.set_index(x.index())
    if (x.has_numsegments()): self.set_numsegments(x.numsegments())
    if (x.has_inlockstep()): self.set_inlockstep(x.inlockstep())
    for i in xrange(x.languages_size()): self.add_languages(x.languages(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_index_ != x.has_index_: return 0
    if self.has_index_ and self.index_ != x.index_: return 0
    if self.has_numsegments_ != x.has_numsegments_: return 0
    if self.has_numsegments_ and self.numsegments_ != x.numsegments_: return 0
    if self.has_inlockstep_ != x.has_inlockstep_: return 0
    if self.has_inlockstep_ and self.inlockstep_ != x.inlockstep_: return 0
    if len(self.languages_) != len(x.languages_): return 0
    for e1, e2 in zip(self.languages_, x.languages_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_index_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: index not set.')
    if (not self.has_numsegments_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: numsegments not set.')
    if (not self.has_inlockstep_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: inlockstep not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.index_)
    n += self.lengthVarInt64(self.numsegments_)
    n += 2 * len(self.languages_)
    for i in xrange(len(self.languages_)): n += self.lengthVarInt64(self.languages_[i])
    return n + 7

  def Clear(self):
    self.clear_index()
    self.clear_numsegments()
    self.clear_inlockstep()
    self.clear_languages()

  def OutputUnchecked(self, out):
    out.putVarInt32(824)
    out.putVarInt32(self.index_)
    out.putVarInt32(832)
    out.putVarInt32(self.numsegments_)
    out.putVarInt32(840)
    out.putBoolean(self.inlockstep_)
    for i in xrange(len(self.languages_)):
      out.putVarInt32(848)
      out.putVarInt32(self.languages_[i])

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 820: break
      if tt == 824:
        self.set_index(d.getVarInt32())
        continue
      if tt == 832:
        self.set_numsegments(d.getVarInt32())
        continue
      if tt == 840:
        self.set_inlockstep(d.getBoolean())
        continue
      if tt == 848:
        self.add_languages(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_index_: res+=prefix+("Index: %s\n" % self.DebugFormatInt32(self.index_))
    if self.has_numsegments_: res+=prefix+("NumSegments: %s\n" % self.DebugFormatInt32(self.numsegments_))
    if self.has_inlockstep_: res+=prefix+("InLockstep: %s\n" % self.DebugFormatBool(self.inlockstep_))
    cnt=0
    for e in self.languages_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Languages%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    return res

class IndexSelectionArgs_ReplicateShardsException(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.start_ = 0
    self.end_ = 0
    self.has_start_ = 0
    self.has_end_ = 0
    if contents is not None: self.MergeFromString(contents)

  def start(self): return self.start_

  def set_start(self, x):
    self.has_start_ = 1
    self.start_ = x

  def clear_start(self):
    self.has_start_ = 0
    self.start_ = 0

  def has_start(self): return self.has_start_

  def end(self): return self.end_

  def set_end(self, x):
    self.has_end_ = 1
    self.end_ = x

  def clear_end(self):
    self.has_end_ = 0
    self.end_ = 0

  def has_end(self): return self.has_end_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_start()): self.set_start(x.start())
    if (x.has_end()): self.set_end(x.end())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_start_ != x.has_start_: return 0
    if self.has_start_ and self.start_ != x.start_: return 0
    if self.has_end_ != x.has_end_: return 0
    if self.has_end_ and self.end_ != x.end_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_start_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: start not set.')
    if (not self.has_end_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: end not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.start_)
    n += self.lengthVarInt64(self.end_)
    return n + 4

  def Clear(self):
    self.clear_start()
    self.clear_end()

  def OutputUnchecked(self, out):
    out.putVarInt32(864)
    out.putVarInt32(self.start_)
    out.putVarInt32(872)
    out.putVarInt32(self.end_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 860: break
      if tt == 864:
        self.set_start(d.getVarInt32())
        continue
      if tt == 872:
        self.set_end(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_start_: res+=prefix+("Start: %s\n" % self.DebugFormatInt32(self.start_))
    if self.has_end_: res+=prefix+("End: %s\n" % self.DebugFormatInt32(self.end_))
    return res

class IndexSelectionArgs(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.bootstrap_mode_ = 0
    self.index_ = ""
    self.queue_ = -1
    self.num_segments_ = 1
    self.epoch_ = ""
    self.segment_ = 0
    self.exclude_deprecated_ = []
    self.exclude_numsegments_deprecated_ = []
    self.exclude_inlockstep_deprecated_ = []
    self.excludedindices_ = []
    self.largedocumentexception_ = []
    self.lowpagerankexception_ = []
    self.replicateshardsexception_ = []
    self.reduceshard_ = 0
    self.drainsource_ = []
    self.drainsource_numtoretain_ = []
    self.drainsource_numtoretaindays_ = []
    self.drainsource_inlockstep_ = []
    self.indexsize_ = 0
    self.languageconstraints_deprecated_ = []
    self.languagefractions_ = []
    self.defaultlanguageguarantees_ = []
    self.countryfractions_ = []
    self.defaultcountryguarantees_ = []
    self.scorerid_ = 0
    self.hostlimit_file_ = ""
    self.hostlimit_multiplier_ = 1.0
    self.hostlimitoverridefile_ = ""
    self.host_minquotas_file_ = ""
    self.churnmaxfraction_ = 0.0
    self.modchurnmaxfraction_ = 0.0
    self.moddupmaxfraction_ = 0.0
    self.languagestoselect_ = []
    self.defaulthostlimit_ = -1
    self.dailyinputqueue_ = []
    self.forummaxfraction_ = 0.0
    self.clickmaxfraction_ = 0.0
    self.regionalspec_ = None
    self.premiummaxfraction_ = 0.0
    self.mobilemaxfraction_deprecated_ = 0.0
    self.source_queue_ = 0
    self.source_queue_name_ = ""
    self.source_queue_num_segdirs_ = 0
    self.source_queue_strict_selector_ = 0
    self.filterforceselectapproxdups_ = 0
    self.contenttoexpire_ = []
    self.filetypeconstraints_ = []
    self.keyholekml_ = 0
    self.tracerconstraints_ = []
    self.patternlimitmultiplier_ = 2.0
    self.domainminfraction_deprecated_ = 0.0
    self.domainmincount_deprecated_ = 0.0
    self.setiruleguaranteefraction_ = 0.0
    self.setiruleguaranteecount_ = 0.0
    self.goodhostguaranteefraction_ = 0.0
    self.goodhostguaranteecount_ = 0.0
    self.goodhostpatterns_ = []
    self.mobileguaranteefraction_ = 0.0
    self.mobileguaranteecount_ = 0.0
    self.randomdocsguaranteefraction_ = 0.0
    self.randomdocsguaranteecount_ = 0.0
    self.selectedscoredistribitionspec_ = None
    self.subindexcomponent_ = []
    self.subindex_ = 0
    self.maxtokens_ = 0
    self.tokensizelimit_ = 0
    self.defaulttokencount_ = 0
    self.setiselected_deprecated_ = 0
    self.adddocattachment_ = 0
    self.minscorefordocs_ = []
    self.discoveryminquota_ = []
    self.domainmincount_ = []
    self.countedlanguages_ = []
    self.has_bootstrap_mode_ = 0
    self.has_index_ = 0
    self.has_queue_ = 0
    self.has_num_segments_ = 0
    self.has_epoch_ = 0
    self.has_segment_ = 0
    self.has_reduceshard_ = 0
    self.has_indexsize_ = 0
    self.has_scorerid_ = 0
    self.has_hostlimit_file_ = 0
    self.has_hostlimit_multiplier_ = 0
    self.has_hostlimitoverridefile_ = 0
    self.has_host_minquotas_file_ = 0
    self.has_churnmaxfraction_ = 0
    self.has_modchurnmaxfraction_ = 0
    self.has_moddupmaxfraction_ = 0
    self.has_defaulthostlimit_ = 0
    self.has_forummaxfraction_ = 0
    self.has_clickmaxfraction_ = 0
    self.has_regionalspec_ = 0
    self.has_premiummaxfraction_ = 0
    self.has_mobilemaxfraction_deprecated_ = 0
    self.has_source_queue_ = 0
    self.has_source_queue_name_ = 0
    self.has_source_queue_num_segdirs_ = 0
    self.has_source_queue_strict_selector_ = 0
    self.has_filterforceselectapproxdups_ = 0
    self.has_keyholekml_ = 0
    self.has_patternlimitmultiplier_ = 0
    self.has_domainminfraction_deprecated_ = 0
    self.has_domainmincount_deprecated_ = 0
    self.has_setiruleguaranteefraction_ = 0
    self.has_setiruleguaranteecount_ = 0
    self.has_goodhostguaranteefraction_ = 0
    self.has_goodhostguaranteecount_ = 0
    self.has_mobileguaranteefraction_ = 0
    self.has_mobileguaranteecount_ = 0
    self.has_randomdocsguaranteefraction_ = 0
    self.has_randomdocsguaranteecount_ = 0
    self.has_selectedscoredistribitionspec_ = 0
    self.has_subindex_ = 0
    self.has_maxtokens_ = 0
    self.has_tokensizelimit_ = 0
    self.has_defaulttokencount_ = 0
    self.has_setiselected_deprecated_ = 0
    self.has_adddocattachment_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def bootstrap_mode(self): return self.bootstrap_mode_

  def set_bootstrap_mode(self, x):
    self.has_bootstrap_mode_ = 1
    self.bootstrap_mode_ = x

  def clear_bootstrap_mode(self):
    self.has_bootstrap_mode_ = 0
    self.bootstrap_mode_ = 0

  def has_bootstrap_mode(self): return self.has_bootstrap_mode_

  def index(self): return self.index_

  def set_index(self, x):
    self.has_index_ = 1
    self.index_ = x

  def clear_index(self):
    self.has_index_ = 0
    self.index_ = ""

  def has_index(self): return self.has_index_

  def queue(self): return self.queue_

  def set_queue(self, x):
    self.has_queue_ = 1
    self.queue_ = x

  def clear_queue(self):
    self.has_queue_ = 0
    self.queue_ = -1

  def has_queue(self): return self.has_queue_

  def num_segments(self): return self.num_segments_

  def set_num_segments(self, x):
    self.has_num_segments_ = 1
    self.num_segments_ = x

  def clear_num_segments(self):
    self.has_num_segments_ = 0
    self.num_segments_ = 1

  def has_num_segments(self): return self.has_num_segments_

  def epoch(self): return self.epoch_

  def set_epoch(self, x):
    self.has_epoch_ = 1
    self.epoch_ = x

  def clear_epoch(self):
    self.has_epoch_ = 0
    self.epoch_ = ""

  def has_epoch(self): return self.has_epoch_

  def segment(self): return self.segment_

  def set_segment(self, x):
    self.has_segment_ = 1
    self.segment_ = x

  def clear_segment(self):
    self.has_segment_ = 0
    self.segment_ = 0

  def has_segment(self): return self.has_segment_

  def exclude_deprecated_size(self): return len(self.exclude_deprecated_)
  def exclude_deprecated_list(self): return self.exclude_deprecated_

  def exclude_deprecated(self, i):
    return self.exclude_deprecated_[i]

  def set_exclude_deprecated(self, i, x):
    self.exclude_deprecated_[i] = x

  def add_exclude_deprecated(self, x):
    self.exclude_deprecated_.append(x)

  def clear_exclude_deprecated(self):
    self.exclude_deprecated_ = []

  def exclude_numsegments_deprecated_size(self): return len(self.exclude_numsegments_deprecated_)
  def exclude_numsegments_deprecated_list(self): return self.exclude_numsegments_deprecated_

  def exclude_numsegments_deprecated(self, i):
    return self.exclude_numsegments_deprecated_[i]

  def set_exclude_numsegments_deprecated(self, i, x):
    self.exclude_numsegments_deprecated_[i] = x

  def add_exclude_numsegments_deprecated(self, x):
    self.exclude_numsegments_deprecated_.append(x)

  def clear_exclude_numsegments_deprecated(self):
    self.exclude_numsegments_deprecated_ = []

  def exclude_inlockstep_deprecated_size(self): return len(self.exclude_inlockstep_deprecated_)
  def exclude_inlockstep_deprecated_list(self): return self.exclude_inlockstep_deprecated_

  def exclude_inlockstep_deprecated(self, i):
    return self.exclude_inlockstep_deprecated_[i]

  def set_exclude_inlockstep_deprecated(self, i, x):
    self.exclude_inlockstep_deprecated_[i] = x

  def add_exclude_inlockstep_deprecated(self, x):
    self.exclude_inlockstep_deprecated_.append(x)

  def clear_exclude_inlockstep_deprecated(self):
    self.exclude_inlockstep_deprecated_ = []

  def excludedindices_size(self): return len(self.excludedindices_)
  def excludedindices_list(self): return self.excludedindices_

  def excludedindices(self, i):
    return self.excludedindices_[i]

  def mutable_excludedindices(self, i):
    return self.excludedindices_[i]

  def add_excludedindices(self):
    x = IndexSelectionArgs_ExcludedIndices()
    self.excludedindices_.append(x)
    return x

  def clear_excludedindices(self):
    self.excludedindices_ = []
  def largedocumentexception_size(self): return len(self.largedocumentexception_)
  def largedocumentexception_list(self): return self.largedocumentexception_

  def largedocumentexception(self, i):
    return self.largedocumentexception_[i]

  def mutable_largedocumentexception(self, i):
    return self.largedocumentexception_[i]

  def add_largedocumentexception(self):
    x = IndexSelectionArgs_LargeDocumentException()
    self.largedocumentexception_.append(x)
    return x

  def clear_largedocumentexception(self):
    self.largedocumentexception_ = []
  def lowpagerankexception_size(self): return len(self.lowpagerankexception_)
  def lowpagerankexception_list(self): return self.lowpagerankexception_

  def lowpagerankexception(self, i):
    return self.lowpagerankexception_[i]

  def mutable_lowpagerankexception(self, i):
    return self.lowpagerankexception_[i]

  def add_lowpagerankexception(self):
    x = IndexSelectionArgs_LowPageRankException()
    self.lowpagerankexception_.append(x)
    return x

  def clear_lowpagerankexception(self):
    self.lowpagerankexception_ = []
  def replicateshardsexception_size(self): return len(self.replicateshardsexception_)
  def replicateshardsexception_list(self): return self.replicateshardsexception_

  def replicateshardsexception(self, i):
    return self.replicateshardsexception_[i]

  def mutable_replicateshardsexception(self, i):
    return self.replicateshardsexception_[i]

  def add_replicateshardsexception(self):
    x = IndexSelectionArgs_ReplicateShardsException()
    self.replicateshardsexception_.append(x)
    return x

  def clear_replicateshardsexception(self):
    self.replicateshardsexception_ = []
  def reduceshard(self): return self.reduceshard_

  def set_reduceshard(self, x):
    self.has_reduceshard_ = 1
    self.reduceshard_ = x

  def clear_reduceshard(self):
    self.has_reduceshard_ = 0
    self.reduceshard_ = 0

  def has_reduceshard(self): return self.has_reduceshard_

  def drainsource_size(self): return len(self.drainsource_)
  def drainsource_list(self): return self.drainsource_

  def drainsource(self, i):
    return self.drainsource_[i]

  def set_drainsource(self, i, x):
    self.drainsource_[i] = x

  def add_drainsource(self, x):
    self.drainsource_.append(x)

  def clear_drainsource(self):
    self.drainsource_ = []

  def drainsource_numtoretain_size(self): return len(self.drainsource_numtoretain_)
  def drainsource_numtoretain_list(self): return self.drainsource_numtoretain_

  def drainsource_numtoretain(self, i):
    return self.drainsource_numtoretain_[i]

  def set_drainsource_numtoretain(self, i, x):
    self.drainsource_numtoretain_[i] = x

  def add_drainsource_numtoretain(self, x):
    self.drainsource_numtoretain_.append(x)

  def clear_drainsource_numtoretain(self):
    self.drainsource_numtoretain_ = []

  def drainsource_numtoretaindays_size(self): return len(self.drainsource_numtoretaindays_)
  def drainsource_numtoretaindays_list(self): return self.drainsource_numtoretaindays_

  def drainsource_numtoretaindays(self, i):
    return self.drainsource_numtoretaindays_[i]

  def set_drainsource_numtoretaindays(self, i, x):
    self.drainsource_numtoretaindays_[i] = x

  def add_drainsource_numtoretaindays(self, x):
    self.drainsource_numtoretaindays_.append(x)

  def clear_drainsource_numtoretaindays(self):
    self.drainsource_numtoretaindays_ = []

  def drainsource_inlockstep_size(self): return len(self.drainsource_inlockstep_)
  def drainsource_inlockstep_list(self): return self.drainsource_inlockstep_

  def drainsource_inlockstep(self, i):
    return self.drainsource_inlockstep_[i]

  def set_drainsource_inlockstep(self, i, x):
    self.drainsource_inlockstep_[i] = x

  def add_drainsource_inlockstep(self, x):
    self.drainsource_inlockstep_.append(x)

  def clear_drainsource_inlockstep(self):
    self.drainsource_inlockstep_ = []

  def indexsize(self): return self.indexsize_

  def set_indexsize(self, x):
    self.has_indexsize_ = 1
    self.indexsize_ = x

  def clear_indexsize(self):
    self.has_indexsize_ = 0
    self.indexsize_ = 0

  def has_indexsize(self): return self.has_indexsize_

  def languageconstraints_deprecated_size(self): return len(self.languageconstraints_deprecated_)
  def languageconstraints_deprecated_list(self): return self.languageconstraints_deprecated_

  def languageconstraints_deprecated(self, i):
    return self.languageconstraints_deprecated_[i]

  def mutable_languageconstraints_deprecated(self, i):
    return self.languageconstraints_deprecated_[i]

  def add_languageconstraints_deprecated(self):
    x = IndexSelectionArgs_LanguageConstraints_DEPRECATED()
    self.languageconstraints_deprecated_.append(x)
    return x

  def clear_languageconstraints_deprecated(self):
    self.languageconstraints_deprecated_ = []
  def languagefractions_size(self): return len(self.languagefractions_)
  def languagefractions_list(self): return self.languagefractions_

  def languagefractions(self, i):
    return self.languagefractions_[i]

  def mutable_languagefractions(self, i):
    return self.languagefractions_[i]

  def add_languagefractions(self):
    x = AttributeFraction()
    self.languagefractions_.append(x)
    return x

  def clear_languagefractions(self):
    self.languagefractions_ = []
  def defaultlanguageguarantees_size(self): return len(self.defaultlanguageguarantees_)
  def defaultlanguageguarantees_list(self): return self.defaultlanguageguarantees_

  def defaultlanguageguarantees(self, i):
    return self.defaultlanguageguarantees_[i]

  def mutable_defaultlanguageguarantees(self, i):
    return self.defaultlanguageguarantees_[i]

  def add_defaultlanguageguarantees(self):
    x = IndexSelectionArgs_DefaultLanguageGuarantees()
    self.defaultlanguageguarantees_.append(x)
    return x

  def clear_defaultlanguageguarantees(self):
    self.defaultlanguageguarantees_ = []
  def countryfractions_size(self): return len(self.countryfractions_)
  def countryfractions_list(self): return self.countryfractions_

  def countryfractions(self, i):
    return self.countryfractions_[i]

  def mutable_countryfractions(self, i):
    return self.countryfractions_[i]

  def add_countryfractions(self):
    x = AttributeFraction()
    self.countryfractions_.append(x)
    return x

  def clear_countryfractions(self):
    self.countryfractions_ = []
  def defaultcountryguarantees_size(self): return len(self.defaultcountryguarantees_)
  def defaultcountryguarantees_list(self): return self.defaultcountryguarantees_

  def defaultcountryguarantees(self, i):
    return self.defaultcountryguarantees_[i]

  def mutable_defaultcountryguarantees(self, i):
    return self.defaultcountryguarantees_[i]

  def add_defaultcountryguarantees(self):
    x = IndexSelectionArgs_DefaultCountryGuarantees()
    self.defaultcountryguarantees_.append(x)
    return x

  def clear_defaultcountryguarantees(self):
    self.defaultcountryguarantees_ = []
  def scorerid(self): return self.scorerid_

  def set_scorerid(self, x):
    self.has_scorerid_ = 1
    self.scorerid_ = x

  def clear_scorerid(self):
    self.has_scorerid_ = 0
    self.scorerid_ = 0

  def has_scorerid(self): return self.has_scorerid_

  def hostlimit_file(self): return self.hostlimit_file_

  def set_hostlimit_file(self, x):
    self.has_hostlimit_file_ = 1
    self.hostlimit_file_ = x

  def clear_hostlimit_file(self):
    self.has_hostlimit_file_ = 0
    self.hostlimit_file_ = ""

  def has_hostlimit_file(self): return self.has_hostlimit_file_

  def hostlimit_multiplier(self): return self.hostlimit_multiplier_

  def set_hostlimit_multiplier(self, x):
    self.has_hostlimit_multiplier_ = 1
    self.hostlimit_multiplier_ = x

  def clear_hostlimit_multiplier(self):
    self.has_hostlimit_multiplier_ = 0
    self.hostlimit_multiplier_ = 1.0

  def has_hostlimit_multiplier(self): return self.has_hostlimit_multiplier_

  def hostlimitoverridefile(self): return self.hostlimitoverridefile_

  def set_hostlimitoverridefile(self, x):
    self.has_hostlimitoverridefile_ = 1
    self.hostlimitoverridefile_ = x

  def clear_hostlimitoverridefile(self):
    self.has_hostlimitoverridefile_ = 0
    self.hostlimitoverridefile_ = ""

  def has_hostlimitoverridefile(self): return self.has_hostlimitoverridefile_

  def host_minquotas_file(self): return self.host_minquotas_file_

  def set_host_minquotas_file(self, x):
    self.has_host_minquotas_file_ = 1
    self.host_minquotas_file_ = x

  def clear_host_minquotas_file(self):
    self.has_host_minquotas_file_ = 0
    self.host_minquotas_file_ = ""

  def has_host_minquotas_file(self): return self.has_host_minquotas_file_

  def churnmaxfraction(self): return self.churnmaxfraction_

  def set_churnmaxfraction(self, x):
    self.has_churnmaxfraction_ = 1
    self.churnmaxfraction_ = x

  def clear_churnmaxfraction(self):
    self.has_churnmaxfraction_ = 0
    self.churnmaxfraction_ = 0.0

  def has_churnmaxfraction(self): return self.has_churnmaxfraction_

  def modchurnmaxfraction(self): return self.modchurnmaxfraction_

  def set_modchurnmaxfraction(self, x):
    self.has_modchurnmaxfraction_ = 1
    self.modchurnmaxfraction_ = x

  def clear_modchurnmaxfraction(self):
    self.has_modchurnmaxfraction_ = 0
    self.modchurnmaxfraction_ = 0.0

  def has_modchurnmaxfraction(self): return self.has_modchurnmaxfraction_

  def moddupmaxfraction(self): return self.moddupmaxfraction_

  def set_moddupmaxfraction(self, x):
    self.has_moddupmaxfraction_ = 1
    self.moddupmaxfraction_ = x

  def clear_moddupmaxfraction(self):
    self.has_moddupmaxfraction_ = 0
    self.moddupmaxfraction_ = 0.0

  def has_moddupmaxfraction(self): return self.has_moddupmaxfraction_

  def languagestoselect_size(self): return len(self.languagestoselect_)
  def languagestoselect_list(self): return self.languagestoselect_

  def languagestoselect(self, i):
    return self.languagestoselect_[i]

  def set_languagestoselect(self, i, x):
    self.languagestoselect_[i] = x

  def add_languagestoselect(self, x):
    self.languagestoselect_.append(x)

  def clear_languagestoselect(self):
    self.languagestoselect_ = []

  def defaulthostlimit(self): return self.defaulthostlimit_

  def set_defaulthostlimit(self, x):
    self.has_defaulthostlimit_ = 1
    self.defaulthostlimit_ = x

  def clear_defaulthostlimit(self):
    self.has_defaulthostlimit_ = 0
    self.defaulthostlimit_ = -1

  def has_defaulthostlimit(self): return self.has_defaulthostlimit_

  def dailyinputqueue_size(self): return len(self.dailyinputqueue_)
  def dailyinputqueue_list(self): return self.dailyinputqueue_

  def dailyinputqueue(self, i):
    return self.dailyinputqueue_[i]

  def set_dailyinputqueue(self, i, x):
    self.dailyinputqueue_[i] = x

  def add_dailyinputqueue(self, x):
    self.dailyinputqueue_.append(x)

  def clear_dailyinputqueue(self):
    self.dailyinputqueue_ = []

  def forummaxfraction(self): return self.forummaxfraction_

  def set_forummaxfraction(self, x):
    self.has_forummaxfraction_ = 1
    self.forummaxfraction_ = x

  def clear_forummaxfraction(self):
    self.has_forummaxfraction_ = 0
    self.forummaxfraction_ = 0.0

  def has_forummaxfraction(self): return self.has_forummaxfraction_

  def clickmaxfraction(self): return self.clickmaxfraction_

  def set_clickmaxfraction(self, x):
    self.has_clickmaxfraction_ = 1
    self.clickmaxfraction_ = x

  def clear_clickmaxfraction(self):
    self.has_clickmaxfraction_ = 0
    self.clickmaxfraction_ = 0.0

  def has_clickmaxfraction(self): return self.has_clickmaxfraction_

  def regionalspec(self):
    if self.regionalspec_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.regionalspec_ is None: self.regionalspec_ = IndexSelectionArgs_RegionalSpec()
      finally:
        self.lazy_init_lock_.release()
    return self.regionalspec_

  def mutable_regionalspec(self): self.has_regionalspec_ = 1; return self.regionalspec()

  def clear_regionalspec(self):
    #Warning: this method does not acquire the lock.
    self.has_regionalspec_ = 0;
    if self.regionalspec_ is not None: self.regionalspec_.Clear()

  def has_regionalspec(self): return self.has_regionalspec_

  def premiummaxfraction(self): return self.premiummaxfraction_

  def set_premiummaxfraction(self, x):
    self.has_premiummaxfraction_ = 1
    self.premiummaxfraction_ = x

  def clear_premiummaxfraction(self):
    self.has_premiummaxfraction_ = 0
    self.premiummaxfraction_ = 0.0

  def has_premiummaxfraction(self): return self.has_premiummaxfraction_

  def mobilemaxfraction_deprecated(self): return self.mobilemaxfraction_deprecated_

  def set_mobilemaxfraction_deprecated(self, x):
    self.has_mobilemaxfraction_deprecated_ = 1
    self.mobilemaxfraction_deprecated_ = x

  def clear_mobilemaxfraction_deprecated(self):
    self.has_mobilemaxfraction_deprecated_ = 0
    self.mobilemaxfraction_deprecated_ = 0.0

  def has_mobilemaxfraction_deprecated(self): return self.has_mobilemaxfraction_deprecated_

  def source_queue(self): return self.source_queue_

  def set_source_queue(self, x):
    self.has_source_queue_ = 1
    self.source_queue_ = x

  def clear_source_queue(self):
    self.has_source_queue_ = 0
    self.source_queue_ = 0

  def has_source_queue(self): return self.has_source_queue_

  def source_queue_name(self): return self.source_queue_name_

  def set_source_queue_name(self, x):
    self.has_source_queue_name_ = 1
    self.source_queue_name_ = x

  def clear_source_queue_name(self):
    self.has_source_queue_name_ = 0
    self.source_queue_name_ = ""

  def has_source_queue_name(self): return self.has_source_queue_name_

  def source_queue_num_segdirs(self): return self.source_queue_num_segdirs_

  def set_source_queue_num_segdirs(self, x):
    self.has_source_queue_num_segdirs_ = 1
    self.source_queue_num_segdirs_ = x

  def clear_source_queue_num_segdirs(self):
    self.has_source_queue_num_segdirs_ = 0
    self.source_queue_num_segdirs_ = 0

  def has_source_queue_num_segdirs(self): return self.has_source_queue_num_segdirs_

  def source_queue_strict_selector(self): return self.source_queue_strict_selector_

  def set_source_queue_strict_selector(self, x):
    self.has_source_queue_strict_selector_ = 1
    self.source_queue_strict_selector_ = x

  def clear_source_queue_strict_selector(self):
    self.has_source_queue_strict_selector_ = 0
    self.source_queue_strict_selector_ = 0

  def has_source_queue_strict_selector(self): return self.has_source_queue_strict_selector_

  def filterforceselectapproxdups(self): return self.filterforceselectapproxdups_

  def set_filterforceselectapproxdups(self, x):
    self.has_filterforceselectapproxdups_ = 1
    self.filterforceselectapproxdups_ = x

  def clear_filterforceselectapproxdups(self):
    self.has_filterforceselectapproxdups_ = 0
    self.filterforceselectapproxdups_ = 0

  def has_filterforceselectapproxdups(self): return self.has_filterforceselectapproxdups_

  def contenttoexpire_size(self): return len(self.contenttoexpire_)
  def contenttoexpire_list(self): return self.contenttoexpire_

  def contenttoexpire(self, i):
    return self.contenttoexpire_[i]

  def mutable_contenttoexpire(self, i):
    return self.contenttoexpire_[i]

  def add_contenttoexpire(self):
    x = IndexSelectionArgs_ContentToExpire()
    self.contenttoexpire_.append(x)
    return x

  def clear_contenttoexpire(self):
    self.contenttoexpire_ = []
  def filetypeconstraints_size(self): return len(self.filetypeconstraints_)
  def filetypeconstraints_list(self): return self.filetypeconstraints_

  def filetypeconstraints(self, i):
    return self.filetypeconstraints_[i]

  def mutable_filetypeconstraints(self, i):
    return self.filetypeconstraints_[i]

  def add_filetypeconstraints(self):
    x = IndexSelectionArgs_FiletypeConstraints()
    self.filetypeconstraints_.append(x)
    return x

  def clear_filetypeconstraints(self):
    self.filetypeconstraints_ = []
  def keyholekml(self): return self.keyholekml_

  def set_keyholekml(self, x):
    self.has_keyholekml_ = 1
    self.keyholekml_ = x

  def clear_keyholekml(self):
    self.has_keyholekml_ = 0
    self.keyholekml_ = 0

  def has_keyholekml(self): return self.has_keyholekml_

  def tracerconstraints_size(self): return len(self.tracerconstraints_)
  def tracerconstraints_list(self): return self.tracerconstraints_

  def tracerconstraints(self, i):
    return self.tracerconstraints_[i]

  def mutable_tracerconstraints(self, i):
    return self.tracerconstraints_[i]

  def add_tracerconstraints(self):
    x = IndexSelectionArgs_TracerConstraints()
    self.tracerconstraints_.append(x)
    return x

  def clear_tracerconstraints(self):
    self.tracerconstraints_ = []
  def patternlimitmultiplier(self): return self.patternlimitmultiplier_

  def set_patternlimitmultiplier(self, x):
    self.has_patternlimitmultiplier_ = 1
    self.patternlimitmultiplier_ = x

  def clear_patternlimitmultiplier(self):
    self.has_patternlimitmultiplier_ = 0
    self.patternlimitmultiplier_ = 2.0

  def has_patternlimitmultiplier(self): return self.has_patternlimitmultiplier_

  def domainminfraction_deprecated(self): return self.domainminfraction_deprecated_

  def set_domainminfraction_deprecated(self, x):
    self.has_domainminfraction_deprecated_ = 1
    self.domainminfraction_deprecated_ = x

  def clear_domainminfraction_deprecated(self):
    self.has_domainminfraction_deprecated_ = 0
    self.domainminfraction_deprecated_ = 0.0

  def has_domainminfraction_deprecated(self): return self.has_domainminfraction_deprecated_

  def domainmincount_deprecated(self): return self.domainmincount_deprecated_

  def set_domainmincount_deprecated(self, x):
    self.has_domainmincount_deprecated_ = 1
    self.domainmincount_deprecated_ = x

  def clear_domainmincount_deprecated(self):
    self.has_domainmincount_deprecated_ = 0
    self.domainmincount_deprecated_ = 0.0

  def has_domainmincount_deprecated(self): return self.has_domainmincount_deprecated_

  def setiruleguaranteefraction(self): return self.setiruleguaranteefraction_

  def set_setiruleguaranteefraction(self, x):
    self.has_setiruleguaranteefraction_ = 1
    self.setiruleguaranteefraction_ = x

  def clear_setiruleguaranteefraction(self):
    self.has_setiruleguaranteefraction_ = 0
    self.setiruleguaranteefraction_ = 0.0

  def has_setiruleguaranteefraction(self): return self.has_setiruleguaranteefraction_

  def setiruleguaranteecount(self): return self.setiruleguaranteecount_

  def set_setiruleguaranteecount(self, x):
    self.has_setiruleguaranteecount_ = 1
    self.setiruleguaranteecount_ = x

  def clear_setiruleguaranteecount(self):
    self.has_setiruleguaranteecount_ = 0
    self.setiruleguaranteecount_ = 0.0

  def has_setiruleguaranteecount(self): return self.has_setiruleguaranteecount_

  def goodhostguaranteefraction(self): return self.goodhostguaranteefraction_

  def set_goodhostguaranteefraction(self, x):
    self.has_goodhostguaranteefraction_ = 1
    self.goodhostguaranteefraction_ = x

  def clear_goodhostguaranteefraction(self):
    self.has_goodhostguaranteefraction_ = 0
    self.goodhostguaranteefraction_ = 0.0

  def has_goodhostguaranteefraction(self): return self.has_goodhostguaranteefraction_

  def goodhostguaranteecount(self): return self.goodhostguaranteecount_

  def set_goodhostguaranteecount(self, x):
    self.has_goodhostguaranteecount_ = 1
    self.goodhostguaranteecount_ = x

  def clear_goodhostguaranteecount(self):
    self.has_goodhostguaranteecount_ = 0
    self.goodhostguaranteecount_ = 0.0

  def has_goodhostguaranteecount(self): return self.has_goodhostguaranteecount_

  def goodhostpatterns_size(self): return len(self.goodhostpatterns_)
  def goodhostpatterns_list(self): return self.goodhostpatterns_

  def goodhostpatterns(self, i):
    return self.goodhostpatterns_[i]

  def set_goodhostpatterns(self, i, x):
    self.goodhostpatterns_[i] = x

  def add_goodhostpatterns(self, x):
    self.goodhostpatterns_.append(x)

  def clear_goodhostpatterns(self):
    self.goodhostpatterns_ = []

  def mobileguaranteefraction(self): return self.mobileguaranteefraction_

  def set_mobileguaranteefraction(self, x):
    self.has_mobileguaranteefraction_ = 1
    self.mobileguaranteefraction_ = x

  def clear_mobileguaranteefraction(self):
    self.has_mobileguaranteefraction_ = 0
    self.mobileguaranteefraction_ = 0.0

  def has_mobileguaranteefraction(self): return self.has_mobileguaranteefraction_

  def mobileguaranteecount(self): return self.mobileguaranteecount_

  def set_mobileguaranteecount(self, x):
    self.has_mobileguaranteecount_ = 1
    self.mobileguaranteecount_ = x

  def clear_mobileguaranteecount(self):
    self.has_mobileguaranteecount_ = 0
    self.mobileguaranteecount_ = 0.0

  def has_mobileguaranteecount(self): return self.has_mobileguaranteecount_

  def randomdocsguaranteefraction(self): return self.randomdocsguaranteefraction_

  def set_randomdocsguaranteefraction(self, x):
    self.has_randomdocsguaranteefraction_ = 1
    self.randomdocsguaranteefraction_ = x

  def clear_randomdocsguaranteefraction(self):
    self.has_randomdocsguaranteefraction_ = 0
    self.randomdocsguaranteefraction_ = 0.0

  def has_randomdocsguaranteefraction(self): return self.has_randomdocsguaranteefraction_

  def randomdocsguaranteecount(self): return self.randomdocsguaranteecount_

  def set_randomdocsguaranteecount(self, x):
    self.has_randomdocsguaranteecount_ = 1
    self.randomdocsguaranteecount_ = x

  def clear_randomdocsguaranteecount(self):
    self.has_randomdocsguaranteecount_ = 0
    self.randomdocsguaranteecount_ = 0.0

  def has_randomdocsguaranteecount(self): return self.has_randomdocsguaranteecount_

  def selectedscoredistribitionspec(self):
    if self.selectedscoredistribitionspec_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.selectedscoredistribitionspec_ is None: self.selectedscoredistribitionspec_ = IndexSelectionArgs_SelectedScoreDistribitionSpec()
      finally:
        self.lazy_init_lock_.release()
    return self.selectedscoredistribitionspec_

  def mutable_selectedscoredistribitionspec(self): self.has_selectedscoredistribitionspec_ = 1; return self.selectedscoredistribitionspec()

  def clear_selectedscoredistribitionspec(self):
    #Warning: this method does not acquire the lock.
    self.has_selectedscoredistribitionspec_ = 0;
    if self.selectedscoredistribitionspec_ is not None: self.selectedscoredistribitionspec_.Clear()

  def has_selectedscoredistribitionspec(self): return self.has_selectedscoredistribitionspec_

  def subindexcomponent_size(self): return len(self.subindexcomponent_)
  def subindexcomponent_list(self): return self.subindexcomponent_

  def subindexcomponent(self, i):
    return self.subindexcomponent_[i]

  def mutable_subindexcomponent(self, i):
    return self.subindexcomponent_[i]

  def add_subindexcomponent(self):
    x = IndexSelectionArgs_SubIndexComponent()
    self.subindexcomponent_.append(x)
    return x

  def clear_subindexcomponent(self):
    self.subindexcomponent_ = []
  def subindex(self): return self.subindex_

  def set_subindex(self, x):
    self.has_subindex_ = 1
    self.subindex_ = x

  def clear_subindex(self):
    self.has_subindex_ = 0
    self.subindex_ = 0

  def has_subindex(self): return self.has_subindex_

  def maxtokens(self): return self.maxtokens_

  def set_maxtokens(self, x):
    self.has_maxtokens_ = 1
    self.maxtokens_ = x

  def clear_maxtokens(self):
    self.has_maxtokens_ = 0
    self.maxtokens_ = 0

  def has_maxtokens(self): return self.has_maxtokens_

  def tokensizelimit(self): return self.tokensizelimit_

  def set_tokensizelimit(self, x):
    self.has_tokensizelimit_ = 1
    self.tokensizelimit_ = x

  def clear_tokensizelimit(self):
    self.has_tokensizelimit_ = 0
    self.tokensizelimit_ = 0

  def has_tokensizelimit(self): return self.has_tokensizelimit_

  def defaulttokencount(self): return self.defaulttokencount_

  def set_defaulttokencount(self, x):
    self.has_defaulttokencount_ = 1
    self.defaulttokencount_ = x

  def clear_defaulttokencount(self):
    self.has_defaulttokencount_ = 0
    self.defaulttokencount_ = 0

  def has_defaulttokencount(self): return self.has_defaulttokencount_

  def setiselected_deprecated(self): return self.setiselected_deprecated_

  def set_setiselected_deprecated(self, x):
    self.has_setiselected_deprecated_ = 1
    self.setiselected_deprecated_ = x

  def clear_setiselected_deprecated(self):
    self.has_setiselected_deprecated_ = 0
    self.setiselected_deprecated_ = 0

  def has_setiselected_deprecated(self): return self.has_setiselected_deprecated_

  def adddocattachment(self): return self.adddocattachment_

  def set_adddocattachment(self, x):
    self.has_adddocattachment_ = 1
    self.adddocattachment_ = x

  def clear_adddocattachment(self):
    self.has_adddocattachment_ = 0
    self.adddocattachment_ = 0

  def has_adddocattachment(self): return self.has_adddocattachment_

  def minscorefordocs_size(self): return len(self.minscorefordocs_)
  def minscorefordocs_list(self): return self.minscorefordocs_

  def minscorefordocs(self, i):
    return self.minscorefordocs_[i]

  def mutable_minscorefordocs(self, i):
    return self.minscorefordocs_[i]

  def add_minscorefordocs(self):
    x = IndexSelectionArgs_MinScoreForDocs()
    self.minscorefordocs_.append(x)
    return x

  def clear_minscorefordocs(self):
    self.minscorefordocs_ = []
  def discoveryminquota_size(self): return len(self.discoveryminquota_)
  def discoveryminquota_list(self): return self.discoveryminquota_

  def discoveryminquota(self, i):
    return self.discoveryminquota_[i]

  def mutable_discoveryminquota(self, i):
    return self.discoveryminquota_[i]

  def add_discoveryminquota(self):
    x = IndexSelectionArgs_DiscoveryMinQuota()
    self.discoveryminquota_.append(x)
    return x

  def clear_discoveryminquota(self):
    self.discoveryminquota_ = []
  def domainmincount_size(self): return len(self.domainmincount_)
  def domainmincount_list(self): return self.domainmincount_

  def domainmincount(self, i):
    return self.domainmincount_[i]

  def mutable_domainmincount(self, i):
    return self.domainmincount_[i]

  def add_domainmincount(self):
    x = IndexSelectionArgs_DomainMinCount()
    self.domainmincount_.append(x)
    return x

  def clear_domainmincount(self):
    self.domainmincount_ = []
  def countedlanguages_size(self): return len(self.countedlanguages_)
  def countedlanguages_list(self): return self.countedlanguages_

  def countedlanguages(self, i):
    return self.countedlanguages_[i]

  def set_countedlanguages(self, i, x):
    self.countedlanguages_[i] = x

  def add_countedlanguages(self, x):
    self.countedlanguages_.append(x)

  def clear_countedlanguages(self):
    self.countedlanguages_ = []


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_bootstrap_mode()): self.set_bootstrap_mode(x.bootstrap_mode())
    if (x.has_index()): self.set_index(x.index())
    if (x.has_queue()): self.set_queue(x.queue())
    if (x.has_num_segments()): self.set_num_segments(x.num_segments())
    if (x.has_epoch()): self.set_epoch(x.epoch())
    if (x.has_segment()): self.set_segment(x.segment())
    for i in xrange(x.exclude_deprecated_size()): self.add_exclude_deprecated(x.exclude_deprecated(i))
    for i in xrange(x.exclude_numsegments_deprecated_size()): self.add_exclude_numsegments_deprecated(x.exclude_numsegments_deprecated(i))
    for i in xrange(x.exclude_inlockstep_deprecated_size()): self.add_exclude_inlockstep_deprecated(x.exclude_inlockstep_deprecated(i))
    for i in xrange(x.excludedindices_size()): self.add_excludedindices().CopyFrom(x.excludedindices(i))
    for i in xrange(x.largedocumentexception_size()): self.add_largedocumentexception().CopyFrom(x.largedocumentexception(i))
    for i in xrange(x.lowpagerankexception_size()): self.add_lowpagerankexception().CopyFrom(x.lowpagerankexception(i))
    for i in xrange(x.replicateshardsexception_size()): self.add_replicateshardsexception().CopyFrom(x.replicateshardsexception(i))
    if (x.has_reduceshard()): self.set_reduceshard(x.reduceshard())
    for i in xrange(x.drainsource_size()): self.add_drainsource(x.drainsource(i))
    for i in xrange(x.drainsource_numtoretain_size()): self.add_drainsource_numtoretain(x.drainsource_numtoretain(i))
    for i in xrange(x.drainsource_numtoretaindays_size()): self.add_drainsource_numtoretaindays(x.drainsource_numtoretaindays(i))
    for i in xrange(x.drainsource_inlockstep_size()): self.add_drainsource_inlockstep(x.drainsource_inlockstep(i))
    if (x.has_indexsize()): self.set_indexsize(x.indexsize())
    for i in xrange(x.languageconstraints_deprecated_size()): self.add_languageconstraints_deprecated().CopyFrom(x.languageconstraints_deprecated(i))
    for i in xrange(x.languagefractions_size()): self.add_languagefractions().CopyFrom(x.languagefractions(i))
    for i in xrange(x.defaultlanguageguarantees_size()): self.add_defaultlanguageguarantees().CopyFrom(x.defaultlanguageguarantees(i))
    for i in xrange(x.countryfractions_size()): self.add_countryfractions().CopyFrom(x.countryfractions(i))
    for i in xrange(x.defaultcountryguarantees_size()): self.add_defaultcountryguarantees().CopyFrom(x.defaultcountryguarantees(i))
    if (x.has_scorerid()): self.set_scorerid(x.scorerid())
    if (x.has_hostlimit_file()): self.set_hostlimit_file(x.hostlimit_file())
    if (x.has_hostlimit_multiplier()): self.set_hostlimit_multiplier(x.hostlimit_multiplier())
    if (x.has_hostlimitoverridefile()): self.set_hostlimitoverridefile(x.hostlimitoverridefile())
    if (x.has_host_minquotas_file()): self.set_host_minquotas_file(x.host_minquotas_file())
    if (x.has_churnmaxfraction()): self.set_churnmaxfraction(x.churnmaxfraction())
    if (x.has_modchurnmaxfraction()): self.set_modchurnmaxfraction(x.modchurnmaxfraction())
    if (x.has_moddupmaxfraction()): self.set_moddupmaxfraction(x.moddupmaxfraction())
    for i in xrange(x.languagestoselect_size()): self.add_languagestoselect(x.languagestoselect(i))
    if (x.has_defaulthostlimit()): self.set_defaulthostlimit(x.defaulthostlimit())
    for i in xrange(x.dailyinputqueue_size()): self.add_dailyinputqueue(x.dailyinputqueue(i))
    if (x.has_forummaxfraction()): self.set_forummaxfraction(x.forummaxfraction())
    if (x.has_clickmaxfraction()): self.set_clickmaxfraction(x.clickmaxfraction())
    if (x.has_regionalspec()): self.mutable_regionalspec().MergeFrom(x.regionalspec())
    if (x.has_premiummaxfraction()): self.set_premiummaxfraction(x.premiummaxfraction())
    if (x.has_mobilemaxfraction_deprecated()): self.set_mobilemaxfraction_deprecated(x.mobilemaxfraction_deprecated())
    if (x.has_source_queue()): self.set_source_queue(x.source_queue())
    if (x.has_source_queue_name()): self.set_source_queue_name(x.source_queue_name())
    if (x.has_source_queue_num_segdirs()): self.set_source_queue_num_segdirs(x.source_queue_num_segdirs())
    if (x.has_source_queue_strict_selector()): self.set_source_queue_strict_selector(x.source_queue_strict_selector())
    if (x.has_filterforceselectapproxdups()): self.set_filterforceselectapproxdups(x.filterforceselectapproxdups())
    for i in xrange(x.contenttoexpire_size()): self.add_contenttoexpire().CopyFrom(x.contenttoexpire(i))
    for i in xrange(x.filetypeconstraints_size()): self.add_filetypeconstraints().CopyFrom(x.filetypeconstraints(i))
    if (x.has_keyholekml()): self.set_keyholekml(x.keyholekml())
    for i in xrange(x.tracerconstraints_size()): self.add_tracerconstraints().CopyFrom(x.tracerconstraints(i))
    if (x.has_patternlimitmultiplier()): self.set_patternlimitmultiplier(x.patternlimitmultiplier())
    if (x.has_domainminfraction_deprecated()): self.set_domainminfraction_deprecated(x.domainminfraction_deprecated())
    if (x.has_domainmincount_deprecated()): self.set_domainmincount_deprecated(x.domainmincount_deprecated())
    if (x.has_setiruleguaranteefraction()): self.set_setiruleguaranteefraction(x.setiruleguaranteefraction())
    if (x.has_setiruleguaranteecount()): self.set_setiruleguaranteecount(x.setiruleguaranteecount())
    if (x.has_goodhostguaranteefraction()): self.set_goodhostguaranteefraction(x.goodhostguaranteefraction())
    if (x.has_goodhostguaranteecount()): self.set_goodhostguaranteecount(x.goodhostguaranteecount())
    for i in xrange(x.goodhostpatterns_size()): self.add_goodhostpatterns(x.goodhostpatterns(i))
    if (x.has_mobileguaranteefraction()): self.set_mobileguaranteefraction(x.mobileguaranteefraction())
    if (x.has_mobileguaranteecount()): self.set_mobileguaranteecount(x.mobileguaranteecount())
    if (x.has_randomdocsguaranteefraction()): self.set_randomdocsguaranteefraction(x.randomdocsguaranteefraction())
    if (x.has_randomdocsguaranteecount()): self.set_randomdocsguaranteecount(x.randomdocsguaranteecount())
    if (x.has_selectedscoredistribitionspec()): self.mutable_selectedscoredistribitionspec().MergeFrom(x.selectedscoredistribitionspec())
    for i in xrange(x.subindexcomponent_size()): self.add_subindexcomponent().CopyFrom(x.subindexcomponent(i))
    if (x.has_subindex()): self.set_subindex(x.subindex())
    if (x.has_maxtokens()): self.set_maxtokens(x.maxtokens())
    if (x.has_tokensizelimit()): self.set_tokensizelimit(x.tokensizelimit())
    if (x.has_defaulttokencount()): self.set_defaulttokencount(x.defaulttokencount())
    if (x.has_setiselected_deprecated()): self.set_setiselected_deprecated(x.setiselected_deprecated())
    if (x.has_adddocattachment()): self.set_adddocattachment(x.adddocattachment())
    for i in xrange(x.minscorefordocs_size()): self.add_minscorefordocs().CopyFrom(x.minscorefordocs(i))
    for i in xrange(x.discoveryminquota_size()): self.add_discoveryminquota().CopyFrom(x.discoveryminquota(i))
    for i in xrange(x.domainmincount_size()): self.add_domainmincount().CopyFrom(x.domainmincount(i))
    for i in xrange(x.countedlanguages_size()): self.add_countedlanguages(x.countedlanguages(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionArgs', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionArgs')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionArgs', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionArgs', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionArgs', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_bootstrap_mode_ != x.has_bootstrap_mode_: return 0
    if self.has_bootstrap_mode_ and self.bootstrap_mode_ != x.bootstrap_mode_: return 0
    if self.has_index_ != x.has_index_: return 0
    if self.has_index_ and self.index_ != x.index_: return 0
    if self.has_queue_ != x.has_queue_: return 0
    if self.has_queue_ and self.queue_ != x.queue_: return 0
    if self.has_num_segments_ != x.has_num_segments_: return 0
    if self.has_num_segments_ and self.num_segments_ != x.num_segments_: return 0
    if self.has_epoch_ != x.has_epoch_: return 0
    if self.has_epoch_ and self.epoch_ != x.epoch_: return 0
    if self.has_segment_ != x.has_segment_: return 0
    if self.has_segment_ and self.segment_ != x.segment_: return 0
    if len(self.exclude_deprecated_) != len(x.exclude_deprecated_): return 0
    for e1, e2 in zip(self.exclude_deprecated_, x.exclude_deprecated_):
      if e1 != e2: return 0
    if len(self.exclude_numsegments_deprecated_) != len(x.exclude_numsegments_deprecated_): return 0
    for e1, e2 in zip(self.exclude_numsegments_deprecated_, x.exclude_numsegments_deprecated_):
      if e1 != e2: return 0
    if len(self.exclude_inlockstep_deprecated_) != len(x.exclude_inlockstep_deprecated_): return 0
    for e1, e2 in zip(self.exclude_inlockstep_deprecated_, x.exclude_inlockstep_deprecated_):
      if e1 != e2: return 0
    if len(self.excludedindices_) != len(x.excludedindices_): return 0
    for e1, e2 in zip(self.excludedindices_, x.excludedindices_):
      if e1 != e2: return 0
    if len(self.largedocumentexception_) != len(x.largedocumentexception_): return 0
    for e1, e2 in zip(self.largedocumentexception_, x.largedocumentexception_):
      if e1 != e2: return 0
    if len(self.lowpagerankexception_) != len(x.lowpagerankexception_): return 0
    for e1, e2 in zip(self.lowpagerankexception_, x.lowpagerankexception_):
      if e1 != e2: return 0
    if len(self.replicateshardsexception_) != len(x.replicateshardsexception_): return 0
    for e1, e2 in zip(self.replicateshardsexception_, x.replicateshardsexception_):
      if e1 != e2: return 0
    if self.has_reduceshard_ != x.has_reduceshard_: return 0
    if self.has_reduceshard_ and self.reduceshard_ != x.reduceshard_: return 0
    if len(self.drainsource_) != len(x.drainsource_): return 0
    for e1, e2 in zip(self.drainsource_, x.drainsource_):
      if e1 != e2: return 0
    if len(self.drainsource_numtoretain_) != len(x.drainsource_numtoretain_): return 0
    for e1, e2 in zip(self.drainsource_numtoretain_, x.drainsource_numtoretain_):
      if e1 != e2: return 0
    if len(self.drainsource_numtoretaindays_) != len(x.drainsource_numtoretaindays_): return 0
    for e1, e2 in zip(self.drainsource_numtoretaindays_, x.drainsource_numtoretaindays_):
      if e1 != e2: return 0
    if len(self.drainsource_inlockstep_) != len(x.drainsource_inlockstep_): return 0
    for e1, e2 in zip(self.drainsource_inlockstep_, x.drainsource_inlockstep_):
      if e1 != e2: return 0
    if self.has_indexsize_ != x.has_indexsize_: return 0
    if self.has_indexsize_ and self.indexsize_ != x.indexsize_: return 0
    if len(self.languageconstraints_deprecated_) != len(x.languageconstraints_deprecated_): return 0
    for e1, e2 in zip(self.languageconstraints_deprecated_, x.languageconstraints_deprecated_):
      if e1 != e2: return 0
    if len(self.languagefractions_) != len(x.languagefractions_): return 0
    for e1, e2 in zip(self.languagefractions_, x.languagefractions_):
      if e1 != e2: return 0
    if len(self.defaultlanguageguarantees_) != len(x.defaultlanguageguarantees_): return 0
    for e1, e2 in zip(self.defaultlanguageguarantees_, x.defaultlanguageguarantees_):
      if e1 != e2: return 0
    if len(self.countryfractions_) != len(x.countryfractions_): return 0
    for e1, e2 in zip(self.countryfractions_, x.countryfractions_):
      if e1 != e2: return 0
    if len(self.defaultcountryguarantees_) != len(x.defaultcountryguarantees_): return 0
    for e1, e2 in zip(self.defaultcountryguarantees_, x.defaultcountryguarantees_):
      if e1 != e2: return 0
    if self.has_scorerid_ != x.has_scorerid_: return 0
    if self.has_scorerid_ and self.scorerid_ != x.scorerid_: return 0
    if self.has_hostlimit_file_ != x.has_hostlimit_file_: return 0
    if self.has_hostlimit_file_ and self.hostlimit_file_ != x.hostlimit_file_: return 0
    if self.has_hostlimit_multiplier_ != x.has_hostlimit_multiplier_: return 0
    if self.has_hostlimit_multiplier_ and self.hostlimit_multiplier_ != x.hostlimit_multiplier_: return 0
    if self.has_hostlimitoverridefile_ != x.has_hostlimitoverridefile_: return 0
    if self.has_hostlimitoverridefile_ and self.hostlimitoverridefile_ != x.hostlimitoverridefile_: return 0
    if self.has_host_minquotas_file_ != x.has_host_minquotas_file_: return 0
    if self.has_host_minquotas_file_ and self.host_minquotas_file_ != x.host_minquotas_file_: return 0
    if self.has_churnmaxfraction_ != x.has_churnmaxfraction_: return 0
    if self.has_churnmaxfraction_ and self.churnmaxfraction_ != x.churnmaxfraction_: return 0
    if self.has_modchurnmaxfraction_ != x.has_modchurnmaxfraction_: return 0
    if self.has_modchurnmaxfraction_ and self.modchurnmaxfraction_ != x.modchurnmaxfraction_: return 0
    if self.has_moddupmaxfraction_ != x.has_moddupmaxfraction_: return 0
    if self.has_moddupmaxfraction_ and self.moddupmaxfraction_ != x.moddupmaxfraction_: return 0
    if len(self.languagestoselect_) != len(x.languagestoselect_): return 0
    for e1, e2 in zip(self.languagestoselect_, x.languagestoselect_):
      if e1 != e2: return 0
    if self.has_defaulthostlimit_ != x.has_defaulthostlimit_: return 0
    if self.has_defaulthostlimit_ and self.defaulthostlimit_ != x.defaulthostlimit_: return 0
    if len(self.dailyinputqueue_) != len(x.dailyinputqueue_): return 0
    for e1, e2 in zip(self.dailyinputqueue_, x.dailyinputqueue_):
      if e1 != e2: return 0
    if self.has_forummaxfraction_ != x.has_forummaxfraction_: return 0
    if self.has_forummaxfraction_ and self.forummaxfraction_ != x.forummaxfraction_: return 0
    if self.has_clickmaxfraction_ != x.has_clickmaxfraction_: return 0
    if self.has_clickmaxfraction_ and self.clickmaxfraction_ != x.clickmaxfraction_: return 0
    if self.has_regionalspec_ != x.has_regionalspec_: return 0
    if self.has_regionalspec_ and self.regionalspec_ != x.regionalspec_: return 0
    if self.has_premiummaxfraction_ != x.has_premiummaxfraction_: return 0
    if self.has_premiummaxfraction_ and self.premiummaxfraction_ != x.premiummaxfraction_: return 0
    if self.has_mobilemaxfraction_deprecated_ != x.has_mobilemaxfraction_deprecated_: return 0
    if self.has_mobilemaxfraction_deprecated_ and self.mobilemaxfraction_deprecated_ != x.mobilemaxfraction_deprecated_: return 0
    if self.has_source_queue_ != x.has_source_queue_: return 0
    if self.has_source_queue_ and self.source_queue_ != x.source_queue_: return 0
    if self.has_source_queue_name_ != x.has_source_queue_name_: return 0
    if self.has_source_queue_name_ and self.source_queue_name_ != x.source_queue_name_: return 0
    if self.has_source_queue_num_segdirs_ != x.has_source_queue_num_segdirs_: return 0
    if self.has_source_queue_num_segdirs_ and self.source_queue_num_segdirs_ != x.source_queue_num_segdirs_: return 0
    if self.has_source_queue_strict_selector_ != x.has_source_queue_strict_selector_: return 0
    if self.has_source_queue_strict_selector_ and self.source_queue_strict_selector_ != x.source_queue_strict_selector_: return 0
    if self.has_filterforceselectapproxdups_ != x.has_filterforceselectapproxdups_: return 0
    if self.has_filterforceselectapproxdups_ and self.filterforceselectapproxdups_ != x.filterforceselectapproxdups_: return 0
    if len(self.contenttoexpire_) != len(x.contenttoexpire_): return 0
    for e1, e2 in zip(self.contenttoexpire_, x.contenttoexpire_):
      if e1 != e2: return 0
    if len(self.filetypeconstraints_) != len(x.filetypeconstraints_): return 0
    for e1, e2 in zip(self.filetypeconstraints_, x.filetypeconstraints_):
      if e1 != e2: return 0
    if self.has_keyholekml_ != x.has_keyholekml_: return 0
    if self.has_keyholekml_ and self.keyholekml_ != x.keyholekml_: return 0
    if len(self.tracerconstraints_) != len(x.tracerconstraints_): return 0
    for e1, e2 in zip(self.tracerconstraints_, x.tracerconstraints_):
      if e1 != e2: return 0
    if self.has_patternlimitmultiplier_ != x.has_patternlimitmultiplier_: return 0
    if self.has_patternlimitmultiplier_ and self.patternlimitmultiplier_ != x.patternlimitmultiplier_: return 0
    if self.has_domainminfraction_deprecated_ != x.has_domainminfraction_deprecated_: return 0
    if self.has_domainminfraction_deprecated_ and self.domainminfraction_deprecated_ != x.domainminfraction_deprecated_: return 0
    if self.has_domainmincount_deprecated_ != x.has_domainmincount_deprecated_: return 0
    if self.has_domainmincount_deprecated_ and self.domainmincount_deprecated_ != x.domainmincount_deprecated_: return 0
    if self.has_setiruleguaranteefraction_ != x.has_setiruleguaranteefraction_: return 0
    if self.has_setiruleguaranteefraction_ and self.setiruleguaranteefraction_ != x.setiruleguaranteefraction_: return 0
    if self.has_setiruleguaranteecount_ != x.has_setiruleguaranteecount_: return 0
    if self.has_setiruleguaranteecount_ and self.setiruleguaranteecount_ != x.setiruleguaranteecount_: return 0
    if self.has_goodhostguaranteefraction_ != x.has_goodhostguaranteefraction_: return 0
    if self.has_goodhostguaranteefraction_ and self.goodhostguaranteefraction_ != x.goodhostguaranteefraction_: return 0
    if self.has_goodhostguaranteecount_ != x.has_goodhostguaranteecount_: return 0
    if self.has_goodhostguaranteecount_ and self.goodhostguaranteecount_ != x.goodhostguaranteecount_: return 0
    if len(self.goodhostpatterns_) != len(x.goodhostpatterns_): return 0
    for e1, e2 in zip(self.goodhostpatterns_, x.goodhostpatterns_):
      if e1 != e2: return 0
    if self.has_mobileguaranteefraction_ != x.has_mobileguaranteefraction_: return 0
    if self.has_mobileguaranteefraction_ and self.mobileguaranteefraction_ != x.mobileguaranteefraction_: return 0
    if self.has_mobileguaranteecount_ != x.has_mobileguaranteecount_: return 0
    if self.has_mobileguaranteecount_ and self.mobileguaranteecount_ != x.mobileguaranteecount_: return 0
    if self.has_randomdocsguaranteefraction_ != x.has_randomdocsguaranteefraction_: return 0
    if self.has_randomdocsguaranteefraction_ and self.randomdocsguaranteefraction_ != x.randomdocsguaranteefraction_: return 0
    if self.has_randomdocsguaranteecount_ != x.has_randomdocsguaranteecount_: return 0
    if self.has_randomdocsguaranteecount_ and self.randomdocsguaranteecount_ != x.randomdocsguaranteecount_: return 0
    if self.has_selectedscoredistribitionspec_ != x.has_selectedscoredistribitionspec_: return 0
    if self.has_selectedscoredistribitionspec_ and self.selectedscoredistribitionspec_ != x.selectedscoredistribitionspec_: return 0
    if len(self.subindexcomponent_) != len(x.subindexcomponent_): return 0
    for e1, e2 in zip(self.subindexcomponent_, x.subindexcomponent_):
      if e1 != e2: return 0
    if self.has_subindex_ != x.has_subindex_: return 0
    if self.has_subindex_ and self.subindex_ != x.subindex_: return 0
    if self.has_maxtokens_ != x.has_maxtokens_: return 0
    if self.has_maxtokens_ and self.maxtokens_ != x.maxtokens_: return 0
    if self.has_tokensizelimit_ != x.has_tokensizelimit_: return 0
    if self.has_tokensizelimit_ and self.tokensizelimit_ != x.tokensizelimit_: return 0
    if self.has_defaulttokencount_ != x.has_defaulttokencount_: return 0
    if self.has_defaulttokencount_ and self.defaulttokencount_ != x.defaulttokencount_: return 0
    if self.has_setiselected_deprecated_ != x.has_setiselected_deprecated_: return 0
    if self.has_setiselected_deprecated_ and self.setiselected_deprecated_ != x.setiselected_deprecated_: return 0
    if self.has_adddocattachment_ != x.has_adddocattachment_: return 0
    if self.has_adddocattachment_ and self.adddocattachment_ != x.adddocattachment_: return 0
    if len(self.minscorefordocs_) != len(x.minscorefordocs_): return 0
    for e1, e2 in zip(self.minscorefordocs_, x.minscorefordocs_):
      if e1 != e2: return 0
    if len(self.discoveryminquota_) != len(x.discoveryminquota_): return 0
    for e1, e2 in zip(self.discoveryminquota_, x.discoveryminquota_):
      if e1 != e2: return 0
    if len(self.domainmincount_) != len(x.domainmincount_): return 0
    for e1, e2 in zip(self.domainmincount_, x.domainmincount_):
      if e1 != e2: return 0
    if len(self.countedlanguages_) != len(x.countedlanguages_): return 0
    for e1, e2 in zip(self.countedlanguages_, x.countedlanguages_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.excludedindices_)):
      if (not self.excludedindices_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.largedocumentexception_)):
      if (not self.largedocumentexception_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.lowpagerankexception_)):
      if (not self.lowpagerankexception_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.replicateshardsexception_)):
      if (not self.replicateshardsexception_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.languageconstraints_deprecated_)):
      if (not self.languageconstraints_deprecated_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.languagefractions_)):
      if (not self.languagefractions_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.defaultlanguageguarantees_)):
      if (not self.defaultlanguageguarantees_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.countryfractions_)):
      if (not self.countryfractions_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.defaultcountryguarantees_)):
      if (not self.defaultcountryguarantees_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_regionalspec_ and not self.regionalspec_.IsInitialized(debug_strs)): initialized = 0
    for i in xrange(len(self.contenttoexpire_)):
      if (not self.contenttoexpire_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.filetypeconstraints_)):
      if (not self.filetypeconstraints_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.tracerconstraints_)):
      if (not self.tracerconstraints_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_selectedscoredistribitionspec_ and not self.selectedscoredistribitionspec_.IsInitialized(debug_strs)): initialized = 0
    for i in xrange(len(self.subindexcomponent_)):
      if (not self.subindexcomponent_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.minscorefordocs_)):
      if (not self.minscorefordocs_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.discoveryminquota_)):
      if (not self.discoveryminquota_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.domainmincount_)):
      if (not self.domainmincount_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_bootstrap_mode_): n += 2
    if (self.has_index_): n += 1 + self.lengthString(len(self.index_))
    if (self.has_queue_): n += 1 + self.lengthVarInt64(self.queue_)
    if (self.has_num_segments_): n += 1 + self.lengthVarInt64(self.num_segments_)
    if (self.has_epoch_): n += 1 + self.lengthString(len(self.epoch_))
    if (self.has_segment_): n += 1 + self.lengthVarInt64(self.segment_)
    n += 1 * len(self.exclude_deprecated_)
    for i in xrange(len(self.exclude_deprecated_)): n += self.lengthVarInt64(self.exclude_deprecated_[i])
    n += 1 * len(self.exclude_numsegments_deprecated_)
    for i in xrange(len(self.exclude_numsegments_deprecated_)): n += self.lengthVarInt64(self.exclude_numsegments_deprecated_[i])
    n += 2 * len(self.exclude_inlockstep_deprecated_)
    n += 4 * len(self.excludedindices_)
    for i in xrange(len(self.excludedindices_)): n += self.excludedindices_[i].ByteSize()
    n += 4 * len(self.largedocumentexception_)
    for i in xrange(len(self.largedocumentexception_)): n += self.largedocumentexception_[i].ByteSize()
    n += 4 * len(self.lowpagerankexception_)
    for i in xrange(len(self.lowpagerankexception_)): n += self.lowpagerankexception_[i].ByteSize()
    n += 4 * len(self.replicateshardsexception_)
    for i in xrange(len(self.replicateshardsexception_)): n += self.replicateshardsexception_[i].ByteSize()
    if (self.has_reduceshard_): n += 2 + self.lengthVarInt64(self.reduceshard_)
    n += 2 * len(self.drainsource_)
    for i in xrange(len(self.drainsource_)): n += self.lengthVarInt64(self.drainsource_[i])
    n += 2 * len(self.drainsource_numtoretain_)
    for i in xrange(len(self.drainsource_numtoretain_)): n += self.lengthVarInt64(self.drainsource_numtoretain_[i])
    n += 2 * len(self.drainsource_numtoretaindays_)
    for i in xrange(len(self.drainsource_numtoretaindays_)): n += self.lengthVarInt64(self.drainsource_numtoretaindays_[i])
    n += 3 * len(self.drainsource_inlockstep_)
    if (self.has_indexsize_): n += 1 + self.lengthVarInt64(self.indexsize_)
    n += 2 * len(self.languageconstraints_deprecated_)
    for i in xrange(len(self.languageconstraints_deprecated_)): n += self.languageconstraints_deprecated_[i].ByteSize()
    n += 2 * len(self.languagefractions_)
    for i in xrange(len(self.languagefractions_)): n += self.lengthString(self.languagefractions_[i].ByteSize())
    n += 4 * len(self.defaultlanguageguarantees_)
    for i in xrange(len(self.defaultlanguageguarantees_)): n += self.defaultlanguageguarantees_[i].ByteSize()
    n += 2 * len(self.countryfractions_)
    for i in xrange(len(self.countryfractions_)): n += self.lengthString(self.countryfractions_[i].ByteSize())
    n += 4 * len(self.defaultcountryguarantees_)
    for i in xrange(len(self.defaultcountryguarantees_)): n += self.defaultcountryguarantees_[i].ByteSize()
    if (self.has_scorerid_): n += 2 + self.lengthVarInt64(self.scorerid_)
    if (self.has_hostlimit_file_): n += 1 + self.lengthString(len(self.hostlimit_file_))
    if (self.has_hostlimit_multiplier_): n += 10
    if (self.has_hostlimitoverridefile_): n += 2 + self.lengthString(len(self.hostlimitoverridefile_))
    if (self.has_host_minquotas_file_): n += 2 + self.lengthString(len(self.host_minquotas_file_))
    if (self.has_churnmaxfraction_): n += 10
    if (self.has_modchurnmaxfraction_): n += 10
    if (self.has_moddupmaxfraction_): n += 10
    n += 2 * len(self.languagestoselect_)
    for i in xrange(len(self.languagestoselect_)): n += self.lengthString(len(self.languagestoselect_[i]))
    if (self.has_defaulthostlimit_): n += 2 + self.lengthVarInt64(self.defaulthostlimit_)
    n += 2 * len(self.dailyinputqueue_)
    for i in xrange(len(self.dailyinputqueue_)): n += self.lengthVarInt64(self.dailyinputqueue_[i])
    if (self.has_forummaxfraction_): n += 10
    if (self.has_clickmaxfraction_): n += 10
    if (self.has_regionalspec_): n += 4 + self.regionalspec_.ByteSize()
    if (self.has_premiummaxfraction_): n += 10
    if (self.has_mobilemaxfraction_deprecated_): n += 10
    if (self.has_source_queue_): n += 2 + self.lengthVarInt64(self.source_queue_)
    if (self.has_source_queue_name_): n += 2 + self.lengthString(len(self.source_queue_name_))
    if (self.has_source_queue_num_segdirs_): n += 2 + self.lengthVarInt64(self.source_queue_num_segdirs_)
    if (self.has_source_queue_strict_selector_): n += 2 + self.lengthVarInt64(self.source_queue_strict_selector_)
    if (self.has_filterforceselectapproxdups_): n += 3
    n += 4 * len(self.contenttoexpire_)
    for i in xrange(len(self.contenttoexpire_)): n += self.contenttoexpire_[i].ByteSize()
    n += 4 * len(self.filetypeconstraints_)
    for i in xrange(len(self.filetypeconstraints_)): n += self.filetypeconstraints_[i].ByteSize()
    if (self.has_keyholekml_): n += 2 + self.lengthVarInt64(self.keyholekml_)
    n += 4 * len(self.tracerconstraints_)
    for i in xrange(len(self.tracerconstraints_)): n += self.tracerconstraints_[i].ByteSize()
    if (self.has_patternlimitmultiplier_): n += 10
    if (self.has_domainminfraction_deprecated_): n += 10
    if (self.has_domainmincount_deprecated_): n += 10
    if (self.has_setiruleguaranteefraction_): n += 10
    if (self.has_setiruleguaranteecount_): n += 10
    if (self.has_goodhostguaranteefraction_): n += 10
    if (self.has_goodhostguaranteecount_): n += 10
    n += 2 * len(self.goodhostpatterns_)
    for i in xrange(len(self.goodhostpatterns_)): n += self.lengthString(len(self.goodhostpatterns_[i]))
    if (self.has_mobileguaranteefraction_): n += 10
    if (self.has_mobileguaranteecount_): n += 10
    if (self.has_randomdocsguaranteefraction_): n += 10
    if (self.has_randomdocsguaranteecount_): n += 10
    if (self.has_selectedscoredistribitionspec_): n += 4 + self.selectedscoredistribitionspec_.ByteSize()
    n += 4 * len(self.subindexcomponent_)
    for i in xrange(len(self.subindexcomponent_)): n += self.subindexcomponent_[i].ByteSize()
    if (self.has_subindex_): n += 2 + self.lengthVarInt64(self.subindex_)
    if (self.has_maxtokens_): n += 2 + self.lengthVarInt64(self.maxtokens_)
    if (self.has_tokensizelimit_): n += 2 + self.lengthVarInt64(self.tokensizelimit_)
    if (self.has_defaulttokencount_): n += 2 + self.lengthVarInt64(self.defaulttokencount_)
    if (self.has_setiselected_deprecated_): n += 3
    if (self.has_adddocattachment_): n += 3
    n += 4 * len(self.minscorefordocs_)
    for i in xrange(len(self.minscorefordocs_)): n += self.minscorefordocs_[i].ByteSize()
    n += 4 * len(self.discoveryminquota_)
    for i in xrange(len(self.discoveryminquota_)): n += self.discoveryminquota_[i].ByteSize()
    n += 4 * len(self.domainmincount_)
    for i in xrange(len(self.domainmincount_)): n += self.domainmincount_[i].ByteSize()
    n += 2 * len(self.countedlanguages_)
    for i in xrange(len(self.countedlanguages_)): n += self.lengthVarInt64(self.countedlanguages_[i])
    return n + 0

  def Clear(self):
    self.clear_bootstrap_mode()
    self.clear_index()
    self.clear_queue()
    self.clear_num_segments()
    self.clear_epoch()
    self.clear_segment()
    self.clear_exclude_deprecated()
    self.clear_exclude_numsegments_deprecated()
    self.clear_exclude_inlockstep_deprecated()
    self.clear_excludedindices()
    self.clear_largedocumentexception()
    self.clear_lowpagerankexception()
    self.clear_replicateshardsexception()
    self.clear_reduceshard()
    self.clear_drainsource()
    self.clear_drainsource_numtoretain()
    self.clear_drainsource_numtoretaindays()
    self.clear_drainsource_inlockstep()
    self.clear_indexsize()
    self.clear_languageconstraints_deprecated()
    self.clear_languagefractions()
    self.clear_defaultlanguageguarantees()
    self.clear_countryfractions()
    self.clear_defaultcountryguarantees()
    self.clear_scorerid()
    self.clear_hostlimit_file()
    self.clear_hostlimit_multiplier()
    self.clear_hostlimitoverridefile()
    self.clear_host_minquotas_file()
    self.clear_churnmaxfraction()
    self.clear_modchurnmaxfraction()
    self.clear_moddupmaxfraction()
    self.clear_languagestoselect()
    self.clear_defaulthostlimit()
    self.clear_dailyinputqueue()
    self.clear_forummaxfraction()
    self.clear_clickmaxfraction()
    self.clear_regionalspec()
    self.clear_premiummaxfraction()
    self.clear_mobilemaxfraction_deprecated()
    self.clear_source_queue()
    self.clear_source_queue_name()
    self.clear_source_queue_num_segdirs()
    self.clear_source_queue_strict_selector()
    self.clear_filterforceselectapproxdups()
    self.clear_contenttoexpire()
    self.clear_filetypeconstraints()
    self.clear_keyholekml()
    self.clear_tracerconstraints()
    self.clear_patternlimitmultiplier()
    self.clear_domainminfraction_deprecated()
    self.clear_domainmincount_deprecated()
    self.clear_setiruleguaranteefraction()
    self.clear_setiruleguaranteecount()
    self.clear_goodhostguaranteefraction()
    self.clear_goodhostguaranteecount()
    self.clear_goodhostpatterns()
    self.clear_mobileguaranteefraction()
    self.clear_mobileguaranteecount()
    self.clear_randomdocsguaranteefraction()
    self.clear_randomdocsguaranteecount()
    self.clear_selectedscoredistribitionspec()
    self.clear_subindexcomponent()
    self.clear_subindex()
    self.clear_maxtokens()
    self.clear_tokensizelimit()
    self.clear_defaulttokencount()
    self.clear_setiselected_deprecated()
    self.clear_adddocattachment()
    self.clear_minscorefordocs()
    self.clear_discoveryminquota()
    self.clear_domainmincount()
    self.clear_countedlanguages()

  def OutputUnchecked(self, out):
    if (self.has_bootstrap_mode_):
      out.putVarInt32(8)
      out.putBoolean(self.bootstrap_mode_)
    if (self.has_index_):
      out.putVarInt32(18)
      out.putPrefixedString(self.index_)
    if (self.has_queue_):
      out.putVarInt32(24)
      out.putVarInt32(self.queue_)
    if (self.has_num_segments_):
      out.putVarInt32(32)
      out.putVarInt32(self.num_segments_)
    if (self.has_epoch_):
      out.putVarInt32(42)
      out.putPrefixedString(self.epoch_)
    if (self.has_segment_):
      out.putVarInt32(48)
      out.putVarInt32(self.segment_)
    for i in xrange(len(self.exclude_deprecated_)):
      out.putVarInt32(56)
      out.putVarInt32(self.exclude_deprecated_[i])
    for i in xrange(len(self.exclude_numsegments_deprecated_)):
      out.putVarInt32(64)
      out.putVarInt32(self.exclude_numsegments_deprecated_[i])
    for i in xrange(len(self.exclude_inlockstep_deprecated_)):
      out.putVarInt32(72)
      out.putBoolean(self.exclude_inlockstep_deprecated_[i])
    if (self.has_indexsize_):
      out.putVarInt32(80)
      out.putVarInt64(self.indexsize_)
    for i in xrange(len(self.languageconstraints_deprecated_)):
      out.putVarInt32(91)
      self.languageconstraints_deprecated_[i].OutputUnchecked(out)
      out.putVarInt32(92)
    if (self.has_hostlimit_file_):
      out.putVarInt32(122)
      out.putPrefixedString(self.hostlimit_file_)
    if (self.has_hostlimit_multiplier_):
      out.putVarInt32(129)
      out.putDouble(self.hostlimit_multiplier_)
    for i in xrange(len(self.drainsource_)):
      out.putVarInt32(136)
      out.putVarInt32(self.drainsource_[i])
    for i in xrange(len(self.drainsource_numtoretain_)):
      out.putVarInt32(144)
      out.putVarInt32(self.drainsource_numtoretain_[i])
    for i in xrange(len(self.drainsource_numtoretaindays_)):
      out.putVarInt32(152)
      out.putVarInt32(self.drainsource_numtoretaindays_[i])
    for i in xrange(len(self.drainsource_inlockstep_)):
      out.putVarInt32(160)
      out.putBoolean(self.drainsource_inlockstep_[i])
    for i in xrange(len(self.languagestoselect_)):
      out.putVarInt32(170)
      out.putPrefixedString(self.languagestoselect_[i])
    if (self.has_defaulthostlimit_):
      out.putVarInt32(176)
      out.putVarInt32(self.defaulthostlimit_)
    for i in xrange(len(self.dailyinputqueue_)):
      out.putVarInt32(184)
      out.putVarInt32(self.dailyinputqueue_[i])
    if (self.has_forummaxfraction_):
      out.putVarInt32(193)
      out.putDouble(self.forummaxfraction_)
    if (self.has_clickmaxfraction_):
      out.putVarInt32(201)
      out.putDouble(self.clickmaxfraction_)
    if (self.has_regionalspec_):
      out.putVarInt32(211)
      self.regionalspec_.OutputUnchecked(out)
      out.putVarInt32(212)
    if (self.has_premiummaxfraction_):
      out.putVarInt32(249)
      out.putDouble(self.premiummaxfraction_)
    for i in xrange(len(self.largedocumentexception_)):
      out.putVarInt32(259)
      self.largedocumentexception_[i].OutputUnchecked(out)
      out.putVarInt32(260)
    for i in xrange(len(self.lowpagerankexception_)):
      out.putVarInt32(283)
      self.lowpagerankexception_[i].OutputUnchecked(out)
      out.putVarInt32(284)
    if (self.has_subindex_):
      out.putVarInt32(304)
      out.putVarInt32(self.subindex_)
    if (self.has_mobilemaxfraction_deprecated_):
      out.putVarInt32(313)
      out.putDouble(self.mobilemaxfraction_deprecated_)
    if (self.has_source_queue_):
      out.putVarInt32(320)
      out.putVarInt32(self.source_queue_)
    if (self.has_source_queue_name_):
      out.putVarInt32(330)
      out.putPrefixedString(self.source_queue_name_)
    if (self.has_source_queue_num_segdirs_):
      out.putVarInt32(336)
      out.putVarInt32(self.source_queue_num_segdirs_)
    if (self.has_filterforceselectapproxdups_):
      out.putVarInt32(344)
      out.putBoolean(self.filterforceselectapproxdups_)
    for i in xrange(len(self.contenttoexpire_)):
      out.putVarInt32(355)
      self.contenttoexpire_[i].OutputUnchecked(out)
      out.putVarInt32(356)
    for i in xrange(len(self.filetypeconstraints_)):
      out.putVarInt32(387)
      self.filetypeconstraints_[i].OutputUnchecked(out)
      out.putVarInt32(388)
    if (self.has_host_minquotas_file_):
      out.putVarInt32(418)
      out.putPrefixedString(self.host_minquotas_file_)
    for i in xrange(len(self.tracerconstraints_)):
      out.putVarInt32(427)
      self.tracerconstraints_[i].OutputUnchecked(out)
      out.putVarInt32(428)
    if (self.has_patternlimitmultiplier_):
      out.putVarInt32(457)
      out.putDouble(self.patternlimitmultiplier_)
    if (self.has_source_queue_strict_selector_):
      out.putVarInt32(464)
      out.putVarInt32(self.source_queue_strict_selector_)
    if (self.has_domainminfraction_deprecated_):
      out.putVarInt32(473)
      out.putDouble(self.domainminfraction_deprecated_)
    if (self.has_domainmincount_deprecated_):
      out.putVarInt32(481)
      out.putDouble(self.domainmincount_deprecated_)
    if (self.has_selectedscoredistribitionspec_):
      out.putVarInt32(491)
      self.selectedscoredistribitionspec_.OutputUnchecked(out)
      out.putVarInt32(492)
    if (self.has_churnmaxfraction_):
      out.putVarInt32(505)
      out.putDouble(self.churnmaxfraction_)
    if (self.has_modchurnmaxfraction_):
      out.putVarInt32(513)
      out.putDouble(self.modchurnmaxfraction_)
    for i in xrange(len(self.subindexcomponent_)):
      out.putVarInt32(523)
      self.subindexcomponent_[i].OutputUnchecked(out)
      out.putVarInt32(524)
    if (self.has_maxtokens_):
      out.putVarInt32(544)
      out.putVarInt64(self.maxtokens_)
    if (self.has_tokensizelimit_):
      out.putVarInt32(552)
      out.putVarInt64(self.tokensizelimit_)
    if (self.has_defaulttokencount_):
      out.putVarInt32(560)
      out.putVarInt64(self.defaulttokencount_)
    if (self.has_setiselected_deprecated_):
      out.putVarInt32(568)
      out.putBoolean(self.setiselected_deprecated_)
    if (self.has_moddupmaxfraction_):
      out.putVarInt32(577)
      out.putDouble(self.moddupmaxfraction_)
    if (self.has_keyholekml_):
      out.putVarInt32(584)
      out.putVarInt64(self.keyholekml_)
    if (self.has_adddocattachment_):
      out.putVarInt32(592)
      out.putBoolean(self.adddocattachment_)
    for i in xrange(len(self.languagefractions_)):
      out.putVarInt32(602)
      out.putVarInt32(self.languagefractions_[i].ByteSize())
      self.languagefractions_[i].OutputUnchecked(out)
    if (self.has_setiruleguaranteefraction_):
      out.putVarInt32(609)
      out.putDouble(self.setiruleguaranteefraction_)
    if (self.has_setiruleguaranteecount_):
      out.putVarInt32(617)
      out.putDouble(self.setiruleguaranteecount_)
    if (self.has_scorerid_):
      out.putVarInt32(624)
      out.putVarInt32(self.scorerid_)
    if (self.has_goodhostguaranteefraction_):
      out.putVarInt32(633)
      out.putDouble(self.goodhostguaranteefraction_)
    if (self.has_goodhostguaranteecount_):
      out.putVarInt32(641)
      out.putDouble(self.goodhostguaranteecount_)
    for i in xrange(len(self.goodhostpatterns_)):
      out.putVarInt32(650)
      out.putPrefixedString(self.goodhostpatterns_[i])
    if (self.has_mobileguaranteefraction_):
      out.putVarInt32(657)
      out.putDouble(self.mobileguaranteefraction_)
    if (self.has_mobileguaranteecount_):
      out.putVarInt32(665)
      out.putDouble(self.mobileguaranteecount_)
    for i in xrange(len(self.minscorefordocs_)):
      out.putVarInt32(675)
      self.minscorefordocs_[i].OutputUnchecked(out)
      out.putVarInt32(676)
    for i in xrange(len(self.discoveryminquota_)):
      out.putVarInt32(699)
      self.discoveryminquota_[i].OutputUnchecked(out)
      out.putVarInt32(700)
    if (self.has_hostlimitoverridefile_):
      out.putVarInt32(722)
      out.putPrefixedString(self.hostlimitoverridefile_)
    for i in xrange(len(self.defaultlanguageguarantees_)):
      out.putVarInt32(731)
      self.defaultlanguageguarantees_[i].OutputUnchecked(out)
      out.putVarInt32(732)
    for i in xrange(len(self.countryfractions_)):
      out.putVarInt32(762)
      out.putVarInt32(self.countryfractions_[i].ByteSize())
      self.countryfractions_[i].OutputUnchecked(out)
    for i in xrange(len(self.defaultcountryguarantees_)):
      out.putVarInt32(771)
      self.defaultcountryguarantees_[i].OutputUnchecked(out)
      out.putVarInt32(772)
    for i in xrange(len(self.domainmincount_)):
      out.putVarInt32(795)
      self.domainmincount_[i].OutputUnchecked(out)
      out.putVarInt32(796)
    for i in xrange(len(self.excludedindices_)):
      out.putVarInt32(819)
      self.excludedindices_[i].OutputUnchecked(out)
      out.putVarInt32(820)
    for i in xrange(len(self.replicateshardsexception_)):
      out.putVarInt32(859)
      self.replicateshardsexception_[i].OutputUnchecked(out)
      out.putVarInt32(860)
    if (self.has_reduceshard_):
      out.putVarInt32(880)
      out.putVarInt32(self.reduceshard_)
    if (self.has_randomdocsguaranteefraction_):
      out.putVarInt32(889)
      out.putDouble(self.randomdocsguaranteefraction_)
    if (self.has_randomdocsguaranteecount_):
      out.putVarInt32(897)
      out.putDouble(self.randomdocsguaranteecount_)
    for i in xrange(len(self.countedlanguages_)):
      out.putVarInt32(904)
      out.putVarInt32(self.countedlanguages_[i])

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_bootstrap_mode(d.getBoolean())
        continue
      if tt == 18:
        self.set_index(d.getPrefixedString())
        continue
      if tt == 24:
        self.set_queue(d.getVarInt32())
        continue
      if tt == 32:
        self.set_num_segments(d.getVarInt32())
        continue
      if tt == 42:
        self.set_epoch(d.getPrefixedString())
        continue
      if tt == 48:
        self.set_segment(d.getVarInt32())
        continue
      if tt == 56:
        self.add_exclude_deprecated(d.getVarInt32())
        continue
      if tt == 64:
        self.add_exclude_numsegments_deprecated(d.getVarInt32())
        continue
      if tt == 72:
        self.add_exclude_inlockstep_deprecated(d.getBoolean())
        continue
      if tt == 80:
        self.set_indexsize(d.getVarInt64())
        continue
      if tt == 91:
        self.add_languageconstraints_deprecated().TryMerge(d)
        continue
      if tt == 122:
        self.set_hostlimit_file(d.getPrefixedString())
        continue
      if tt == 129:
        self.set_hostlimit_multiplier(d.getDouble())
        continue
      if tt == 136:
        self.add_drainsource(d.getVarInt32())
        continue
      if tt == 144:
        self.add_drainsource_numtoretain(d.getVarInt32())
        continue
      if tt == 152:
        self.add_drainsource_numtoretaindays(d.getVarInt32())
        continue
      if tt == 160:
        self.add_drainsource_inlockstep(d.getBoolean())
        continue
      if tt == 170:
        self.add_languagestoselect(d.getPrefixedString())
        continue
      if tt == 176:
        self.set_defaulthostlimit(d.getVarInt32())
        continue
      if tt == 184:
        self.add_dailyinputqueue(d.getVarInt32())
        continue
      if tt == 193:
        self.set_forummaxfraction(d.getDouble())
        continue
      if tt == 201:
        self.set_clickmaxfraction(d.getDouble())
        continue
      if tt == 211:
        self.mutable_regionalspec().TryMerge(d)
        continue
      if tt == 249:
        self.set_premiummaxfraction(d.getDouble())
        continue
      if tt == 259:
        self.add_largedocumentexception().TryMerge(d)
        continue
      if tt == 283:
        self.add_lowpagerankexception().TryMerge(d)
        continue
      if tt == 304:
        self.set_subindex(d.getVarInt32())
        continue
      if tt == 313:
        self.set_mobilemaxfraction_deprecated(d.getDouble())
        continue
      if tt == 320:
        self.set_source_queue(d.getVarInt32())
        continue
      if tt == 330:
        self.set_source_queue_name(d.getPrefixedString())
        continue
      if tt == 336:
        self.set_source_queue_num_segdirs(d.getVarInt32())
        continue
      if tt == 344:
        self.set_filterforceselectapproxdups(d.getBoolean())
        continue
      if tt == 355:
        self.add_contenttoexpire().TryMerge(d)
        continue
      if tt == 387:
        self.add_filetypeconstraints().TryMerge(d)
        continue
      if tt == 418:
        self.set_host_minquotas_file(d.getPrefixedString())
        continue
      if tt == 427:
        self.add_tracerconstraints().TryMerge(d)
        continue
      if tt == 457:
        self.set_patternlimitmultiplier(d.getDouble())
        continue
      if tt == 464:
        self.set_source_queue_strict_selector(d.getVarInt32())
        continue
      if tt == 473:
        self.set_domainminfraction_deprecated(d.getDouble())
        continue
      if tt == 481:
        self.set_domainmincount_deprecated(d.getDouble())
        continue
      if tt == 491:
        self.mutable_selectedscoredistribitionspec().TryMerge(d)
        continue
      if tt == 505:
        self.set_churnmaxfraction(d.getDouble())
        continue
      if tt == 513:
        self.set_modchurnmaxfraction(d.getDouble())
        continue
      if tt == 523:
        self.add_subindexcomponent().TryMerge(d)
        continue
      if tt == 544:
        self.set_maxtokens(d.getVarInt64())
        continue
      if tt == 552:
        self.set_tokensizelimit(d.getVarInt64())
        continue
      if tt == 560:
        self.set_defaulttokencount(d.getVarInt64())
        continue
      if tt == 568:
        self.set_setiselected_deprecated(d.getBoolean())
        continue
      if tt == 577:
        self.set_moddupmaxfraction(d.getDouble())
        continue
      if tt == 584:
        self.set_keyholekml(d.getVarInt64())
        continue
      if tt == 592:
        self.set_adddocattachment(d.getBoolean())
        continue
      if tt == 602:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_languagefractions().TryMerge(tmp)
        continue
      if tt == 609:
        self.set_setiruleguaranteefraction(d.getDouble())
        continue
      if tt == 617:
        self.set_setiruleguaranteecount(d.getDouble())
        continue
      if tt == 624:
        self.set_scorerid(d.getVarInt32())
        continue
      if tt == 633:
        self.set_goodhostguaranteefraction(d.getDouble())
        continue
      if tt == 641:
        self.set_goodhostguaranteecount(d.getDouble())
        continue
      if tt == 650:
        self.add_goodhostpatterns(d.getPrefixedString())
        continue
      if tt == 657:
        self.set_mobileguaranteefraction(d.getDouble())
        continue
      if tt == 665:
        self.set_mobileguaranteecount(d.getDouble())
        continue
      if tt == 675:
        self.add_minscorefordocs().TryMerge(d)
        continue
      if tt == 699:
        self.add_discoveryminquota().TryMerge(d)
        continue
      if tt == 722:
        self.set_hostlimitoverridefile(d.getPrefixedString())
        continue
      if tt == 731:
        self.add_defaultlanguageguarantees().TryMerge(d)
        continue
      if tt == 762:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_countryfractions().TryMerge(tmp)
        continue
      if tt == 771:
        self.add_defaultcountryguarantees().TryMerge(d)
        continue
      if tt == 795:
        self.add_domainmincount().TryMerge(d)
        continue
      if tt == 819:
        self.add_excludedindices().TryMerge(d)
        continue
      if tt == 859:
        self.add_replicateshardsexception().TryMerge(d)
        continue
      if tt == 880:
        self.set_reduceshard(d.getVarInt32())
        continue
      if tt == 889:
        self.set_randomdocsguaranteefraction(d.getDouble())
        continue
      if tt == 897:
        self.set_randomdocsguaranteecount(d.getDouble())
        continue
      if tt == 904:
        self.add_countedlanguages(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_bootstrap_mode_: res+=prefix+("Bootstrap_Mode: %s\n" % self.DebugFormatBool(self.bootstrap_mode_))
    if self.has_index_: res+=prefix+("Index: %s\n" % self.DebugFormatString(self.index_))
    if self.has_queue_: res+=prefix+("Queue: %s\n" % self.DebugFormatInt32(self.queue_))
    if self.has_num_segments_: res+=prefix+("Num_Segments: %s\n" % self.DebugFormatInt32(self.num_segments_))
    if self.has_epoch_: res+=prefix+("Epoch: %s\n" % self.DebugFormatString(self.epoch_))
    if self.has_segment_: res+=prefix+("Segment: %s\n" % self.DebugFormatInt32(self.segment_))
    cnt=0
    for e in self.exclude_deprecated_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Exclude_DEPRECATED%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    cnt=0
    for e in self.exclude_numsegments_deprecated_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Exclude_NumSegments_DEPRECATED%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    cnt=0
    for e in self.exclude_inlockstep_deprecated_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Exclude_InLockstep_DEPRECATED%s: %s\n" % (elm, self.DebugFormatBool(e)))
      cnt+=1
    cnt=0
    for e in self.excludedindices_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("ExcludedIndices%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.largedocumentexception_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("LargeDocumentException%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.lowpagerankexception_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("LowPageRankException%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.replicateshardsexception_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("ReplicateShardsException%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_reduceshard_: res+=prefix+("ReduceShard: %s\n" % self.DebugFormatInt32(self.reduceshard_))
    cnt=0
    for e in self.drainsource_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DrainSource%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    cnt=0
    for e in self.drainsource_numtoretain_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DrainSource_NumToRetain%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    cnt=0
    for e in self.drainsource_numtoretaindays_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DrainSource_NumToRetainDays%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    cnt=0
    for e in self.drainsource_inlockstep_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DrainSource_InLockstep%s: %s\n" % (elm, self.DebugFormatBool(e)))
      cnt+=1
    if self.has_indexsize_: res+=prefix+("IndexSize: %s\n" % self.DebugFormatInt64(self.indexsize_))
    cnt=0
    for e in self.languageconstraints_deprecated_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("LanguageConstraints_DEPRECATED%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.languagefractions_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("LanguageFractions%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.defaultlanguageguarantees_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DefaultLanguageGuarantees%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.countryfractions_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("CountryFractions%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.defaultcountryguarantees_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DefaultCountryGuarantees%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_scorerid_: res+=prefix+("ScorerId: %s\n" % self.DebugFormatInt32(self.scorerid_))
    if self.has_hostlimit_file_: res+=prefix+("HostLimit_File: %s\n" % self.DebugFormatString(self.hostlimit_file_))
    if self.has_hostlimit_multiplier_: res+=prefix+("HostLimit_Multiplier: %s\n" % self.DebugFormat(self.hostlimit_multiplier_))
    if self.has_hostlimitoverridefile_: res+=prefix+("HostLimitOverrideFile: %s\n" % self.DebugFormatString(self.hostlimitoverridefile_))
    if self.has_host_minquotas_file_: res+=prefix+("Host_MinQuotas_File: %s\n" % self.DebugFormatString(self.host_minquotas_file_))
    if self.has_churnmaxfraction_: res+=prefix+("ChurnMaxFraction: %s\n" % self.DebugFormat(self.churnmaxfraction_))
    if self.has_modchurnmaxfraction_: res+=prefix+("ModChurnMaxFraction: %s\n" % self.DebugFormat(self.modchurnmaxfraction_))
    if self.has_moddupmaxfraction_: res+=prefix+("ModDupMaxFraction: %s\n" % self.DebugFormat(self.moddupmaxfraction_))
    cnt=0
    for e in self.languagestoselect_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("LanguagesToSelect%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_defaulthostlimit_: res+=prefix+("DefaultHostLimit: %s\n" % self.DebugFormatInt32(self.defaulthostlimit_))
    cnt=0
    for e in self.dailyinputqueue_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DailyInputQueue%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    if self.has_forummaxfraction_: res+=prefix+("ForumMaxFraction: %s\n" % self.DebugFormat(self.forummaxfraction_))
    if self.has_clickmaxfraction_: res+=prefix+("ClickMaxFraction: %s\n" % self.DebugFormat(self.clickmaxfraction_))
    if self.has_regionalspec_:
      res+=prefix+"RegionalSpec {\n"
      res+=self.regionalspec_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_premiummaxfraction_: res+=prefix+("PremiumMaxFraction: %s\n" % self.DebugFormat(self.premiummaxfraction_))
    if self.has_mobilemaxfraction_deprecated_: res+=prefix+("MobileMaxFraction_DEPRECATED: %s\n" % self.DebugFormat(self.mobilemaxfraction_deprecated_))
    if self.has_source_queue_: res+=prefix+("source_queue: %s\n" % self.DebugFormatInt32(self.source_queue_))
    if self.has_source_queue_name_: res+=prefix+("source_queue_name: %s\n" % self.DebugFormatString(self.source_queue_name_))
    if self.has_source_queue_num_segdirs_: res+=prefix+("source_queue_num_segdirs: %s\n" % self.DebugFormatInt32(self.source_queue_num_segdirs_))
    if self.has_source_queue_strict_selector_: res+=prefix+("source_queue_strict_selector: %s\n" % self.DebugFormatInt32(self.source_queue_strict_selector_))
    if self.has_filterforceselectapproxdups_: res+=prefix+("FilterForceSelectApproxDups: %s\n" % self.DebugFormatBool(self.filterforceselectapproxdups_))
    cnt=0
    for e in self.contenttoexpire_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("ContentToExpire%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.filetypeconstraints_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("FiletypeConstraints%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_keyholekml_: res+=prefix+("KeyholeKml: %s\n" % self.DebugFormatInt64(self.keyholekml_))
    cnt=0
    for e in self.tracerconstraints_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("TracerConstraints%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_patternlimitmultiplier_: res+=prefix+("PatternLimitMultiplier: %s\n" % self.DebugFormat(self.patternlimitmultiplier_))
    if self.has_domainminfraction_deprecated_: res+=prefix+("DomainMinFraction_DEPRECATED: %s\n" % self.DebugFormat(self.domainminfraction_deprecated_))
    if self.has_domainmincount_deprecated_: res+=prefix+("DomainMinCount_DEPRECATED: %s\n" % self.DebugFormat(self.domainmincount_deprecated_))
    if self.has_setiruleguaranteefraction_: res+=prefix+("SetiRuleGuaranteeFraction: %s\n" % self.DebugFormat(self.setiruleguaranteefraction_))
    if self.has_setiruleguaranteecount_: res+=prefix+("SetiRuleGuaranteeCount: %s\n" % self.DebugFormat(self.setiruleguaranteecount_))
    if self.has_goodhostguaranteefraction_: res+=prefix+("GoodHostGuaranteeFraction: %s\n" % self.DebugFormat(self.goodhostguaranteefraction_))
    if self.has_goodhostguaranteecount_: res+=prefix+("GoodHostGuaranteeCount: %s\n" % self.DebugFormat(self.goodhostguaranteecount_))
    cnt=0
    for e in self.goodhostpatterns_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("GoodHostPatterns%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_mobileguaranteefraction_: res+=prefix+("MobileGuaranteeFraction: %s\n" % self.DebugFormat(self.mobileguaranteefraction_))
    if self.has_mobileguaranteecount_: res+=prefix+("MobileGuaranteeCount: %s\n" % self.DebugFormat(self.mobileguaranteecount_))
    if self.has_randomdocsguaranteefraction_: res+=prefix+("RandomDocsGuaranteeFraction: %s\n" % self.DebugFormat(self.randomdocsguaranteefraction_))
    if self.has_randomdocsguaranteecount_: res+=prefix+("RandomDocsGuaranteeCount: %s\n" % self.DebugFormat(self.randomdocsguaranteecount_))
    if self.has_selectedscoredistribitionspec_:
      res+=prefix+"SelectedScoreDistribitionSpec {\n"
      res+=self.selectedscoredistribitionspec_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    cnt=0
    for e in self.subindexcomponent_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("SubIndexComponent%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_subindex_: res+=prefix+("SubIndex: %s\n" % self.DebugFormatInt32(self.subindex_))
    if self.has_maxtokens_: res+=prefix+("MaxTokens: %s\n" % self.DebugFormatInt64(self.maxtokens_))
    if self.has_tokensizelimit_: res+=prefix+("TokenSizeLimit: %s\n" % self.DebugFormatInt64(self.tokensizelimit_))
    if self.has_defaulttokencount_: res+=prefix+("DefaultTokenCount: %s\n" % self.DebugFormatInt64(self.defaulttokencount_))
    if self.has_setiselected_deprecated_: res+=prefix+("SetiSelected_DEPRECATED: %s\n" % self.DebugFormatBool(self.setiselected_deprecated_))
    if self.has_adddocattachment_: res+=prefix+("AddDocAttachment: %s\n" % self.DebugFormatBool(self.adddocattachment_))
    cnt=0
    for e in self.minscorefordocs_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("MinScoreForDocs%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.discoveryminquota_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DiscoveryMinQuota%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.domainmincount_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DomainMinCount%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.countedlanguages_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("CountedLanguages%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    return res

  kBootstrap_Mode = 1
  kIndex = 2
  kQueue = 3
  kNum_Segments = 4
  kEpoch = 5
  kSegment = 6
  kExclude_DEPRECATED = 7
  kExclude_NumSegments_DEPRECATED = 8
  kExclude_InLockstep_DEPRECATED = 9
  kExcludedIndicesGroup = 102
  kExcludedIndicesIndex = 103
  kExcludedIndicesNumSegments = 104
  kExcludedIndicesInLockstep = 105
  kExcludedIndicesLanguages = 106
  kLargeDocumentExceptionGroup = 32
  kLargeDocumentExceptionIndex = 33
  kLargeDocumentExceptionDocSize = 34
  kLowPageRankExceptionGroup = 35
  kLowPageRankExceptionIndex = 36
  kLowPageRankExceptionPageRank = 37
  kReplicateShardsExceptionGroup = 107
  kReplicateShardsExceptionStart = 108
  kReplicateShardsExceptionEnd = 109
  kReduceShard = 110
  kDrainSource = 17
  kDrainSource_NumToRetain = 18
  kDrainSource_NumToRetainDays = 19
  kDrainSource_InLockstep = 20
  kIndexSize = 10
  kLanguageConstraints_DEPRECATEDGroup = 11
  kLanguageConstraints_DEPRECATEDLanguage = 12
  kLanguageConstraints_DEPRECATEDMinFraction = 13
  kLanguageConstraints_DEPRECATEDMaxFraction = 14
  kLanguageFractions = 75
  kDefaultLanguageGuaranteesGroup = 91
  kDefaultLanguageGuaranteesFraction = 92
  kDefaultLanguageGuaranteesScorerId = 93
  kCountryFractions = 95
  kDefaultCountryGuaranteesGroup = 96
  kDefaultCountryGuaranteesFraction = 97
  kDefaultCountryGuaranteesScorerId = 98
  kScorerId = 78
  kHostLimit_File = 15
  kHostLimit_Multiplier = 16
  kHostLimitOverrideFile = 90
  kHost_MinQuotas_File = 52
  kChurnMaxFraction = 63
  kModChurnMaxFraction = 64
  kModDupMaxFraction = 72
  kLanguagesToSelect = 21
  kDefaultHostLimit = 22
  kDailyInputQueue = 23
  kForumMaxFraction = 24
  kClickMaxFraction = 25
  kRegionalSpecGroup = 26
  kRegionalSpecLanguages = 27
  kRegionalSpecEncodings = 28
  kRegionalSpecTLDs = 29
  kRegionalSpecGeocodes = 30
  kPremiumMaxFraction = 31
  kMobileMaxFraction_DEPRECATED = 39
  ksource_queue = 40
  ksource_queue_name = 41
  ksource_queue_num_segdirs = 42
  ksource_queue_strict_selector = 58
  kFilterForceSelectApproxDups = 43
  kContentToExpireGroup = 44
  kContentToExpireCategory = 45
  kContentToExpireExpiryEpoch = 46
  kContentToExpiredelta = 47
  kFiletypeConstraintsGroup = 48
  kFiletypeConstraintsFiletype = 49
  kFiletypeConstraintsMinFraction = 50
  kFiletypeConstraintsMaxFraction = 51
  kKeyholeKml = 73
  kTracerConstraintsGroup = 53
  kTracerConstraintsqueuename = 54
  kTracerConstraintsqueueid = 55
  kTracerConstraintsmaxfraction = 56
  kPatternLimitMultiplier = 57
  kDomainMinFraction_DEPRECATED = 59
  kDomainMinCount_DEPRECATED = 60
  kSetiRuleGuaranteeFraction = 76
  kSetiRuleGuaranteeCount = 77
  kGoodHostGuaranteeFraction = 79
  kGoodHostGuaranteeCount = 80
  kGoodHostPatterns = 81
  kMobileGuaranteeFraction = 82
  kMobileGuaranteeCount = 83
  kRandomDocsGuaranteeFraction = 111
  kRandomDocsGuaranteeCount = 112
  kSelectedScoreDistribitionSpecGroup = 61
  kSelectedScoreDistribitionSpecBucketMax = 62
  kSubIndexComponentGroup = 65
  kSubIndexComponentType = 66
  kSubIndexComponentPercent = 67
  kSubIndex = 38
  kMaxTokens = 68
  kTokenSizeLimit = 69
  kDefaultTokenCount = 70
  kSetiSelected_DEPRECATED = 71
  kAddDocAttachment = 74
  kMinScoreForDocsGroup = 84
  kMinScoreForDocsmin_score = 85
  kMinScoreForDocsScorerId = 86
  kDiscoveryMinQuotaGroup = 87
  kDiscoveryMinQuotaFraction = 88
  kDiscoveryMinQuotaScorerId = 89
  kDiscoveryMinQuotaDiscoveryQueues = 94
  kDomainMinCountGroup = 99
  kDomainMinCountTLD = 100
  kDomainMinCountCount = 101
  kCountedLanguages = 113

  _TEXT = (
   "ErrorCode",  #   0
   "Bootstrap_Mode",  #   1
   "Index",  #   2
   "Queue",  #   3
   "Num_Segments",  #   4
   "Epoch",  #   5
   "Segment",  #   6
   "Exclude_DEPRECATED",  #   7
   "Exclude_NumSegments_DEPRECATED",  #   8
   "Exclude_InLockstep_DEPRECATED",  #   9
   "IndexSize",  #  10
   "LanguageConstraints_DEPRECATED",  #  11
   "Language",  #  12
   "MinFraction",  #  13
   "MaxFraction",  #  14
   "HostLimit_File",  #  15
   "HostLimit_Multiplier",  #  16
   "DrainSource",  #  17
   "DrainSource_NumToRetain",  #  18
   "DrainSource_NumToRetainDays",  #  19
   "DrainSource_InLockstep",  #  20
   "LanguagesToSelect",  #  21
   "DefaultHostLimit",  #  22
   "DailyInputQueue",  #  23
   "ForumMaxFraction",  #  24
   "ClickMaxFraction",  #  25
   "RegionalSpec",  #  26
   "Languages",  #  27
   "Encodings",  #  28
   "TLDs",  #  29
   "Geocodes",  #  30
   "PremiumMaxFraction",  #  31
   "LargeDocumentException",  #  32
   "Index",  #  33
   "DocSize",  #  34
   "LowPageRankException",  #  35
   "Index",  #  36
   "PageRank",  #  37
   "SubIndex",  #  38
   "MobileMaxFraction_DEPRECATED",  #  39
   "source_queue",  #  40
   "source_queue_name",  #  41
   "source_queue_num_segdirs",  #  42
   "FilterForceSelectApproxDups",  #  43
   "ContentToExpire",  #  44
   "Category",  #  45
   "ExpiryEpoch",  #  46
   "delta",  #  47
   "FiletypeConstraints",  #  48
   "Filetype",  #  49
   "MinFraction",  #  50
   "MaxFraction",  #  51
   "Host_MinQuotas_File",  #  52
   "TracerConstraints",  #  53
   "queuename",  #  54
   "queueid",  #  55
   "maxfraction",  #  56
   "PatternLimitMultiplier",  #  57
   "source_queue_strict_selector",  #  58
   "DomainMinFraction_DEPRECATED",  #  59
   "DomainMinCount_DEPRECATED",  #  60
   "SelectedScoreDistribitionSpec",  #  61
   "BucketMax",  #  62
   "ChurnMaxFraction",  #  63
   "ModChurnMaxFraction",  #  64
   "SubIndexComponent",  #  65
   "Type",  #  66
   "Percent",  #  67
   "MaxTokens",  #  68
   "TokenSizeLimit",  #  69
   "DefaultTokenCount",  #  70
   "SetiSelected_DEPRECATED",  #  71
   "ModDupMaxFraction",  #  72
   "KeyholeKml",  #  73
   "AddDocAttachment",  #  74
   "LanguageFractions",  #  75
   "SetiRuleGuaranteeFraction",  #  76
   "SetiRuleGuaranteeCount",  #  77
   "ScorerId",  #  78
   "GoodHostGuaranteeFraction",  #  79
   "GoodHostGuaranteeCount",  #  80
   "GoodHostPatterns",  #  81
   "MobileGuaranteeFraction",  #  82
   "MobileGuaranteeCount",  #  83
   "MinScoreForDocs",  #  84
   "min_score",  #  85
   "ScorerId",  #  86
   "DiscoveryMinQuota",  #  87
   "Fraction",  #  88
   "ScorerId",  #  89
   "HostLimitOverrideFile",  #  90
   "DefaultLanguageGuarantees",  #  91
   "Fraction",  #  92
   "ScorerId",  #  93
   "DiscoveryQueues",  #  94
   "CountryFractions",  #  95
   "DefaultCountryGuarantees",  #  96
   "Fraction",  #  97
   "ScorerId",  #  98
   "DomainMinCount",  #  99
   "TLD",  # 100
   "Count",  # 101
   "ExcludedIndices",  # 102
   "Index",  # 103
   "NumSegments",  # 104
   "InLockstep",  # 105
   "Languages",  # 106
   "ReplicateShardsException",  # 107
   "Start",  # 108
   "End",  # 109
   "ReduceShard",  # 110
   "RandomDocsGuaranteeFraction",  # 111
   "RandomDocsGuaranteeCount",  # 112
   "CountedLanguages",  # 113
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.NUMERIC,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.STARTGROUP,  #  11

   ProtocolBuffer.Encoder.STRING,  #  12

   ProtocolBuffer.Encoder.DOUBLE,  #  13

   ProtocolBuffer.Encoder.DOUBLE,  #  14

   ProtocolBuffer.Encoder.STRING,  #  15

   ProtocolBuffer.Encoder.DOUBLE,  #  16

   ProtocolBuffer.Encoder.NUMERIC,  #  17

   ProtocolBuffer.Encoder.NUMERIC,  #  18

   ProtocolBuffer.Encoder.NUMERIC,  #  19

   ProtocolBuffer.Encoder.NUMERIC,  #  20

   ProtocolBuffer.Encoder.STRING,  #  21

   ProtocolBuffer.Encoder.NUMERIC,  #  22

   ProtocolBuffer.Encoder.NUMERIC,  #  23

   ProtocolBuffer.Encoder.DOUBLE,  #  24

   ProtocolBuffer.Encoder.DOUBLE,  #  25

   ProtocolBuffer.Encoder.STARTGROUP,  #  26

   ProtocolBuffer.Encoder.STRING,  #  27

   ProtocolBuffer.Encoder.STRING,  #  28

   ProtocolBuffer.Encoder.STRING,  #  29

   ProtocolBuffer.Encoder.NUMERIC,  #  30

   ProtocolBuffer.Encoder.DOUBLE,  #  31

   ProtocolBuffer.Encoder.STARTGROUP,  #  32

   ProtocolBuffer.Encoder.NUMERIC,  #  33

   ProtocolBuffer.Encoder.NUMERIC,  #  34

   ProtocolBuffer.Encoder.STARTGROUP,  #  35

   ProtocolBuffer.Encoder.NUMERIC,  #  36

   ProtocolBuffer.Encoder.NUMERIC,  #  37

   ProtocolBuffer.Encoder.NUMERIC,  #  38

   ProtocolBuffer.Encoder.DOUBLE,  #  39

   ProtocolBuffer.Encoder.NUMERIC,  #  40

   ProtocolBuffer.Encoder.STRING,  #  41

   ProtocolBuffer.Encoder.NUMERIC,  #  42

   ProtocolBuffer.Encoder.NUMERIC,  #  43

   ProtocolBuffer.Encoder.STARTGROUP,  #  44

   ProtocolBuffer.Encoder.STRING,  #  45

   ProtocolBuffer.Encoder.STRING,  #  46

   ProtocolBuffer.Encoder.NUMERIC,  #  47

   ProtocolBuffer.Encoder.STARTGROUP,  #  48

   ProtocolBuffer.Encoder.NUMERIC,  #  49

   ProtocolBuffer.Encoder.DOUBLE,  #  50

   ProtocolBuffer.Encoder.DOUBLE,  #  51

   ProtocolBuffer.Encoder.STRING,  #  52

   ProtocolBuffer.Encoder.STARTGROUP,  #  53

   ProtocolBuffer.Encoder.STRING,  #  54

   ProtocolBuffer.Encoder.NUMERIC,  #  55

   ProtocolBuffer.Encoder.DOUBLE,  #  56

   ProtocolBuffer.Encoder.DOUBLE,  #  57

   ProtocolBuffer.Encoder.NUMERIC,  #  58

   ProtocolBuffer.Encoder.DOUBLE,  #  59

   ProtocolBuffer.Encoder.DOUBLE,  #  60

   ProtocolBuffer.Encoder.STARTGROUP,  #  61

   ProtocolBuffer.Encoder.DOUBLE,  #  62

   ProtocolBuffer.Encoder.DOUBLE,  #  63

   ProtocolBuffer.Encoder.DOUBLE,  #  64

   ProtocolBuffer.Encoder.STARTGROUP,  #  65

   ProtocolBuffer.Encoder.NUMERIC,  #  66

   ProtocolBuffer.Encoder.NUMERIC,  #  67

   ProtocolBuffer.Encoder.NUMERIC,  #  68

   ProtocolBuffer.Encoder.NUMERIC,  #  69

   ProtocolBuffer.Encoder.NUMERIC,  #  70

   ProtocolBuffer.Encoder.NUMERIC,  #  71

   ProtocolBuffer.Encoder.DOUBLE,  #  72

   ProtocolBuffer.Encoder.NUMERIC,  #  73

   ProtocolBuffer.Encoder.NUMERIC,  #  74

   ProtocolBuffer.Encoder.STRING,  #  75

   ProtocolBuffer.Encoder.DOUBLE,  #  76

   ProtocolBuffer.Encoder.DOUBLE,  #  77

   ProtocolBuffer.Encoder.NUMERIC,  #  78

   ProtocolBuffer.Encoder.DOUBLE,  #  79

   ProtocolBuffer.Encoder.DOUBLE,  #  80

   ProtocolBuffer.Encoder.STRING,  #  81

   ProtocolBuffer.Encoder.DOUBLE,  #  82

   ProtocolBuffer.Encoder.DOUBLE,  #  83

   ProtocolBuffer.Encoder.STARTGROUP,  #  84

   ProtocolBuffer.Encoder.FLOAT,  #  85

   ProtocolBuffer.Encoder.NUMERIC,  #  86

   ProtocolBuffer.Encoder.STARTGROUP,  #  87

   ProtocolBuffer.Encoder.DOUBLE,  #  88

   ProtocolBuffer.Encoder.NUMERIC,  #  89

   ProtocolBuffer.Encoder.STRING,  #  90

   ProtocolBuffer.Encoder.STARTGROUP,  #  91

   ProtocolBuffer.Encoder.DOUBLE,  #  92

   ProtocolBuffer.Encoder.NUMERIC,  #  93

   ProtocolBuffer.Encoder.NUMERIC,  #  94

   ProtocolBuffer.Encoder.STRING,  #  95

   ProtocolBuffer.Encoder.STARTGROUP,  #  96

   ProtocolBuffer.Encoder.DOUBLE,  #  97

   ProtocolBuffer.Encoder.NUMERIC,  #  98

   ProtocolBuffer.Encoder.STARTGROUP,  #  99

   ProtocolBuffer.Encoder.STRING,  # 100

   ProtocolBuffer.Encoder.NUMERIC,  # 101

   ProtocolBuffer.Encoder.STARTGROUP,  # 102

   ProtocolBuffer.Encoder.NUMERIC,  # 103

   ProtocolBuffer.Encoder.NUMERIC,  # 104

   ProtocolBuffer.Encoder.NUMERIC,  # 105

   ProtocolBuffer.Encoder.NUMERIC,  # 106

   ProtocolBuffer.Encoder.STARTGROUP,  # 107

   ProtocolBuffer.Encoder.NUMERIC,  # 108

   ProtocolBuffer.Encoder.NUMERIC,  # 109

   ProtocolBuffer.Encoder.NUMERIC,  # 110

   ProtocolBuffer.Encoder.DOUBLE,  # 111

   ProtocolBuffer.Encoder.DOUBLE,  # 112

   ProtocolBuffer.Encoder.NUMERIC,  # 113

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x25,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x41,
    0x72,
    0x67,
    0x73,
    0x13,
    0x1a,
    0x0e,
    0x42,
    0x6f,
    0x6f,
    0x74,
    0x73,
    0x74,
    0x72,
    0x61,
    0x70,
    0x5f,
    0x4d,
    0x6f,
    0x64,
    0x65,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x51,
    0x75,
    0x65,
    0x75,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x02,
    0x2d,
    0x31,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x2d,
    0x31,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x4e,
    0x75,
    0x6d,
    0x5f,
    0x53,
    0x65,
    0x67,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x31,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x31,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x45,
    0x70,
    0x6f,
    0x63,
    0x68,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x53,
    0x65,
    0x67,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x45,
    0x78,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x45,
    0x78,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x5f,
    0x4e,
    0x75,
    0x6d,
    0x53,
    0x65,
    0x67,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1d,
    0x45,
    0x78,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x5f,
    0x49,
    0x6e,
    0x4c,
    0x6f,
    0x63,
    0x6b,
    0x73,
    0x74,
    0x65,
    0x70,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x09,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x45,
    0x78,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x64,
    0x49,
    0x6e,
    0x64,
    0x69,
    0x63,
    0x65,
    0x73,
    0x20,
    0x66,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x45,
    0x78,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x64,
    0x49,
    0x6e,
    0x64,
    0x69,
    0x63,
    0x65,
    0x73,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x67,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x09,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x45,
    0x78,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x64,
    0x49,
    0x6e,
    0x64,
    0x69,
    0x63,
    0x65,
    0x73,
    0x2e,
    0x4e,
    0x75,
    0x6d,
    0x53,
    0x65,
    0x67,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x68,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x09,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x45,
    0x78,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x64,
    0x49,
    0x6e,
    0x64,
    0x69,
    0x63,
    0x65,
    0x73,
    0x2e,
    0x49,
    0x6e,
    0x4c,
    0x6f,
    0x63,
    0x6b,
    0x73,
    0x74,
    0x65,
    0x70,
    0x20,
    0x69,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x02,
    0x60,
    0x09,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x45,
    0x78,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x64,
    0x49,
    0x6e,
    0x64,
    0x69,
    0x63,
    0x65,
    0x73,
    0x2e,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x6a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x60,
    0x09,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x4c,
    0x61,
    0x72,
    0x67,
    0x65,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x45,
    0x78,
    0x63,
    0x65,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x20,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x4c,
    0x61,
    0x72,
    0x67,
    0x65,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x45,
    0x78,
    0x63,
    0x65,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x21,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x0e,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x4c,
    0x61,
    0x72,
    0x67,
    0x65,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x45,
    0x78,
    0x63,
    0x65,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x44,
    0x6f,
    0x63,
    0x53,
    0x69,
    0x7a,
    0x65,
    0x20,
    0x22,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x60,
    0x0e,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x4c,
    0x6f,
    0x77,
    0x50,
    0x61,
    0x67,
    0x65,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x45,
    0x78,
    0x63,
    0x65,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x23,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x4c,
    0x6f,
    0x77,
    0x50,
    0x61,
    0x67,
    0x65,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x45,
    0x78,
    0x63,
    0x65,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x24,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x11,
    0x14,
    0x13,
    0x1a,
    0x1d,
    0x4c,
    0x6f,
    0x77,
    0x50,
    0x61,
    0x67,
    0x65,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x45,
    0x78,
    0x63,
    0x65,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x50,
    0x61,
    0x67,
    0x65,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x25,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x11,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x65,
    0x53,
    0x68,
    0x61,
    0x72,
    0x64,
    0x73,
    0x45,
    0x78,
    0x63,
    0x65,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x6b,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x65,
    0x53,
    0x68,
    0x61,
    0x72,
    0x64,
    0x73,
    0x45,
    0x78,
    0x63,
    0x65,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x53,
    0x74,
    0x61,
    0x72,
    0x74,
    0x20,
    0x6c,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x14,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x65,
    0x53,
    0x68,
    0x61,
    0x72,
    0x64,
    0x73,
    0x45,
    0x78,
    0x63,
    0x65,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x45,
    0x6e,
    0x64,
    0x20,
    0x6d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x14,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x52,
    0x65,
    0x64,
    0x75,
    0x63,
    0x65,
    0x53,
    0x68,
    0x61,
    0x72,
    0x64,
    0x20,
    0x6e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x44,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x20,
    0x11,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x44,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x4e,
    0x75,
    0x6d,
    0x54,
    0x6f,
    0x52,
    0x65,
    0x74,
    0x61,
    0x69,
    0x6e,
    0x20,
    0x12,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x44,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x4e,
    0x75,
    0x6d,
    0x54,
    0x6f,
    0x52,
    0x65,
    0x74,
    0x61,
    0x69,
    0x6e,
    0x44,
    0x61,
    0x79,
    0x73,
    0x20,
    0x13,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x44,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x49,
    0x6e,
    0x4c,
    0x6f,
    0x63,
    0x6b,
    0x73,
    0x74,
    0x65,
    0x70,
    0x20,
    0x14,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x69,
    0x7a,
    0x65,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x74,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x74,
    0x73,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x0b,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x27,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x74,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x74,
    0x73,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x2e,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x20,
    0x0c,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x1d,
    0x14,
    0x13,
    0x1a,
    0x2a,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x74,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x74,
    0x73,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x2e,
    0x4d,
    0x69,
    0x6e,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x0d,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0x60,
    0x1d,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x2a,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x74,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x74,
    0x73,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x2e,
    0x4d,
    0x61,
    0x78,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x0e,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x31,
    0x2e,
    0x30,
    0x60,
    0x1d,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x4b,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x24,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x44,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x73,
    0x20,
    0x5b,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x22,
    0x44,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x73,
    0x2e,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x5c,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0x60,
    0x22,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x22,
    0x44,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x73,
    0x2e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x49,
    0x64,
    0x20,
    0x5d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x22,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x72,
    0x79,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x5f,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x24,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x44,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x72,
    0x79,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x73,
    0x20,
    0x60,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x21,
    0x44,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x72,
    0x79,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x73,
    0x2e,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x61,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0x60,
    0x26,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x21,
    0x44,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x72,
    0x79,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x73,
    0x2e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x49,
    0x64,
    0x20,
    0x62,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x26,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x49,
    0x64,
    0x20,
    0x4e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x5f,
    0x46,
    0x69,
    0x6c,
    0x65,
    0x20,
    0x0f,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x5f,
    0x4d,
    0x75,
    0x6c,
    0x74,
    0x69,
    0x70,
    0x6c,
    0x69,
    0x65,
    0x72,
    0x20,
    0x10,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x4f,
    0x76,
    0x65,
    0x72,
    0x72,
    0x69,
    0x64,
    0x65,
    0x46,
    0x69,
    0x6c,
    0x65,
    0x20,
    0x5a,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x5f,
    0x4d,
    0x69,
    0x6e,
    0x51,
    0x75,
    0x6f,
    0x74,
    0x61,
    0x73,
    0x5f,
    0x46,
    0x69,
    0x6c,
    0x65,
    0x20,
    0x34,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x43,
    0x68,
    0x75,
    0x72,
    0x6e,
    0x4d,
    0x61,
    0x78,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x3f,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x4d,
    0x6f,
    0x64,
    0x43,
    0x68,
    0x75,
    0x72,
    0x6e,
    0x4d,
    0x61,
    0x78,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x40,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x4d,
    0x6f,
    0x64,
    0x44,
    0x75,
    0x70,
    0x4d,
    0x61,
    0x78,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x48,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x73,
    0x54,
    0x6f,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x20,
    0x15,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x44,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x20,
    0x16,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x02,
    0x2d,
    0x31,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x2d,
    0x31,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x44,
    0x61,
    0x69,
    0x6c,
    0x79,
    0x49,
    0x6e,
    0x70,
    0x75,
    0x74,
    0x51,
    0x75,
    0x65,
    0x75,
    0x65,
    0x20,
    0x17,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x46,
    0x6f,
    0x72,
    0x75,
    0x6d,
    0x4d,
    0x61,
    0x78,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x18,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x43,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x4d,
    0x61,
    0x78,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x19,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x6c,
    0x53,
    0x70,
    0x65,
    0x63,
    0x20,
    0x1a,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x6c,
    0x53,
    0x70,
    0x65,
    0x63,
    0x2e,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x1b,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x60,
    0x36,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x6c,
    0x53,
    0x70,
    0x65,
    0x63,
    0x2e,
    0x45,
    0x6e,
    0x63,
    0x6f,
    0x64,
    0x69,
    0x6e,
    0x67,
    0x73,
    0x20,
    0x1c,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x60,
    0x36,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x6c,
    0x53,
    0x70,
    0x65,
    0x63,
    0x2e,
    0x54,
    0x4c,
    0x44,
    0x73,
    0x20,
    0x1d,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x60,
    0x36,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x6c,
    0x53,
    0x70,
    0x65,
    0x63,
    0x2e,
    0x47,
    0x65,
    0x6f,
    0x63,
    0x6f,
    0x64,
    0x65,
    0x73,
    0x20,
    0x1e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x60,
    0x36,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x50,
    0x72,
    0x65,
    0x6d,
    0x69,
    0x75,
    0x6d,
    0x4d,
    0x61,
    0x78,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x1f,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x4d,
    0x6f,
    0x62,
    0x69,
    0x6c,
    0x65,
    0x4d,
    0x61,
    0x78,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x27,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x71,
    0x75,
    0x65,
    0x75,
    0x65,
    0x20,
    0x28,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x71,
    0x75,
    0x65,
    0x75,
    0x65,
    0x5f,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x29,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x71,
    0x75,
    0x65,
    0x75,
    0x65,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x5f,
    0x73,
    0x65,
    0x67,
    0x64,
    0x69,
    0x72,
    0x73,
    0x20,
    0x2a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x71,
    0x75,
    0x65,
    0x75,
    0x65,
    0x5f,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x5f,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x20,
    0x3a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x46,
    0x69,
    0x6c,
    0x74,
    0x65,
    0x72,
    0x46,
    0x6f,
    0x72,
    0x63,
    0x65,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x41,
    0x70,
    0x70,
    0x72,
    0x6f,
    0x78,
    0x44,
    0x75,
    0x70,
    0x73,
    0x20,
    0x2b,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x54,
    0x6f,
    0x45,
    0x78,
    0x70,
    0x69,
    0x72,
    0x65,
    0x20,
    0x2c,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x54,
    0x6f,
    0x45,
    0x78,
    0x70,
    0x69,
    0x72,
    0x65,
    0x2e,
    0x43,
    0x61,
    0x74,
    0x65,
    0x67,
    0x6f,
    0x72,
    0x79,
    0x20,
    0x2d,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x42,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x54,
    0x6f,
    0x45,
    0x78,
    0x70,
    0x69,
    0x72,
    0x65,
    0x2e,
    0x45,
    0x78,
    0x70,
    0x69,
    0x72,
    0x79,
    0x45,
    0x70,
    0x6f,
    0x63,
    0x68,
    0x20,
    0x2e,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x42,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x54,
    0x6f,
    0x45,
    0x78,
    0x70,
    0x69,
    0x72,
    0x65,
    0x2e,
    0x64,
    0x65,
    0x6c,
    0x74,
    0x61,
    0x20,
    0x2f,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x42,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x46,
    0x69,
    0x6c,
    0x65,
    0x74,
    0x79,
    0x70,
    0x65,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x74,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x30,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x46,
    0x69,
    0x6c,
    0x65,
    0x74,
    0x79,
    0x70,
    0x65,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x74,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x46,
    0x69,
    0x6c,
    0x65,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x31,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x60,
    0x46,
    0x14,
    0x13,
    0x1a,
    0x1f,
    0x46,
    0x69,
    0x6c,
    0x65,
    0x74,
    0x79,
    0x70,
    0x65,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x74,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x4d,
    0x69,
    0x6e,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x32,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0x60,
    0x46,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1f,
    0x46,
    0x69,
    0x6c,
    0x65,
    0x74,
    0x79,
    0x70,
    0x65,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x74,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x4d,
    0x61,
    0x78,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x33,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x31,
    0x2e,
    0x30,
    0x60,
    0x46,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x4b,
    0x65,
    0x79,
    0x68,
    0x6f,
    0x6c,
    0x65,
    0x4b,
    0x6d,
    0x6c,
    0x20,
    0x49,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x54,
    0x72,
    0x61,
    0x63,
    0x65,
    0x72,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x74,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x35,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x54,
    0x72,
    0x61,
    0x63,
    0x65,
    0x72,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x74,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x71,
    0x75,
    0x65,
    0x75,
    0x65,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x36,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x4b,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x54,
    0x72,
    0x61,
    0x63,
    0x65,
    0x72,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x74,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x71,
    0x75,
    0x65,
    0x75,
    0x65,
    0x69,
    0x64,
    0x20,
    0x37,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x4b,
    0x14,
    0x13,
    0x1a,
    0x1d,
    0x54,
    0x72,
    0x61,
    0x63,
    0x65,
    0x72,
    0x43,
    0x6f,
    0x6e,
    0x73,
    0x74,
    0x72,
    0x61,
    0x69,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x6d,
    0x61,
    0x78,
    0x66,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x38,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x02,
    0x60,
    0x4b,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x50,
    0x61,
    0x74,
    0x74,
    0x65,
    0x72,
    0x6e,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x4d,
    0x75,
    0x6c,
    0x74,
    0x69,
    0x70,
    0x6c,
    0x69,
    0x65,
    0x72,
    0x20,
    0x39,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x32,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x32,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x44,
    0x6f,
    0x6d,
    0x61,
    0x69,
    0x6e,
    0x4d,
    0x69,
    0x6e,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x3b,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x44,
    0x6f,
    0x6d,
    0x61,
    0x69,
    0x6e,
    0x4d,
    0x69,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x3c,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x53,
    0x65,
    0x74,
    0x69,
    0x52,
    0x75,
    0x6c,
    0x65,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x4c,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x53,
    0x65,
    0x74,
    0x69,
    0x52,
    0x75,
    0x6c,
    0x65,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x4d,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x47,
    0x6f,
    0x6f,
    0x64,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x4f,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x47,
    0x6f,
    0x6f,
    0x64,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x50,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x47,
    0x6f,
    0x6f,
    0x64,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x50,
    0x61,
    0x74,
    0x74,
    0x65,
    0x72,
    0x6e,
    0x73,
    0x20,
    0x51,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x4d,
    0x6f,
    0x62,
    0x69,
    0x6c,
    0x65,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x52,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x4d,
    0x6f,
    0x62,
    0x69,
    0x6c,
    0x65,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x53,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x52,
    0x61,
    0x6e,
    0x64,
    0x6f,
    0x6d,
    0x44,
    0x6f,
    0x63,
    0x73,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x6f,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x52,
    0x61,
    0x6e,
    0x64,
    0x6f,
    0x6d,
    0x44,
    0x6f,
    0x63,
    0x73,
    0x47,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x65,
    0x65,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x70,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1d,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x65,
    0x64,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x44,
    0x69,
    0x73,
    0x74,
    0x72,
    0x69,
    0x62,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x53,
    0x70,
    0x65,
    0x63,
    0x20,
    0x3d,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x27,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x65,
    0x64,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x44,
    0x69,
    0x73,
    0x74,
    0x72,
    0x69,
    0x62,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x53,
    0x70,
    0x65,
    0x63,
    0x2e,
    0x42,
    0x75,
    0x63,
    0x6b,
    0x65,
    0x74,
    0x4d,
    0x61,
    0x78,
    0x20,
    0x3e,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x03,
    0x60,
    0x5b,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x53,
    0x75,
    0x62,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x6d,
    0x70,
    0x6f,
    0x6e,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x41,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x53,
    0x75,
    0x62,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x6d,
    0x70,
    0x6f,
    0x6e,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x42,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x5d,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x53,
    0x75,
    0x62,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x6d,
    0x70,
    0x6f,
    0x6e,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x65,
    0x72,
    0x63,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x43,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x5d,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x53,
    0x75,
    0x62,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x26,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x4d,
    0x61,
    0x78,
    0x54,
    0x6f,
    0x6b,
    0x65,
    0x6e,
    0x73,
    0x20,
    0x44,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x54,
    0x6f,
    0x6b,
    0x65,
    0x6e,
    0x53,
    0x69,
    0x7a,
    0x65,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x20,
    0x45,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x44,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0x54,
    0x6f,
    0x6b,
    0x65,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x46,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x53,
    0x65,
    0x74,
    0x69,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x65,
    0x64,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x47,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x41,
    0x64,
    0x64,
    0x44,
    0x6f,
    0x63,
    0x41,
    0x74,
    0x74,
    0x61,
    0x63,
    0x68,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x4a,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x4d,
    0x69,
    0x6e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x46,
    0x6f,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x73,
    0x20,
    0x54,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x4d,
    0x69,
    0x6e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x46,
    0x6f,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x73,
    0x2e,
    0x6d,
    0x69,
    0x6e,
    0x5f,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x55,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0x60,
    0x66,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x4d,
    0x69,
    0x6e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x46,
    0x6f,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x73,
    0x2e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x49,
    0x64,
    0x20,
    0x56,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x66,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x44,
    0x69,
    0x73,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x79,
    0x4d,
    0x69,
    0x6e,
    0x51,
    0x75,
    0x6f,
    0x74,
    0x61,
    0x20,
    0x57,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x44,
    0x69,
    0x73,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x79,
    0x4d,
    0x69,
    0x6e,
    0x51,
    0x75,
    0x6f,
    0x74,
    0x61,
    0x2e,
    0x46,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x58,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x02,
    0x60,
    0x69,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x44,
    0x69,
    0x73,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x79,
    0x4d,
    0x69,
    0x6e,
    0x51,
    0x75,
    0x6f,
    0x74,
    0x61,
    0x2e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x49,
    0x64,
    0x20,
    0x59,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x69,
    0x14,
    0x13,
    0x1a,
    0x21,
    0x44,
    0x69,
    0x73,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x79,
    0x4d,
    0x69,
    0x6e,
    0x51,
    0x75,
    0x6f,
    0x74,
    0x61,
    0x2e,
    0x44,
    0x69,
    0x73,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x79,
    0x51,
    0x75,
    0x65,
    0x75,
    0x65,
    0x73,
    0x20,
    0x5e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x60,
    0x69,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x44,
    0x6f,
    0x6d,
    0x61,
    0x69,
    0x6e,
    0x4d,
    0x69,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x63,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x44,
    0x6f,
    0x6d,
    0x61,
    0x69,
    0x6e,
    0x4d,
    0x69,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x2e,
    0x54,
    0x4c,
    0x44,
    0x20,
    0x64,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x6d,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x44,
    0x6f,
    0x6d,
    0x61,
    0x69,
    0x6e,
    0x4d,
    0x69,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x65,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x60,
    0x6d,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x65,
    0x64,
    0x4c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x71,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class IndexSelectionSiteStats_VersionedPornScore(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.score_ = 0.0
    self.version_ = 0
    self.has_score_ = 0
    self.has_version_ = 0
    if contents is not None: self.MergeFromString(contents)

  def score(self): return self.score_

  def set_score(self, x):
    self.has_score_ = 1
    self.score_ = x

  def clear_score(self):
    self.has_score_ = 0
    self.score_ = 0.0

  def has_score(self): return self.has_score_

  def version(self): return self.version_

  def set_version(self, x):
    self.has_version_ = 1
    self.version_ = x

  def clear_version(self):
    self.has_version_ = 0
    self.version_ = 0

  def has_version(self): return self.has_version_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_score()): self.set_score(x.score())
    if (x.has_version()): self.set_version(x.version())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionSiteStats', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionSiteStats')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionSiteStats', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionSiteStats', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionSiteStats', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_score_ != x.has_score_: return 0
    if self.has_score_ and self.score_ != x.score_: return 0
    if self.has_version_ != x.has_version_: return 0
    if self.has_version_ and self.version_ != x.version_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_score_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: score not set.')
    if (not self.has_version_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: version not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.version_)
    return n + 6

  def Clear(self):
    self.clear_score()
    self.clear_version()

  def OutputUnchecked(self, out):
    out.putVarInt32(77)
    out.putFloat(self.score_)
    out.putVarInt32(80)
    out.putVarInt32(self.version_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 68: break
      if tt == 77:
        self.set_score(d.getFloat())
        continue
      if tt == 80:
        self.set_version(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_score_: res+=prefix+("score: %s\n" % self.DebugFormatFloat(self.score_))
    if self.has_version_: res+=prefix+("version: %s\n" % self.DebugFormatInt32(self.version_))
    return res

class IndexSelectionSiteStats_ImagePorn(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.pages_ = 0
    self.anypornpages_ = 0
    self.pornpages_ = 0
    self.i18npornpages_ = 0
    self.mainadultpages_ = 0
    self.i18nsoftpornpages_ = 0
    self.has_pages_ = 0
    self.has_anypornpages_ = 0
    self.has_pornpages_ = 0
    self.has_i18npornpages_ = 0
    self.has_mainadultpages_ = 0
    self.has_i18nsoftpornpages_ = 0
    if contents is not None: self.MergeFromString(contents)

  def pages(self): return self.pages_

  def set_pages(self, x):
    self.has_pages_ = 1
    self.pages_ = x

  def clear_pages(self):
    self.has_pages_ = 0
    self.pages_ = 0

  def has_pages(self): return self.has_pages_

  def anypornpages(self): return self.anypornpages_

  def set_anypornpages(self, x):
    self.has_anypornpages_ = 1
    self.anypornpages_ = x

  def clear_anypornpages(self):
    self.has_anypornpages_ = 0
    self.anypornpages_ = 0

  def has_anypornpages(self): return self.has_anypornpages_

  def pornpages(self): return self.pornpages_

  def set_pornpages(self, x):
    self.has_pornpages_ = 1
    self.pornpages_ = x

  def clear_pornpages(self):
    self.has_pornpages_ = 0
    self.pornpages_ = 0

  def has_pornpages(self): return self.has_pornpages_

  def i18npornpages(self): return self.i18npornpages_

  def set_i18npornpages(self, x):
    self.has_i18npornpages_ = 1
    self.i18npornpages_ = x

  def clear_i18npornpages(self):
    self.has_i18npornpages_ = 0
    self.i18npornpages_ = 0

  def has_i18npornpages(self): return self.has_i18npornpages_

  def mainadultpages(self): return self.mainadultpages_

  def set_mainadultpages(self, x):
    self.has_mainadultpages_ = 1
    self.mainadultpages_ = x

  def clear_mainadultpages(self):
    self.has_mainadultpages_ = 0
    self.mainadultpages_ = 0

  def has_mainadultpages(self): return self.has_mainadultpages_

  def i18nsoftpornpages(self): return self.i18nsoftpornpages_

  def set_i18nsoftpornpages(self, x):
    self.has_i18nsoftpornpages_ = 1
    self.i18nsoftpornpages_ = x

  def clear_i18nsoftpornpages(self):
    self.has_i18nsoftpornpages_ = 0
    self.i18nsoftpornpages_ = 0

  def has_i18nsoftpornpages(self): return self.has_i18nsoftpornpages_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_pages()): self.set_pages(x.pages())
    if (x.has_anypornpages()): self.set_anypornpages(x.anypornpages())
    if (x.has_pornpages()): self.set_pornpages(x.pornpages())
    if (x.has_i18npornpages()): self.set_i18npornpages(x.i18npornpages())
    if (x.has_mainadultpages()): self.set_mainadultpages(x.mainadultpages())
    if (x.has_i18nsoftpornpages()): self.set_i18nsoftpornpages(x.i18nsoftpornpages())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionSiteStats', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionSiteStats')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionSiteStats', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionSiteStats', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionSiteStats', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_pages_ != x.has_pages_: return 0
    if self.has_pages_ and self.pages_ != x.pages_: return 0
    if self.has_anypornpages_ != x.has_anypornpages_: return 0
    if self.has_anypornpages_ and self.anypornpages_ != x.anypornpages_: return 0
    if self.has_pornpages_ != x.has_pornpages_: return 0
    if self.has_pornpages_ and self.pornpages_ != x.pornpages_: return 0
    if self.has_i18npornpages_ != x.has_i18npornpages_: return 0
    if self.has_i18npornpages_ and self.i18npornpages_ != x.i18npornpages_: return 0
    if self.has_mainadultpages_ != x.has_mainadultpages_: return 0
    if self.has_mainadultpages_ and self.mainadultpages_ != x.mainadultpages_: return 0
    if self.has_i18nsoftpornpages_ != x.has_i18nsoftpornpages_: return 0
    if self.has_i18nsoftpornpages_ and self.i18nsoftpornpages_ != x.i18nsoftpornpages_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_pages_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: pages not set.')
    if (not self.has_anypornpages_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: anypornpages not set.')
    if (not self.has_pornpages_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: pornpages not set.')
    if (not self.has_i18npornpages_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: i18npornpages not set.')
    if (not self.has_mainadultpages_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: mainadultpages not set.')
    if (not self.has_i18nsoftpornpages_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: i18nsoftpornpages not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.pages_)
    n += self.lengthVarInt64(self.anypornpages_)
    n += self.lengthVarInt64(self.pornpages_)
    n += self.lengthVarInt64(self.i18npornpages_)
    n += self.lengthVarInt64(self.mainadultpages_)
    n += self.lengthVarInt64(self.i18nsoftpornpages_)
    return n + 8

  def Clear(self):
    self.clear_pages()
    self.clear_anypornpages()
    self.clear_pornpages()
    self.clear_i18npornpages()
    self.clear_mainadultpages()
    self.clear_i18nsoftpornpages()

  def OutputUnchecked(self, out):
    out.putVarInt32(96)
    out.putVarUint64(self.pages_)
    out.putVarInt32(104)
    out.putVarUint64(self.anypornpages_)
    out.putVarInt32(112)
    out.putVarUint64(self.pornpages_)
    out.putVarInt32(120)
    out.putVarUint64(self.i18npornpages_)
    out.putVarInt32(128)
    out.putVarUint64(self.mainadultpages_)
    out.putVarInt32(136)
    out.putVarUint64(self.i18nsoftpornpages_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 92: break
      if tt == 96:
        self.set_pages(d.getVarUint64())
        continue
      if tt == 104:
        self.set_anypornpages(d.getVarUint64())
        continue
      if tt == 112:
        self.set_pornpages(d.getVarUint64())
        continue
      if tt == 120:
        self.set_i18npornpages(d.getVarUint64())
        continue
      if tt == 128:
        self.set_mainadultpages(d.getVarUint64())
        continue
      if tt == 136:
        self.set_i18nsoftpornpages(d.getVarUint64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_pages_: res+=prefix+("Pages: %s\n" % self.DebugFormatInt64(self.pages_))
    if self.has_anypornpages_: res+=prefix+("AnyPornPages: %s\n" % self.DebugFormatInt64(self.anypornpages_))
    if self.has_pornpages_: res+=prefix+("PornPages: %s\n" % self.DebugFormatInt64(self.pornpages_))
    if self.has_i18npornpages_: res+=prefix+("I18nPornPages: %s\n" % self.DebugFormatInt64(self.i18npornpages_))
    if self.has_mainadultpages_: res+=prefix+("MainAdultPages: %s\n" % self.DebugFormatInt64(self.mainadultpages_))
    if self.has_i18nsoftpornpages_: res+=prefix+("I18nSoftPornPages: %s\n" % self.DebugFormatInt64(self.i18nsoftpornpages_))
    return res

class IndexSelectionSiteStats(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.spamscore_y_ = 0.0
    self.spamscore_e_ = 0.0
    self.deliberate_visits_ = 0
    self.indyrank_ = 0
    self.redfin_ = 0.0
    self.isparkeddomain_ = 0
    self.pornscore_ = 0.0
    self.versionedpornscore_ = []
    self.imageporn_ = None
    self.has_spamscore_y_ = 0
    self.has_spamscore_e_ = 0
    self.has_deliberate_visits_ = 0
    self.has_indyrank_ = 0
    self.has_redfin_ = 0
    self.has_isparkeddomain_ = 0
    self.has_pornscore_ = 0
    self.has_imageporn_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def spamscore_y(self): return self.spamscore_y_

  def set_spamscore_y(self, x):
    self.has_spamscore_y_ = 1
    self.spamscore_y_ = x

  def clear_spamscore_y(self):
    self.has_spamscore_y_ = 0
    self.spamscore_y_ = 0.0

  def has_spamscore_y(self): return self.has_spamscore_y_

  def spamscore_e(self): return self.spamscore_e_

  def set_spamscore_e(self, x):
    self.has_spamscore_e_ = 1
    self.spamscore_e_ = x

  def clear_spamscore_e(self):
    self.has_spamscore_e_ = 0
    self.spamscore_e_ = 0.0

  def has_spamscore_e(self): return self.has_spamscore_e_

  def deliberate_visits(self): return self.deliberate_visits_

  def set_deliberate_visits(self, x):
    self.has_deliberate_visits_ = 1
    self.deliberate_visits_ = x

  def clear_deliberate_visits(self):
    self.has_deliberate_visits_ = 0
    self.deliberate_visits_ = 0

  def has_deliberate_visits(self): return self.has_deliberate_visits_

  def indyrank(self): return self.indyrank_

  def set_indyrank(self, x):
    self.has_indyrank_ = 1
    self.indyrank_ = x

  def clear_indyrank(self):
    self.has_indyrank_ = 0
    self.indyrank_ = 0

  def has_indyrank(self): return self.has_indyrank_

  def redfin(self): return self.redfin_

  def set_redfin(self, x):
    self.has_redfin_ = 1
    self.redfin_ = x

  def clear_redfin(self):
    self.has_redfin_ = 0
    self.redfin_ = 0.0

  def has_redfin(self): return self.has_redfin_

  def isparkeddomain(self): return self.isparkeddomain_

  def set_isparkeddomain(self, x):
    self.has_isparkeddomain_ = 1
    self.isparkeddomain_ = x

  def clear_isparkeddomain(self):
    self.has_isparkeddomain_ = 0
    self.isparkeddomain_ = 0

  def has_isparkeddomain(self): return self.has_isparkeddomain_

  def pornscore(self): return self.pornscore_

  def set_pornscore(self, x):
    self.has_pornscore_ = 1
    self.pornscore_ = x

  def clear_pornscore(self):
    self.has_pornscore_ = 0
    self.pornscore_ = 0.0

  def has_pornscore(self): return self.has_pornscore_

  def versionedpornscore_size(self): return len(self.versionedpornscore_)
  def versionedpornscore_list(self): return self.versionedpornscore_

  def versionedpornscore(self, i):
    return self.versionedpornscore_[i]

  def mutable_versionedpornscore(self, i):
    return self.versionedpornscore_[i]

  def add_versionedpornscore(self):
    x = IndexSelectionSiteStats_VersionedPornScore()
    self.versionedpornscore_.append(x)
    return x

  def clear_versionedpornscore(self):
    self.versionedpornscore_ = []
  def imageporn(self):
    if self.imageporn_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.imageporn_ is None: self.imageporn_ = IndexSelectionSiteStats_ImagePorn()
      finally:
        self.lazy_init_lock_.release()
    return self.imageporn_

  def mutable_imageporn(self): self.has_imageporn_ = 1; return self.imageporn()

  def clear_imageporn(self):
    #Warning: this method does not acquire the lock.
    self.has_imageporn_ = 0;
    if self.imageporn_ is not None: self.imageporn_.Clear()

  def has_imageporn(self): return self.has_imageporn_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_spamscore_y()): self.set_spamscore_y(x.spamscore_y())
    if (x.has_spamscore_e()): self.set_spamscore_e(x.spamscore_e())
    if (x.has_deliberate_visits()): self.set_deliberate_visits(x.deliberate_visits())
    if (x.has_indyrank()): self.set_indyrank(x.indyrank())
    if (x.has_redfin()): self.set_redfin(x.redfin())
    if (x.has_isparkeddomain()): self.set_isparkeddomain(x.isparkeddomain())
    if (x.has_pornscore()): self.set_pornscore(x.pornscore())
    for i in xrange(x.versionedpornscore_size()): self.add_versionedpornscore().CopyFrom(x.versionedpornscore(i))
    if (x.has_imageporn()): self.mutable_imageporn().MergeFrom(x.imageporn())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionSiteStats', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionSiteStats')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionSiteStats', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionSiteStats', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionSiteStats', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_spamscore_y_ != x.has_spamscore_y_: return 0
    if self.has_spamscore_y_ and self.spamscore_y_ != x.spamscore_y_: return 0
    if self.has_spamscore_e_ != x.has_spamscore_e_: return 0
    if self.has_spamscore_e_ and self.spamscore_e_ != x.spamscore_e_: return 0
    if self.has_deliberate_visits_ != x.has_deliberate_visits_: return 0
    if self.has_deliberate_visits_ and self.deliberate_visits_ != x.deliberate_visits_: return 0
    if self.has_indyrank_ != x.has_indyrank_: return 0
    if self.has_indyrank_ and self.indyrank_ != x.indyrank_: return 0
    if self.has_redfin_ != x.has_redfin_: return 0
    if self.has_redfin_ and self.redfin_ != x.redfin_: return 0
    if self.has_isparkeddomain_ != x.has_isparkeddomain_: return 0
    if self.has_isparkeddomain_ and self.isparkeddomain_ != x.isparkeddomain_: return 0
    if self.has_pornscore_ != x.has_pornscore_: return 0
    if self.has_pornscore_ and self.pornscore_ != x.pornscore_: return 0
    if len(self.versionedpornscore_) != len(x.versionedpornscore_): return 0
    for e1, e2 in zip(self.versionedpornscore_, x.versionedpornscore_):
      if e1 != e2: return 0
    if self.has_imageporn_ != x.has_imageporn_: return 0
    if self.has_imageporn_ and self.imageporn_ != x.imageporn_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.versionedpornscore_)):
      if (not self.versionedpornscore_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_imageporn_ and not self.imageporn_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_spamscore_y_): n += 5
    if (self.has_spamscore_e_): n += 5
    if (self.has_deliberate_visits_): n += 1 + self.lengthVarInt64(self.deliberate_visits_)
    if (self.has_indyrank_): n += 1 + self.lengthVarInt64(self.indyrank_)
    if (self.has_redfin_): n += 9
    if (self.has_isparkeddomain_): n += 2
    if (self.has_pornscore_): n += 5
    n += 2 * len(self.versionedpornscore_)
    for i in xrange(len(self.versionedpornscore_)): n += self.versionedpornscore_[i].ByteSize()
    if (self.has_imageporn_): n += 2 + self.imageporn_.ByteSize()
    return n + 0

  def Clear(self):
    self.clear_spamscore_y()
    self.clear_spamscore_e()
    self.clear_deliberate_visits()
    self.clear_indyrank()
    self.clear_redfin()
    self.clear_isparkeddomain()
    self.clear_pornscore()
    self.clear_versionedpornscore()
    self.clear_imageporn()

  def OutputUnchecked(self, out):
    if (self.has_spamscore_y_):
      out.putVarInt32(13)
      out.putFloat(self.spamscore_y_)
    if (self.has_spamscore_e_):
      out.putVarInt32(21)
      out.putFloat(self.spamscore_e_)
    if (self.has_deliberate_visits_):
      out.putVarInt32(24)
      out.putVarInt32(self.deliberate_visits_)
    if (self.has_indyrank_):
      out.putVarInt32(32)
      out.putVarInt32(self.indyrank_)
    if (self.has_redfin_):
      out.putVarInt32(41)
      out.putDouble(self.redfin_)
    if (self.has_isparkeddomain_):
      out.putVarInt32(48)
      out.putBoolean(self.isparkeddomain_)
    if (self.has_pornscore_):
      out.putVarInt32(61)
      out.putFloat(self.pornscore_)
    for i in xrange(len(self.versionedpornscore_)):
      out.putVarInt32(67)
      self.versionedpornscore_[i].OutputUnchecked(out)
      out.putVarInt32(68)
    if (self.has_imageporn_):
      out.putVarInt32(91)
      self.imageporn_.OutputUnchecked(out)
      out.putVarInt32(92)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 13:
        self.set_spamscore_y(d.getFloat())
        continue
      if tt == 21:
        self.set_spamscore_e(d.getFloat())
        continue
      if tt == 24:
        self.set_deliberate_visits(d.getVarInt32())
        continue
      if tt == 32:
        self.set_indyrank(d.getVarInt32())
        continue
      if tt == 41:
        self.set_redfin(d.getDouble())
        continue
      if tt == 48:
        self.set_isparkeddomain(d.getBoolean())
        continue
      if tt == 61:
        self.set_pornscore(d.getFloat())
        continue
      if tt == 67:
        self.add_versionedpornscore().TryMerge(d)
        continue
      if tt == 91:
        self.mutable_imageporn().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_spamscore_y_: res+=prefix+("SpamScore_Y: %s\n" % self.DebugFormatFloat(self.spamscore_y_))
    if self.has_spamscore_e_: res+=prefix+("SpamScore_E: %s\n" % self.DebugFormatFloat(self.spamscore_e_))
    if self.has_deliberate_visits_: res+=prefix+("Deliberate_Visits: %s\n" % self.DebugFormatInt32(self.deliberate_visits_))
    if self.has_indyrank_: res+=prefix+("IndyRank: %s\n" % self.DebugFormatInt32(self.indyrank_))
    if self.has_redfin_: res+=prefix+("Redfin: %s\n" % self.DebugFormat(self.redfin_))
    if self.has_isparkeddomain_: res+=prefix+("IsParkedDomain: %s\n" % self.DebugFormatBool(self.isparkeddomain_))
    if self.has_pornscore_: res+=prefix+("PornScore: %s\n" % self.DebugFormatFloat(self.pornscore_))
    cnt=0
    for e in self.versionedpornscore_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("VersionedPornScore%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_imageporn_:
      res+=prefix+"ImagePorn {\n"
      res+=self.imageporn_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    return res

  kSpamScore_Y = 1
  kSpamScore_E = 2
  kDeliberate_Visits = 3
  kIndyRank = 4
  kRedfin = 5
  kIsParkedDomain = 6
  kPornScore = 7
  kVersionedPornScoreGroup = 8
  kVersionedPornScorescore = 9
  kVersionedPornScoreversion = 10
  kImagePornGroup = 11
  kImagePornPages = 12
  kImagePornAnyPornPages = 13
  kImagePornPornPages = 14
  kImagePornI18nPornPages = 15
  kImagePornMainAdultPages = 16
  kImagePornI18nSoftPornPages = 17

  _TEXT = (
   "ErrorCode",  #   0
   "SpamScore_Y",  #   1
   "SpamScore_E",  #   2
   "Deliberate_Visits",  #   3
   "IndyRank",  #   4
   "Redfin",  #   5
   "IsParkedDomain",  #   6
   "PornScore",  #   7
   "VersionedPornScore",  #   8
   "score",  #   9
   "version",  #  10
   "ImagePorn",  #  11
   "Pages",  #  12
   "AnyPornPages",  #  13
   "PornPages",  #  14
   "I18nPornPages",  #  15
   "MainAdultPages",  #  16
   "I18nSoftPornPages",  #  17
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.FLOAT,  #   1

   ProtocolBuffer.Encoder.FLOAT,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.DOUBLE,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.FLOAT,  #   7

   ProtocolBuffer.Encoder.STARTGROUP,  #   8

   ProtocolBuffer.Encoder.FLOAT,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.STARTGROUP,  #  11

   ProtocolBuffer.Encoder.NUMERIC,  #  12

   ProtocolBuffer.Encoder.NUMERIC,  #  13

   ProtocolBuffer.Encoder.NUMERIC,  #  14

   ProtocolBuffer.Encoder.NUMERIC,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

   ProtocolBuffer.Encoder.NUMERIC,  #  17

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x2a,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x53,
    0x69,
    0x74,
    0x65,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x13,
    0x1a,
    0x0b,
    0x53,
    0x70,
    0x61,
    0x6d,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x5f,
    0x59,
    0x20,
    0x01,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x53,
    0x70,
    0x61,
    0x6d,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x5f,
    0x45,
    0x20,
    0x02,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x44,
    0x65,
    0x6c,
    0x69,
    0x62,
    0x65,
    0x72,
    0x61,
    0x74,
    0x65,
    0x5f,
    0x56,
    0x69,
    0x73,
    0x69,
    0x74,
    0x73,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x49,
    0x6e,
    0x64,
    0x79,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x52,
    0x65,
    0x64,
    0x66,
    0x69,
    0x6e,
    0x20,
    0x05,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x49,
    0x73,
    0x50,
    0x61,
    0x72,
    0x6b,
    0x65,
    0x64,
    0x44,
    0x6f,
    0x6d,
    0x61,
    0x69,
    0x6e,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x07,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x56,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x65,
    0x64,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x08,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x56,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x65,
    0x64,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x2e,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x09,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x02,
    0x60,
    0x07,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x56,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x65,
    0x64,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x2e,
    0x76,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x07,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x20,
    0x0b,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x2e,
    0x50,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x0c,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x2e,
    0x41,
    0x6e,
    0x79,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x50,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x0d,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x2e,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x50,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x0e,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x2e,
    0x49,
    0x31,
    0x38,
    0x6e,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x50,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x0f,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x2e,
    0x4d,
    0x61,
    0x69,
    0x6e,
    0x41,
    0x64,
    0x75,
    0x6c,
    0x74,
    0x50,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x2e,
    0x49,
    0x31,
    0x38,
    0x6e,
    0x53,
    0x6f,
    0x66,
    0x74,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x50,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x11,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class IndexSelectionHostStats(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.hostlimit_ = 0
    self.rankwithinhost_ = 0
    self.docsinbase_ = 0
    self.docsinblimpie_ = 0
    self.has_hostlimit_ = 0
    self.has_rankwithinhost_ = 0
    self.has_docsinbase_ = 0
    self.has_docsinblimpie_ = 0
    if contents is not None: self.MergeFromString(contents)

  def hostlimit(self): return self.hostlimit_

  def set_hostlimit(self, x):
    self.has_hostlimit_ = 1
    self.hostlimit_ = x

  def clear_hostlimit(self):
    self.has_hostlimit_ = 0
    self.hostlimit_ = 0

  def has_hostlimit(self): return self.has_hostlimit_

  def rankwithinhost(self): return self.rankwithinhost_

  def set_rankwithinhost(self, x):
    self.has_rankwithinhost_ = 1
    self.rankwithinhost_ = x

  def clear_rankwithinhost(self):
    self.has_rankwithinhost_ = 0
    self.rankwithinhost_ = 0

  def has_rankwithinhost(self): return self.has_rankwithinhost_

  def docsinbase(self): return self.docsinbase_

  def set_docsinbase(self, x):
    self.has_docsinbase_ = 1
    self.docsinbase_ = x

  def clear_docsinbase(self):
    self.has_docsinbase_ = 0
    self.docsinbase_ = 0

  def has_docsinbase(self): return self.has_docsinbase_

  def docsinblimpie(self): return self.docsinblimpie_

  def set_docsinblimpie(self, x):
    self.has_docsinblimpie_ = 1
    self.docsinblimpie_ = x

  def clear_docsinblimpie(self):
    self.has_docsinblimpie_ = 0
    self.docsinblimpie_ = 0

  def has_docsinblimpie(self): return self.has_docsinblimpie_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_hostlimit()): self.set_hostlimit(x.hostlimit())
    if (x.has_rankwithinhost()): self.set_rankwithinhost(x.rankwithinhost())
    if (x.has_docsinbase()): self.set_docsinbase(x.docsinbase())
    if (x.has_docsinblimpie()): self.set_docsinblimpie(x.docsinblimpie())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionHostStats', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionHostStats')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionHostStats', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionHostStats', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionHostStats', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_hostlimit_ != x.has_hostlimit_: return 0
    if self.has_hostlimit_ and self.hostlimit_ != x.hostlimit_: return 0
    if self.has_rankwithinhost_ != x.has_rankwithinhost_: return 0
    if self.has_rankwithinhost_ and self.rankwithinhost_ != x.rankwithinhost_: return 0
    if self.has_docsinbase_ != x.has_docsinbase_: return 0
    if self.has_docsinbase_ and self.docsinbase_ != x.docsinbase_: return 0
    if self.has_docsinblimpie_ != x.has_docsinblimpie_: return 0
    if self.has_docsinblimpie_ and self.docsinblimpie_ != x.docsinblimpie_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_hostlimit_): n += 1 + self.lengthVarInt64(self.hostlimit_)
    if (self.has_rankwithinhost_): n += 1 + self.lengthVarInt64(self.rankwithinhost_)
    if (self.has_docsinbase_): n += 1 + self.lengthVarInt64(self.docsinbase_)
    if (self.has_docsinblimpie_): n += 1 + self.lengthVarInt64(self.docsinblimpie_)
    return n + 0

  def Clear(self):
    self.clear_hostlimit()
    self.clear_rankwithinhost()
    self.clear_docsinbase()
    self.clear_docsinblimpie()

  def OutputUnchecked(self, out):
    if (self.has_hostlimit_):
      out.putVarInt32(8)
      out.putVarUint64(self.hostlimit_)
    if (self.has_rankwithinhost_):
      out.putVarInt32(16)
      out.putVarInt32(self.rankwithinhost_)
    if (self.has_docsinbase_):
      out.putVarInt32(24)
      out.putVarUint64(self.docsinbase_)
    if (self.has_docsinblimpie_):
      out.putVarInt32(32)
      out.putVarUint64(self.docsinblimpie_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_hostlimit(d.getVarUint64())
        continue
      if tt == 16:
        self.set_rankwithinhost(d.getVarInt32())
        continue
      if tt == 24:
        self.set_docsinbase(d.getVarUint64())
        continue
      if tt == 32:
        self.set_docsinblimpie(d.getVarUint64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_hostlimit_: res+=prefix+("HostLimit: %s\n" % self.DebugFormatInt64(self.hostlimit_))
    if self.has_rankwithinhost_: res+=prefix+("RankWithinHost: %s\n" % self.DebugFormatInt32(self.rankwithinhost_))
    if self.has_docsinbase_: res+=prefix+("DocsInBase: %s\n" % self.DebugFormatInt64(self.docsinbase_))
    if self.has_docsinblimpie_: res+=prefix+("DocsInBlimpie: %s\n" % self.DebugFormatInt64(self.docsinblimpie_))
    return res

  kHostLimit = 1
  kRankWithinHost = 2
  kDocsInBase = 3
  kDocsInBlimpie = 4

  _TEXT = (
   "ErrorCode",  #   0
   "HostLimit",  #   1
   "RankWithinHost",  #   2
   "DocsInBase",  #   3
   "DocsInBlimpie",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x2a,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x13,
    0x1a,
    0x09,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x57,
    0x69,
    0x74,
    0x68,
    0x69,
    0x6e,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x44,
    0x6f,
    0x63,
    0x73,
    0x49,
    0x6e,
    0x42,
    0x61,
    0x73,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x44,
    0x6f,
    0x63,
    0x73,
    0x49,
    0x6e,
    0x42,
    0x6c,
    0x69,
    0x6d,
    0x70,
    0x69,
    0x65,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ClusterInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.label_ = ""
    self.rank_ = 0
    self.size_ = 0
    self.termsinlabel_ = 0
    self.approxdupcanonicalurl_ = ""
    self.cleartextlabel_ = ""
    self.clusterid_ = 0
    self.has_label_ = 0
    self.has_rank_ = 0
    self.has_size_ = 0
    self.has_termsinlabel_ = 0
    self.has_approxdupcanonicalurl_ = 0
    self.has_cleartextlabel_ = 0
    self.has_clusterid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def label(self): return self.label_

  def set_label(self, x):
    self.has_label_ = 1
    self.label_ = x

  def clear_label(self):
    self.has_label_ = 0
    self.label_ = ""

  def has_label(self): return self.has_label_

  def rank(self): return self.rank_

  def set_rank(self, x):
    self.has_rank_ = 1
    self.rank_ = x

  def clear_rank(self):
    self.has_rank_ = 0
    self.rank_ = 0

  def has_rank(self): return self.has_rank_

  def size(self): return self.size_

  def set_size(self, x):
    self.has_size_ = 1
    self.size_ = x

  def clear_size(self):
    self.has_size_ = 0
    self.size_ = 0

  def has_size(self): return self.has_size_

  def termsinlabel(self): return self.termsinlabel_

  def set_termsinlabel(self, x):
    self.has_termsinlabel_ = 1
    self.termsinlabel_ = x

  def clear_termsinlabel(self):
    self.has_termsinlabel_ = 0
    self.termsinlabel_ = 0

  def has_termsinlabel(self): return self.has_termsinlabel_

  def approxdupcanonicalurl(self): return self.approxdupcanonicalurl_

  def set_approxdupcanonicalurl(self, x):
    self.has_approxdupcanonicalurl_ = 1
    self.approxdupcanonicalurl_ = x

  def clear_approxdupcanonicalurl(self):
    self.has_approxdupcanonicalurl_ = 0
    self.approxdupcanonicalurl_ = ""

  def has_approxdupcanonicalurl(self): return self.has_approxdupcanonicalurl_

  def cleartextlabel(self): return self.cleartextlabel_

  def set_cleartextlabel(self, x):
    self.has_cleartextlabel_ = 1
    self.cleartextlabel_ = x

  def clear_cleartextlabel(self):
    self.has_cleartextlabel_ = 0
    self.cleartextlabel_ = ""

  def has_cleartextlabel(self): return self.has_cleartextlabel_

  def clusterid(self): return self.clusterid_

  def set_clusterid(self, x):
    self.has_clusterid_ = 1
    self.clusterid_ = x

  def clear_clusterid(self):
    self.has_clusterid_ = 0
    self.clusterid_ = 0

  def has_clusterid(self): return self.has_clusterid_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_label()): self.set_label(x.label())
    if (x.has_rank()): self.set_rank(x.rank())
    if (x.has_size()): self.set_size(x.size())
    if (x.has_termsinlabel()): self.set_termsinlabel(x.termsinlabel())
    if (x.has_approxdupcanonicalurl()): self.set_approxdupcanonicalurl(x.approxdupcanonicalurl())
    if (x.has_cleartextlabel()): self.set_cleartextlabel(x.cleartextlabel())
    if (x.has_clusterid()): self.set_clusterid(x.clusterid())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.ClusterInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.ClusterInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.ClusterInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.ClusterInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.ClusterInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_label_ != x.has_label_: return 0
    if self.has_label_ and self.label_ != x.label_: return 0
    if self.has_rank_ != x.has_rank_: return 0
    if self.has_rank_ and self.rank_ != x.rank_: return 0
    if self.has_size_ != x.has_size_: return 0
    if self.has_size_ and self.size_ != x.size_: return 0
    if self.has_termsinlabel_ != x.has_termsinlabel_: return 0
    if self.has_termsinlabel_ and self.termsinlabel_ != x.termsinlabel_: return 0
    if self.has_approxdupcanonicalurl_ != x.has_approxdupcanonicalurl_: return 0
    if self.has_approxdupcanonicalurl_ and self.approxdupcanonicalurl_ != x.approxdupcanonicalurl_: return 0
    if self.has_cleartextlabel_ != x.has_cleartextlabel_: return 0
    if self.has_cleartextlabel_ and self.cleartextlabel_ != x.cleartextlabel_: return 0
    if self.has_clusterid_ != x.has_clusterid_: return 0
    if self.has_clusterid_ and self.clusterid_ != x.clusterid_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_label_): n += 1 + self.lengthString(len(self.label_))
    if (self.has_rank_): n += 1 + self.lengthVarInt64(self.rank_)
    if (self.has_size_): n += 1 + self.lengthVarInt64(self.size_)
    if (self.has_termsinlabel_): n += 1 + self.lengthVarInt64(self.termsinlabel_)
    if (self.has_approxdupcanonicalurl_): n += 1 + self.lengthString(len(self.approxdupcanonicalurl_))
    if (self.has_cleartextlabel_): n += 1 + self.lengthString(len(self.cleartextlabel_))
    if (self.has_clusterid_): n += 1 + self.lengthVarInt64(self.clusterid_)
    return n + 0

  def Clear(self):
    self.clear_label()
    self.clear_rank()
    self.clear_size()
    self.clear_termsinlabel()
    self.clear_approxdupcanonicalurl()
    self.clear_cleartextlabel()
    self.clear_clusterid()

  def OutputUnchecked(self, out):
    if (self.has_label_):
      out.putVarInt32(10)
      out.putPrefixedString(self.label_)
    if (self.has_rank_):
      out.putVarInt32(16)
      out.putVarInt32(self.rank_)
    if (self.has_size_):
      out.putVarInt32(24)
      out.putVarInt32(self.size_)
    if (self.has_termsinlabel_):
      out.putVarInt32(32)
      out.putVarInt32(self.termsinlabel_)
    if (self.has_approxdupcanonicalurl_):
      out.putVarInt32(42)
      out.putPrefixedString(self.approxdupcanonicalurl_)
    if (self.has_cleartextlabel_):
      out.putVarInt32(50)
      out.putPrefixedString(self.cleartextlabel_)
    if (self.has_clusterid_):
      out.putVarInt32(56)
      out.putVarInt32(self.clusterid_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_label(d.getPrefixedString())
        continue
      if tt == 16:
        self.set_rank(d.getVarInt32())
        continue
      if tt == 24:
        self.set_size(d.getVarInt32())
        continue
      if tt == 32:
        self.set_termsinlabel(d.getVarInt32())
        continue
      if tt == 42:
        self.set_approxdupcanonicalurl(d.getPrefixedString())
        continue
      if tt == 50:
        self.set_cleartextlabel(d.getPrefixedString())
        continue
      if tt == 56:
        self.set_clusterid(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_label_: res+=prefix+("Label: %s\n" % self.DebugFormatString(self.label_))
    if self.has_rank_: res+=prefix+("Rank: %s\n" % self.DebugFormatInt32(self.rank_))
    if self.has_size_: res+=prefix+("Size: %s\n" % self.DebugFormatInt32(self.size_))
    if self.has_termsinlabel_: res+=prefix+("TermsInLabel: %s\n" % self.DebugFormatInt32(self.termsinlabel_))
    if self.has_approxdupcanonicalurl_: res+=prefix+("ApproxDupCanonicalUrl: %s\n" % self.DebugFormatString(self.approxdupcanonicalurl_))
    if self.has_cleartextlabel_: res+=prefix+("ClearTextLabel: %s\n" % self.DebugFormatString(self.cleartextlabel_))
    if self.has_clusterid_: res+=prefix+("ClusterID: %s\n" % self.DebugFormatInt32(self.clusterid_))
    return res

  kLabel = 1
  kRank = 2
  kSize = 3
  kTermsInLabel = 4
  kApproxDupCanonicalUrl = 5
  kClearTextLabel = 6
  kClusterID = 7

  _TEXT = (
   "ErrorCode",  #   0
   "Label",  #   1
   "Rank",  #   2
   "Size",  #   3
   "TermsInLabel",  #   4
   "ApproxDupCanonicalUrl",  #   5
   "ClearTextLabel",  #   6
   "ClusterID",  #   7
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1e,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x13,
    0x1a,
    0x05,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x53,
    0x69,
    0x7a,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x54,
    0x65,
    0x72,
    0x6d,
    0x73,
    0x49,
    0x6e,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x41,
    0x70,
    0x70,
    0x72,
    0x6f,
    0x78,
    0x44,
    0x75,
    0x70,
    0x43,
    0x61,
    0x6e,
    0x6f,
    0x6e,
    0x69,
    0x63,
    0x61,
    0x6c,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x43,
    0x6c,
    0x65,
    0x61,
    0x72,
    0x54,
    0x65,
    0x78,
    0x74,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x49,
    0x44,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class IndexSelectionURLStats(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.clusterinfo_ = []
    self.clicks_ = 0.0
    self.rankwithinhost_deprecated_ = 0
    self.hostlimit_deprecated_ = 0
    self.numterms_ = 0
    self.frameset_ = 0
    self.porn_deprecated_ = 0
    self.nlscore_ = 0.0
    self.coveragestats_ = None
    self.has_clicks_ = 0
    self.has_rankwithinhost_deprecated_ = 0
    self.has_hostlimit_deprecated_ = 0
    self.has_numterms_ = 0
    self.has_frameset_ = 0
    self.has_porn_deprecated_ = 0
    self.has_nlscore_ = 0
    self.has_coveragestats_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def clusterinfo_size(self): return len(self.clusterinfo_)
  def clusterinfo_list(self): return self.clusterinfo_

  def clusterinfo(self, i):
    return self.clusterinfo_[i]

  def mutable_clusterinfo(self, i):
    return self.clusterinfo_[i]

  def add_clusterinfo(self):
    x = ClusterInfo()
    self.clusterinfo_.append(x)
    return x

  def clear_clusterinfo(self):
    self.clusterinfo_ = []
  def clicks(self): return self.clicks_

  def set_clicks(self, x):
    self.has_clicks_ = 1
    self.clicks_ = x

  def clear_clicks(self):
    self.has_clicks_ = 0
    self.clicks_ = 0.0

  def has_clicks(self): return self.has_clicks_

  def rankwithinhost_deprecated(self): return self.rankwithinhost_deprecated_

  def set_rankwithinhost_deprecated(self, x):
    self.has_rankwithinhost_deprecated_ = 1
    self.rankwithinhost_deprecated_ = x

  def clear_rankwithinhost_deprecated(self):
    self.has_rankwithinhost_deprecated_ = 0
    self.rankwithinhost_deprecated_ = 0

  def has_rankwithinhost_deprecated(self): return self.has_rankwithinhost_deprecated_

  def hostlimit_deprecated(self): return self.hostlimit_deprecated_

  def set_hostlimit_deprecated(self, x):
    self.has_hostlimit_deprecated_ = 1
    self.hostlimit_deprecated_ = x

  def clear_hostlimit_deprecated(self):
    self.has_hostlimit_deprecated_ = 0
    self.hostlimit_deprecated_ = 0

  def has_hostlimit_deprecated(self): return self.has_hostlimit_deprecated_

  def numterms(self): return self.numterms_

  def set_numterms(self, x):
    self.has_numterms_ = 1
    self.numterms_ = x

  def clear_numterms(self):
    self.has_numterms_ = 0
    self.numterms_ = 0

  def has_numterms(self): return self.has_numterms_

  def frameset(self): return self.frameset_

  def set_frameset(self, x):
    self.has_frameset_ = 1
    self.frameset_ = x

  def clear_frameset(self):
    self.has_frameset_ = 0
    self.frameset_ = 0

  def has_frameset(self): return self.has_frameset_

  def porn_deprecated(self): return self.porn_deprecated_

  def set_porn_deprecated(self, x):
    self.has_porn_deprecated_ = 1
    self.porn_deprecated_ = x

  def clear_porn_deprecated(self):
    self.has_porn_deprecated_ = 0
    self.porn_deprecated_ = 0

  def has_porn_deprecated(self): return self.has_porn_deprecated_

  def nlscore(self): return self.nlscore_

  def set_nlscore(self, x):
    self.has_nlscore_ = 1
    self.nlscore_ = x

  def clear_nlscore(self):
    self.has_nlscore_ = 0
    self.nlscore_ = 0.0

  def has_nlscore(self): return self.has_nlscore_

  def coveragestats(self):
    if self.coveragestats_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.coveragestats_ is None: self.coveragestats_ = IndexCoverage()
      finally:
        self.lazy_init_lock_.release()
    return self.coveragestats_

  def mutable_coveragestats(self): self.has_coveragestats_ = 1; return self.coveragestats()

  def clear_coveragestats(self):
    #Warning: this method does not acquire the lock.
    self.has_coveragestats_ = 0;
    if self.coveragestats_ is not None: self.coveragestats_.Clear()

  def has_coveragestats(self): return self.has_coveragestats_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.clusterinfo_size()): self.add_clusterinfo().CopyFrom(x.clusterinfo(i))
    if (x.has_clicks()): self.set_clicks(x.clicks())
    if (x.has_rankwithinhost_deprecated()): self.set_rankwithinhost_deprecated(x.rankwithinhost_deprecated())
    if (x.has_hostlimit_deprecated()): self.set_hostlimit_deprecated(x.hostlimit_deprecated())
    if (x.has_numterms()): self.set_numterms(x.numterms())
    if (x.has_frameset()): self.set_frameset(x.frameset())
    if (x.has_porn_deprecated()): self.set_porn_deprecated(x.porn_deprecated())
    if (x.has_nlscore()): self.set_nlscore(x.nlscore())
    if (x.has_coveragestats()): self.mutable_coveragestats().MergeFrom(x.coveragestats())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionURLStats', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionURLStats')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionURLStats', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionURLStats', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionURLStats', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.clusterinfo_) != len(x.clusterinfo_): return 0
    for e1, e2 in zip(self.clusterinfo_, x.clusterinfo_):
      if e1 != e2: return 0
    if self.has_clicks_ != x.has_clicks_: return 0
    if self.has_clicks_ and self.clicks_ != x.clicks_: return 0
    if self.has_rankwithinhost_deprecated_ != x.has_rankwithinhost_deprecated_: return 0
    if self.has_rankwithinhost_deprecated_ and self.rankwithinhost_deprecated_ != x.rankwithinhost_deprecated_: return 0
    if self.has_hostlimit_deprecated_ != x.has_hostlimit_deprecated_: return 0
    if self.has_hostlimit_deprecated_ and self.hostlimit_deprecated_ != x.hostlimit_deprecated_: return 0
    if self.has_numterms_ != x.has_numterms_: return 0
    if self.has_numterms_ and self.numterms_ != x.numterms_: return 0
    if self.has_frameset_ != x.has_frameset_: return 0
    if self.has_frameset_ and self.frameset_ != x.frameset_: return 0
    if self.has_porn_deprecated_ != x.has_porn_deprecated_: return 0
    if self.has_porn_deprecated_ and self.porn_deprecated_ != x.porn_deprecated_: return 0
    if self.has_nlscore_ != x.has_nlscore_: return 0
    if self.has_nlscore_ and self.nlscore_ != x.nlscore_: return 0
    if self.has_coveragestats_ != x.has_coveragestats_: return 0
    if self.has_coveragestats_ and self.coveragestats_ != x.coveragestats_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.clusterinfo_)):
      if (not self.clusterinfo_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_coveragestats_ and not self.coveragestats_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.clusterinfo_)
    for i in xrange(len(self.clusterinfo_)): n += self.lengthString(self.clusterinfo_[i].ByteSize())
    if (self.has_clicks_): n += 9
    if (self.has_rankwithinhost_deprecated_): n += 1 + self.lengthVarInt64(self.rankwithinhost_deprecated_)
    if (self.has_hostlimit_deprecated_): n += 1 + self.lengthVarInt64(self.hostlimit_deprecated_)
    if (self.has_numterms_): n += 1 + self.lengthVarInt64(self.numterms_)
    if (self.has_frameset_): n += 2
    if (self.has_porn_deprecated_): n += 2
    if (self.has_nlscore_): n += 9
    if (self.has_coveragestats_): n += 1 + self.lengthString(self.coveragestats_.ByteSize())
    return n + 0

  def Clear(self):
    self.clear_clusterinfo()
    self.clear_clicks()
    self.clear_rankwithinhost_deprecated()
    self.clear_hostlimit_deprecated()
    self.clear_numterms()
    self.clear_frameset()
    self.clear_porn_deprecated()
    self.clear_nlscore()
    self.clear_coveragestats()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.clusterinfo_)):
      out.putVarInt32(10)
      out.putVarInt32(self.clusterinfo_[i].ByteSize())
      self.clusterinfo_[i].OutputUnchecked(out)
    if (self.has_clicks_):
      out.putVarInt32(17)
      out.putDouble(self.clicks_)
    if (self.has_rankwithinhost_deprecated_):
      out.putVarInt32(32)
      out.putVarInt32(self.rankwithinhost_deprecated_)
    if (self.has_hostlimit_deprecated_):
      out.putVarInt32(40)
      out.putVarUint64(self.hostlimit_deprecated_)
    if (self.has_numterms_):
      out.putVarInt32(48)
      out.putVarInt32(self.numterms_)
    if (self.has_frameset_):
      out.putVarInt32(56)
      out.putBoolean(self.frameset_)
    if (self.has_porn_deprecated_):
      out.putVarInt32(64)
      out.putBoolean(self.porn_deprecated_)
    if (self.has_nlscore_):
      out.putVarInt32(73)
      out.putDouble(self.nlscore_)
    if (self.has_coveragestats_):
      out.putVarInt32(82)
      out.putVarInt32(self.coveragestats_.ByteSize())
      self.coveragestats_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_clusterinfo().TryMerge(tmp)
        continue
      if tt == 17:
        self.set_clicks(d.getDouble())
        continue
      if tt == 32:
        self.set_rankwithinhost_deprecated(d.getVarInt32())
        continue
      if tt == 40:
        self.set_hostlimit_deprecated(d.getVarUint64())
        continue
      if tt == 48:
        self.set_numterms(d.getVarInt32())
        continue
      if tt == 56:
        self.set_frameset(d.getBoolean())
        continue
      if tt == 64:
        self.set_porn_deprecated(d.getBoolean())
        continue
      if tt == 73:
        self.set_nlscore(d.getDouble())
        continue
      if tt == 82:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_coveragestats().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.clusterinfo_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("ClusterInfo%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_clicks_: res+=prefix+("Clicks: %s\n" % self.DebugFormat(self.clicks_))
    if self.has_rankwithinhost_deprecated_: res+=prefix+("RankWithinHost_DEPRECATED: %s\n" % self.DebugFormatInt32(self.rankwithinhost_deprecated_))
    if self.has_hostlimit_deprecated_: res+=prefix+("HostLimit_DEPRECATED: %s\n" % self.DebugFormatInt64(self.hostlimit_deprecated_))
    if self.has_numterms_: res+=prefix+("NumTerms: %s\n" % self.DebugFormatInt32(self.numterms_))
    if self.has_frameset_: res+=prefix+("Frameset: %s\n" % self.DebugFormatBool(self.frameset_))
    if self.has_porn_deprecated_: res+=prefix+("Porn_DEPRECATED: %s\n" % self.DebugFormatBool(self.porn_deprecated_))
    if self.has_nlscore_: res+=prefix+("NLScore: %s\n" % self.DebugFormat(self.nlscore_))
    if self.has_coveragestats_:
      res+=prefix+"CoverageStats <\n"
      res+=self.coveragestats_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

  kClusterInfo = 1
  kClicks = 2
  kRankWithinHost_DEPRECATED = 4
  kHostLimit_DEPRECATED = 5
  kNumTerms = 6
  kFrameset = 7
  kPorn_DEPRECATED = 8
  kNLScore = 9
  kCoverageStats = 10

  _TEXT = (
   "ErrorCode",  #   0
   "ClusterInfo",  #   1
   "Clicks",  #   2
   None,  #   3
   "RankWithinHost_DEPRECATED",  #   4
   "HostLimit_DEPRECATED",  #   5
   "NumTerms",  #   6
   "Frameset",  #   7
   "Porn_DEPRECATED",  #   8
   "NLScore",  #   9
   "CoverageStats",  #  10
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.DOUBLE,  #   2

   ProtocolBuffer.Encoder.MAX_TYPE,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.DOUBLE,  #   9

   ProtocolBuffer.Encoder.STRING,  #  10

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x29,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x55,
    0x52,
    0x4c,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x13,
    0x1a,
    0x0b,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x1e,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x43,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x73,
    0x20,
    0x02,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x57,
    0x69,
    0x74,
    0x68,
    0x69,
    0x6e,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x4c,
    0x69,
    0x6d,
    0x69,
    0x74,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x4e,
    0x75,
    0x6d,
    0x54,
    0x65,
    0x72,
    0x6d,
    0x73,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x46,
    0x72,
    0x61,
    0x6d,
    0x65,
    0x73,
    0x65,
    0x74,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x50,
    0x6f,
    0x72,
    0x6e,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x4e,
    0x4c,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x09,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x20,
    0x0a,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x15,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class SelectionRules_FiredRulesDebugInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.condition_ = ""
    self.weight_ = 0.0
    self.has_condition_ = 0
    self.has_weight_ = 0
    if contents is not None: self.MergeFromString(contents)

  def condition(self): return self.condition_

  def set_condition(self, x):
    self.has_condition_ = 1
    self.condition_ = x

  def clear_condition(self):
    self.has_condition_ = 0
    self.condition_ = ""

  def has_condition(self): return self.has_condition_

  def weight(self): return self.weight_

  def set_weight(self, x):
    self.has_weight_ = 1
    self.weight_ = x

  def clear_weight(self):
    self.has_weight_ = 0
    self.weight_ = 0.0

  def has_weight(self): return self.has_weight_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_condition()): self.set_condition(x.condition())
    if (x.has_weight()): self.set_weight(x.weight())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.SelectionRules', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.SelectionRules')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.SelectionRules', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.SelectionRules', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.SelectionRules', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_condition_ != x.has_condition_: return 0
    if self.has_condition_ and self.condition_ != x.condition_: return 0
    if self.has_weight_ != x.has_weight_: return 0
    if self.has_weight_ and self.weight_ != x.weight_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_condition_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: condition not set.')
    if (not self.has_weight_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: weight not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.condition_))
    return n + 10

  def Clear(self):
    self.clear_condition()
    self.clear_weight()

  def OutputUnchecked(self, out):
    out.putVarInt32(50)
    out.putPrefixedString(self.condition_)
    out.putVarInt32(57)
    out.putDouble(self.weight_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 44: break
      if tt == 50:
        self.set_condition(d.getPrefixedString())
        continue
      if tt == 57:
        self.set_weight(d.getDouble())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_condition_: res+=prefix+("Condition: %s\n" % self.DebugFormatString(self.condition_))
    if self.has_weight_: res+=prefix+("Weight: %s\n" % self.DebugFormat(self.weight_))
    return res

class SelectionRules_FiredRules(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.ruleid_ = 0
    self.debuginfo_ = None
    self.has_ruleid_ = 0
    self.has_debuginfo_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def ruleid(self): return self.ruleid_

  def set_ruleid(self, x):
    self.has_ruleid_ = 1
    self.ruleid_ = x

  def clear_ruleid(self):
    self.has_ruleid_ = 0
    self.ruleid_ = 0

  def has_ruleid(self): return self.has_ruleid_

  def debuginfo(self):
    if self.debuginfo_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.debuginfo_ is None: self.debuginfo_ = SelectionRules_FiredRulesDebugInfo()
      finally:
        self.lazy_init_lock_.release()
    return self.debuginfo_

  def mutable_debuginfo(self): self.has_debuginfo_ = 1; return self.debuginfo()

  def clear_debuginfo(self):
    #Warning: this method does not acquire the lock.
    self.has_debuginfo_ = 0;
    if self.debuginfo_ is not None: self.debuginfo_.Clear()

  def has_debuginfo(self): return self.has_debuginfo_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_ruleid()): self.set_ruleid(x.ruleid())
    if (x.has_debuginfo()): self.mutable_debuginfo().MergeFrom(x.debuginfo())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.SelectionRules', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.SelectionRules')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.SelectionRules', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.SelectionRules', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.SelectionRules', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_ruleid_ != x.has_ruleid_: return 0
    if self.has_ruleid_ and self.ruleid_ != x.ruleid_: return 0
    if self.has_debuginfo_ != x.has_debuginfo_: return 0
    if self.has_debuginfo_ and self.debuginfo_ != x.debuginfo_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_ruleid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: ruleid not set.')
    if (self.has_debuginfo_ and not self.debuginfo_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.ruleid_)
    if (self.has_debuginfo_): n += 2 + self.debuginfo_.ByteSize()
    return n + 1

  def Clear(self):
    self.clear_ruleid()
    self.clear_debuginfo()

  def OutputUnchecked(self, out):
    out.putVarInt32(32)
    out.putVarInt32(self.ruleid_)
    if (self.has_debuginfo_):
      out.putVarInt32(43)
      self.debuginfo_.OutputUnchecked(out)
      out.putVarInt32(44)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 28: break
      if tt == 32:
        self.set_ruleid(d.getVarInt32())
        continue
      if tt == 43:
        self.mutable_debuginfo().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_ruleid_: res+=prefix+("RuleId: %s\n" % self.DebugFormatInt32(self.ruleid_))
    if self.has_debuginfo_:
      res+=prefix+"DebugInfo {\n"
      res+=self.debuginfo_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    return res

class SelectionRules(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.weight_ = 0.0
    self.rawscore_ = 0.0
    self.firedrules_ = []
    self.has_weight_ = 0
    self.has_rawscore_ = 0
    if contents is not None: self.MergeFromString(contents)

  def weight(self): return self.weight_

  def set_weight(self, x):
    self.has_weight_ = 1
    self.weight_ = x

  def clear_weight(self):
    self.has_weight_ = 0
    self.weight_ = 0.0

  def has_weight(self): return self.has_weight_

  def rawscore(self): return self.rawscore_

  def set_rawscore(self, x):
    self.has_rawscore_ = 1
    self.rawscore_ = x

  def clear_rawscore(self):
    self.has_rawscore_ = 0
    self.rawscore_ = 0.0

  def has_rawscore(self): return self.has_rawscore_

  def firedrules_size(self): return len(self.firedrules_)
  def firedrules_list(self): return self.firedrules_

  def firedrules(self, i):
    return self.firedrules_[i]

  def mutable_firedrules(self, i):
    return self.firedrules_[i]

  def add_firedrules(self):
    x = SelectionRules_FiredRules()
    self.firedrules_.append(x)
    return x

  def clear_firedrules(self):
    self.firedrules_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_weight()): self.set_weight(x.weight())
    if (x.has_rawscore()): self.set_rawscore(x.rawscore())
    for i in xrange(x.firedrules_size()): self.add_firedrules().CopyFrom(x.firedrules(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.SelectionRules', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.SelectionRules')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.SelectionRules', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.SelectionRules', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.SelectionRules', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_weight_ != x.has_weight_: return 0
    if self.has_weight_ and self.weight_ != x.weight_: return 0
    if self.has_rawscore_ != x.has_rawscore_: return 0
    if self.has_rawscore_ and self.rawscore_ != x.rawscore_: return 0
    if len(self.firedrules_) != len(x.firedrules_): return 0
    for e1, e2 in zip(self.firedrules_, x.firedrules_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_weight_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: weight not set.')
    if (not self.has_rawscore_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: rawscore not set.')
    for i in xrange(len(self.firedrules_)):
      if (not self.firedrules_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.firedrules_)
    for i in xrange(len(self.firedrules_)): n += self.firedrules_[i].ByteSize()
    return n + 18

  def Clear(self):
    self.clear_weight()
    self.clear_rawscore()
    self.clear_firedrules()

  def OutputUnchecked(self, out):
    out.putVarInt32(9)
    out.putDouble(self.weight_)
    out.putVarInt32(17)
    out.putDouble(self.rawscore_)
    for i in xrange(len(self.firedrules_)):
      out.putVarInt32(27)
      self.firedrules_[i].OutputUnchecked(out)
      out.putVarInt32(28)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 9:
        self.set_weight(d.getDouble())
        continue
      if tt == 17:
        self.set_rawscore(d.getDouble())
        continue
      if tt == 27:
        self.add_firedrules().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_weight_: res+=prefix+("Weight: %s\n" % self.DebugFormat(self.weight_))
    if self.has_rawscore_: res+=prefix+("RawScore: %s\n" % self.DebugFormat(self.rawscore_))
    cnt=0
    for e in self.firedrules_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("FiredRules%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kWeight = 1
  kRawScore = 2
  kFiredRulesGroup = 3
  kFiredRulesRuleId = 4
  kFiredRulesDebugInfoGroup = 5
  kFiredRulesDebugInfoCondition = 6
  kFiredRulesDebugInfoWeight = 7

  _TEXT = (
   "ErrorCode",  #   0
   "Weight",  #   1
   "RawScore",  #   2
   "FiredRules",  #   3
   "RuleId",  #   4
   "DebugInfo",  #   5
   "Condition",  #   6
   "Weight",  #   7
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.DOUBLE,  #   1

   ProtocolBuffer.Encoder.DOUBLE,  #   2

   ProtocolBuffer.Encoder.STARTGROUP,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.STARTGROUP,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.DOUBLE,  #   7

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x21,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x75,
    0x6c,
    0x65,
    0x73,
    0x13,
    0x1a,
    0x06,
    0x57,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x01,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x52,
    0x61,
    0x77,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x02,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x46,
    0x69,
    0x72,
    0x65,
    0x64,
    0x52,
    0x75,
    0x6c,
    0x65,
    0x73,
    0x20,
    0x03,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x46,
    0x69,
    0x72,
    0x65,
    0x64,
    0x52,
    0x75,
    0x6c,
    0x65,
    0x73,
    0x2e,
    0x52,
    0x75,
    0x6c,
    0x65,
    0x49,
    0x64,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x46,
    0x69,
    0x72,
    0x65,
    0x64,
    0x52,
    0x75,
    0x6c,
    0x65,
    0x73,
    0x2e,
    0x44,
    0x65,
    0x62,
    0x75,
    0x67,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x05,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x46,
    0x69,
    0x72,
    0x65,
    0x64,
    0x52,
    0x75,
    0x6c,
    0x65,
    0x73,
    0x2e,
    0x44,
    0x65,
    0x62,
    0x75,
    0x67,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x43,
    0x6f,
    0x6e,
    0x64,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x46,
    0x69,
    0x72,
    0x65,
    0x64,
    0x52,
    0x75,
    0x6c,
    0x65,
    0x73,
    0x2e,
    0x44,
    0x65,
    0x62,
    0x75,
    0x67,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x57,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x07,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x02,
    0x60,
    0x04,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class SelectionFactors(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.factor_ = 0
    self.start_ = 0.0
    self.end_ = 0.0
    self.value_ = 0.0
    self.rules_ = None
    self.payload_ = ""
    self.has_factor_ = 0
    self.has_start_ = 0
    self.has_end_ = 0
    self.has_value_ = 0
    self.has_rules_ = 0
    self.has_payload_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def factor(self): return self.factor_

  def set_factor(self, x):
    self.has_factor_ = 1
    self.factor_ = x

  def clear_factor(self):
    self.has_factor_ = 0
    self.factor_ = 0

  def has_factor(self): return self.has_factor_

  def start(self): return self.start_

  def set_start(self, x):
    self.has_start_ = 1
    self.start_ = x

  def clear_start(self):
    self.has_start_ = 0
    self.start_ = 0.0

  def has_start(self): return self.has_start_

  def end(self): return self.end_

  def set_end(self, x):
    self.has_end_ = 1
    self.end_ = x

  def clear_end(self):
    self.has_end_ = 0
    self.end_ = 0.0

  def has_end(self): return self.has_end_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = 0.0

  def has_value(self): return self.has_value_

  def rules(self):
    if self.rules_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.rules_ is None: self.rules_ = SelectionRules()
      finally:
        self.lazy_init_lock_.release()
    return self.rules_

  def mutable_rules(self): self.has_rules_ = 1; return self.rules()

  def clear_rules(self):
    #Warning: this method does not acquire the lock.
    self.has_rules_ = 0;
    if self.rules_ is not None: self.rules_.Clear()

  def has_rules(self): return self.has_rules_

  def payload(self): return self.payload_

  def set_payload(self, x):
    self.has_payload_ = 1
    self.payload_ = x

  def clear_payload(self):
    self.has_payload_ = 0
    self.payload_ = ""

  def has_payload(self): return self.has_payload_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_factor()): self.set_factor(x.factor())
    if (x.has_start()): self.set_start(x.start())
    if (x.has_end()): self.set_end(x.end())
    if (x.has_value()): self.set_value(x.value())
    if (x.has_rules()): self.mutable_rules().MergeFrom(x.rules())
    if (x.has_payload()): self.set_payload(x.payload())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.SelectionFactors', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.SelectionFactors')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.SelectionFactors', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.SelectionFactors', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.SelectionFactors', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_factor_ != x.has_factor_: return 0
    if self.has_factor_ and self.factor_ != x.factor_: return 0
    if self.has_start_ != x.has_start_: return 0
    if self.has_start_ and self.start_ != x.start_: return 0
    if self.has_end_ != x.has_end_: return 0
    if self.has_end_ and self.end_ != x.end_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    if self.has_rules_ != x.has_rules_: return 0
    if self.has_rules_ and self.rules_ != x.rules_: return 0
    if self.has_payload_ != x.has_payload_: return 0
    if self.has_payload_ and self.payload_ != x.payload_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_factor_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: factor not set.')
    if (self.has_rules_ and not self.rules_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.factor_)
    if (self.has_start_): n += 9
    if (self.has_end_): n += 9
    if (self.has_value_): n += 9
    if (self.has_rules_): n += 1 + self.lengthString(self.rules_.ByteSize())
    if (self.has_payload_): n += 1 + self.lengthString(len(self.payload_))
    return n + 1

  def Clear(self):
    self.clear_factor()
    self.clear_start()
    self.clear_end()
    self.clear_value()
    self.clear_rules()
    self.clear_payload()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.factor_)
    if (self.has_value_):
      out.putVarInt32(17)
      out.putDouble(self.value_)
    if (self.has_start_):
      out.putVarInt32(25)
      out.putDouble(self.start_)
    if (self.has_end_):
      out.putVarInt32(33)
      out.putDouble(self.end_)
    if (self.has_rules_):
      out.putVarInt32(42)
      out.putVarInt32(self.rules_.ByteSize())
      self.rules_.OutputUnchecked(out)
    if (self.has_payload_):
      out.putVarInt32(50)
      out.putPrefixedString(self.payload_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_factor(d.getVarInt32())
        continue
      if tt == 17:
        self.set_value(d.getDouble())
        continue
      if tt == 25:
        self.set_start(d.getDouble())
        continue
      if tt == 33:
        self.set_end(d.getDouble())
        continue
      if tt == 42:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_rules().TryMerge(tmp)
        continue
      if tt == 50:
        self.set_payload(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_factor_: res+=prefix+("Factor: %s\n" % self.DebugFormatInt32(self.factor_))
    if self.has_start_: res+=prefix+("Start: %s\n" % self.DebugFormat(self.start_))
    if self.has_end_: res+=prefix+("End: %s\n" % self.DebugFormat(self.end_))
    if self.has_value_: res+=prefix+("Value: %s\n" % self.DebugFormat(self.value_))
    if self.has_rules_:
      res+=prefix+"Rules <\n"
      res+=self.rules_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_payload_: res+=prefix+("Payload: %s\n" % self.DebugFormatString(self.payload_))
    return res

  kFactor = 1
  kStart = 3
  kEnd = 4
  kValue = 2
  kRules = 5
  kPayload = 6

  _TEXT = (
   "ErrorCode",  #   0
   "Factor",  #   1
   "Value",  #   2
   "Start",  #   3
   "End",  #   4
   "Rules",  #   5
   "Payload",  #   6
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.DOUBLE,  #   2

   ProtocolBuffer.Encoder.DOUBLE,  #   3

   ProtocolBuffer.Encoder.DOUBLE,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x23,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x13,
    0x1a,
    0x06,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x53,
    0x74,
    0x61,
    0x72,
    0x74,
    0x20,
    0x03,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x03,
    0x45,
    0x6e,
    0x64,
    0x20,
    0x04,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x02,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x52,
    0x75,
    0x6c,
    0x65,
    0x73,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x21,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x75,
    0x6c,
    0x65,
    0x73,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x50,
    0x61,
    0x79,
    0x6c,
    0x6f,
    0x61,
    0x64,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ScorerOutput(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.indexselectionscore_ = 0.0
    self.factors_ = []
    self.scorerid_ = -1
    self.has_indexselectionscore_ = 0
    self.has_scorerid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def indexselectionscore(self): return self.indexselectionscore_

  def set_indexselectionscore(self, x):
    self.has_indexselectionscore_ = 1
    self.indexselectionscore_ = x

  def clear_indexselectionscore(self):
    self.has_indexselectionscore_ = 0
    self.indexselectionscore_ = 0.0

  def has_indexselectionscore(self): return self.has_indexselectionscore_

  def factors_size(self): return len(self.factors_)
  def factors_list(self): return self.factors_

  def factors(self, i):
    return self.factors_[i]

  def mutable_factors(self, i):
    return self.factors_[i]

  def add_factors(self):
    x = SelectionFactors()
    self.factors_.append(x)
    return x

  def clear_factors(self):
    self.factors_ = []
  def scorerid(self): return self.scorerid_

  def set_scorerid(self, x):
    self.has_scorerid_ = 1
    self.scorerid_ = x

  def clear_scorerid(self):
    self.has_scorerid_ = 0
    self.scorerid_ = -1

  def has_scorerid(self): return self.has_scorerid_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_indexselectionscore()): self.set_indexselectionscore(x.indexselectionscore())
    for i in xrange(x.factors_size()): self.add_factors().CopyFrom(x.factors(i))
    if (x.has_scorerid()): self.set_scorerid(x.scorerid())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.ScorerOutput', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.ScorerOutput')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.ScorerOutput', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.ScorerOutput', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.ScorerOutput', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_indexselectionscore_ != x.has_indexselectionscore_: return 0
    if self.has_indexselectionscore_ and self.indexselectionscore_ != x.indexselectionscore_: return 0
    if len(self.factors_) != len(x.factors_): return 0
    for e1, e2 in zip(self.factors_, x.factors_):
      if e1 != e2: return 0
    if self.has_scorerid_ != x.has_scorerid_: return 0
    if self.has_scorerid_ and self.scorerid_ != x.scorerid_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_indexselectionscore_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: indexselectionscore not set.')
    for i in xrange(len(self.factors_)):
      if (not self.factors_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.factors_)
    for i in xrange(len(self.factors_)): n += self.lengthString(self.factors_[i].ByteSize())
    if (self.has_scorerid_): n += 1 + self.lengthVarInt64(self.scorerid_)
    return n + 9

  def Clear(self):
    self.clear_indexselectionscore()
    self.clear_factors()
    self.clear_scorerid()

  def OutputUnchecked(self, out):
    out.putVarInt32(9)
    out.putDouble(self.indexselectionscore_)
    for i in xrange(len(self.factors_)):
      out.putVarInt32(18)
      out.putVarInt32(self.factors_[i].ByteSize())
      self.factors_[i].OutputUnchecked(out)
    if (self.has_scorerid_):
      out.putVarInt32(24)
      out.putVarInt32(self.scorerid_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 9:
        self.set_indexselectionscore(d.getDouble())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_factors().TryMerge(tmp)
        continue
      if tt == 24:
        self.set_scorerid(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_indexselectionscore_: res+=prefix+("IndexSelectionScore: %s\n" % self.DebugFormat(self.indexselectionscore_))
    cnt=0
    for e in self.factors_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Factors%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_scorerid_: res+=prefix+("ScorerId: %s\n" % self.DebugFormatInt32(self.scorerid_))
    return res

  kIndexSelectionScore = 1
  kFactors = 2
  kScorerId = 3

  _TEXT = (
   "ErrorCode",  #   0
   "IndexSelectionScore",  #   1
   "Factors",  #   2
   "ScorerId",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.DOUBLE,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1f,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x13,
    0x1a,
    0x13,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x01,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x23,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x49,
    0x64,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x02,
    0x2d,
    0x31,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x2d,
    0x31,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class SelectorOutput_SubIndexFactors(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.subindex_ = 0
    self.isselected_ = 0
    self.factors_ = []
    self.rank_ = -1
    self.has_subindex_ = 0
    self.has_isselected_ = 0
    self.has_rank_ = 0
    if contents is not None: self.MergeFromString(contents)

  def subindex(self): return self.subindex_

  def set_subindex(self, x):
    self.has_subindex_ = 1
    self.subindex_ = x

  def clear_subindex(self):
    self.has_subindex_ = 0
    self.subindex_ = 0

  def has_subindex(self): return self.has_subindex_

  def isselected(self): return self.isselected_

  def set_isselected(self, x):
    self.has_isselected_ = 1
    self.isselected_ = x

  def clear_isselected(self):
    self.has_isselected_ = 0
    self.isselected_ = 0

  def has_isselected(self): return self.has_isselected_

  def factors_size(self): return len(self.factors_)
  def factors_list(self): return self.factors_

  def factors(self, i):
    return self.factors_[i]

  def mutable_factors(self, i):
    return self.factors_[i]

  def add_factors(self):
    x = SelectionFactors()
    self.factors_.append(x)
    return x

  def clear_factors(self):
    self.factors_ = []
  def rank(self): return self.rank_

  def set_rank(self, x):
    self.has_rank_ = 1
    self.rank_ = x

  def clear_rank(self):
    self.has_rank_ = 0
    self.rank_ = -1

  def has_rank(self): return self.has_rank_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_subindex()): self.set_subindex(x.subindex())
    if (x.has_isselected()): self.set_isselected(x.isselected())
    for i in xrange(x.factors_size()): self.add_factors().CopyFrom(x.factors(i))
    if (x.has_rank()): self.set_rank(x.rank())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.SelectorOutput', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.SelectorOutput')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.SelectorOutput', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.SelectorOutput', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.SelectorOutput', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_subindex_ != x.has_subindex_: return 0
    if self.has_subindex_ and self.subindex_ != x.subindex_: return 0
    if self.has_isselected_ != x.has_isselected_: return 0
    if self.has_isselected_ and self.isselected_ != x.isselected_: return 0
    if len(self.factors_) != len(x.factors_): return 0
    for e1, e2 in zip(self.factors_, x.factors_):
      if e1 != e2: return 0
    if self.has_rank_ != x.has_rank_: return 0
    if self.has_rank_ and self.rank_ != x.rank_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_subindex_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: subindex not set.')
    if (not self.has_isselected_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: isselected not set.')
    for i in xrange(len(self.factors_)):
      if (not self.factors_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.subindex_)
    n += 1 * len(self.factors_)
    for i in xrange(len(self.factors_)): n += self.lengthString(self.factors_[i].ByteSize())
    if (self.has_rank_): n += 1 + self.lengthVarInt64(self.rank_)
    return n + 3

  def Clear(self):
    self.clear_subindex()
    self.clear_isselected()
    self.clear_factors()
    self.clear_rank()

  def OutputUnchecked(self, out):
    out.putVarInt32(56)
    out.putVarInt32(self.subindex_)
    out.putVarInt32(64)
    out.putBoolean(self.isselected_)
    for i in xrange(len(self.factors_)):
      out.putVarInt32(74)
      out.putVarInt32(self.factors_[i].ByteSize())
      self.factors_[i].OutputUnchecked(out)
    if (self.has_rank_):
      out.putVarInt32(88)
      out.putVarInt64(self.rank_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 52: break
      if tt == 56:
        self.set_subindex(d.getVarInt32())
        continue
      if tt == 64:
        self.set_isselected(d.getBoolean())
        continue
      if tt == 74:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_factors().TryMerge(tmp)
        continue
      if tt == 88:
        self.set_rank(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_subindex_: res+=prefix+("SubIndex: %s\n" % self.DebugFormatInt32(self.subindex_))
    if self.has_isselected_: res+=prefix+("IsSelected: %s\n" % self.DebugFormatBool(self.isselected_))
    cnt=0
    for e in self.factors_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Factors%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_rank_: res+=prefix+("Rank: %s\n" % self.DebugFormatInt64(self.rank_))
    return res

class SelectorOutput(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.queue_ = 0
    self.isselected_ = 0
    self.factors_ = []
    self.scoreroffset_ = -1
    self.subindexfactors_ = []
    self.rank_ = -1
    self.has_queue_ = 0
    self.has_isselected_ = 0
    self.has_scoreroffset_ = 0
    self.has_rank_ = 0
    if contents is not None: self.MergeFromString(contents)

  def queue(self): return self.queue_

  def set_queue(self, x):
    self.has_queue_ = 1
    self.queue_ = x

  def clear_queue(self):
    self.has_queue_ = 0
    self.queue_ = 0

  def has_queue(self): return self.has_queue_

  def isselected(self): return self.isselected_

  def set_isselected(self, x):
    self.has_isselected_ = 1
    self.isselected_ = x

  def clear_isselected(self):
    self.has_isselected_ = 0
    self.isselected_ = 0

  def has_isselected(self): return self.has_isselected_

  def factors_size(self): return len(self.factors_)
  def factors_list(self): return self.factors_

  def factors(self, i):
    return self.factors_[i]

  def mutable_factors(self, i):
    return self.factors_[i]

  def add_factors(self):
    x = SelectionFactors()
    self.factors_.append(x)
    return x

  def clear_factors(self):
    self.factors_ = []
  def scoreroffset(self): return self.scoreroffset_

  def set_scoreroffset(self, x):
    self.has_scoreroffset_ = 1
    self.scoreroffset_ = x

  def clear_scoreroffset(self):
    self.has_scoreroffset_ = 0
    self.scoreroffset_ = -1

  def has_scoreroffset(self): return self.has_scoreroffset_

  def subindexfactors_size(self): return len(self.subindexfactors_)
  def subindexfactors_list(self): return self.subindexfactors_

  def subindexfactors(self, i):
    return self.subindexfactors_[i]

  def mutable_subindexfactors(self, i):
    return self.subindexfactors_[i]

  def add_subindexfactors(self):
    x = SelectorOutput_SubIndexFactors()
    self.subindexfactors_.append(x)
    return x

  def clear_subindexfactors(self):
    self.subindexfactors_ = []
  def rank(self): return self.rank_

  def set_rank(self, x):
    self.has_rank_ = 1
    self.rank_ = x

  def clear_rank(self):
    self.has_rank_ = 0
    self.rank_ = -1

  def has_rank(self): return self.has_rank_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_queue()): self.set_queue(x.queue())
    if (x.has_isselected()): self.set_isselected(x.isselected())
    for i in xrange(x.factors_size()): self.add_factors().CopyFrom(x.factors(i))
    if (x.has_scoreroffset()): self.set_scoreroffset(x.scoreroffset())
    for i in xrange(x.subindexfactors_size()): self.add_subindexfactors().CopyFrom(x.subindexfactors(i))
    if (x.has_rank()): self.set_rank(x.rank())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.SelectorOutput', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.SelectorOutput')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.SelectorOutput', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.SelectorOutput', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.SelectorOutput', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_queue_ != x.has_queue_: return 0
    if self.has_queue_ and self.queue_ != x.queue_: return 0
    if self.has_isselected_ != x.has_isselected_: return 0
    if self.has_isselected_ and self.isselected_ != x.isselected_: return 0
    if len(self.factors_) != len(x.factors_): return 0
    for e1, e2 in zip(self.factors_, x.factors_):
      if e1 != e2: return 0
    if self.has_scoreroffset_ != x.has_scoreroffset_: return 0
    if self.has_scoreroffset_ and self.scoreroffset_ != x.scoreroffset_: return 0
    if len(self.subindexfactors_) != len(x.subindexfactors_): return 0
    for e1, e2 in zip(self.subindexfactors_, x.subindexfactors_):
      if e1 != e2: return 0
    if self.has_rank_ != x.has_rank_: return 0
    if self.has_rank_ and self.rank_ != x.rank_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_queue_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: queue not set.')
    if (not self.has_isselected_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: isselected not set.')
    for i in xrange(len(self.factors_)):
      if (not self.factors_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.subindexfactors_)):
      if (not self.subindexfactors_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.queue_)
    n += 1 * len(self.factors_)
    for i in xrange(len(self.factors_)): n += self.lengthString(self.factors_[i].ByteSize())
    if (self.has_scoreroffset_): n += 1 + self.lengthVarInt64(self.scoreroffset_)
    n += 2 * len(self.subindexfactors_)
    for i in xrange(len(self.subindexfactors_)): n += self.subindexfactors_[i].ByteSize()
    if (self.has_rank_): n += 1 + self.lengthVarInt64(self.rank_)
    return n + 3

  def Clear(self):
    self.clear_queue()
    self.clear_isselected()
    self.clear_factors()
    self.clear_scoreroffset()
    self.clear_subindexfactors()
    self.clear_rank()

  def OutputUnchecked(self, out):
    out.putVarInt32(16)
    out.putVarInt32(self.queue_)
    out.putVarInt32(24)
    out.putBoolean(self.isselected_)
    for i in xrange(len(self.factors_)):
      out.putVarInt32(34)
      out.putVarInt32(self.factors_[i].ByteSize())
      self.factors_[i].OutputUnchecked(out)
    if (self.has_scoreroffset_):
      out.putVarInt32(40)
      out.putVarInt32(self.scoreroffset_)
    for i in xrange(len(self.subindexfactors_)):
      out.putVarInt32(51)
      self.subindexfactors_[i].OutputUnchecked(out)
      out.putVarInt32(52)
    if (self.has_rank_):
      out.putVarInt32(80)
      out.putVarInt64(self.rank_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 16:
        self.set_queue(d.getVarInt32())
        continue
      if tt == 24:
        self.set_isselected(d.getBoolean())
        continue
      if tt == 34:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_factors().TryMerge(tmp)
        continue
      if tt == 40:
        self.set_scoreroffset(d.getVarInt32())
        continue
      if tt == 51:
        self.add_subindexfactors().TryMerge(d)
        continue
      if tt == 80:
        self.set_rank(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_queue_: res+=prefix+("Queue: %s\n" % self.DebugFormatInt32(self.queue_))
    if self.has_isselected_: res+=prefix+("IsSelected: %s\n" % self.DebugFormatBool(self.isselected_))
    cnt=0
    for e in self.factors_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Factors%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_scoreroffset_: res+=prefix+("ScorerOffset: %s\n" % self.DebugFormatInt32(self.scoreroffset_))
    cnt=0
    for e in self.subindexfactors_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("SubIndexFactors%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_rank_: res+=prefix+("Rank: %s\n" % self.DebugFormatInt64(self.rank_))
    return res

  kQueue = 2
  kIsSelected = 3
  kFactors = 4
  kScorerOffset = 5
  kSubIndexFactorsGroup = 6
  kSubIndexFactorsSubIndex = 7
  kSubIndexFactorsIsSelected = 8
  kSubIndexFactorsFactors = 9
  kSubIndexFactorsRank = 11
  kRank = 10

  _TEXT = (
   "ErrorCode",  #   0
   None,  #   1
   "Queue",  #   2
   "IsSelected",  #   3
   "Factors",  #   4
   "ScorerOffset",  #   5
   "SubIndexFactors",  #   6
   "SubIndex",  #   7
   "IsSelected",  #   8
   "Factors",  #   9
   "Rank",  #  10
   "Rank",  #  11
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.MAX_TYPE,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.STARTGROUP,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x21,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x13,
    0x1a,
    0x05,
    0x51,
    0x75,
    0x65,
    0x75,
    0x65,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x49,
    0x73,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x65,
    0x64,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x23,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x4f,
    0x66,
    0x66,
    0x73,
    0x65,
    0x74,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x02,
    0x2d,
    0x31,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x2d,
    0x31,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x53,
    0x75,
    0x62,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x20,
    0x06,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x53,
    0x75,
    0x62,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x2e,
    0x53,
    0x75,
    0x62,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x53,
    0x75,
    0x62,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x2e,
    0x49,
    0x73,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x65,
    0x64,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x02,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x53,
    0x75,
    0x62,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x2e,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x23,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x53,
    0x75,
    0x62,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x2e,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x42,
    0x02,
    0x2d,
    0x31,
    0x60,
    0x04,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x2d,
    0x31,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x42,
    0x02,
    0x2d,
    0x31,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x2d,
    0x31,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class IndexSelectionOutput(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.scoreroutput_ = []
    self.selectoroutput_ = []
    self.debuginfo_ = []
    if contents is not None: self.MergeFromString(contents)

  def scoreroutput_size(self): return len(self.scoreroutput_)
  def scoreroutput_list(self): return self.scoreroutput_

  def scoreroutput(self, i):
    return self.scoreroutput_[i]

  def mutable_scoreroutput(self, i):
    return self.scoreroutput_[i]

  def add_scoreroutput(self):
    x = ScorerOutput()
    self.scoreroutput_.append(x)
    return x

  def clear_scoreroutput(self):
    self.scoreroutput_ = []
  def selectoroutput_size(self): return len(self.selectoroutput_)
  def selectoroutput_list(self): return self.selectoroutput_

  def selectoroutput(self, i):
    return self.selectoroutput_[i]

  def mutable_selectoroutput(self, i):
    return self.selectoroutput_[i]

  def add_selectoroutput(self):
    x = SelectorOutput()
    self.selectoroutput_.append(x)
    return x

  def clear_selectoroutput(self):
    self.selectoroutput_ = []
  def debuginfo_size(self): return len(self.debuginfo_)
  def debuginfo_list(self): return self.debuginfo_

  def debuginfo(self, i):
    return self.debuginfo_[i]

  def set_debuginfo(self, i, x):
    self.debuginfo_[i] = x

  def add_debuginfo(self, x):
    self.debuginfo_.append(x)

  def clear_debuginfo(self):
    self.debuginfo_ = []


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.scoreroutput_size()): self.add_scoreroutput().CopyFrom(x.scoreroutput(i))
    for i in xrange(x.selectoroutput_size()): self.add_selectoroutput().CopyFrom(x.selectoroutput(i))
    for i in xrange(x.debuginfo_size()): self.add_debuginfo(x.debuginfo(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionOutput', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionOutput')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionOutput', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionOutput', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionOutput', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.scoreroutput_) != len(x.scoreroutput_): return 0
    for e1, e2 in zip(self.scoreroutput_, x.scoreroutput_):
      if e1 != e2: return 0
    if len(self.selectoroutput_) != len(x.selectoroutput_): return 0
    for e1, e2 in zip(self.selectoroutput_, x.selectoroutput_):
      if e1 != e2: return 0
    if len(self.debuginfo_) != len(x.debuginfo_): return 0
    for e1, e2 in zip(self.debuginfo_, x.debuginfo_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.scoreroutput_)):
      if (not self.scoreroutput_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.selectoroutput_)):
      if (not self.selectoroutput_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.scoreroutput_)
    for i in xrange(len(self.scoreroutput_)): n += self.lengthString(self.scoreroutput_[i].ByteSize())
    n += 1 * len(self.selectoroutput_)
    for i in xrange(len(self.selectoroutput_)): n += self.lengthString(self.selectoroutput_[i].ByteSize())
    n += 1 * len(self.debuginfo_)
    for i in xrange(len(self.debuginfo_)): n += self.lengthString(len(self.debuginfo_[i]))
    return n + 0

  def Clear(self):
    self.clear_scoreroutput()
    self.clear_selectoroutput()
    self.clear_debuginfo()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.scoreroutput_)):
      out.putVarInt32(10)
      out.putVarInt32(self.scoreroutput_[i].ByteSize())
      self.scoreroutput_[i].OutputUnchecked(out)
    for i in xrange(len(self.selectoroutput_)):
      out.putVarInt32(18)
      out.putVarInt32(self.selectoroutput_[i].ByteSize())
      self.selectoroutput_[i].OutputUnchecked(out)
    for i in xrange(len(self.debuginfo_)):
      out.putVarInt32(26)
      out.putPrefixedString(self.debuginfo_[i])

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_scoreroutput().TryMerge(tmp)
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_selectoroutput().TryMerge(tmp)
        continue
      if tt == 26:
        self.add_debuginfo(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.scoreroutput_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("ScorerOutput%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.selectoroutput_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("SelectorOutput%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.debuginfo_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DebugInfo%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    return res

  kScorerOutput = 1
  kSelectorOutput = 2
  kDebugInfo = 3

  _TEXT = (
   "ErrorCode",  #   0
   "ScorerOutput",  #   1
   "SelectorOutput",  #   2
   "DebugInfo",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x13,
    0x1a,
    0x0c,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x1f,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x21,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x65,
    0x62,
    0x75,
    0x67,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class HistoricalFactors_IndexSpecificFactors_DEPRECATED(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.index_ = 0
    self.isselected_ = 0
    self.factors_ = []
    self.has_index_ = 0
    self.has_isselected_ = 0
    if contents is not None: self.MergeFromString(contents)

  def index(self): return self.index_

  def set_index(self, x):
    self.has_index_ = 1
    self.index_ = x

  def clear_index(self):
    self.has_index_ = 0
    self.index_ = 0

  def has_index(self): return self.has_index_

  def isselected(self): return self.isselected_

  def set_isselected(self, x):
    self.has_isselected_ = 1
    self.isselected_ = x

  def clear_isselected(self):
    self.has_isselected_ = 0
    self.isselected_ = 0

  def has_isselected(self): return self.has_isselected_

  def factors_size(self): return len(self.factors_)
  def factors_list(self): return self.factors_

  def factors(self, i):
    return self.factors_[i]

  def mutable_factors(self, i):
    return self.factors_[i]

  def add_factors(self):
    x = SelectionFactors()
    self.factors_.append(x)
    return x

  def clear_factors(self):
    self.factors_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_index()): self.set_index(x.index())
    if (x.has_isselected()): self.set_isselected(x.isselected())
    for i in xrange(x.factors_size()): self.add_factors().CopyFrom(x.factors(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.HistoricalFactors', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.HistoricalFactors')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.HistoricalFactors', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.HistoricalFactors', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.HistoricalFactors', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_index_ != x.has_index_: return 0
    if self.has_index_ and self.index_ != x.index_: return 0
    if self.has_isselected_ != x.has_isselected_: return 0
    if self.has_isselected_ and self.isselected_ != x.isselected_: return 0
    if len(self.factors_) != len(x.factors_): return 0
    for e1, e2 in zip(self.factors_, x.factors_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_index_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: index not set.')
    if (not self.has_isselected_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: isselected not set.')
    for i in xrange(len(self.factors_)):
      if (not self.factors_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.index_)
    n += 1 * len(self.factors_)
    for i in xrange(len(self.factors_)): n += self.lengthString(self.factors_[i].ByteSize())
    return n + 3

  def Clear(self):
    self.clear_index()
    self.clear_isselected()
    self.clear_factors()

  def OutputUnchecked(self, out):
    out.putVarInt32(32)
    out.putVarInt32(self.index_)
    out.putVarInt32(40)
    out.putBoolean(self.isselected_)
    for i in xrange(len(self.factors_)):
      out.putVarInt32(50)
      out.putVarInt32(self.factors_[i].ByteSize())
      self.factors_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 28: break
      if tt == 32:
        self.set_index(d.getVarInt32())
        continue
      if tt == 40:
        self.set_isselected(d.getBoolean())
        continue
      if tt == 50:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_factors().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_index_: res+=prefix+("Index: %s\n" % self.DebugFormatInt32(self.index_))
    if self.has_isselected_: res+=prefix+("IsSelected: %s\n" % self.DebugFormatBool(self.isselected_))
    cnt=0
    for e in self.factors_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Factors%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

class HistoricalFactors(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.indexselectionscore_deprecated_ = 0.0
    self.globalfactors_deprecated_ = []
    self.indexspecificfactors_deprecated_ = []
    self.selectionoutput_ = None
    self.has_indexselectionscore_deprecated_ = 0
    self.has_selectionoutput_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def indexselectionscore_deprecated(self): return self.indexselectionscore_deprecated_

  def set_indexselectionscore_deprecated(self, x):
    self.has_indexselectionscore_deprecated_ = 1
    self.indexselectionscore_deprecated_ = x

  def clear_indexselectionscore_deprecated(self):
    self.has_indexselectionscore_deprecated_ = 0
    self.indexselectionscore_deprecated_ = 0.0

  def has_indexselectionscore_deprecated(self): return self.has_indexselectionscore_deprecated_

  def globalfactors_deprecated_size(self): return len(self.globalfactors_deprecated_)
  def globalfactors_deprecated_list(self): return self.globalfactors_deprecated_

  def globalfactors_deprecated(self, i):
    return self.globalfactors_deprecated_[i]

  def mutable_globalfactors_deprecated(self, i):
    return self.globalfactors_deprecated_[i]

  def add_globalfactors_deprecated(self):
    x = SelectionFactors()
    self.globalfactors_deprecated_.append(x)
    return x

  def clear_globalfactors_deprecated(self):
    self.globalfactors_deprecated_ = []
  def indexspecificfactors_deprecated_size(self): return len(self.indexspecificfactors_deprecated_)
  def indexspecificfactors_deprecated_list(self): return self.indexspecificfactors_deprecated_

  def indexspecificfactors_deprecated(self, i):
    return self.indexspecificfactors_deprecated_[i]

  def mutable_indexspecificfactors_deprecated(self, i):
    return self.indexspecificfactors_deprecated_[i]

  def add_indexspecificfactors_deprecated(self):
    x = HistoricalFactors_IndexSpecificFactors_DEPRECATED()
    self.indexspecificfactors_deprecated_.append(x)
    return x

  def clear_indexspecificfactors_deprecated(self):
    self.indexspecificfactors_deprecated_ = []
  def selectionoutput(self):
    if self.selectionoutput_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.selectionoutput_ is None: self.selectionoutput_ = IndexSelectionOutput()
      finally:
        self.lazy_init_lock_.release()
    return self.selectionoutput_

  def mutable_selectionoutput(self): self.has_selectionoutput_ = 1; return self.selectionoutput()

  def clear_selectionoutput(self):
    #Warning: this method does not acquire the lock.
    self.has_selectionoutput_ = 0;
    if self.selectionoutput_ is not None: self.selectionoutput_.Clear()

  def has_selectionoutput(self): return self.has_selectionoutput_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_indexselectionscore_deprecated()): self.set_indexselectionscore_deprecated(x.indexselectionscore_deprecated())
    for i in xrange(x.globalfactors_deprecated_size()): self.add_globalfactors_deprecated().CopyFrom(x.globalfactors_deprecated(i))
    for i in xrange(x.indexspecificfactors_deprecated_size()): self.add_indexspecificfactors_deprecated().CopyFrom(x.indexspecificfactors_deprecated(i))
    if (x.has_selectionoutput()): self.mutable_selectionoutput().MergeFrom(x.selectionoutput())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.HistoricalFactors', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.HistoricalFactors')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.HistoricalFactors', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.HistoricalFactors', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.HistoricalFactors', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_indexselectionscore_deprecated_ != x.has_indexselectionscore_deprecated_: return 0
    if self.has_indexselectionscore_deprecated_ and self.indexselectionscore_deprecated_ != x.indexselectionscore_deprecated_: return 0
    if len(self.globalfactors_deprecated_) != len(x.globalfactors_deprecated_): return 0
    for e1, e2 in zip(self.globalfactors_deprecated_, x.globalfactors_deprecated_):
      if e1 != e2: return 0
    if len(self.indexspecificfactors_deprecated_) != len(x.indexspecificfactors_deprecated_): return 0
    for e1, e2 in zip(self.indexspecificfactors_deprecated_, x.indexspecificfactors_deprecated_):
      if e1 != e2: return 0
    if self.has_selectionoutput_ != x.has_selectionoutput_: return 0
    if self.has_selectionoutput_ and self.selectionoutput_ != x.selectionoutput_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.globalfactors_deprecated_)):
      if (not self.globalfactors_deprecated_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.indexspecificfactors_deprecated_)):
      if (not self.indexspecificfactors_deprecated_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_selectionoutput_ and not self.selectionoutput_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_indexselectionscore_deprecated_): n += 9
    n += 1 * len(self.globalfactors_deprecated_)
    for i in xrange(len(self.globalfactors_deprecated_)): n += self.lengthString(self.globalfactors_deprecated_[i].ByteSize())
    n += 2 * len(self.indexspecificfactors_deprecated_)
    for i in xrange(len(self.indexspecificfactors_deprecated_)): n += self.indexspecificfactors_deprecated_[i].ByteSize()
    if (self.has_selectionoutput_): n += 1 + self.lengthString(self.selectionoutput_.ByteSize())
    return n + 0

  def Clear(self):
    self.clear_indexselectionscore_deprecated()
    self.clear_globalfactors_deprecated()
    self.clear_indexspecificfactors_deprecated()
    self.clear_selectionoutput()

  def OutputUnchecked(self, out):
    if (self.has_indexselectionscore_deprecated_):
      out.putVarInt32(9)
      out.putDouble(self.indexselectionscore_deprecated_)
    for i in xrange(len(self.globalfactors_deprecated_)):
      out.putVarInt32(18)
      out.putVarInt32(self.globalfactors_deprecated_[i].ByteSize())
      self.globalfactors_deprecated_[i].OutputUnchecked(out)
    for i in xrange(len(self.indexspecificfactors_deprecated_)):
      out.putVarInt32(27)
      self.indexspecificfactors_deprecated_[i].OutputUnchecked(out)
      out.putVarInt32(28)
    if (self.has_selectionoutput_):
      out.putVarInt32(58)
      out.putVarInt32(self.selectionoutput_.ByteSize())
      self.selectionoutput_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 9:
        self.set_indexselectionscore_deprecated(d.getDouble())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_globalfactors_deprecated().TryMerge(tmp)
        continue
      if tt == 27:
        self.add_indexspecificfactors_deprecated().TryMerge(d)
        continue
      if tt == 58:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_selectionoutput().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_indexselectionscore_deprecated_: res+=prefix+("IndexSelectionScore_DEPRECATED: %s\n" % self.DebugFormat(self.indexselectionscore_deprecated_))
    cnt=0
    for e in self.globalfactors_deprecated_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("GlobalFactors_DEPRECATED%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.indexspecificfactors_deprecated_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("IndexSpecificFactors_DEPRECATED%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_selectionoutput_:
      res+=prefix+"SelectionOutput <\n"
      res+=self.selectionoutput_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

  kIndexSelectionScore_DEPRECATED = 1
  kGlobalFactors_DEPRECATED = 2
  kIndexSpecificFactors_DEPRECATEDGroup = 3
  kIndexSpecificFactors_DEPRECATEDIndex = 4
  kIndexSpecificFactors_DEPRECATEDIsSelected = 5
  kIndexSpecificFactors_DEPRECATEDFactors = 6
  kSelectionOutput = 7

  _TEXT = (
   "ErrorCode",  #   0
   "IndexSelectionScore_DEPRECATED",  #   1
   "GlobalFactors_DEPRECATED",  #   2
   "IndexSpecificFactors_DEPRECATED",  #   3
   "Index",  #   4
   "IsSelected",  #   5
   "Factors",  #   6
   "SelectionOutput",  #   7
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.DOUBLE,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STARTGROUP,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.STRING,  #   7

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x24,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x48,
    0x69,
    0x73,
    0x74,
    0x6f,
    0x72,
    0x69,
    0x63,
    0x61,
    0x6c,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x13,
    0x1a,
    0x1e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x01,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x47,
    0x6c,
    0x6f,
    0x62,
    0x61,
    0x6c,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x23,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x14,
    0x13,
    0x1a,
    0x1f,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x03,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x25,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x2a,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x2e,
    0x49,
    0x73,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x65,
    0x64,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x27,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x2e,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x23,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x46,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x20,
    0x07,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class IndexSelectionAttachment_Info(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.index_ = ""
    self.rank_ = 0.0
    self.score_ = 0.0
    self.scorerid_ = 0
    self.raw_global_score_ = 0.0
    self.raw_index_score_ = 0.0
    self.indexid_ = 0
    self.has_index_ = 0
    self.has_rank_ = 0
    self.has_score_ = 0
    self.has_scorerid_ = 0
    self.has_raw_global_score_ = 0
    self.has_raw_index_score_ = 0
    self.has_indexid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def index(self): return self.index_

  def set_index(self, x):
    self.has_index_ = 1
    self.index_ = x

  def clear_index(self):
    self.has_index_ = 0
    self.index_ = ""

  def has_index(self): return self.has_index_

  def rank(self): return self.rank_

  def set_rank(self, x):
    self.has_rank_ = 1
    self.rank_ = x

  def clear_rank(self):
    self.has_rank_ = 0
    self.rank_ = 0.0

  def has_rank(self): return self.has_rank_

  def score(self): return self.score_

  def set_score(self, x):
    self.has_score_ = 1
    self.score_ = x

  def clear_score(self):
    self.has_score_ = 0
    self.score_ = 0.0

  def has_score(self): return self.has_score_

  def scorerid(self): return self.scorerid_

  def set_scorerid(self, x):
    self.has_scorerid_ = 1
    self.scorerid_ = x

  def clear_scorerid(self):
    self.has_scorerid_ = 0
    self.scorerid_ = 0

  def has_scorerid(self): return self.has_scorerid_

  def raw_global_score(self): return self.raw_global_score_

  def set_raw_global_score(self, x):
    self.has_raw_global_score_ = 1
    self.raw_global_score_ = x

  def clear_raw_global_score(self):
    self.has_raw_global_score_ = 0
    self.raw_global_score_ = 0.0

  def has_raw_global_score(self): return self.has_raw_global_score_

  def raw_index_score(self): return self.raw_index_score_

  def set_raw_index_score(self, x):
    self.has_raw_index_score_ = 1
    self.raw_index_score_ = x

  def clear_raw_index_score(self):
    self.has_raw_index_score_ = 0
    self.raw_index_score_ = 0.0

  def has_raw_index_score(self): return self.has_raw_index_score_

  def indexid(self): return self.indexid_

  def set_indexid(self, x):
    self.has_indexid_ = 1
    self.indexid_ = x

  def clear_indexid(self):
    self.has_indexid_ = 0
    self.indexid_ = 0

  def has_indexid(self): return self.has_indexid_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_index()): self.set_index(x.index())
    if (x.has_rank()): self.set_rank(x.rank())
    if (x.has_score()): self.set_score(x.score())
    if (x.has_scorerid()): self.set_scorerid(x.scorerid())
    if (x.has_raw_global_score()): self.set_raw_global_score(x.raw_global_score())
    if (x.has_raw_index_score()): self.set_raw_index_score(x.raw_index_score())
    if (x.has_indexid()): self.set_indexid(x.indexid())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionAttachment', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionAttachment')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionAttachment', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionAttachment', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionAttachment', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_index_ != x.has_index_: return 0
    if self.has_index_ and self.index_ != x.index_: return 0
    if self.has_rank_ != x.has_rank_: return 0
    if self.has_rank_ and self.rank_ != x.rank_: return 0
    if self.has_score_ != x.has_score_: return 0
    if self.has_score_ and self.score_ != x.score_: return 0
    if self.has_scorerid_ != x.has_scorerid_: return 0
    if self.has_scorerid_ and self.scorerid_ != x.scorerid_: return 0
    if self.has_raw_global_score_ != x.has_raw_global_score_: return 0
    if self.has_raw_global_score_ and self.raw_global_score_ != x.raw_global_score_: return 0
    if self.has_raw_index_score_ != x.has_raw_index_score_: return 0
    if self.has_raw_index_score_ and self.raw_index_score_ != x.raw_index_score_: return 0
    if self.has_indexid_ != x.has_indexid_: return 0
    if self.has_indexid_ and self.indexid_ != x.indexid_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_index_): n += 1 + self.lengthString(len(self.index_))
    if (self.has_rank_): n += 9
    if (self.has_score_): n += 9
    if (self.has_scorerid_): n += 1 + self.lengthVarInt64(self.scorerid_)
    if (self.has_raw_global_score_): n += 9
    if (self.has_raw_index_score_): n += 9
    if (self.has_indexid_): n += 1 + self.lengthVarInt64(self.indexid_)
    return n + 0

  def Clear(self):
    self.clear_index()
    self.clear_rank()
    self.clear_score()
    self.clear_scorerid()
    self.clear_raw_global_score()
    self.clear_raw_index_score()
    self.clear_indexid()

  def OutputUnchecked(self, out):
    if (self.has_index_):
      out.putVarInt32(18)
      out.putPrefixedString(self.index_)
    if (self.has_rank_):
      out.putVarInt32(25)
      out.putDouble(self.rank_)
    if (self.has_score_):
      out.putVarInt32(33)
      out.putDouble(self.score_)
    if (self.has_scorerid_):
      out.putVarInt32(40)
      out.putVarInt32(self.scorerid_)
    if (self.has_raw_global_score_):
      out.putVarInt32(49)
      out.putDouble(self.raw_global_score_)
    if (self.has_raw_index_score_):
      out.putVarInt32(57)
      out.putDouble(self.raw_index_score_)
    if (self.has_indexid_):
      out.putVarInt32(64)
      out.putVarInt32(self.indexid_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        self.set_index(d.getPrefixedString())
        continue
      if tt == 25:
        self.set_rank(d.getDouble())
        continue
      if tt == 33:
        self.set_score(d.getDouble())
        continue
      if tt == 40:
        self.set_scorerid(d.getVarInt32())
        continue
      if tt == 49:
        self.set_raw_global_score(d.getDouble())
        continue
      if tt == 57:
        self.set_raw_index_score(d.getDouble())
        continue
      if tt == 64:
        self.set_indexid(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_index_: res+=prefix+("index: %s\n" % self.DebugFormatString(self.index_))
    if self.has_rank_: res+=prefix+("rank: %s\n" % self.DebugFormat(self.rank_))
    if self.has_score_: res+=prefix+("score: %s\n" % self.DebugFormat(self.score_))
    if self.has_scorerid_: res+=prefix+("scorerid: %s\n" % self.DebugFormatInt32(self.scorerid_))
    if self.has_raw_global_score_: res+=prefix+("raw_global_score: %s\n" % self.DebugFormat(self.raw_global_score_))
    if self.has_raw_index_score_: res+=prefix+("raw_index_score: %s\n" % self.DebugFormat(self.raw_index_score_))
    if self.has_indexid_: res+=prefix+("indexId: %s\n" % self.DebugFormatInt32(self.indexid_))
    return res

class IndexSelectionAttachment(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 4534201 

  _TypeId_NAMES = {
    4534201: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.info_ = []
    if contents is not None: self.MergeFromString(contents)

  def info_size(self): return len(self.info_)
  def info_list(self): return self.info_

  def info(self, i):
    return self.info_[i]

  def mutable_info(self, i):
    return self.info_[i]

  def add_info(self):
    x = IndexSelectionAttachment_Info()
    self.info_.append(x)
    return x

  def clear_info(self):
    self.info_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.info_size()): self.add_info().CopyFrom(x.info(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'repository_updater.IndexSelectionAttachment', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'repository_updater.IndexSelectionAttachment')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'repository_updater.IndexSelectionAttachment', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'repository_updater.IndexSelectionAttachment', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'repository_updater.IndexSelectionAttachment', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.info_) != len(x.info_): return 0
    for e1, e2 in zip(self.info_, x.info_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.info_)):
      if (not self.info_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.info_)
    for i in xrange(len(self.info_)): n += self.info_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_info()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.info_)):
      out.putVarInt32(11)
      self.info_[i].OutputUnchecked(out)
      out.putVarInt32(12)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_info().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.info_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Info%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kInfoGroup = 1
  kInfoindex = 2
  kInforank = 3
  kInfoscore = 4
  kInfoscorerid = 5
  kInforaw_global_score = 6
  kInforaw_index_score = 7
  kInfoindexId = 8

  _TEXT = (
   "ErrorCode",  #   0
   "Info",  #   1
   "index",  #   2
   "rank",  #   3
   "score",  #   4
   "scorerid",  #   5
   "raw_global_score",  #   6
   "raw_index_score",  #   7
   "indexId",  #   8
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.DOUBLE,  #   3

   ProtocolBuffer.Encoder.DOUBLE,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.DOUBLE,  #   6

   ProtocolBuffer.Encoder.DOUBLE,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x27,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x2f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x73,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x2b,
    0x72,
    0x65,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x79,
    0x5f,
    0x75,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x41,
    0x74,
    0x74,
    0x61,
    0x63,
    0x68,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x03,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x04,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x69,
    0x64,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x72,
    0x61,
    0x77,
    0x5f,
    0x67,
    0x6c,
    0x6f,
    0x62,
    0x61,
    0x6c,
    0x5f,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x06,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x72,
    0x61,
    0x77,
    0x5f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x5f,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x07,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x49,
    0x64,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xb9,
    0xdf,
    0x94,
    0x02,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['AttributeFraction','IndexSelectionArgs','IndexSelectionArgs_LanguageConstraints_DEPRECATED','IndexSelectionArgs_RegionalSpec','IndexSelectionArgs_LargeDocumentException','IndexSelectionArgs_LowPageRankException','IndexSelectionArgs_ContentToExpire','IndexSelectionArgs_FiletypeConstraints','IndexSelectionArgs_TracerConstraints','IndexSelectionArgs_SelectedScoreDistribitionSpec','IndexSelectionArgs_SubIndexComponent','IndexSelectionArgs_MinScoreForDocs','IndexSelectionArgs_DiscoveryMinQuota','IndexSelectionArgs_DefaultLanguageGuarantees','IndexSelectionArgs_DefaultCountryGuarantees','IndexSelectionArgs_DomainMinCount','IndexSelectionArgs_ExcludedIndices','IndexSelectionArgs_ReplicateShardsException','IndexSelectionSiteStats','IndexSelectionSiteStats_VersionedPornScore','IndexSelectionSiteStats_ImagePorn','IndexSelectionHostStats','ClusterInfo','IndexSelectionURLStats','SelectionRules','SelectionRules_FiredRulesDebugInfo','SelectionRules_FiredRules','SelectionFactors','ScorerOutput','SelectorOutput','SelectorOutput_SubIndexFactors','IndexSelectionOutput','HistoricalFactors','HistoricalFactors_IndexSpecificFactors_DEPRECATED','IndexSelectionAttachment','IndexSelectionAttachment_Info']
