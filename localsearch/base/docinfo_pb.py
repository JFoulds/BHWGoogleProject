# This file automatically generated by protocol-compiler from localsearch/base/docinfo.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

from google3.localsearch.base.reviewattributes_pb import ReviewAttributes
class DocInfo_ContentContext(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.deprecated_start_ = 0
    self.deprecated_length_ = 0
    self.offset_start_ = 0
    self.offset_length_ = 0
    self.context_rejection_bits_ = 0
    self.has_deprecated_start_ = 0
    self.has_deprecated_length_ = 0
    self.has_offset_start_ = 0
    self.has_offset_length_ = 0
    self.has_context_rejection_bits_ = 0
    if contents is not None: self.MergeFromString(contents)

  def deprecated_start(self): return self.deprecated_start_

  def set_deprecated_start(self, x):
    self.has_deprecated_start_ = 1
    self.deprecated_start_ = x

  def clear_deprecated_start(self):
    self.has_deprecated_start_ = 0
    self.deprecated_start_ = 0

  def has_deprecated_start(self): return self.has_deprecated_start_

  def deprecated_length(self): return self.deprecated_length_

  def set_deprecated_length(self, x):
    self.has_deprecated_length_ = 1
    self.deprecated_length_ = x

  def clear_deprecated_length(self):
    self.has_deprecated_length_ = 0
    self.deprecated_length_ = 0

  def has_deprecated_length(self): return self.has_deprecated_length_

  def offset_start(self): return self.offset_start_

  def set_offset_start(self, x):
    self.has_offset_start_ = 1
    self.offset_start_ = x

  def clear_offset_start(self):
    self.has_offset_start_ = 0
    self.offset_start_ = 0

  def has_offset_start(self): return self.has_offset_start_

  def offset_length(self): return self.offset_length_

  def set_offset_length(self, x):
    self.has_offset_length_ = 1
    self.offset_length_ = x

  def clear_offset_length(self):
    self.has_offset_length_ = 0
    self.offset_length_ = 0

  def has_offset_length(self): return self.has_offset_length_

  def context_rejection_bits(self): return self.context_rejection_bits_

  def set_context_rejection_bits(self, x):
    self.has_context_rejection_bits_ = 1
    self.context_rejection_bits_ = x

  def clear_context_rejection_bits(self):
    self.has_context_rejection_bits_ = 0
    self.context_rejection_bits_ = 0

  def has_context_rejection_bits(self): return self.has_context_rejection_bits_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_deprecated_start()): self.set_deprecated_start(x.deprecated_start())
    if (x.has_deprecated_length()): self.set_deprecated_length(x.deprecated_length())
    if (x.has_offset_start()): self.set_offset_start(x.offset_start())
    if (x.has_offset_length()): self.set_offset_length(x.offset_length())
    if (x.has_context_rejection_bits()): self.set_context_rejection_bits(x.context_rejection_bits())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'localsearch.DocInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'localsearch.DocInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'localsearch.DocInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'localsearch.DocInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'localsearch.DocInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_deprecated_start_ != x.has_deprecated_start_: return 0
    if self.has_deprecated_start_ and self.deprecated_start_ != x.deprecated_start_: return 0
    if self.has_deprecated_length_ != x.has_deprecated_length_: return 0
    if self.has_deprecated_length_ and self.deprecated_length_ != x.deprecated_length_: return 0
    if self.has_offset_start_ != x.has_offset_start_: return 0
    if self.has_offset_start_ and self.offset_start_ != x.offset_start_: return 0
    if self.has_offset_length_ != x.has_offset_length_: return 0
    if self.has_offset_length_ and self.offset_length_ != x.offset_length_: return 0
    if self.has_context_rejection_bits_ != x.has_context_rejection_bits_: return 0
    if self.has_context_rejection_bits_ and self.context_rejection_bits_ != x.context_rejection_bits_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_deprecated_start_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: deprecated_start not set.')
    if (not self.has_deprecated_length_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: deprecated_length not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.deprecated_start_)
    n += self.lengthVarInt64(self.deprecated_length_)
    if (self.has_offset_start_): n += 1 + self.lengthVarInt64(self.offset_start_)
    if (self.has_offset_length_): n += 1 + self.lengthVarInt64(self.offset_length_)
    if (self.has_context_rejection_bits_): n += 2 + self.lengthVarInt64(self.context_rejection_bits_)
    return n + 2

  def Clear(self):
    self.clear_deprecated_start()
    self.clear_deprecated_length()
    self.clear_offset_start()
    self.clear_offset_length()
    self.clear_context_rejection_bits()

  def OutputUnchecked(self, out):
    out.putVarInt32(48)
    out.putVarInt32(self.deprecated_start_)
    out.putVarInt32(56)
    out.putVarInt32(self.deprecated_length_)
    if (self.has_offset_start_):
      out.putVarInt32(104)
      out.putVarInt32(self.offset_start_)
    if (self.has_offset_length_):
      out.putVarInt32(112)
      out.putVarInt32(self.offset_length_)
    if (self.has_context_rejection_bits_):
      out.putVarInt32(136)
      out.putVarInt32(self.context_rejection_bits_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 44: break
      if tt == 48:
        self.set_deprecated_start(d.getVarInt32())
        continue
      if tt == 56:
        self.set_deprecated_length(d.getVarInt32())
        continue
      if tt == 104:
        self.set_offset_start(d.getVarInt32())
        continue
      if tt == 112:
        self.set_offset_length(d.getVarInt32())
        continue
      if tt == 136:
        self.set_context_rejection_bits(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_deprecated_start_: res+=prefix+("DEPRECATED_start: %s\n" % self.DebugFormatInt32(self.deprecated_start_))
    if self.has_deprecated_length_: res+=prefix+("DEPRECATED_length: %s\n" % self.DebugFormatInt32(self.deprecated_length_))
    if self.has_offset_start_: res+=prefix+("offset_start: %s\n" % self.DebugFormatInt32(self.offset_start_))
    if self.has_offset_length_: res+=prefix+("offset_length: %s\n" % self.DebugFormatInt32(self.offset_length_))
    if self.has_context_rejection_bits_: res+=prefix+("context_rejection_bits: %s\n" % self.DebugFormatInt32(self.context_rejection_bits_))
    return res

class DocInfo_ContentHighlight(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.deprecated_start_ = 0
    self.deprecated_length_ = 0
    self.offset_start_ = 0
    self.offset_length_ = 0
    self.has_deprecated_start_ = 0
    self.has_deprecated_length_ = 0
    self.has_offset_start_ = 0
    self.has_offset_length_ = 0
    if contents is not None: self.MergeFromString(contents)

  def deprecated_start(self): return self.deprecated_start_

  def set_deprecated_start(self, x):
    self.has_deprecated_start_ = 1
    self.deprecated_start_ = x

  def clear_deprecated_start(self):
    self.has_deprecated_start_ = 0
    self.deprecated_start_ = 0

  def has_deprecated_start(self): return self.has_deprecated_start_

  def deprecated_length(self): return self.deprecated_length_

  def set_deprecated_length(self, x):
    self.has_deprecated_length_ = 1
    self.deprecated_length_ = x

  def clear_deprecated_length(self):
    self.has_deprecated_length_ = 0
    self.deprecated_length_ = 0

  def has_deprecated_length(self): return self.has_deprecated_length_

  def offset_start(self): return self.offset_start_

  def set_offset_start(self, x):
    self.has_offset_start_ = 1
    self.offset_start_ = x

  def clear_offset_start(self):
    self.has_offset_start_ = 0
    self.offset_start_ = 0

  def has_offset_start(self): return self.has_offset_start_

  def offset_length(self): return self.offset_length_

  def set_offset_length(self, x):
    self.has_offset_length_ = 1
    self.offset_length_ = x

  def clear_offset_length(self):
    self.has_offset_length_ = 0
    self.offset_length_ = 0

  def has_offset_length(self): return self.has_offset_length_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_deprecated_start()): self.set_deprecated_start(x.deprecated_start())
    if (x.has_deprecated_length()): self.set_deprecated_length(x.deprecated_length())
    if (x.has_offset_start()): self.set_offset_start(x.offset_start())
    if (x.has_offset_length()): self.set_offset_length(x.offset_length())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'localsearch.DocInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'localsearch.DocInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'localsearch.DocInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'localsearch.DocInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'localsearch.DocInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_deprecated_start_ != x.has_deprecated_start_: return 0
    if self.has_deprecated_start_ and self.deprecated_start_ != x.deprecated_start_: return 0
    if self.has_deprecated_length_ != x.has_deprecated_length_: return 0
    if self.has_deprecated_length_ and self.deprecated_length_ != x.deprecated_length_: return 0
    if self.has_offset_start_ != x.has_offset_start_: return 0
    if self.has_offset_start_ and self.offset_start_ != x.offset_start_: return 0
    if self.has_offset_length_ != x.has_offset_length_: return 0
    if self.has_offset_length_ and self.offset_length_ != x.offset_length_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_deprecated_start_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: deprecated_start not set.')
    if (not self.has_deprecated_length_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: deprecated_length not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.deprecated_start_)
    n += self.lengthVarInt64(self.deprecated_length_)
    if (self.has_offset_start_): n += 1 + self.lengthVarInt64(self.offset_start_)
    if (self.has_offset_length_): n += 2 + self.lengthVarInt64(self.offset_length_)
    return n + 2

  def Clear(self):
    self.clear_deprecated_start()
    self.clear_deprecated_length()
    self.clear_offset_start()
    self.clear_offset_length()

  def OutputUnchecked(self, out):
    out.putVarInt32(72)
    out.putVarInt32(self.deprecated_start_)
    out.putVarInt32(80)
    out.putVarInt32(self.deprecated_length_)
    if (self.has_offset_start_):
      out.putVarInt32(120)
      out.putVarInt32(self.offset_start_)
    if (self.has_offset_length_):
      out.putVarInt32(128)
      out.putVarInt32(self.offset_length_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 68: break
      if tt == 72:
        self.set_deprecated_start(d.getVarInt32())
        continue
      if tt == 80:
        self.set_deprecated_length(d.getVarInt32())
        continue
      if tt == 120:
        self.set_offset_start(d.getVarInt32())
        continue
      if tt == 128:
        self.set_offset_length(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_deprecated_start_: res+=prefix+("DEPRECATED_start: %s\n" % self.DebugFormatInt32(self.deprecated_start_))
    if self.has_deprecated_length_: res+=prefix+("DEPRECATED_length: %s\n" % self.DebugFormatInt32(self.deprecated_length_))
    if self.has_offset_start_: res+=prefix+("offset_start: %s\n" % self.DebugFormatInt32(self.offset_start_))
    if self.has_offset_length_: res+=prefix+("offset_length: %s\n" % self.DebugFormatInt32(self.offset_length_))
    return res

class DocInfo_Content(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.clusterdocid_ = 0
    self.content_id_ = 0
    self.language_ = 0
    self.context_ = []
    self.highlight_ = []
    self.attributes_ = None
    self.scraped_ = 0
    self.inferred_ = 0
    self.authority_ = 0.0
    self.has_clusterdocid_ = 0
    self.has_content_id_ = 0
    self.has_language_ = 0
    self.has_attributes_ = 0
    self.has_scraped_ = 0
    self.has_inferred_ = 0
    self.has_authority_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def clusterdocid(self): return self.clusterdocid_

  def set_clusterdocid(self, x):
    self.has_clusterdocid_ = 1
    self.clusterdocid_ = x

  def clear_clusterdocid(self):
    self.has_clusterdocid_ = 0
    self.clusterdocid_ = 0

  def has_clusterdocid(self): return self.has_clusterdocid_

  def content_id(self): return self.content_id_

  def set_content_id(self, x):
    self.has_content_id_ = 1
    self.content_id_ = x

  def clear_content_id(self):
    self.has_content_id_ = 0
    self.content_id_ = 0

  def has_content_id(self): return self.has_content_id_

  def language(self): return self.language_

  def set_language(self, x):
    self.has_language_ = 1
    self.language_ = x

  def clear_language(self):
    self.has_language_ = 0
    self.language_ = 0

  def has_language(self): return self.has_language_

  def context_size(self): return len(self.context_)
  def context_list(self): return self.context_

  def context(self, i):
    return self.context_[i]

  def mutable_context(self, i):
    return self.context_[i]

  def add_context(self):
    x = DocInfo_ContentContext()
    self.context_.append(x)
    return x

  def clear_context(self):
    self.context_ = []
  def highlight_size(self): return len(self.highlight_)
  def highlight_list(self): return self.highlight_

  def highlight(self, i):
    return self.highlight_[i]

  def mutable_highlight(self, i):
    return self.highlight_[i]

  def add_highlight(self):
    x = DocInfo_ContentHighlight()
    self.highlight_.append(x)
    return x

  def clear_highlight(self):
    self.highlight_ = []
  def attributes(self):
    if self.attributes_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.attributes_ is None: self.attributes_ = ReviewAttributes()
      finally:
        self.lazy_init_lock_.release()
    return self.attributes_

  def mutable_attributes(self): self.has_attributes_ = 1; return self.attributes()

  def clear_attributes(self):
    #Warning: this method does not acquire the lock.
    self.has_attributes_ = 0;
    if self.attributes_ is not None: self.attributes_.Clear()

  def has_attributes(self): return self.has_attributes_

  def scraped(self): return self.scraped_

  def set_scraped(self, x):
    self.has_scraped_ = 1
    self.scraped_ = x

  def clear_scraped(self):
    self.has_scraped_ = 0
    self.scraped_ = 0

  def has_scraped(self): return self.has_scraped_

  def inferred(self): return self.inferred_

  def set_inferred(self, x):
    self.has_inferred_ = 1
    self.inferred_ = x

  def clear_inferred(self):
    self.has_inferred_ = 0
    self.inferred_ = 0

  def has_inferred(self): return self.has_inferred_

  def authority(self): return self.authority_

  def set_authority(self, x):
    self.has_authority_ = 1
    self.authority_ = x

  def clear_authority(self):
    self.has_authority_ = 0
    self.authority_ = 0.0

  def has_authority(self): return self.has_authority_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_clusterdocid()): self.set_clusterdocid(x.clusterdocid())
    if (x.has_content_id()): self.set_content_id(x.content_id())
    if (x.has_language()): self.set_language(x.language())
    for i in xrange(x.context_size()): self.add_context().CopyFrom(x.context(i))
    for i in xrange(x.highlight_size()): self.add_highlight().CopyFrom(x.highlight(i))
    if (x.has_attributes()): self.mutable_attributes().MergeFrom(x.attributes())
    if (x.has_scraped()): self.set_scraped(x.scraped())
    if (x.has_inferred()): self.set_inferred(x.inferred())
    if (x.has_authority()): self.set_authority(x.authority())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'localsearch.DocInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'localsearch.DocInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'localsearch.DocInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'localsearch.DocInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'localsearch.DocInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_clusterdocid_ != x.has_clusterdocid_: return 0
    if self.has_clusterdocid_ and self.clusterdocid_ != x.clusterdocid_: return 0
    if self.has_content_id_ != x.has_content_id_: return 0
    if self.has_content_id_ and self.content_id_ != x.content_id_: return 0
    if self.has_language_ != x.has_language_: return 0
    if self.has_language_ and self.language_ != x.language_: return 0
    if len(self.context_) != len(x.context_): return 0
    for e1, e2 in zip(self.context_, x.context_):
      if e1 != e2: return 0
    if len(self.highlight_) != len(x.highlight_): return 0
    for e1, e2 in zip(self.highlight_, x.highlight_):
      if e1 != e2: return 0
    if self.has_attributes_ != x.has_attributes_: return 0
    if self.has_attributes_ and self.attributes_ != x.attributes_: return 0
    if self.has_scraped_ != x.has_scraped_: return 0
    if self.has_scraped_ and self.scraped_ != x.scraped_: return 0
    if self.has_inferred_ != x.has_inferred_: return 0
    if self.has_inferred_ and self.inferred_ != x.inferred_: return 0
    if self.has_authority_ != x.has_authority_: return 0
    if self.has_authority_ and self.authority_ != x.authority_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_clusterdocid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: clusterdocid not set.')
    if (not self.has_content_id_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: content_id not set.')
    for i in xrange(len(self.context_)):
      if (not self.context_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.highlight_)):
      if (not self.highlight_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_attributes_ and not self.attributes_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.content_id_)
    if (self.has_language_): n += 1 + self.lengthVarInt64(self.language_)
    n += 2 * len(self.context_)
    for i in xrange(len(self.context_)): n += self.context_[i].ByteSize()
    n += 2 * len(self.highlight_)
    for i in xrange(len(self.highlight_)): n += self.highlight_[i].ByteSize()
    if (self.has_attributes_): n += 1 + self.lengthString(self.attributes_.ByteSize())
    if (self.has_scraped_): n += 3
    if (self.has_inferred_): n += 3
    if (self.has_authority_): n += 10
    return n + 10

  def Clear(self):
    self.clear_clusterdocid()
    self.clear_content_id()
    self.clear_language()
    self.clear_context()
    self.clear_highlight()
    self.clear_attributes()
    self.clear_scraped()
    self.clear_inferred()
    self.clear_authority()

  def OutputUnchecked(self, out):
    out.putVarInt32(17)
    out.put64(self.clusterdocid_)
    out.putVarInt32(24)
    out.putVarInt32(self.content_id_)
    if (self.has_language_):
      out.putVarInt32(32)
      out.putVarInt32(self.language_)
    for i in xrange(len(self.context_)):
      out.putVarInt32(43)
      self.context_[i].OutputUnchecked(out)
      out.putVarInt32(44)
    for i in xrange(len(self.highlight_)):
      out.putVarInt32(67)
      self.highlight_[i].OutputUnchecked(out)
      out.putVarInt32(68)
    if (self.has_attributes_):
      out.putVarInt32(98)
      out.putVarInt32(self.attributes_.ByteSize())
      self.attributes_.OutputUnchecked(out)
    if (self.has_scraped_):
      out.putVarInt32(144)
      out.putBoolean(self.scraped_)
    if (self.has_inferred_):
      out.putVarInt32(152)
      out.putBoolean(self.inferred_)
    if (self.has_authority_):
      out.putVarInt32(161)
      out.putDouble(self.authority_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 17:
        self.set_clusterdocid(d.get64())
        continue
      if tt == 24:
        self.set_content_id(d.getVarInt32())
        continue
      if tt == 32:
        self.set_language(d.getVarInt32())
        continue
      if tt == 43:
        self.add_context().TryMerge(d)
        continue
      if tt == 67:
        self.add_highlight().TryMerge(d)
        continue
      if tt == 98:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_attributes().TryMerge(tmp)
        continue
      if tt == 144:
        self.set_scraped(d.getBoolean())
        continue
      if tt == 152:
        self.set_inferred(d.getBoolean())
        continue
      if tt == 161:
        self.set_authority(d.getDouble())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_clusterdocid_: res+=prefix+("clusterdocid: %s\n" % self.DebugFormatFixed64(self.clusterdocid_))
    if self.has_content_id_: res+=prefix+("content_id: %s\n" % self.DebugFormatInt32(self.content_id_))
    if self.has_language_: res+=prefix+("language: %s\n" % self.DebugFormatInt32(self.language_))
    cnt=0
    for e in self.context_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Context%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.highlight_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Highlight%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_attributes_:
      res+=prefix+"attributes <\n"
      res+=self.attributes_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_scraped_: res+=prefix+("scraped: %s\n" % self.DebugFormatBool(self.scraped_))
    if self.has_inferred_: res+=prefix+("inferred: %s\n" % self.DebugFormatBool(self.inferred_))
    if self.has_authority_: res+=prefix+("authority: %s\n" % self.DebugFormat(self.authority_))
    return res

class DocInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.content_ = []
    if contents is not None: self.MergeFromString(contents)

  def content_size(self): return len(self.content_)
  def content_list(self): return self.content_

  def content(self, i):
    return self.content_[i]

  def mutable_content(self, i):
    return self.content_[i]

  def add_content(self):
    x = DocInfo_Content()
    self.content_.append(x)
    return x

  def clear_content(self):
    self.content_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.content_size()): self.add_content().CopyFrom(x.content(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'localsearch.DocInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'localsearch.DocInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'localsearch.DocInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'localsearch.DocInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'localsearch.DocInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.content_) != len(x.content_): return 0
    for e1, e2 in zip(self.content_, x.content_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.content_)):
      if (not self.content_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.content_)
    for i in xrange(len(self.content_)): n += self.content_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_content()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.content_)):
      out.putVarInt32(11)
      self.content_[i].OutputUnchecked(out)
      out.putVarInt32(12)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_content().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.content_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Content%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kContentGroup = 1
  kContentclusterdocid = 2
  kContentcontent_id = 3
  kContentlanguage = 4
  kContentContextGroup = 5
  kContentContextDEPRECATED_start = 6
  kContentContextDEPRECATED_length = 7
  kContentContextoffset_start = 13
  kContentContextoffset_length = 14
  kContentContextcontext_rejection_bits = 17
  kContentHighlightGroup = 8
  kContentHighlightDEPRECATED_start = 9
  kContentHighlightDEPRECATED_length = 10
  kContentHighlightoffset_start = 15
  kContentHighlightoffset_length = 16
  kContentattributes = 12
  kContentscraped = 18
  kContentinferred = 19
  kContentauthority = 20

  _TEXT = (
   "ErrorCode",  #   0
   "Content",  #   1
   "clusterdocid",  #   2
   "content_id",  #   3
   "language",  #   4
   "Context",  #   5
   "DEPRECATED_start",  #   6
   "DEPRECATED_length",  #   7
   "Highlight",  #   8
   "DEPRECATED_start",  #   9
   "DEPRECATED_length",  #  10
   None,  #  11
   "attributes",  #  12
   "offset_start",  #  13
   "offset_length",  #  14
   "offset_start",  #  15
   "offset_length",  #  16
   "context_rejection_bits",  #  17
   "scraped",  #  18
   "inferred",  #  19
   "authority",  #  20
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.DOUBLE,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.STARTGROUP,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.STARTGROUP,  #   8

   ProtocolBuffer.Encoder.NUMERIC,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.MAX_TYPE,  #  11

   ProtocolBuffer.Encoder.STRING,  #  12

   ProtocolBuffer.Encoder.NUMERIC,  #  13

   ProtocolBuffer.Encoder.NUMERIC,  #  14

   ProtocolBuffer.Encoder.NUMERIC,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

   ProtocolBuffer.Encoder.NUMERIC,  #  17

   ProtocolBuffer.Encoder.NUMERIC,  #  18

   ProtocolBuffer.Encoder.NUMERIC,  #  19

   ProtocolBuffer.Encoder.DOUBLE,  #  20

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x1e,
    0x6c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x61,
    0x72,
    0x63,
    0x68,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x13,
    0x6c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x61,
    0x72,
    0x63,
    0x68,
    0x2e,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x13,
    0x1a,
    0x07,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x63,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x64,
    0x20,
    0x02,
    0x28,
    0x01,
    0x30,
    0x06,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x69,
    0x64,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x6c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x78,
    0x74,
    0x20,
    0x05,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x20,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x78,
    0x74,
    0x2e,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x5f,
    0x73,
    0x74,
    0x61,
    0x72,
    0x74,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x21,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x78,
    0x74,
    0x2e,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x5f,
    0x6c,
    0x65,
    0x6e,
    0x67,
    0x74,
    0x68,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x78,
    0x74,
    0x2e,
    0x6f,
    0x66,
    0x66,
    0x73,
    0x65,
    0x74,
    0x5f,
    0x73,
    0x74,
    0x61,
    0x72,
    0x74,
    0x20,
    0x0d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0x60,
    0x04,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1d,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x78,
    0x74,
    0x2e,
    0x6f,
    0x66,
    0x66,
    0x73,
    0x65,
    0x74,
    0x5f,
    0x6c,
    0x65,
    0x6e,
    0x67,
    0x74,
    0x68,
    0x20,
    0x0e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0x60,
    0x04,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x26,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x78,
    0x74,
    0x2e,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x78,
    0x74,
    0x5f,
    0x72,
    0x65,
    0x6a,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x62,
    0x69,
    0x74,
    0x73,
    0x20,
    0x11,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x48,
    0x69,
    0x67,
    0x68,
    0x6c,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x08,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x22,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x48,
    0x69,
    0x67,
    0x68,
    0x6c,
    0x69,
    0x67,
    0x68,
    0x74,
    0x2e,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x5f,
    0x73,
    0x74,
    0x61,
    0x72,
    0x74,
    0x20,
    0x09,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x23,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x48,
    0x69,
    0x67,
    0x68,
    0x6c,
    0x69,
    0x67,
    0x68,
    0x74,
    0x2e,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x5f,
    0x6c,
    0x65,
    0x6e,
    0x67,
    0x74,
    0x68,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x48,
    0x69,
    0x67,
    0x68,
    0x6c,
    0x69,
    0x67,
    0x68,
    0x74,
    0x2e,
    0x6f,
    0x66,
    0x66,
    0x73,
    0x65,
    0x74,
    0x5f,
    0x73,
    0x74,
    0x61,
    0x72,
    0x74,
    0x20,
    0x0f,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0x60,
    0x0a,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1f,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x48,
    0x69,
    0x67,
    0x68,
    0x6c,
    0x69,
    0x67,
    0x68,
    0x74,
    0x2e,
    0x6f,
    0x66,
    0x66,
    0x73,
    0x65,
    0x74,
    0x5f,
    0x6c,
    0x65,
    0x6e,
    0x67,
    0x74,
    0x68,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0x60,
    0x0a,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x61,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x73,
    0x20,
    0x0c,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x1c,
    0x6c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x61,
    0x72,
    0x63,
    0x68,
    0x2e,
    0x52,
    0x65,
    0x76,
    0x69,
    0x65,
    0x77,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x73,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x73,
    0x63,
    0x72,
    0x61,
    0x70,
    0x65,
    0x64,
    0x20,
    0x12,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x69,
    0x6e,
    0x66,
    0x65,
    0x72,
    0x72,
    0x65,
    0x64,
    0x20,
    0x13,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x61,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x69,
    0x74,
    0x79,
    0x20,
    0x14,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['DocInfo','DocInfo_ContentContext','DocInfo_ContentHighlight','DocInfo_Content']
