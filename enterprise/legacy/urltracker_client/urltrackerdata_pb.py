# This file automatically generated by protocol-compiler from webutil/url/urltrackerdata.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

class UrlTrackerData_SetsCountsCounts(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.state_ = 0
    self.count_ = 0
    self.has_state_ = 0
    self.has_count_ = 0
    if contents is not None: self.MergeFromString(contents)

  def state(self): return self.state_

  def set_state(self, x):
    self.has_state_ = 1
    self.state_ = x

  def clear_state(self):
    self.has_state_ = 0
    self.state_ = 0

  def has_state(self): return self.has_state_

  def count(self): return self.count_

  def set_count(self, x):
    self.has_count_ = 1
    self.count_ = x

  def clear_count(self):
    self.has_count_ = 0
    self.count_ = 0

  def has_count(self): return self.has_count_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_state()): self.set_state(x.state())
    if (x.has_count()): self.set_count(x.count())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'UrlTrackerData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'UrlTrackerData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'UrlTrackerData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'UrlTrackerData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'UrlTrackerData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_state_ != x.has_state_: return 0
    if self.has_state_ and self.state_ != x.state_: return 0
    if self.has_count_ != x.has_count_: return 0
    if self.has_count_ and self.count_ != x.count_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_state_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: state not set.')
    if (not self.has_count_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: count not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.state_)
    n += self.lengthVarInt64(self.count_)
    return n + 2

  def Clear(self):
    self.clear_state()
    self.clear_count()

  def OutputUnchecked(self, out):
    out.putVarInt32(112)
    out.putVarInt32(self.state_)
    out.putVarInt32(120)
    out.putVarInt64(self.count_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 108: break
      if tt == 112:
        self.set_state(d.getVarInt32())
        continue
      if tt == 120:
        self.set_count(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_state_: res+=prefix+("State: %s\n" % self.DebugFormatInt32(self.state_))
    if self.has_count_: res+=prefix+("Count: %s\n" % self.DebugFormatInt64(self.count_))
    return res

class UrlTrackerData_States(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.state_ = 0
    self.timestamp_ = 0
    self.epochmarker_ = 0
    self.iscookieservererror_ = 0
    self.has_state_ = 0
    self.has_timestamp_ = 0
    self.has_epochmarker_ = 0
    self.has_iscookieservererror_ = 0
    if contents is not None: self.MergeFromString(contents)

  def state(self): return self.state_

  def set_state(self, x):
    self.has_state_ = 1
    self.state_ = x

  def clear_state(self):
    self.has_state_ = 0
    self.state_ = 0

  def has_state(self): return self.has_state_

  def timestamp(self): return self.timestamp_

  def set_timestamp(self, x):
    self.has_timestamp_ = 1
    self.timestamp_ = x

  def clear_timestamp(self):
    self.has_timestamp_ = 0
    self.timestamp_ = 0

  def has_timestamp(self): return self.has_timestamp_

  def epochmarker(self): return self.epochmarker_

  def set_epochmarker(self, x):
    self.has_epochmarker_ = 1
    self.epochmarker_ = x

  def clear_epochmarker(self):
    self.has_epochmarker_ = 0
    self.epochmarker_ = 0

  def has_epochmarker(self): return self.has_epochmarker_

  def iscookieservererror(self): return self.iscookieservererror_

  def set_iscookieservererror(self, x):
    self.has_iscookieservererror_ = 1
    self.iscookieservererror_ = x

  def clear_iscookieservererror(self):
    self.has_iscookieservererror_ = 0
    self.iscookieservererror_ = 0

  def has_iscookieservererror(self): return self.has_iscookieservererror_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_state()): self.set_state(x.state())
    if (x.has_timestamp()): self.set_timestamp(x.timestamp())
    if (x.has_epochmarker()): self.set_epochmarker(x.epochmarker())
    if (x.has_iscookieservererror()): self.set_iscookieservererror(x.iscookieservererror())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'UrlTrackerData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'UrlTrackerData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'UrlTrackerData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'UrlTrackerData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'UrlTrackerData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_state_ != x.has_state_: return 0
    if self.has_state_ and self.state_ != x.state_: return 0
    if self.has_timestamp_ != x.has_timestamp_: return 0
    if self.has_timestamp_ and self.timestamp_ != x.timestamp_: return 0
    if self.has_epochmarker_ != x.has_epochmarker_: return 0
    if self.has_epochmarker_ and self.epochmarker_ != x.epochmarker_: return 0
    if self.has_iscookieservererror_ != x.has_iscookieservererror_: return 0
    if self.has_iscookieservererror_ and self.iscookieservererror_ != x.iscookieservererror_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_state_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: state not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.state_)
    if (self.has_timestamp_): n += 1 + self.lengthVarInt64(self.timestamp_)
    if (self.has_epochmarker_): n += 1 + self.lengthVarInt64(self.epochmarker_)
    if (self.has_iscookieservererror_): n += 3
    return n + 1

  def Clear(self):
    self.clear_state()
    self.clear_timestamp()
    self.clear_epochmarker()
    self.clear_iscookieservererror()

  def OutputUnchecked(self, out):
    out.putVarInt32(16)
    out.putVarInt32(self.state_)
    if (self.has_timestamp_):
      out.putVarInt32(24)
      out.putVarInt32(self.timestamp_)
    if (self.has_epochmarker_):
      out.putVarInt32(80)
      out.putVarInt32(self.epochmarker_)
    if (self.has_iscookieservererror_):
      out.putVarInt32(152)
      out.putBoolean(self.iscookieservererror_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 16:
        self.set_state(d.getVarInt32())
        continue
      if tt == 24:
        self.set_timestamp(d.getVarInt32())
        continue
      if tt == 80:
        self.set_epochmarker(d.getVarInt32())
        continue
      if tt == 152:
        self.set_iscookieservererror(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_state_: res+=prefix+("State: %s\n" % self.DebugFormatInt32(self.state_))
    if self.has_timestamp_: res+=prefix+("Timestamp: %s\n" % self.DebugFormatInt32(self.timestamp_))
    if self.has_epochmarker_: res+=prefix+("EpochMarker: %s\n" % self.DebugFormatInt32(self.epochmarker_))
    if self.has_iscookieservererror_: res+=prefix+("IsCookieServerError: %s\n" % self.DebugFormatBool(self.iscookieservererror_))
    return res

class UrlTrackerData_Counts(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.state_ = 0
    self.count_ = 0
    self.newesttimestamp_ = 0
    self.has_state_ = 0
    self.has_count_ = 0
    self.has_newesttimestamp_ = 0
    if contents is not None: self.MergeFromString(contents)

  def state(self): return self.state_

  def set_state(self, x):
    self.has_state_ = 1
    self.state_ = x

  def clear_state(self):
    self.has_state_ = 0
    self.state_ = 0

  def has_state(self): return self.has_state_

  def count(self): return self.count_

  def set_count(self, x):
    self.has_count_ = 1
    self.count_ = x

  def clear_count(self):
    self.has_count_ = 0
    self.count_ = 0

  def has_count(self): return self.has_count_

  def newesttimestamp(self): return self.newesttimestamp_

  def set_newesttimestamp(self, x):
    self.has_newesttimestamp_ = 1
    self.newesttimestamp_ = x

  def clear_newesttimestamp(self):
    self.has_newesttimestamp_ = 0
    self.newesttimestamp_ = 0

  def has_newesttimestamp(self): return self.has_newesttimestamp_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_state()): self.set_state(x.state())
    if (x.has_count()): self.set_count(x.count())
    if (x.has_newesttimestamp()): self.set_newesttimestamp(x.newesttimestamp())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'UrlTrackerData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'UrlTrackerData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'UrlTrackerData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'UrlTrackerData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'UrlTrackerData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_state_ != x.has_state_: return 0
    if self.has_state_ and self.state_ != x.state_: return 0
    if self.has_count_ != x.has_count_: return 0
    if self.has_count_ and self.count_ != x.count_: return 0
    if self.has_newesttimestamp_ != x.has_newesttimestamp_: return 0
    if self.has_newesttimestamp_ and self.newesttimestamp_ != x.newesttimestamp_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_state_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: state not set.')
    if (not self.has_count_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: count not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.state_)
    n += self.lengthVarInt64(self.count_)
    if (self.has_newesttimestamp_): n += 2 + self.lengthVarInt64(self.newesttimestamp_)
    return n + 2

  def Clear(self):
    self.clear_state()
    self.clear_count()
    self.clear_newesttimestamp()

  def OutputUnchecked(self, out):
    out.putVarInt32(40)
    out.putVarInt32(self.state_)
    out.putVarInt32(48)
    out.putVarInt64(self.count_)
    if (self.has_newesttimestamp_):
      out.putVarInt32(136)
      out.putVarInt32(self.newesttimestamp_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 36: break
      if tt == 40:
        self.set_state(d.getVarInt32())
        continue
      if tt == 48:
        self.set_count(d.getVarInt64())
        continue
      if tt == 136:
        self.set_newesttimestamp(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_state_: res+=prefix+("State: %s\n" % self.DebugFormatInt32(self.state_))
    if self.has_count_: res+=prefix+("Count: %s\n" % self.DebugFormatInt64(self.count_))
    if self.has_newesttimestamp_: res+=prefix+("NewestTimestamp: %s\n" % self.DebugFormatInt32(self.newesttimestamp_))
    return res

class UrlTrackerData_SetsCounts(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.setsversion_ = 0
    self.set_ = 0
    self.setsbitmap_ = ""
    self.counts_ = []
    self.has_setsversion_ = 0
    self.has_set_ = 0
    self.has_setsbitmap_ = 0
    if contents is not None: self.MergeFromString(contents)

  def setsversion(self): return self.setsversion_

  def set_setsversion(self, x):
    self.has_setsversion_ = 1
    self.setsversion_ = x

  def clear_setsversion(self):
    self.has_setsversion_ = 0
    self.setsversion_ = 0

  def has_setsversion(self): return self.has_setsversion_

  def set(self): return self.set_

  def set_set(self, x):
    self.has_set_ = 1
    self.set_ = x

  def clear_set(self):
    self.has_set_ = 0
    self.set_ = 0

  def has_set(self): return self.has_set_

  def setsbitmap(self): return self.setsbitmap_

  def set_setsbitmap(self, x):
    self.has_setsbitmap_ = 1
    self.setsbitmap_ = x

  def clear_setsbitmap(self):
    self.has_setsbitmap_ = 0
    self.setsbitmap_ = ""

  def has_setsbitmap(self): return self.has_setsbitmap_

  def counts_size(self): return len(self.counts_)
  def counts_list(self): return self.counts_

  def counts(self, i):
    return self.counts_[i]

  def mutable_counts(self, i):
    return self.counts_[i]

  def add_counts(self):
    x = UrlTrackerData_SetsCountsCounts()
    self.counts_.append(x)
    return x

  def clear_counts(self):
    self.counts_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_setsversion()): self.set_setsversion(x.setsversion())
    if (x.has_set()): self.set_set(x.set())
    if (x.has_setsbitmap()): self.set_setsbitmap(x.setsbitmap())
    for i in xrange(x.counts_size()): self.add_counts().CopyFrom(x.counts(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'UrlTrackerData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'UrlTrackerData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'UrlTrackerData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'UrlTrackerData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'UrlTrackerData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_setsversion_ != x.has_setsversion_: return 0
    if self.has_setsversion_ and self.setsversion_ != x.setsversion_: return 0
    if self.has_set_ != x.has_set_: return 0
    if self.has_set_ and self.set_ != x.set_: return 0
    if self.has_setsbitmap_ != x.has_setsbitmap_: return 0
    if self.has_setsbitmap_ and self.setsbitmap_ != x.setsbitmap_: return 0
    if len(self.counts_) != len(x.counts_): return 0
    for e1, e2 in zip(self.counts_, x.counts_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.counts_)):
      if (not self.counts_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_setsversion_): n += 2 + self.lengthVarInt64(self.setsversion_)
    if (self.has_set_): n += 1 + self.lengthVarInt64(self.set_)
    if (self.has_setsbitmap_): n += 2 + self.lengthString(len(self.setsbitmap_))
    n += 2 * len(self.counts_)
    for i in xrange(len(self.counts_)): n += self.counts_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_setsversion()
    self.clear_set()
    self.clear_setsbitmap()
    self.clear_counts()

  def OutputUnchecked(self, out):
    if (self.has_set_):
      out.putVarInt32(96)
      out.putVarUint64(self.set_)
    for i in xrange(len(self.counts_)):
      out.putVarInt32(107)
      self.counts_[i].OutputUnchecked(out)
      out.putVarInt32(108)
    if (self.has_setsversion_):
      out.putVarInt32(192)
      out.putVarInt32(self.setsversion_)
    if (self.has_setsbitmap_):
      out.putVarInt32(202)
      out.putPrefixedString(self.setsbitmap_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 92: break
      if tt == 96:
        self.set_set(d.getVarUint64())
        continue
      if tt == 107:
        self.add_counts().TryMerge(d)
        continue
      if tt == 192:
        self.set_setsversion(d.getVarInt32())
        continue
      if tt == 202:
        self.set_setsbitmap(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_setsversion_: res+=prefix+("SetsVersion: %s\n" % self.DebugFormatInt32(self.setsversion_))
    if self.has_set_: res+=prefix+("Set: %s\n" % self.DebugFormatInt64(self.set_))
    if self.has_setsbitmap_: res+=prefix+("SetsBitmap: %s\n" % self.DebugFormatString(self.setsbitmap_))
    cnt=0
    for e in self.counts_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Counts%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

class UrlTrackerData(ProtocolBuffer.ProtocolMessage):

  FIRST_STATE  =    0 
  UNCRAWLED    =    0 
  CRAWLED_NEW  =    1 
  CRAWLED_FROM_REPOSITORY =    2 
  NOT_GOOD_PATTERNS =    3 
  IN_BAD_PATTERNS =    4 
  OFF_DOMAIN_REDIRECT =    5 
  LONG_REDIRECT_CHAIN =    6 
  REDIRECT_NO_LOCATION =    7 
  INFINITE_SPACE =    8 
  UNHANDLED_PROTOCOL =    9 
  URL_TOO_LONG =   10 
  URL_NOT_FOUND_404 =   11 
  HTTP_RCODE_OTHER_4XX =   12 
  ROBOTS_NO_INDEX =   13 
  HTTP_RCODE_0 =   14 
  PERM_DNS_FAILURE =   15 
  EMPTY_DOC_BODY =   16 
  IMAGE_CONVERSION_FAILED =   17 
  URL_REJECTED =   18 
  UNKNOWN_EXTENSION =   19 
  NO_FOLLOW    =   20 
  DROPPED_BY_IMS =   21 
  AUTHENTICATION_FAILED =   22 
  COOKIE_SERVER =   23 
  ROBOTS_DISALLOW =   24 
  CONVERSION_FAILURE =   25 
  UNHANDLED_CONTENT_TYPE =   26 
  NO_FILTER_FOR_CONTENT_TYPE =   27 
  CONVERTER_NO_BODY =   28 
  INTERNAL_CONVERTER_KILLED =   29 
  INTERNAL_CONVERTER_ZOMBIE =   30 
  DRAIN_MODE_URL =   31 
  HTTP_RCODE_500 =   32 
  ROBOTS_UNREACHABLE =   33 
  ROBOTS_FORBIDDEN =   34 
  TEMP_DNS_FAILURE =   35 
  CONNECTION_FAILURE =   36 
  CONNECTION_TIMEOUT =   37 
  CONNECTION_CLOSED =   38 
  BROKEN_PIPE  =   39 
  CONNECTION_REFUSED =   40 
  CONNECTION_RESET =   41 
  NETWORK_UNREACHABLE =   42 
  NO_ROUTE_TO_HOST =   43 
  INTERNAL_CONVERT_TO_REPOS =   44 
  REDIRECT     =   45 
  URL_REWRITTEN =   46 
  ASSUMING_HTTP =   47 
  CANONICALIZED_DUP_HOST =   48 
  ROBOTS_MISC  =   49 
  ERROR_MISC   =   50 
  UNREACHABLE_MISC =   51 
  INVALID      =   52 
  NOT_LEGAL_HOSTNAME =   53 
  CRAWLED_FEED =   54 
  DOCUMENT_ARCHIVED =   55 
  FAILED_LOCAL_FETCH =   56 
  BLOG_UNHANDLED_CONTENT =   57 
  FILE_SIZE_OVER_LIMIT =   58 
  NUM_STATES   =   59 

  _TrackerState_NAMES = {
    0: "FIRST_STATE",
    0: "UNCRAWLED",
    1: "CRAWLED_NEW",
    2: "CRAWLED_FROM_REPOSITORY",
    3: "NOT_GOOD_PATTERNS",
    4: "IN_BAD_PATTERNS",
    5: "OFF_DOMAIN_REDIRECT",
    6: "LONG_REDIRECT_CHAIN",
    7: "REDIRECT_NO_LOCATION",
    8: "INFINITE_SPACE",
    9: "UNHANDLED_PROTOCOL",
    10: "URL_TOO_LONG",
    11: "URL_NOT_FOUND_404",
    12: "HTTP_RCODE_OTHER_4XX",
    13: "ROBOTS_NO_INDEX",
    14: "HTTP_RCODE_0",
    15: "PERM_DNS_FAILURE",
    16: "EMPTY_DOC_BODY",
    17: "IMAGE_CONVERSION_FAILED",
    18: "URL_REJECTED",
    19: "UNKNOWN_EXTENSION",
    20: "NO_FOLLOW",
    21: "DROPPED_BY_IMS",
    22: "AUTHENTICATION_FAILED",
    23: "COOKIE_SERVER",
    24: "ROBOTS_DISALLOW",
    25: "CONVERSION_FAILURE",
    26: "UNHANDLED_CONTENT_TYPE",
    27: "NO_FILTER_FOR_CONTENT_TYPE",
    28: "CONVERTER_NO_BODY",
    29: "INTERNAL_CONVERTER_KILLED",
    30: "INTERNAL_CONVERTER_ZOMBIE",
    31: "DRAIN_MODE_URL",
    32: "HTTP_RCODE_500",
    33: "ROBOTS_UNREACHABLE",
    34: "ROBOTS_FORBIDDEN",
    35: "TEMP_DNS_FAILURE",
    36: "CONNECTION_FAILURE",
    37: "CONNECTION_TIMEOUT",
    38: "CONNECTION_CLOSED",
    39: "BROKEN_PIPE",
    40: "CONNECTION_REFUSED",
    41: "CONNECTION_RESET",
    42: "NETWORK_UNREACHABLE",
    43: "NO_ROUTE_TO_HOST",
    44: "INTERNAL_CONVERT_TO_REPOS",
    45: "REDIRECT",
    46: "URL_REWRITTEN",
    47: "ASSUMING_HTTP",
    48: "CANONICALIZED_DUP_HOST",
    49: "ROBOTS_MISC",
    50: "ERROR_MISC",
    51: "UNREACHABLE_MISC",
    52: "INVALID",
    53: "NOT_LEGAL_HOSTNAME",
    54: "CRAWLED_FEED",
    55: "DOCUMENT_ARCHIVED",
    56: "FAILED_LOCAL_FETCH",
    57: "BLOG_UNHANDLED_CONTENT",
    58: "FILE_SIZE_OVER_LIMIT",
    59: "NUM_STATES",
  }

  def TrackerState_Name(cls, x): return cls._TrackerState_NAMES.get(x, "")
  TrackerState_Name = classmethod(TrackerState_Name)

  def __init__(self, contents=None):
    self.path_ = ""
    self.deleted_ = 0
    self.failedpatterntest_ = 0
    self.states_ = []
    self.contenttype_ = 0
    self.contentlength_ = 0
    self.lastcrawltimestamp_ = 0
    self.authmethod_ = 0
    self.setsversion_ = 0
    self.sets_ = []
    self.setsbitmap_ = ""
    self.counts_ = []
    self.setscounts_ = []
    self.has_path_ = 0
    self.has_deleted_ = 0
    self.has_failedpatterntest_ = 0
    self.has_contenttype_ = 0
    self.has_contentlength_ = 0
    self.has_lastcrawltimestamp_ = 0
    self.has_authmethod_ = 0
    self.has_setsversion_ = 0
    self.has_setsbitmap_ = 0
    if contents is not None: self.MergeFromString(contents)

  def path(self): return self.path_

  def set_path(self, x):
    self.has_path_ = 1
    self.path_ = x

  def clear_path(self):
    self.has_path_ = 0
    self.path_ = ""

  def has_path(self): return self.has_path_

  def deleted(self): return self.deleted_

  def set_deleted(self, x):
    self.has_deleted_ = 1
    self.deleted_ = x

  def clear_deleted(self):
    self.has_deleted_ = 0
    self.deleted_ = 0

  def has_deleted(self): return self.has_deleted_

  def failedpatterntest(self): return self.failedpatterntest_

  def set_failedpatterntest(self, x):
    self.has_failedpatterntest_ = 1
    self.failedpatterntest_ = x

  def clear_failedpatterntest(self):
    self.has_failedpatterntest_ = 0
    self.failedpatterntest_ = 0

  def has_failedpatterntest(self): return self.has_failedpatterntest_

  def states_size(self): return len(self.states_)
  def states_list(self): return self.states_

  def states(self, i):
    return self.states_[i]

  def mutable_states(self, i):
    return self.states_[i]

  def add_states(self):
    x = UrlTrackerData_States()
    self.states_.append(x)
    return x

  def clear_states(self):
    self.states_ = []
  def contenttype(self): return self.contenttype_

  def set_contenttype(self, x):
    self.has_contenttype_ = 1
    self.contenttype_ = x

  def clear_contenttype(self):
    self.has_contenttype_ = 0
    self.contenttype_ = 0

  def has_contenttype(self): return self.has_contenttype_

  def contentlength(self): return self.contentlength_

  def set_contentlength(self, x):
    self.has_contentlength_ = 1
    self.contentlength_ = x

  def clear_contentlength(self):
    self.has_contentlength_ = 0
    self.contentlength_ = 0

  def has_contentlength(self): return self.has_contentlength_

  def lastcrawltimestamp(self): return self.lastcrawltimestamp_

  def set_lastcrawltimestamp(self, x):
    self.has_lastcrawltimestamp_ = 1
    self.lastcrawltimestamp_ = x

  def clear_lastcrawltimestamp(self):
    self.has_lastcrawltimestamp_ = 0
    self.lastcrawltimestamp_ = 0

  def has_lastcrawltimestamp(self): return self.has_lastcrawltimestamp_

  def authmethod(self): return self.authmethod_

  def set_authmethod(self, x):
    self.has_authmethod_ = 1
    self.authmethod_ = x

  def clear_authmethod(self):
    self.has_authmethod_ = 0
    self.authmethod_ = 0

  def has_authmethod(self): return self.has_authmethod_

  def setsversion(self): return self.setsversion_

  def set_setsversion(self, x):
    self.has_setsversion_ = 1
    self.setsversion_ = x

  def clear_setsversion(self):
    self.has_setsversion_ = 0
    self.setsversion_ = 0

  def has_setsversion(self): return self.has_setsversion_

  def sets_size(self): return len(self.sets_)
  def sets_list(self): return self.sets_

  def sets(self, i):
    return self.sets_[i]

  def set_sets(self, i, x):
    self.sets_[i] = x

  def add_sets(self, x):
    self.sets_.append(x)

  def clear_sets(self):
    self.sets_ = []

  def setsbitmap(self): return self.setsbitmap_

  def set_setsbitmap(self, x):
    self.has_setsbitmap_ = 1
    self.setsbitmap_ = x

  def clear_setsbitmap(self):
    self.has_setsbitmap_ = 0
    self.setsbitmap_ = ""

  def has_setsbitmap(self): return self.has_setsbitmap_

  def counts_size(self): return len(self.counts_)
  def counts_list(self): return self.counts_

  def counts(self, i):
    return self.counts_[i]

  def mutable_counts(self, i):
    return self.counts_[i]

  def add_counts(self):
    x = UrlTrackerData_Counts()
    self.counts_.append(x)
    return x

  def clear_counts(self):
    self.counts_ = []
  def setscounts_size(self): return len(self.setscounts_)
  def setscounts_list(self): return self.setscounts_

  def setscounts(self, i):
    return self.setscounts_[i]

  def mutable_setscounts(self, i):
    return self.setscounts_[i]

  def add_setscounts(self):
    x = UrlTrackerData_SetsCounts()
    self.setscounts_.append(x)
    return x

  def clear_setscounts(self):
    self.setscounts_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_path()): self.set_path(x.path())
    if (x.has_deleted()): self.set_deleted(x.deleted())
    if (x.has_failedpatterntest()): self.set_failedpatterntest(x.failedpatterntest())
    for i in xrange(x.states_size()): self.add_states().CopyFrom(x.states(i))
    if (x.has_contenttype()): self.set_contenttype(x.contenttype())
    if (x.has_contentlength()): self.set_contentlength(x.contentlength())
    if (x.has_lastcrawltimestamp()): self.set_lastcrawltimestamp(x.lastcrawltimestamp())
    if (x.has_authmethod()): self.set_authmethod(x.authmethod())
    if (x.has_setsversion()): self.set_setsversion(x.setsversion())
    for i in xrange(x.sets_size()): self.add_sets(x.sets(i))
    if (x.has_setsbitmap()): self.set_setsbitmap(x.setsbitmap())
    for i in xrange(x.counts_size()): self.add_counts().CopyFrom(x.counts(i))
    for i in xrange(x.setscounts_size()): self.add_setscounts().CopyFrom(x.setscounts(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'UrlTrackerData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'UrlTrackerData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'UrlTrackerData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'UrlTrackerData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'UrlTrackerData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_path_ != x.has_path_: return 0
    if self.has_path_ and self.path_ != x.path_: return 0
    if self.has_deleted_ != x.has_deleted_: return 0
    if self.has_deleted_ and self.deleted_ != x.deleted_: return 0
    if self.has_failedpatterntest_ != x.has_failedpatterntest_: return 0
    if self.has_failedpatterntest_ and self.failedpatterntest_ != x.failedpatterntest_: return 0
    if len(self.states_) != len(x.states_): return 0
    for e1, e2 in zip(self.states_, x.states_):
      if e1 != e2: return 0
    if self.has_contenttype_ != x.has_contenttype_: return 0
    if self.has_contenttype_ and self.contenttype_ != x.contenttype_: return 0
    if self.has_contentlength_ != x.has_contentlength_: return 0
    if self.has_contentlength_ and self.contentlength_ != x.contentlength_: return 0
    if self.has_lastcrawltimestamp_ != x.has_lastcrawltimestamp_: return 0
    if self.has_lastcrawltimestamp_ and self.lastcrawltimestamp_ != x.lastcrawltimestamp_: return 0
    if self.has_authmethod_ != x.has_authmethod_: return 0
    if self.has_authmethod_ and self.authmethod_ != x.authmethod_: return 0
    if self.has_setsversion_ != x.has_setsversion_: return 0
    if self.has_setsversion_ and self.setsversion_ != x.setsversion_: return 0
    if len(self.sets_) != len(x.sets_): return 0
    for e1, e2 in zip(self.sets_, x.sets_):
      if e1 != e2: return 0
    if self.has_setsbitmap_ != x.has_setsbitmap_: return 0
    if self.has_setsbitmap_ and self.setsbitmap_ != x.setsbitmap_: return 0
    if len(self.counts_) != len(x.counts_): return 0
    for e1, e2 in zip(self.counts_, x.counts_):
      if e1 != e2: return 0
    if len(self.setscounts_) != len(x.setscounts_): return 0
    for e1, e2 in zip(self.setscounts_, x.setscounts_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.states_)):
      if (not self.states_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.counts_)):
      if (not self.counts_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.setscounts_)):
      if (not self.setscounts_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_path_): n += 1 + self.lengthString(len(self.path_))
    if (self.has_deleted_): n += 2
    if (self.has_failedpatterntest_): n += 3
    n += 2 * len(self.states_)
    for i in xrange(len(self.states_)): n += self.states_[i].ByteSize()
    if (self.has_contenttype_): n += 1 + self.lengthVarInt64(self.contenttype_)
    if (self.has_contentlength_): n += 2 + self.lengthVarInt64(self.contentlength_)
    if (self.has_lastcrawltimestamp_): n += 2 + self.lengthVarInt64(self.lastcrawltimestamp_)
    if (self.has_authmethod_): n += 2 + self.lengthVarInt64(self.authmethod_)
    if (self.has_setsversion_): n += 2 + self.lengthVarInt64(self.setsversion_)
    n += 2 * len(self.sets_)
    for i in xrange(len(self.sets_)): n += self.lengthVarInt64(self.sets_[i])
    if (self.has_setsbitmap_): n += 2 + self.lengthString(len(self.setsbitmap_))
    n += 2 * len(self.counts_)
    for i in xrange(len(self.counts_)): n += self.counts_[i].ByteSize()
    n += 2 * len(self.setscounts_)
    for i in xrange(len(self.setscounts_)): n += self.setscounts_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_path()
    self.clear_deleted()
    self.clear_failedpatterntest()
    self.clear_states()
    self.clear_contenttype()
    self.clear_contentlength()
    self.clear_lastcrawltimestamp()
    self.clear_authmethod()
    self.clear_setsversion()
    self.clear_sets()
    self.clear_setsbitmap()
    self.clear_counts()
    self.clear_setscounts()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.states_)):
      out.putVarInt32(11)
      self.states_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    for i in xrange(len(self.counts_)):
      out.putVarInt32(35)
      self.counts_[i].OutputUnchecked(out)
      out.putVarInt32(36)
    if (self.has_contenttype_):
      out.putVarInt32(56)
      out.putVarInt32(self.contenttype_)
    if (self.has_path_):
      out.putVarInt32(66)
      out.putPrefixedString(self.path_)
    if (self.has_deleted_):
      out.putVarInt32(72)
      out.putBoolean(self.deleted_)
    for i in xrange(len(self.setscounts_)):
      out.putVarInt32(91)
      self.setscounts_[i].OutputUnchecked(out)
      out.putVarInt32(92)
    for i in xrange(len(self.sets_)):
      out.putVarInt32(128)
      out.putVarUint64(self.sets_[i])
    if (self.has_failedpatterntest_):
      out.putVarInt32(144)
      out.putBoolean(self.failedpatterntest_)
    if (self.has_lastcrawltimestamp_):
      out.putVarInt32(160)
      out.putVarInt32(self.lastcrawltimestamp_)
    if (self.has_authmethod_):
      out.putVarInt32(168)
      out.putVarInt32(self.authmethod_)
    if (self.has_setsversion_):
      out.putVarInt32(176)
      out.putVarInt32(self.setsversion_)
    if (self.has_setsbitmap_):
      out.putVarInt32(186)
      out.putPrefixedString(self.setsbitmap_)
    if (self.has_contentlength_):
      out.putVarInt32(208)
      out.putVarInt32(self.contentlength_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_states().TryMerge(d)
        continue
      if tt == 35:
        self.add_counts().TryMerge(d)
        continue
      if tt == 56:
        self.set_contenttype(d.getVarInt32())
        continue
      if tt == 66:
        self.set_path(d.getPrefixedString())
        continue
      if tt == 72:
        self.set_deleted(d.getBoolean())
        continue
      if tt == 91:
        self.add_setscounts().TryMerge(d)
        continue
      if tt == 128:
        self.add_sets(d.getVarUint64())
        continue
      if tt == 144:
        self.set_failedpatterntest(d.getBoolean())
        continue
      if tt == 160:
        self.set_lastcrawltimestamp(d.getVarInt32())
        continue
      if tt == 168:
        self.set_authmethod(d.getVarInt32())
        continue
      if tt == 176:
        self.set_setsversion(d.getVarInt32())
        continue
      if tt == 186:
        self.set_setsbitmap(d.getPrefixedString())
        continue
      if tt == 208:
        self.set_contentlength(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_path_: res+=prefix+("Path: %s\n" % self.DebugFormatString(self.path_))
    if self.has_deleted_: res+=prefix+("Deleted: %s\n" % self.DebugFormatBool(self.deleted_))
    if self.has_failedpatterntest_: res+=prefix+("FailedPatternTest: %s\n" % self.DebugFormatBool(self.failedpatterntest_))
    cnt=0
    for e in self.states_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("States%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_contenttype_: res+=prefix+("ContentType: %s\n" % self.DebugFormatInt32(self.contenttype_))
    if self.has_contentlength_: res+=prefix+("ContentLength: %s\n" % self.DebugFormatInt32(self.contentlength_))
    if self.has_lastcrawltimestamp_: res+=prefix+("lastCrawlTimestamp: %s\n" % self.DebugFormatInt32(self.lastcrawltimestamp_))
    if self.has_authmethod_: res+=prefix+("authMethod: %s\n" % self.DebugFormatInt32(self.authmethod_))
    if self.has_setsversion_: res+=prefix+("SetsVersion: %s\n" % self.DebugFormatInt32(self.setsversion_))
    cnt=0
    for e in self.sets_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Sets%s: %s\n" % (elm, self.DebugFormatInt64(e)))
      cnt+=1
    if self.has_setsbitmap_: res+=prefix+("SetsBitmap: %s\n" % self.DebugFormatString(self.setsbitmap_))
    cnt=0
    for e in self.counts_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Counts%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.setscounts_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("SetsCounts%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kPath = 8
  kDeleted = 9
  kFailedPatternTest = 18
  kStatesGroup = 1
  kStatesState = 2
  kStatesTimestamp = 3
  kStatesEpochMarker = 10
  kStatesIsCookieServerError = 19
  kContentType = 7
  kContentLength = 26
  klastCrawlTimestamp = 20
  kauthMethod = 21
  kSetsVersion = 22
  kSets = 16
  kSetsBitmap = 23
  kCountsGroup = 4
  kCountsState = 5
  kCountsCount = 6
  kCountsNewestTimestamp = 17
  kSetsCountsGroup = 11
  kSetsCountsSetsVersion = 24
  kSetsCountsSet = 12
  kSetsCountsSetsBitmap = 25
  kSetsCountsCountsGroup = 13
  kSetsCountsCountsState = 14
  kSetsCountsCountsCount = 15

  _TEXT = (
   "ErrorCode",  #   0
   "States",  #   1
   "State",  #   2
   "Timestamp",  #   3
   "Counts",  #   4
   "State",  #   5
   "Count",  #   6
   "ContentType",  #   7
   "Path",  #   8
   "Deleted",  #   9
   "EpochMarker",  #  10
   "SetsCounts",  #  11
   "Set",  #  12
   "Counts",  #  13
   "State",  #  14
   "Count",  #  15
   "Sets",  #  16
   "NewestTimestamp",  #  17
   "FailedPatternTest",  #  18
   "IsCookieServerError",  #  19
   "lastCrawlTimestamp",  #  20
   "authMethod",  #  21
   "SetsVersion",  #  22
   "SetsBitmap",  #  23
   "SetsVersion",  #  24
   "SetsBitmap",  #  25
   "ContentLength",  #  26
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.STARTGROUP,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.NUMERIC,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.STARTGROUP,  #  11

   ProtocolBuffer.Encoder.NUMERIC,  #  12

   ProtocolBuffer.Encoder.STARTGROUP,  #  13

   ProtocolBuffer.Encoder.NUMERIC,  #  14

   ProtocolBuffer.Encoder.NUMERIC,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

   ProtocolBuffer.Encoder.NUMERIC,  #  17

   ProtocolBuffer.Encoder.NUMERIC,  #  18

   ProtocolBuffer.Encoder.NUMERIC,  #  19

   ProtocolBuffer.Encoder.NUMERIC,  #  20

   ProtocolBuffer.Encoder.NUMERIC,  #  21

   ProtocolBuffer.Encoder.NUMERIC,  #  22

   ProtocolBuffer.Encoder.STRING,  #  23

   ProtocolBuffer.Encoder.NUMERIC,  #  24

   ProtocolBuffer.Encoder.STRING,  #  25

   ProtocolBuffer.Encoder.NUMERIC,  #  26

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x20,
    0x77,
    0x65,
    0x62,
    0x75,
    0x74,
    0x69,
    0x6c,
    0x2f,
    0x75,
    0x72,
    0x6c,
    0x2f,
    0x75,
    0x72,
    0x6c,
    0x74,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0e,
    0x55,
    0x72,
    0x6c,
    0x54,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x04,
    0x50,
    0x61,
    0x74,
    0x68,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x64,
    0x20,
    0x09,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x46,
    0x61,
    0x69,
    0x6c,
    0x65,
    0x64,
    0x50,
    0x61,
    0x74,
    0x74,
    0x65,
    0x72,
    0x6e,
    0x54,
    0x65,
    0x73,
    0x74,
    0x20,
    0x12,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x65,
    0x73,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x53,
    0x74,
    0x61,
    0x74,
    0x65,
    0x73,
    0x2e,
    0x53,
    0x74,
    0x61,
    0x74,
    0x65,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x53,
    0x74,
    0x61,
    0x74,
    0x65,
    0x73,
    0x2e,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x53,
    0x74,
    0x61,
    0x74,
    0x65,
    0x73,
    0x2e,
    0x45,
    0x70,
    0x6f,
    0x63,
    0x68,
    0x4d,
    0x61,
    0x72,
    0x6b,
    0x65,
    0x72,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x53,
    0x74,
    0x61,
    0x74,
    0x65,
    0x73,
    0x2e,
    0x49,
    0x73,
    0x43,
    0x6f,
    0x6f,
    0x6b,
    0x69,
    0x65,
    0x53,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x45,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x20,
    0x13,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0x60,
    0x03,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x4c,
    0x65,
    0x6e,
    0x67,
    0x74,
    0x68,
    0x20,
    0x1a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x6c,
    0x61,
    0x73,
    0x74,
    0x43,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x14,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x61,
    0x75,
    0x74,
    0x68,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x20,
    0x15,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x53,
    0x65,
    0x74,
    0x73,
    0x56,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x16,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x53,
    0x65,
    0x74,
    0x73,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x53,
    0x65,
    0x74,
    0x73,
    0x42,
    0x69,
    0x74,
    0x6d,
    0x61,
    0x70,
    0x20,
    0x17,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x04,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x53,
    0x74,
    0x61,
    0x74,
    0x65,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x0f,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x60,
    0x0f,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x4e,
    0x65,
    0x77,
    0x65,
    0x73,
    0x74,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x11,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x0f,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x53,
    0x65,
    0x74,
    0x73,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x0b,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x53,
    0x65,
    0x74,
    0x73,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x53,
    0x65,
    0x74,
    0x73,
    0x56,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x18,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0x60,
    0x13,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x53,
    0x65,
    0x74,
    0x73,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x53,
    0x65,
    0x74,
    0x20,
    0x0c,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x60,
    0x13,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x53,
    0x65,
    0x74,
    0x73,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x53,
    0x65,
    0x74,
    0x73,
    0x42,
    0x69,
    0x74,
    0x6d,
    0x61,
    0x70,
    0x20,
    0x19,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x13,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x53,
    0x65,
    0x74,
    0x73,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x0d,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x13,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x53,
    0x65,
    0x74,
    0x73,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x53,
    0x74,
    0x61,
    0x74,
    0x65,
    0x20,
    0x0e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x17,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x53,
    0x65,
    0x74,
    0x73,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x0f,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x60,
    0x17,
    0x14,
    0x73,
    0x7a,
    0x0c,
    0x54,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x53,
    0x74,
    0x61,
    0x74,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x46,
    0x49,
    0x52,
    0x53,
    0x54,
    0x5f,
    0x53,
    0x54,
    0x41,
    0x54,
    0x45,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x55,
    0x4e,
    0x43,
    0x52,
    0x41,
    0x57,
    0x4c,
    0x45,
    0x44,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x43,
    0x52,
    0x41,
    0x57,
    0x4c,
    0x45,
    0x44,
    0x5f,
    0x4e,
    0x45,
    0x57,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x17,
    0x43,
    0x52,
    0x41,
    0x57,
    0x4c,
    0x45,
    0x44,
    0x5f,
    0x46,
    0x52,
    0x4f,
    0x4d,
    0x5f,
    0x52,
    0x45,
    0x50,
    0x4f,
    0x53,
    0x49,
    0x54,
    0x4f,
    0x52,
    0x59,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x4e,
    0x4f,
    0x54,
    0x5f,
    0x47,
    0x4f,
    0x4f,
    0x44,
    0x5f,
    0x50,
    0x41,
    0x54,
    0x54,
    0x45,
    0x52,
    0x4e,
    0x53,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x49,
    0x4e,
    0x5f,
    0x42,
    0x41,
    0x44,
    0x5f,
    0x50,
    0x41,
    0x54,
    0x54,
    0x45,
    0x52,
    0x4e,
    0x53,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x13,
    0x4f,
    0x46,
    0x46,
    0x5f,
    0x44,
    0x4f,
    0x4d,
    0x41,
    0x49,
    0x4e,
    0x5f,
    0x52,
    0x45,
    0x44,
    0x49,
    0x52,
    0x45,
    0x43,
    0x54,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x13,
    0x4c,
    0x4f,
    0x4e,
    0x47,
    0x5f,
    0x52,
    0x45,
    0x44,
    0x49,
    0x52,
    0x45,
    0x43,
    0x54,
    0x5f,
    0x43,
    0x48,
    0x41,
    0x49,
    0x4e,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x14,
    0x52,
    0x45,
    0x44,
    0x49,
    0x52,
    0x45,
    0x43,
    0x54,
    0x5f,
    0x4e,
    0x4f,
    0x5f,
    0x4c,
    0x4f,
    0x43,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x07,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x49,
    0x4e,
    0x46,
    0x49,
    0x4e,
    0x49,
    0x54,
    0x45,
    0x5f,
    0x53,
    0x50,
    0x41,
    0x43,
    0x45,
    0x98,
    0x01,
    0x08,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x55,
    0x4e,
    0x48,
    0x41,
    0x4e,
    0x44,
    0x4c,
    0x45,
    0x44,
    0x5f,
    0x50,
    0x52,
    0x4f,
    0x54,
    0x4f,
    0x43,
    0x4f,
    0x4c,
    0x98,
    0x01,
    0x09,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x55,
    0x52,
    0x4c,
    0x5f,
    0x54,
    0x4f,
    0x4f,
    0x5f,
    0x4c,
    0x4f,
    0x4e,
    0x47,
    0x98,
    0x01,
    0x0a,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x55,
    0x52,
    0x4c,
    0x5f,
    0x4e,
    0x4f,
    0x54,
    0x5f,
    0x46,
    0x4f,
    0x55,
    0x4e,
    0x44,
    0x5f,
    0x34,
    0x30,
    0x34,
    0x98,
    0x01,
    0x0b,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x14,
    0x48,
    0x54,
    0x54,
    0x50,
    0x5f,
    0x52,
    0x43,
    0x4f,
    0x44,
    0x45,
    0x5f,
    0x4f,
    0x54,
    0x48,
    0x45,
    0x52,
    0x5f,
    0x34,
    0x58,
    0x58,
    0x98,
    0x01,
    0x0c,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x52,
    0x4f,
    0x42,
    0x4f,
    0x54,
    0x53,
    0x5f,
    0x4e,
    0x4f,
    0x5f,
    0x49,
    0x4e,
    0x44,
    0x45,
    0x58,
    0x98,
    0x01,
    0x0d,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x48,
    0x54,
    0x54,
    0x50,
    0x5f,
    0x52,
    0x43,
    0x4f,
    0x44,
    0x45,
    0x5f,
    0x30,
    0x98,
    0x01,
    0x0e,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x50,
    0x45,
    0x52,
    0x4d,
    0x5f,
    0x44,
    0x4e,
    0x53,
    0x5f,
    0x46,
    0x41,
    0x49,
    0x4c,
    0x55,
    0x52,
    0x45,
    0x98,
    0x01,
    0x0f,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x45,
    0x4d,
    0x50,
    0x54,
    0x59,
    0x5f,
    0x44,
    0x4f,
    0x43,
    0x5f,
    0x42,
    0x4f,
    0x44,
    0x59,
    0x98,
    0x01,
    0x10,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x17,
    0x49,
    0x4d,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x56,
    0x45,
    0x52,
    0x53,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x46,
    0x41,
    0x49,
    0x4c,
    0x45,
    0x44,
    0x98,
    0x01,
    0x11,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x55,
    0x52,
    0x4c,
    0x5f,
    0x52,
    0x45,
    0x4a,
    0x45,
    0x43,
    0x54,
    0x45,
    0x44,
    0x98,
    0x01,
    0x12,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x55,
    0x4e,
    0x4b,
    0x4e,
    0x4f,
    0x57,
    0x4e,
    0x5f,
    0x45,
    0x58,
    0x54,
    0x45,
    0x4e,
    0x53,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x13,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x4e,
    0x4f,
    0x5f,
    0x46,
    0x4f,
    0x4c,
    0x4c,
    0x4f,
    0x57,
    0x98,
    0x01,
    0x14,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x44,
    0x52,
    0x4f,
    0x50,
    0x50,
    0x45,
    0x44,
    0x5f,
    0x42,
    0x59,
    0x5f,
    0x49,
    0x4d,
    0x53,
    0x98,
    0x01,
    0x15,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x15,
    0x41,
    0x55,
    0x54,
    0x48,
    0x45,
    0x4e,
    0x54,
    0x49,
    0x43,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x46,
    0x41,
    0x49,
    0x4c,
    0x45,
    0x44,
    0x98,
    0x01,
    0x16,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x43,
    0x4f,
    0x4f,
    0x4b,
    0x49,
    0x45,
    0x5f,
    0x53,
    0x45,
    0x52,
    0x56,
    0x45,
    0x52,
    0x98,
    0x01,
    0x17,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x52,
    0x4f,
    0x42,
    0x4f,
    0x54,
    0x53,
    0x5f,
    0x44,
    0x49,
    0x53,
    0x41,
    0x4c,
    0x4c,
    0x4f,
    0x57,
    0x98,
    0x01,
    0x18,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x43,
    0x4f,
    0x4e,
    0x56,
    0x45,
    0x52,
    0x53,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x46,
    0x41,
    0x49,
    0x4c,
    0x55,
    0x52,
    0x45,
    0x98,
    0x01,
    0x19,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x16,
    0x55,
    0x4e,
    0x48,
    0x41,
    0x4e,
    0x44,
    0x4c,
    0x45,
    0x44,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x54,
    0x45,
    0x4e,
    0x54,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x98,
    0x01,
    0x1a,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x1a,
    0x4e,
    0x4f,
    0x5f,
    0x46,
    0x49,
    0x4c,
    0x54,
    0x45,
    0x52,
    0x5f,
    0x46,
    0x4f,
    0x52,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x54,
    0x45,
    0x4e,
    0x54,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x98,
    0x01,
    0x1b,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x43,
    0x4f,
    0x4e,
    0x56,
    0x45,
    0x52,
    0x54,
    0x45,
    0x52,
    0x5f,
    0x4e,
    0x4f,
    0x5f,
    0x42,
    0x4f,
    0x44,
    0x59,
    0x98,
    0x01,
    0x1c,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x19,
    0x49,
    0x4e,
    0x54,
    0x45,
    0x52,
    0x4e,
    0x41,
    0x4c,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x56,
    0x45,
    0x52,
    0x54,
    0x45,
    0x52,
    0x5f,
    0x4b,
    0x49,
    0x4c,
    0x4c,
    0x45,
    0x44,
    0x98,
    0x01,
    0x1d,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x19,
    0x49,
    0x4e,
    0x54,
    0x45,
    0x52,
    0x4e,
    0x41,
    0x4c,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x56,
    0x45,
    0x52,
    0x54,
    0x45,
    0x52,
    0x5f,
    0x5a,
    0x4f,
    0x4d,
    0x42,
    0x49,
    0x45,
    0x98,
    0x01,
    0x1e,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x44,
    0x52,
    0x41,
    0x49,
    0x4e,
    0x5f,
    0x4d,
    0x4f,
    0x44,
    0x45,
    0x5f,
    0x55,
    0x52,
    0x4c,
    0x98,
    0x01,
    0x1f,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x48,
    0x54,
    0x54,
    0x50,
    0x5f,
    0x52,
    0x43,
    0x4f,
    0x44,
    0x45,
    0x5f,
    0x35,
    0x30,
    0x30,
    0x98,
    0x01,
    0x20,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x52,
    0x4f,
    0x42,
    0x4f,
    0x54,
    0x53,
    0x5f,
    0x55,
    0x4e,
    0x52,
    0x45,
    0x41,
    0x43,
    0x48,
    0x41,
    0x42,
    0x4c,
    0x45,
    0x98,
    0x01,
    0x21,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x52,
    0x4f,
    0x42,
    0x4f,
    0x54,
    0x53,
    0x5f,
    0x46,
    0x4f,
    0x52,
    0x42,
    0x49,
    0x44,
    0x44,
    0x45,
    0x4e,
    0x98,
    0x01,
    0x22,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x54,
    0x45,
    0x4d,
    0x50,
    0x5f,
    0x44,
    0x4e,
    0x53,
    0x5f,
    0x46,
    0x41,
    0x49,
    0x4c,
    0x55,
    0x52,
    0x45,
    0x98,
    0x01,
    0x23,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x43,
    0x4f,
    0x4e,
    0x4e,
    0x45,
    0x43,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x46,
    0x41,
    0x49,
    0x4c,
    0x55,
    0x52,
    0x45,
    0x98,
    0x01,
    0x24,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x43,
    0x4f,
    0x4e,
    0x4e,
    0x45,
    0x43,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x54,
    0x49,
    0x4d,
    0x45,
    0x4f,
    0x55,
    0x54,
    0x98,
    0x01,
    0x25,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x43,
    0x4f,
    0x4e,
    0x4e,
    0x45,
    0x43,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x43,
    0x4c,
    0x4f,
    0x53,
    0x45,
    0x44,
    0x98,
    0x01,
    0x26,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x42,
    0x52,
    0x4f,
    0x4b,
    0x45,
    0x4e,
    0x5f,
    0x50,
    0x49,
    0x50,
    0x45,
    0x98,
    0x01,
    0x27,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x43,
    0x4f,
    0x4e,
    0x4e,
    0x45,
    0x43,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x52,
    0x45,
    0x46,
    0x55,
    0x53,
    0x45,
    0x44,
    0x98,
    0x01,
    0x28,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x43,
    0x4f,
    0x4e,
    0x4e,
    0x45,
    0x43,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x52,
    0x45,
    0x53,
    0x45,
    0x54,
    0x98,
    0x01,
    0x29,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x13,
    0x4e,
    0x45,
    0x54,
    0x57,
    0x4f,
    0x52,
    0x4b,
    0x5f,
    0x55,
    0x4e,
    0x52,
    0x45,
    0x41,
    0x43,
    0x48,
    0x41,
    0x42,
    0x4c,
    0x45,
    0x98,
    0x01,
    0x2a,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x4e,
    0x4f,
    0x5f,
    0x52,
    0x4f,
    0x55,
    0x54,
    0x45,
    0x5f,
    0x54,
    0x4f,
    0x5f,
    0x48,
    0x4f,
    0x53,
    0x54,
    0x98,
    0x01,
    0x2b,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x19,
    0x49,
    0x4e,
    0x54,
    0x45,
    0x52,
    0x4e,
    0x41,
    0x4c,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x56,
    0x45,
    0x52,
    0x54,
    0x5f,
    0x54,
    0x4f,
    0x5f,
    0x52,
    0x45,
    0x50,
    0x4f,
    0x53,
    0x98,
    0x01,
    0x2c,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x52,
    0x45,
    0x44,
    0x49,
    0x52,
    0x45,
    0x43,
    0x54,
    0x98,
    0x01,
    0x2d,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x55,
    0x52,
    0x4c,
    0x5f,
    0x52,
    0x45,
    0x57,
    0x52,
    0x49,
    0x54,
    0x54,
    0x45,
    0x4e,
    0x98,
    0x01,
    0x2e,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x41,
    0x53,
    0x53,
    0x55,
    0x4d,
    0x49,
    0x4e,
    0x47,
    0x5f,
    0x48,
    0x54,
    0x54,
    0x50,
    0x98,
    0x01,
    0x2f,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x16,
    0x43,
    0x41,
    0x4e,
    0x4f,
    0x4e,
    0x49,
    0x43,
    0x41,
    0x4c,
    0x49,
    0x5a,
    0x45,
    0x44,
    0x5f,
    0x44,
    0x55,
    0x50,
    0x5f,
    0x48,
    0x4f,
    0x53,
    0x54,
    0x98,
    0x01,
    0x30,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x52,
    0x4f,
    0x42,
    0x4f,
    0x54,
    0x53,
    0x5f,
    0x4d,
    0x49,
    0x53,
    0x43,
    0x98,
    0x01,
    0x31,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x45,
    0x52,
    0x52,
    0x4f,
    0x52,
    0x5f,
    0x4d,
    0x49,
    0x53,
    0x43,
    0x98,
    0x01,
    0x32,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x55,
    0x4e,
    0x52,
    0x45,
    0x41,
    0x43,
    0x48,
    0x41,
    0x42,
    0x4c,
    0x45,
    0x5f,
    0x4d,
    0x49,
    0x53,
    0x43,
    0x98,
    0x01,
    0x33,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x49,
    0x4e,
    0x56,
    0x41,
    0x4c,
    0x49,
    0x44,
    0x98,
    0x01,
    0x34,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x4e,
    0x4f,
    0x54,
    0x5f,
    0x4c,
    0x45,
    0x47,
    0x41,
    0x4c,
    0x5f,
    0x48,
    0x4f,
    0x53,
    0x54,
    0x4e,
    0x41,
    0x4d,
    0x45,
    0x98,
    0x01,
    0x35,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x43,
    0x52,
    0x41,
    0x57,
    0x4c,
    0x45,
    0x44,
    0x5f,
    0x46,
    0x45,
    0x45,
    0x44,
    0x98,
    0x01,
    0x36,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x44,
    0x4f,
    0x43,
    0x55,
    0x4d,
    0x45,
    0x4e,
    0x54,
    0x5f,
    0x41,
    0x52,
    0x43,
    0x48,
    0x49,
    0x56,
    0x45,
    0x44,
    0x98,
    0x01,
    0x37,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x46,
    0x41,
    0x49,
    0x4c,
    0x45,
    0x44,
    0x5f,
    0x4c,
    0x4f,
    0x43,
    0x41,
    0x4c,
    0x5f,
    0x46,
    0x45,
    0x54,
    0x43,
    0x48,
    0x98,
    0x01,
    0x38,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x16,
    0x42,
    0x4c,
    0x4f,
    0x47,
    0x5f,
    0x55,
    0x4e,
    0x48,
    0x41,
    0x4e,
    0x44,
    0x4c,
    0x45,
    0x44,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x54,
    0x45,
    0x4e,
    0x54,
    0x98,
    0x01,
    0x39,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x14,
    0x46,
    0x49,
    0x4c,
    0x45,
    0x5f,
    0x53,
    0x49,
    0x5a,
    0x45,
    0x5f,
    0x4f,
    0x56,
    0x45,
    0x52,
    0x5f,
    0x4c,
    0x49,
    0x4d,
    0x49,
    0x54,
    0x98,
    0x01,
    0x3a,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x4e,
    0x55,
    0x4d,
    0x5f,
    0x53,
    0x54,
    0x41,
    0x54,
    0x45,
    0x53,
    0x98,
    0x01,
    0x3b,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class TrackerGathererCommand_AddUrl(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.urldata_ = UrlTrackerData()
    self.epochnum_ = 0
    self.has_urldata_ = 0
    self.has_epochnum_ = 0
    if contents is not None: self.MergeFromString(contents)

  def urldata(self): return self.urldata_

  def mutable_urldata(self): self.has_urldata_ = 1; return self.urldata_

  def clear_urldata(self):self.has_urldata_ = 0; self.urldata_.Clear()

  def has_urldata(self): return self.has_urldata_

  def epochnum(self): return self.epochnum_

  def set_epochnum(self, x):
    self.has_epochnum_ = 1
    self.epochnum_ = x

  def clear_epochnum(self):
    self.has_epochnum_ = 0
    self.epochnum_ = 0

  def has_epochnum(self): return self.has_epochnum_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_urldata()): self.mutable_urldata().MergeFrom(x.urldata())
    if (x.has_epochnum()): self.set_epochnum(x.epochnum())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'TrackerGathererCommand', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'TrackerGathererCommand')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'TrackerGathererCommand', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'TrackerGathererCommand', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'TrackerGathererCommand', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_urldata_ != x.has_urldata_: return 0
    if self.has_urldata_ and self.urldata_ != x.urldata_: return 0
    if self.has_epochnum_ != x.has_epochnum_: return 0
    if self.has_epochnum_ and self.epochnum_ != x.epochnum_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_urldata_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: urldata not set.')
    elif not self.urldata_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.urldata_.ByteSize())
    if (self.has_epochnum_): n += 1 + self.lengthVarInt64(self.epochnum_)
    return n + 1

  def Clear(self):
    self.clear_urldata()
    self.clear_epochnum()

  def OutputUnchecked(self, out):
    out.putVarInt32(26)
    out.putVarInt32(self.urldata_.ByteSize())
    self.urldata_.OutputUnchecked(out)
    if (self.has_epochnum_):
      out.putVarInt32(32)
      out.putVarInt32(self.epochnum_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_urldata().TryMerge(tmp)
        continue
      if tt == 32:
        self.set_epochnum(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_urldata_:
      res+=prefix+"UrlData <\n"
      res+=self.urldata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_epochnum_: res+=prefix+("EpochNum: %s\n" % self.DebugFormatInt32(self.epochnum_))
    return res

class TrackerGathererCommand_DiscardBeforeEpoch(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.epochnum_ = 0
    self.has_epochnum_ = 0
    if contents is not None: self.MergeFromString(contents)

  def epochnum(self): return self.epochnum_

  def set_epochnum(self, x):
    self.has_epochnum_ = 1
    self.epochnum_ = x

  def clear_epochnum(self):
    self.has_epochnum_ = 0
    self.epochnum_ = 0

  def has_epochnum(self): return self.has_epochnum_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_epochnum()): self.set_epochnum(x.epochnum())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'TrackerGathererCommand', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'TrackerGathererCommand')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'TrackerGathererCommand', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'TrackerGathererCommand', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'TrackerGathererCommand', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_epochnum_ != x.has_epochnum_: return 0
    if self.has_epochnum_ and self.epochnum_ != x.epochnum_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_epochnum_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: epochnum not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.epochnum_)
    return n + 1

  def Clear(self):
    self.clear_epochnum()

  def OutputUnchecked(self, out):
    out.putVarInt32(48)
    out.putVarInt32(self.epochnum_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 44: break
      if tt == 48:
        self.set_epochnum(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_epochnum_: res+=prefix+("EpochNum: %s\n" % self.DebugFormatInt32(self.epochnum_))
    return res

class TrackerGathererCommand(ProtocolBuffer.ProtocolMessage):

  ADD_URL      =    0 
  DISCARD_BEFORE_EPOCH =    1 
  HEARTBEAT    =    2 

  _CommandType_NAMES = {
    0: "ADD_URL",
    1: "DISCARD_BEFORE_EPOCH",
    2: "HEARTBEAT",
  }

  def CommandType_Name(cls, x): return cls._CommandType_NAMES.get(x, "")
  CommandType_Name = classmethod(CommandType_Name)

  def __init__(self, contents=None):
    self.commandtype_ = 0
    self.addurl_ = []
    self.discardbeforeepoch_ = None
    self.has_commandtype_ = 0
    self.has_discardbeforeepoch_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def commandtype(self): return self.commandtype_

  def set_commandtype(self, x):
    self.has_commandtype_ = 1
    self.commandtype_ = x

  def clear_commandtype(self):
    self.has_commandtype_ = 0
    self.commandtype_ = 0

  def has_commandtype(self): return self.has_commandtype_

  def addurl_size(self): return len(self.addurl_)
  def addurl_list(self): return self.addurl_

  def addurl(self, i):
    return self.addurl_[i]

  def mutable_addurl(self, i):
    return self.addurl_[i]

  def add_addurl(self):
    x = TrackerGathererCommand_AddUrl()
    self.addurl_.append(x)
    return x

  def clear_addurl(self):
    self.addurl_ = []
  def discardbeforeepoch(self):
    if self.discardbeforeepoch_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.discardbeforeepoch_ is None: self.discardbeforeepoch_ = TrackerGathererCommand_DiscardBeforeEpoch()
      finally:
        self.lazy_init_lock_.release()
    return self.discardbeforeepoch_

  def mutable_discardbeforeepoch(self): self.has_discardbeforeepoch_ = 1; return self.discardbeforeepoch()

  def clear_discardbeforeepoch(self):
    #Warning: this method does not acquire the lock.
    self.has_discardbeforeepoch_ = 0;
    if self.discardbeforeepoch_ is not None: self.discardbeforeepoch_.Clear()

  def has_discardbeforeepoch(self): return self.has_discardbeforeepoch_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_commandtype()): self.set_commandtype(x.commandtype())
    for i in xrange(x.addurl_size()): self.add_addurl().CopyFrom(x.addurl(i))
    if (x.has_discardbeforeepoch()): self.mutable_discardbeforeepoch().MergeFrom(x.discardbeforeepoch())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'TrackerGathererCommand', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'TrackerGathererCommand')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'TrackerGathererCommand', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'TrackerGathererCommand', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'TrackerGathererCommand', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_commandtype_ != x.has_commandtype_: return 0
    if self.has_commandtype_ and self.commandtype_ != x.commandtype_: return 0
    if len(self.addurl_) != len(x.addurl_): return 0
    for e1, e2 in zip(self.addurl_, x.addurl_):
      if e1 != e2: return 0
    if self.has_discardbeforeepoch_ != x.has_discardbeforeepoch_: return 0
    if self.has_discardbeforeepoch_ and self.discardbeforeepoch_ != x.discardbeforeepoch_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_commandtype_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: commandtype not set.')
    for i in xrange(len(self.addurl_)):
      if (not self.addurl_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_discardbeforeepoch_ and not self.discardbeforeepoch_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.commandtype_)
    n += 2 * len(self.addurl_)
    for i in xrange(len(self.addurl_)): n += self.addurl_[i].ByteSize()
    if (self.has_discardbeforeepoch_): n += 2 + self.discardbeforeepoch_.ByteSize()
    return n + 1

  def Clear(self):
    self.clear_commandtype()
    self.clear_addurl()
    self.clear_discardbeforeepoch()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.commandtype_)
    for i in xrange(len(self.addurl_)):
      out.putVarInt32(19)
      self.addurl_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    if (self.has_discardbeforeepoch_):
      out.putVarInt32(43)
      self.discardbeforeepoch_.OutputUnchecked(out)
      out.putVarInt32(44)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_commandtype(d.getVarInt32())
        continue
      if tt == 19:
        self.add_addurl().TryMerge(d)
        continue
      if tt == 43:
        self.mutable_discardbeforeepoch().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_commandtype_: res+=prefix+("CommandType: %s\n" % self.DebugFormatInt32(self.commandtype_))
    cnt=0
    for e in self.addurl_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("AddUrl%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_discardbeforeepoch_:
      res+=prefix+"DiscardBeforeEpoch {\n"
      res+=self.discardbeforeepoch_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    return res

  kCommandType = 1
  kAddUrlGroup = 2
  kAddUrlUrlData = 3
  kAddUrlEpochNum = 4
  kDiscardBeforeEpochGroup = 5
  kDiscardBeforeEpochEpochNum = 6

  _TEXT = (
   "ErrorCode",  #   0
   "CommandType",  #   1
   "AddUrl",  #   2
   "UrlData",  #   3
   "EpochNum",  #   4
   "DiscardBeforeEpoch",  #   5
   "EpochNum",  #   6
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.STARTGROUP,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x20,
    0x77,
    0x65,
    0x62,
    0x75,
    0x74,
    0x69,
    0x6c,
    0x2f,
    0x75,
    0x72,
    0x6c,
    0x2f,
    0x75,
    0x72,
    0x6c,
    0x74,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x16,
    0x54,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x47,
    0x61,
    0x74,
    0x68,
    0x65,
    0x72,
    0x65,
    0x72,
    0x43,
    0x6f,
    0x6d,
    0x6d,
    0x61,
    0x6e,
    0x64,
    0x13,
    0x1a,
    0x0b,
    0x43,
    0x6f,
    0x6d,
    0x6d,
    0x61,
    0x6e,
    0x64,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x41,
    0x64,
    0x64,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x41,
    0x64,
    0x64,
    0x55,
    0x72,
    0x6c,
    0x2e,
    0x55,
    0x72,
    0x6c,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x0e,
    0x55,
    0x72,
    0x6c,
    0x54,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x44,
    0x61,
    0x74,
    0x61,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x41,
    0x64,
    0x64,
    0x55,
    0x72,
    0x6c,
    0x2e,
    0x45,
    0x70,
    0x6f,
    0x63,
    0x68,
    0x4e,
    0x75,
    0x6d,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x44,
    0x69,
    0x73,
    0x63,
    0x61,
    0x72,
    0x64,
    0x42,
    0x65,
    0x66,
    0x6f,
    0x72,
    0x65,
    0x45,
    0x70,
    0x6f,
    0x63,
    0x68,
    0x20,
    0x05,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x44,
    0x69,
    0x73,
    0x63,
    0x61,
    0x72,
    0x64,
    0x42,
    0x65,
    0x66,
    0x6f,
    0x72,
    0x65,
    0x45,
    0x70,
    0x6f,
    0x63,
    0x68,
    0x2e,
    0x45,
    0x70,
    0x6f,
    0x63,
    0x68,
    0x4e,
    0x75,
    0x6d,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x04,
    0x14,
    0x73,
    0x7a,
    0x0b,
    0x43,
    0x6f,
    0x6d,
    0x6d,
    0x61,
    0x6e,
    0x64,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x41,
    0x44,
    0x44,
    0x5f,
    0x55,
    0x52,
    0x4c,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x14,
    0x44,
    0x49,
    0x53,
    0x43,
    0x41,
    0x52,
    0x44,
    0x5f,
    0x42,
    0x45,
    0x46,
    0x4f,
    0x52,
    0x45,
    0x5f,
    0x45,
    0x50,
    0x4f,
    0x43,
    0x48,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x48,
    0x45,
    0x41,
    0x52,
    0x54,
    0x42,
    0x45,
    0x41,
    0x54,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class UrlTrackerServerCommand(ProtocolBuffer.ProtocolMessage):

  CMD_DIR_INFO =    0 
  CMD_DIR_BROWSE =    1 
  CMD_FILE_BROWSE =    2 
  CMD_DOMAIN_INFO =    3 
  CMD_CONTENTTYPE_STATS =    4 

  _CmdType_NAMES = {
    0: "CMD_DIR_INFO",
    1: "CMD_DIR_BROWSE",
    2: "CMD_FILE_BROWSE",
    3: "CMD_DOMAIN_INFO",
    4: "CMD_CONTENTTYPE_STATS",
  }

  def CmdType_Name(cls, x): return cls._CmdType_NAMES.get(x, "")
  CmdType_Name = classmethod(CmdType_Name)


  OUTPUT_PROTOCOL_BUFFER =    0 
  OUTPUT_ASCII =    1 

  _OutputType_NAMES = {
    0: "OUTPUT_PROTOCOL_BUFFER",
    1: "OUTPUT_ASCII",
  }

  def OutputType_Name(cls, x): return cls._OutputType_NAMES.get(x, "")
  OutputType_Name = classmethod(OutputType_Name)

  def __init__(self, contents=None):
    self.cmd_ = 0
    self.path_ = ""
    self.output_type_ = 0
    self.filefilter_ = ""
    self.dirfilter_ = ""
    self.dirsort_ = ""
    self.filesort_ = ""
    self.setfilter_ = ""
    self.dir_start_ = 0
    self.dir_num_ = 25
    self.file_start_ = 0
    self.file_num_ = 25
    self.skiplevel1_ = 0
    self.filequick_ = 0
    self.dirquick_ = 0
    self.partial_match_ = 0
    self.has_cmd_ = 0
    self.has_path_ = 0
    self.has_output_type_ = 0
    self.has_filefilter_ = 0
    self.has_dirfilter_ = 0
    self.has_dirsort_ = 0
    self.has_filesort_ = 0
    self.has_setfilter_ = 0
    self.has_dir_start_ = 0
    self.has_dir_num_ = 0
    self.has_file_start_ = 0
    self.has_file_num_ = 0
    self.has_skiplevel1_ = 0
    self.has_filequick_ = 0
    self.has_dirquick_ = 0
    self.has_partial_match_ = 0
    if contents is not None: self.MergeFromString(contents)

  def cmd(self): return self.cmd_

  def set_cmd(self, x):
    self.has_cmd_ = 1
    self.cmd_ = x

  def clear_cmd(self):
    self.has_cmd_ = 0
    self.cmd_ = 0

  def has_cmd(self): return self.has_cmd_

  def path(self): return self.path_

  def set_path(self, x):
    self.has_path_ = 1
    self.path_ = x

  def clear_path(self):
    self.has_path_ = 0
    self.path_ = ""

  def has_path(self): return self.has_path_

  def output_type(self): return self.output_type_

  def set_output_type(self, x):
    self.has_output_type_ = 1
    self.output_type_ = x

  def clear_output_type(self):
    self.has_output_type_ = 0
    self.output_type_ = 0

  def has_output_type(self): return self.has_output_type_

  def filefilter(self): return self.filefilter_

  def set_filefilter(self, x):
    self.has_filefilter_ = 1
    self.filefilter_ = x

  def clear_filefilter(self):
    self.has_filefilter_ = 0
    self.filefilter_ = ""

  def has_filefilter(self): return self.has_filefilter_

  def dirfilter(self): return self.dirfilter_

  def set_dirfilter(self, x):
    self.has_dirfilter_ = 1
    self.dirfilter_ = x

  def clear_dirfilter(self):
    self.has_dirfilter_ = 0
    self.dirfilter_ = ""

  def has_dirfilter(self): return self.has_dirfilter_

  def dirsort(self): return self.dirsort_

  def set_dirsort(self, x):
    self.has_dirsort_ = 1
    self.dirsort_ = x

  def clear_dirsort(self):
    self.has_dirsort_ = 0
    self.dirsort_ = ""

  def has_dirsort(self): return self.has_dirsort_

  def filesort(self): return self.filesort_

  def set_filesort(self, x):
    self.has_filesort_ = 1
    self.filesort_ = x

  def clear_filesort(self):
    self.has_filesort_ = 0
    self.filesort_ = ""

  def has_filesort(self): return self.has_filesort_

  def setfilter(self): return self.setfilter_

  def set_setfilter(self, x):
    self.has_setfilter_ = 1
    self.setfilter_ = x

  def clear_setfilter(self):
    self.has_setfilter_ = 0
    self.setfilter_ = ""

  def has_setfilter(self): return self.has_setfilter_

  def dir_start(self): return self.dir_start_

  def set_dir_start(self, x):
    self.has_dir_start_ = 1
    self.dir_start_ = x

  def clear_dir_start(self):
    self.has_dir_start_ = 0
    self.dir_start_ = 0

  def has_dir_start(self): return self.has_dir_start_

  def dir_num(self): return self.dir_num_

  def set_dir_num(self, x):
    self.has_dir_num_ = 1
    self.dir_num_ = x

  def clear_dir_num(self):
    self.has_dir_num_ = 0
    self.dir_num_ = 25

  def has_dir_num(self): return self.has_dir_num_

  def file_start(self): return self.file_start_

  def set_file_start(self, x):
    self.has_file_start_ = 1
    self.file_start_ = x

  def clear_file_start(self):
    self.has_file_start_ = 0
    self.file_start_ = 0

  def has_file_start(self): return self.has_file_start_

  def file_num(self): return self.file_num_

  def set_file_num(self, x):
    self.has_file_num_ = 1
    self.file_num_ = x

  def clear_file_num(self):
    self.has_file_num_ = 0
    self.file_num_ = 25

  def has_file_num(self): return self.has_file_num_

  def skiplevel1(self): return self.skiplevel1_

  def set_skiplevel1(self, x):
    self.has_skiplevel1_ = 1
    self.skiplevel1_ = x

  def clear_skiplevel1(self):
    self.has_skiplevel1_ = 0
    self.skiplevel1_ = 0

  def has_skiplevel1(self): return self.has_skiplevel1_

  def filequick(self): return self.filequick_

  def set_filequick(self, x):
    self.has_filequick_ = 1
    self.filequick_ = x

  def clear_filequick(self):
    self.has_filequick_ = 0
    self.filequick_ = 0

  def has_filequick(self): return self.has_filequick_

  def dirquick(self): return self.dirquick_

  def set_dirquick(self, x):
    self.has_dirquick_ = 1
    self.dirquick_ = x

  def clear_dirquick(self):
    self.has_dirquick_ = 0
    self.dirquick_ = 0

  def has_dirquick(self): return self.has_dirquick_

  def partial_match(self): return self.partial_match_

  def set_partial_match(self, x):
    self.has_partial_match_ = 1
    self.partial_match_ = x

  def clear_partial_match(self):
    self.has_partial_match_ = 0
    self.partial_match_ = 0

  def has_partial_match(self): return self.has_partial_match_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_cmd()): self.set_cmd(x.cmd())
    if (x.has_path()): self.set_path(x.path())
    if (x.has_output_type()): self.set_output_type(x.output_type())
    if (x.has_filefilter()): self.set_filefilter(x.filefilter())
    if (x.has_dirfilter()): self.set_dirfilter(x.dirfilter())
    if (x.has_dirsort()): self.set_dirsort(x.dirsort())
    if (x.has_filesort()): self.set_filesort(x.filesort())
    if (x.has_setfilter()): self.set_setfilter(x.setfilter())
    if (x.has_dir_start()): self.set_dir_start(x.dir_start())
    if (x.has_dir_num()): self.set_dir_num(x.dir_num())
    if (x.has_file_start()): self.set_file_start(x.file_start())
    if (x.has_file_num()): self.set_file_num(x.file_num())
    if (x.has_skiplevel1()): self.set_skiplevel1(x.skiplevel1())
    if (x.has_filequick()): self.set_filequick(x.filequick())
    if (x.has_dirquick()): self.set_dirquick(x.dirquick())
    if (x.has_partial_match()): self.set_partial_match(x.partial_match())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'UrlTrackerServerCommand', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'UrlTrackerServerCommand')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'UrlTrackerServerCommand', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'UrlTrackerServerCommand', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'UrlTrackerServerCommand', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_cmd_ != x.has_cmd_: return 0
    if self.has_cmd_ and self.cmd_ != x.cmd_: return 0
    if self.has_path_ != x.has_path_: return 0
    if self.has_path_ and self.path_ != x.path_: return 0
    if self.has_output_type_ != x.has_output_type_: return 0
    if self.has_output_type_ and self.output_type_ != x.output_type_: return 0
    if self.has_filefilter_ != x.has_filefilter_: return 0
    if self.has_filefilter_ and self.filefilter_ != x.filefilter_: return 0
    if self.has_dirfilter_ != x.has_dirfilter_: return 0
    if self.has_dirfilter_ and self.dirfilter_ != x.dirfilter_: return 0
    if self.has_dirsort_ != x.has_dirsort_: return 0
    if self.has_dirsort_ and self.dirsort_ != x.dirsort_: return 0
    if self.has_filesort_ != x.has_filesort_: return 0
    if self.has_filesort_ and self.filesort_ != x.filesort_: return 0
    if self.has_setfilter_ != x.has_setfilter_: return 0
    if self.has_setfilter_ and self.setfilter_ != x.setfilter_: return 0
    if self.has_dir_start_ != x.has_dir_start_: return 0
    if self.has_dir_start_ and self.dir_start_ != x.dir_start_: return 0
    if self.has_dir_num_ != x.has_dir_num_: return 0
    if self.has_dir_num_ and self.dir_num_ != x.dir_num_: return 0
    if self.has_file_start_ != x.has_file_start_: return 0
    if self.has_file_start_ and self.file_start_ != x.file_start_: return 0
    if self.has_file_num_ != x.has_file_num_: return 0
    if self.has_file_num_ and self.file_num_ != x.file_num_: return 0
    if self.has_skiplevel1_ != x.has_skiplevel1_: return 0
    if self.has_skiplevel1_ and self.skiplevel1_ != x.skiplevel1_: return 0
    if self.has_filequick_ != x.has_filequick_: return 0
    if self.has_filequick_ and self.filequick_ != x.filequick_: return 0
    if self.has_dirquick_ != x.has_dirquick_: return 0
    if self.has_dirquick_ and self.dirquick_ != x.dirquick_: return 0
    if self.has_partial_match_ != x.has_partial_match_: return 0
    if self.has_partial_match_ and self.partial_match_ != x.partial_match_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_cmd_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: cmd not set.')
    if (not self.has_path_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: path not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.cmd_)
    n += self.lengthString(len(self.path_))
    if (self.has_output_type_): n += 1 + self.lengthVarInt64(self.output_type_)
    if (self.has_filefilter_): n += 1 + self.lengthString(len(self.filefilter_))
    if (self.has_dirfilter_): n += 1 + self.lengthString(len(self.dirfilter_))
    if (self.has_dirsort_): n += 1 + self.lengthString(len(self.dirsort_))
    if (self.has_filesort_): n += 1 + self.lengthString(len(self.filesort_))
    if (self.has_setfilter_): n += 1 + self.lengthString(len(self.setfilter_))
    if (self.has_dir_start_): n += 1 + self.lengthVarInt64(self.dir_start_)
    if (self.has_dir_num_): n += 1 + self.lengthVarInt64(self.dir_num_)
    if (self.has_file_start_): n += 1 + self.lengthVarInt64(self.file_start_)
    if (self.has_file_num_): n += 1 + self.lengthVarInt64(self.file_num_)
    if (self.has_skiplevel1_): n += 2
    if (self.has_filequick_): n += 1 + self.lengthVarInt64(self.filequick_)
    if (self.has_dirquick_): n += 1 + self.lengthVarInt64(self.dirquick_)
    if (self.has_partial_match_): n += 3
    return n + 2

  def Clear(self):
    self.clear_cmd()
    self.clear_path()
    self.clear_output_type()
    self.clear_filefilter()
    self.clear_dirfilter()
    self.clear_dirsort()
    self.clear_filesort()
    self.clear_setfilter()
    self.clear_dir_start()
    self.clear_dir_num()
    self.clear_file_start()
    self.clear_file_num()
    self.clear_skiplevel1()
    self.clear_filequick()
    self.clear_dirquick()
    self.clear_partial_match()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.cmd_)
    out.putVarInt32(18)
    out.putPrefixedString(self.path_)
    if (self.has_output_type_):
      out.putVarInt32(24)
      out.putVarInt32(self.output_type_)
    if (self.has_filefilter_):
      out.putVarInt32(34)
      out.putPrefixedString(self.filefilter_)
    if (self.has_dirfilter_):
      out.putVarInt32(42)
      out.putPrefixedString(self.dirfilter_)
    if (self.has_dirsort_):
      out.putVarInt32(50)
      out.putPrefixedString(self.dirsort_)
    if (self.has_setfilter_):
      out.putVarInt32(58)
      out.putPrefixedString(self.setfilter_)
    if (self.has_dir_start_):
      out.putVarInt32(64)
      out.putVarInt32(self.dir_start_)
    if (self.has_dir_num_):
      out.putVarInt32(72)
      out.putVarInt32(self.dir_num_)
    if (self.has_file_start_):
      out.putVarInt32(80)
      out.putVarInt32(self.file_start_)
    if (self.has_file_num_):
      out.putVarInt32(88)
      out.putVarInt32(self.file_num_)
    if (self.has_filesort_):
      out.putVarInt32(98)
      out.putPrefixedString(self.filesort_)
    if (self.has_skiplevel1_):
      out.putVarInt32(104)
      out.putBoolean(self.skiplevel1_)
    if (self.has_filequick_):
      out.putVarInt32(112)
      out.putVarInt32(self.filequick_)
    if (self.has_dirquick_):
      out.putVarInt32(120)
      out.putVarInt32(self.dirquick_)
    if (self.has_partial_match_):
      out.putVarInt32(128)
      out.putBoolean(self.partial_match_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_cmd(d.getVarInt32())
        continue
      if tt == 18:
        self.set_path(d.getPrefixedString())
        continue
      if tt == 24:
        self.set_output_type(d.getVarInt32())
        continue
      if tt == 34:
        self.set_filefilter(d.getPrefixedString())
        continue
      if tt == 42:
        self.set_dirfilter(d.getPrefixedString())
        continue
      if tt == 50:
        self.set_dirsort(d.getPrefixedString())
        continue
      if tt == 58:
        self.set_setfilter(d.getPrefixedString())
        continue
      if tt == 64:
        self.set_dir_start(d.getVarInt32())
        continue
      if tt == 72:
        self.set_dir_num(d.getVarInt32())
        continue
      if tt == 80:
        self.set_file_start(d.getVarInt32())
        continue
      if tt == 88:
        self.set_file_num(d.getVarInt32())
        continue
      if tt == 98:
        self.set_filesort(d.getPrefixedString())
        continue
      if tt == 104:
        self.set_skiplevel1(d.getBoolean())
        continue
      if tt == 112:
        self.set_filequick(d.getVarInt32())
        continue
      if tt == 120:
        self.set_dirquick(d.getVarInt32())
        continue
      if tt == 128:
        self.set_partial_match(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_cmd_: res+=prefix+("cmd: %s\n" % self.DebugFormatInt32(self.cmd_))
    if self.has_path_: res+=prefix+("path: %s\n" % self.DebugFormatString(self.path_))
    if self.has_output_type_: res+=prefix+("output_type: %s\n" % self.DebugFormatInt32(self.output_type_))
    if self.has_filefilter_: res+=prefix+("filefilter: %s\n" % self.DebugFormatString(self.filefilter_))
    if self.has_dirfilter_: res+=prefix+("dirfilter: %s\n" % self.DebugFormatString(self.dirfilter_))
    if self.has_dirsort_: res+=prefix+("dirsort: %s\n" % self.DebugFormatString(self.dirsort_))
    if self.has_filesort_: res+=prefix+("filesort: %s\n" % self.DebugFormatString(self.filesort_))
    if self.has_setfilter_: res+=prefix+("setfilter: %s\n" % self.DebugFormatString(self.setfilter_))
    if self.has_dir_start_: res+=prefix+("dir_start: %s\n" % self.DebugFormatInt32(self.dir_start_))
    if self.has_dir_num_: res+=prefix+("dir_num: %s\n" % self.DebugFormatInt32(self.dir_num_))
    if self.has_file_start_: res+=prefix+("file_start: %s\n" % self.DebugFormatInt32(self.file_start_))
    if self.has_file_num_: res+=prefix+("file_num: %s\n" % self.DebugFormatInt32(self.file_num_))
    if self.has_skiplevel1_: res+=prefix+("skiplevel1: %s\n" % self.DebugFormatBool(self.skiplevel1_))
    if self.has_filequick_: res+=prefix+("filequick: %s\n" % self.DebugFormatInt32(self.filequick_))
    if self.has_dirquick_: res+=prefix+("dirquick: %s\n" % self.DebugFormatInt32(self.dirquick_))
    if self.has_partial_match_: res+=prefix+("partial_match: %s\n" % self.DebugFormatBool(self.partial_match_))
    return res

  kcmd = 1
  kpath = 2
  koutput_type = 3
  kfilefilter = 4
  kdirfilter = 5
  kdirsort = 6
  kfilesort = 12
  ksetfilter = 7
  kdir_start = 8
  kdir_num = 9
  kfile_start = 10
  kfile_num = 11
  kskiplevel1 = 13
  kfilequick = 14
  kdirquick = 15
  kpartial_match = 16

  _TEXT = (
   "ErrorCode",  #   0
   "cmd",  #   1
   "path",  #   2
   "output_type",  #   3
   "filefilter",  #   4
   "dirfilter",  #   5
   "dirsort",  #   6
   "setfilter",  #   7
   "dir_start",  #   8
   "dir_num",  #   9
   "file_start",  #  10
   "file_num",  #  11
   "filesort",  #  12
   "skiplevel1",  #  13
   "filequick",  #  14
   "dirquick",  #  15
   "partial_match",  #  16
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.STRING,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.NUMERIC,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

   ProtocolBuffer.Encoder.STRING,  #  12

   ProtocolBuffer.Encoder.NUMERIC,  #  13

   ProtocolBuffer.Encoder.NUMERIC,  #  14

   ProtocolBuffer.Encoder.NUMERIC,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x20,
    0x77,
    0x65,
    0x62,
    0x75,
    0x74,
    0x69,
    0x6c,
    0x2f,
    0x75,
    0x72,
    0x6c,
    0x2f,
    0x75,
    0x72,
    0x6c,
    0x74,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x17,
    0x55,
    0x72,
    0x6c,
    0x54,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x53,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x43,
    0x6f,
    0x6d,
    0x6d,
    0x61,
    0x6e,
    0x64,
    0x13,
    0x1a,
    0x03,
    0x63,
    0x6d,
    0x64,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x70,
    0x61,
    0x74,
    0x68,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x6f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x66,
    0x69,
    0x6c,
    0x74,
    0x65,
    0x72,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x64,
    0x69,
    0x72,
    0x66,
    0x69,
    0x6c,
    0x74,
    0x65,
    0x72,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x64,
    0x69,
    0x72,
    0x73,
    0x6f,
    0x72,
    0x74,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x73,
    0x6f,
    0x72,
    0x74,
    0x20,
    0x0c,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x73,
    0x65,
    0x74,
    0x66,
    0x69,
    0x6c,
    0x74,
    0x65,
    0x72,
    0x20,
    0x07,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x64,
    0x69,
    0x72,
    0x5f,
    0x73,
    0x74,
    0x61,
    0x72,
    0x74,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x64,
    0x69,
    0x72,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x20,
    0x09,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x02,
    0x32,
    0x35,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x32,
    0x35,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x5f,
    0x73,
    0x74,
    0x61,
    0x72,
    0x74,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x02,
    0x32,
    0x35,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x32,
    0x35,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x73,
    0x6b,
    0x69,
    0x70,
    0x6c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x31,
    0x20,
    0x0d,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x71,
    0x75,
    0x69,
    0x63,
    0x6b,
    0x20,
    0x0e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x64,
    0x69,
    0x72,
    0x71,
    0x75,
    0x69,
    0x63,
    0x6b,
    0x20,
    0x0f,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x70,
    0x61,
    0x72,
    0x74,
    0x69,
    0x61,
    0x6c,
    0x5f,
    0x6d,
    0x61,
    0x74,
    0x63,
    0x68,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x07,
    0x43,
    0x6d,
    0x64,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x43,
    0x4d,
    0x44,
    0x5f,
    0x44,
    0x49,
    0x52,
    0x5f,
    0x49,
    0x4e,
    0x46,
    0x4f,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x43,
    0x4d,
    0x44,
    0x5f,
    0x44,
    0x49,
    0x52,
    0x5f,
    0x42,
    0x52,
    0x4f,
    0x57,
    0x53,
    0x45,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x43,
    0x4d,
    0x44,
    0x5f,
    0x46,
    0x49,
    0x4c,
    0x45,
    0x5f,
    0x42,
    0x52,
    0x4f,
    0x57,
    0x53,
    0x45,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x43,
    0x4d,
    0x44,
    0x5f,
    0x44,
    0x4f,
    0x4d,
    0x41,
    0x49,
    0x4e,
    0x5f,
    0x49,
    0x4e,
    0x46,
    0x4f,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x15,
    0x43,
    0x4d,
    0x44,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x54,
    0x45,
    0x4e,
    0x54,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x53,
    0x54,
    0x41,
    0x54,
    0x53,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x0a,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x16,
    0x4f,
    0x55,
    0x54,
    0x50,
    0x55,
    0x54,
    0x5f,
    0x50,
    0x52,
    0x4f,
    0x54,
    0x4f,
    0x43,
    0x4f,
    0x4c,
    0x5f,
    0x42,
    0x55,
    0x46,
    0x46,
    0x45,
    0x52,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x4f,
    0x55,
    0x54,
    0x50,
    0x55,
    0x54,
    0x5f,
    0x41,
    0x53,
    0x43,
    0x49,
    0x49,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class TrackerContentType_Stats(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.mimetype_ = 0
    self.minsize_ = 0
    self.maxsize_ = 0
    self.numfiles_ = 0
    self.totalsize_ = 0
    self.has_mimetype_ = 0
    self.has_minsize_ = 0
    self.has_maxsize_ = 0
    self.has_numfiles_ = 0
    self.has_totalsize_ = 0
    if contents is not None: self.MergeFromString(contents)

  def mimetype(self): return self.mimetype_

  def set_mimetype(self, x):
    self.has_mimetype_ = 1
    self.mimetype_ = x

  def clear_mimetype(self):
    self.has_mimetype_ = 0
    self.mimetype_ = 0

  def has_mimetype(self): return self.has_mimetype_

  def minsize(self): return self.minsize_

  def set_minsize(self, x):
    self.has_minsize_ = 1
    self.minsize_ = x

  def clear_minsize(self):
    self.has_minsize_ = 0
    self.minsize_ = 0

  def has_minsize(self): return self.has_minsize_

  def maxsize(self): return self.maxsize_

  def set_maxsize(self, x):
    self.has_maxsize_ = 1
    self.maxsize_ = x

  def clear_maxsize(self):
    self.has_maxsize_ = 0
    self.maxsize_ = 0

  def has_maxsize(self): return self.has_maxsize_

  def numfiles(self): return self.numfiles_

  def set_numfiles(self, x):
    self.has_numfiles_ = 1
    self.numfiles_ = x

  def clear_numfiles(self):
    self.has_numfiles_ = 0
    self.numfiles_ = 0

  def has_numfiles(self): return self.has_numfiles_

  def totalsize(self): return self.totalsize_

  def set_totalsize(self, x):
    self.has_totalsize_ = 1
    self.totalsize_ = x

  def clear_totalsize(self):
    self.has_totalsize_ = 0
    self.totalsize_ = 0

  def has_totalsize(self): return self.has_totalsize_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_mimetype()): self.set_mimetype(x.mimetype())
    if (x.has_minsize()): self.set_minsize(x.minsize())
    if (x.has_maxsize()): self.set_maxsize(x.maxsize())
    if (x.has_numfiles()): self.set_numfiles(x.numfiles())
    if (x.has_totalsize()): self.set_totalsize(x.totalsize())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'TrackerContentType', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'TrackerContentType')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'TrackerContentType', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'TrackerContentType', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'TrackerContentType', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_mimetype_ != x.has_mimetype_: return 0
    if self.has_mimetype_ and self.mimetype_ != x.mimetype_: return 0
    if self.has_minsize_ != x.has_minsize_: return 0
    if self.has_minsize_ and self.minsize_ != x.minsize_: return 0
    if self.has_maxsize_ != x.has_maxsize_: return 0
    if self.has_maxsize_ and self.maxsize_ != x.maxsize_: return 0
    if self.has_numfiles_ != x.has_numfiles_: return 0
    if self.has_numfiles_ and self.numfiles_ != x.numfiles_: return 0
    if self.has_totalsize_ != x.has_totalsize_: return 0
    if self.has_totalsize_ and self.totalsize_ != x.totalsize_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_mimetype_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: mimetype not set.')
    if (not self.has_minsize_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: minsize not set.')
    if (not self.has_maxsize_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: maxsize not set.')
    if (not self.has_numfiles_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: numfiles not set.')
    if (not self.has_totalsize_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: totalsize not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.mimetype_)
    n += self.lengthVarInt64(self.minsize_)
    n += self.lengthVarInt64(self.maxsize_)
    n += self.lengthVarInt64(self.numfiles_)
    n += self.lengthVarInt64(self.totalsize_)
    return n + 5

  def Clear(self):
    self.clear_mimetype()
    self.clear_minsize()
    self.clear_maxsize()
    self.clear_numfiles()
    self.clear_totalsize()

  def OutputUnchecked(self, out):
    out.putVarInt32(24)
    out.putVarInt32(self.mimetype_)
    out.putVarInt32(32)
    out.putVarInt32(self.minsize_)
    out.putVarInt32(40)
    out.putVarInt32(self.maxsize_)
    out.putVarInt32(48)
    out.putVarInt32(self.numfiles_)
    out.putVarInt32(56)
    out.putVarInt64(self.totalsize_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 24:
        self.set_mimetype(d.getVarInt32())
        continue
      if tt == 32:
        self.set_minsize(d.getVarInt32())
        continue
      if tt == 40:
        self.set_maxsize(d.getVarInt32())
        continue
      if tt == 48:
        self.set_numfiles(d.getVarInt32())
        continue
      if tt == 56:
        self.set_totalsize(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_mimetype_: res+=prefix+("mimeType: %s\n" % self.DebugFormatInt32(self.mimetype_))
    if self.has_minsize_: res+=prefix+("minSize: %s\n" % self.DebugFormatInt32(self.minsize_))
    if self.has_maxsize_: res+=prefix+("maxSize: %s\n" % self.DebugFormatInt32(self.maxsize_))
    if self.has_numfiles_: res+=prefix+("numFiles: %s\n" % self.DebugFormatInt32(self.numfiles_))
    if self.has_totalsize_: res+=prefix+("totalSize: %s\n" % self.DebugFormatInt64(self.totalsize_))
    return res

class TrackerContentType(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.set_ = 0
    self.stats_ = []
    self.has_set_ = 0
    if contents is not None: self.MergeFromString(contents)

  def set(self): return self.set_

  def set_set(self, x):
    self.has_set_ = 1
    self.set_ = x

  def clear_set(self):
    self.has_set_ = 0
    self.set_ = 0

  def has_set(self): return self.has_set_

  def stats_size(self): return len(self.stats_)
  def stats_list(self): return self.stats_

  def stats(self, i):
    return self.stats_[i]

  def mutable_stats(self, i):
    return self.stats_[i]

  def add_stats(self):
    x = TrackerContentType_Stats()
    self.stats_.append(x)
    return x

  def clear_stats(self):
    self.stats_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_set()): self.set_set(x.set())
    for i in xrange(x.stats_size()): self.add_stats().CopyFrom(x.stats(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'TrackerContentType', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'TrackerContentType')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'TrackerContentType', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'TrackerContentType', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'TrackerContentType', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_set_ != x.has_set_: return 0
    if self.has_set_ and self.set_ != x.set_: return 0
    if len(self.stats_) != len(x.stats_): return 0
    for e1, e2 in zip(self.stats_, x.stats_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_set_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: set not set.')
    for i in xrange(len(self.stats_)):
      if (not self.stats_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.set_)
    n += 2 * len(self.stats_)
    for i in xrange(len(self.stats_)): n += self.stats_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_set()
    self.clear_stats()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarUint64(self.set_)
    for i in xrange(len(self.stats_)):
      out.putVarInt32(19)
      self.stats_[i].OutputUnchecked(out)
      out.putVarInt32(20)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_set(d.getVarUint64())
        continue
      if tt == 19:
        self.add_stats().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_set_: res+=prefix+("Set: %s\n" % self.DebugFormatInt64(self.set_))
    cnt=0
    for e in self.stats_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Stats%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kSet = 1
  kStatsGroup = 2
  kStatsmimeType = 3
  kStatsminSize = 4
  kStatsmaxSize = 5
  kStatsnumFiles = 6
  kStatstotalSize = 7

  _TEXT = (
   "ErrorCode",  #   0
   "Set",  #   1
   "Stats",  #   2
   "mimeType",  #   3
   "minSize",  #   4
   "maxSize",  #   5
   "numFiles",  #   6
   "totalSize",  #   7
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x20,
    0x77,
    0x65,
    0x62,
    0x75,
    0x74,
    0x69,
    0x6c,
    0x2f,
    0x75,
    0x72,
    0x6c,
    0x2f,
    0x75,
    0x72,
    0x6c,
    0x74,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x12,
    0x54,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x54,
    0x79,
    0x70,
    0x65,
    0x13,
    0x1a,
    0x03,
    0x53,
    0x65,
    0x74,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x2e,
    0x6d,
    0x69,
    0x6d,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x2e,
    0x6d,
    0x69,
    0x6e,
    0x53,
    0x69,
    0x7a,
    0x65,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x2e,
    0x6d,
    0x61,
    0x78,
    0x53,
    0x69,
    0x7a,
    0x65,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x2e,
    0x6e,
    0x75,
    0x6d,
    0x46,
    0x69,
    0x6c,
    0x65,
    0x73,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x2e,
    0x74,
    0x6f,
    0x74,
    0x61,
    0x6c,
    0x53,
    0x69,
    0x7a,
    0x65,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class UrlTrackerServerResponse_Urls(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.path_ = ""
    self.lastcrawltimestamp_ = 0
    self.authmethod_ = 0
    self.data_ = None
    self.has_path_ = 0
    self.has_lastcrawltimestamp_ = 0
    self.has_authmethod_ = 0
    self.has_data_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def path(self): return self.path_

  def set_path(self, x):
    self.has_path_ = 1
    self.path_ = x

  def clear_path(self):
    self.has_path_ = 0
    self.path_ = ""

  def has_path(self): return self.has_path_

  def lastcrawltimestamp(self): return self.lastcrawltimestamp_

  def set_lastcrawltimestamp(self, x):
    self.has_lastcrawltimestamp_ = 1
    self.lastcrawltimestamp_ = x

  def clear_lastcrawltimestamp(self):
    self.has_lastcrawltimestamp_ = 0
    self.lastcrawltimestamp_ = 0

  def has_lastcrawltimestamp(self): return self.has_lastcrawltimestamp_

  def authmethod(self): return self.authmethod_

  def set_authmethod(self, x):
    self.has_authmethod_ = 1
    self.authmethod_ = x

  def clear_authmethod(self):
    self.has_authmethod_ = 0
    self.authmethod_ = 0

  def has_authmethod(self): return self.has_authmethod_

  def data(self):
    if self.data_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.data_ is None: self.data_ = UrlTrackerData()
      finally:
        self.lazy_init_lock_.release()
    return self.data_

  def mutable_data(self): self.has_data_ = 1; return self.data()

  def clear_data(self):
    #Warning: this method does not acquire the lock.
    self.has_data_ = 0;
    if self.data_ is not None: self.data_.Clear()

  def has_data(self): return self.has_data_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_path()): self.set_path(x.path())
    if (x.has_lastcrawltimestamp()): self.set_lastcrawltimestamp(x.lastcrawltimestamp())
    if (x.has_authmethod()): self.set_authmethod(x.authmethod())
    if (x.has_data()): self.mutable_data().MergeFrom(x.data())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'UrlTrackerServerResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'UrlTrackerServerResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'UrlTrackerServerResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'UrlTrackerServerResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'UrlTrackerServerResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_path_ != x.has_path_: return 0
    if self.has_path_ and self.path_ != x.path_: return 0
    if self.has_lastcrawltimestamp_ != x.has_lastcrawltimestamp_: return 0
    if self.has_lastcrawltimestamp_ and self.lastcrawltimestamp_ != x.lastcrawltimestamp_: return 0
    if self.has_authmethod_ != x.has_authmethod_: return 0
    if self.has_authmethod_ and self.authmethod_ != x.authmethod_: return 0
    if self.has_data_ != x.has_data_: return 0
    if self.has_data_ and self.data_ != x.data_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (self.has_data_ and not self.data_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_path_): n += 1 + self.lengthString(len(self.path_))
    if (self.has_lastcrawltimestamp_): n += 1 + self.lengthVarInt64(self.lastcrawltimestamp_)
    if (self.has_authmethod_): n += 1 + self.lengthVarInt64(self.authmethod_)
    if (self.has_data_): n += 1 + self.lengthString(self.data_.ByteSize())
    return n + 0

  def Clear(self):
    self.clear_path()
    self.clear_lastcrawltimestamp()
    self.clear_authmethod()
    self.clear_data()

  def OutputUnchecked(self, out):
    if (self.has_path_):
      out.putVarInt32(26)
      out.putPrefixedString(self.path_)
    if (self.has_data_):
      out.putVarInt32(34)
      out.putVarInt32(self.data_.ByteSize())
      self.data_.OutputUnchecked(out)
    if (self.has_lastcrawltimestamp_):
      out.putVarInt32(104)
      out.putVarInt32(self.lastcrawltimestamp_)
    if (self.has_authmethod_):
      out.putVarInt32(112)
      out.putVarInt32(self.authmethod_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 26:
        self.set_path(d.getPrefixedString())
        continue
      if tt == 34:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_data().TryMerge(tmp)
        continue
      if tt == 104:
        self.set_lastcrawltimestamp(d.getVarInt32())
        continue
      if tt == 112:
        self.set_authmethod(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_path_: res+=prefix+("Path: %s\n" % self.DebugFormatString(self.path_))
    if self.has_lastcrawltimestamp_: res+=prefix+("lastCrawlTimestamp: %s\n" % self.DebugFormatInt32(self.lastcrawltimestamp_))
    if self.has_authmethod_: res+=prefix+("authMethod: %s\n" % self.DebugFormatInt32(self.authmethod_))
    if self.has_data_:
      res+=prefix+"Data <\n"
      res+=self.data_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

class UrlTrackerServerResponse_Dirs(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.path_ = ""
    self.data_ = None
    self.has_path_ = 0
    self.has_data_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def path(self): return self.path_

  def set_path(self, x):
    self.has_path_ = 1
    self.path_ = x

  def clear_path(self):
    self.has_path_ = 0
    self.path_ = ""

  def has_path(self): return self.has_path_

  def data(self):
    if self.data_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.data_ is None: self.data_ = UrlTrackerData()
      finally:
        self.lazy_init_lock_.release()
    return self.data_

  def mutable_data(self): self.has_data_ = 1; return self.data()

  def clear_data(self):
    #Warning: this method does not acquire the lock.
    self.has_data_ = 0;
    if self.data_ is not None: self.data_.Clear()

  def has_data(self): return self.has_data_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_path()): self.set_path(x.path())
    if (x.has_data()): self.mutable_data().MergeFrom(x.data())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'UrlTrackerServerResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'UrlTrackerServerResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'UrlTrackerServerResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'UrlTrackerServerResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'UrlTrackerServerResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_path_ != x.has_path_: return 0
    if self.has_path_ and self.path_ != x.path_: return 0
    if self.has_data_ != x.has_data_: return 0
    if self.has_data_ and self.data_ != x.data_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (self.has_data_ and not self.data_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_path_): n += 1 + self.lengthString(len(self.path_))
    if (self.has_data_): n += 1 + self.lengthString(self.data_.ByteSize())
    return n + 0

  def Clear(self):
    self.clear_path()
    self.clear_data()

  def OutputUnchecked(self, out):
    if (self.has_path_):
      out.putVarInt32(42)
      out.putPrefixedString(self.path_)
    if (self.has_data_):
      out.putVarInt32(50)
      out.putVarInt32(self.data_.ByteSize())
      self.data_.OutputUnchecked(out)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 42:
        self.set_path(d.getPrefixedString())
        continue
      if tt == 50:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_data().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_path_: res+=prefix+("Path: %s\n" % self.DebugFormatString(self.path_))
    if self.has_data_:
      res+=prefix+"Data <\n"
      res+=self.data_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

class UrlTrackerServerResponse(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.urls_ = []
    self.dirs_ = []
    self.statspercontenttype_ = None
    self.searchedpath_ = ""
    self.urlsfound_ = 0
    self.urlsmatch_ = 0
    self.dirsfound_ = 0
    self.dirsmatch_ = 0
    self.domain_ = None
    self.has_statspercontenttype_ = 0
    self.has_searchedpath_ = 0
    self.has_urlsfound_ = 0
    self.has_urlsmatch_ = 0
    self.has_dirsfound_ = 0
    self.has_dirsmatch_ = 0
    self.has_domain_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def urls_size(self): return len(self.urls_)
  def urls_list(self): return self.urls_

  def urls(self, i):
    return self.urls_[i]

  def mutable_urls(self, i):
    return self.urls_[i]

  def add_urls(self):
    x = UrlTrackerServerResponse_Urls()
    self.urls_.append(x)
    return x

  def clear_urls(self):
    self.urls_ = []
  def dirs_size(self): return len(self.dirs_)
  def dirs_list(self): return self.dirs_

  def dirs(self, i):
    return self.dirs_[i]

  def mutable_dirs(self, i):
    return self.dirs_[i]

  def add_dirs(self):
    x = UrlTrackerServerResponse_Dirs()
    self.dirs_.append(x)
    return x

  def clear_dirs(self):
    self.dirs_ = []
  def statspercontenttype(self):
    if self.statspercontenttype_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.statspercontenttype_ is None: self.statspercontenttype_ = TrackerContentType()
      finally:
        self.lazy_init_lock_.release()
    return self.statspercontenttype_

  def mutable_statspercontenttype(self): self.has_statspercontenttype_ = 1; return self.statspercontenttype()

  def clear_statspercontenttype(self):
    #Warning: this method does not acquire the lock.
    self.has_statspercontenttype_ = 0;
    if self.statspercontenttype_ is not None: self.statspercontenttype_.Clear()

  def has_statspercontenttype(self): return self.has_statspercontenttype_

  def searchedpath(self): return self.searchedpath_

  def set_searchedpath(self, x):
    self.has_searchedpath_ = 1
    self.searchedpath_ = x

  def clear_searchedpath(self):
    self.has_searchedpath_ = 0
    self.searchedpath_ = ""

  def has_searchedpath(self): return self.has_searchedpath_

  def urlsfound(self): return self.urlsfound_

  def set_urlsfound(self, x):
    self.has_urlsfound_ = 1
    self.urlsfound_ = x

  def clear_urlsfound(self):
    self.has_urlsfound_ = 0
    self.urlsfound_ = 0

  def has_urlsfound(self): return self.has_urlsfound_

  def urlsmatch(self): return self.urlsmatch_

  def set_urlsmatch(self, x):
    self.has_urlsmatch_ = 1
    self.urlsmatch_ = x

  def clear_urlsmatch(self):
    self.has_urlsmatch_ = 0
    self.urlsmatch_ = 0

  def has_urlsmatch(self): return self.has_urlsmatch_

  def dirsfound(self): return self.dirsfound_

  def set_dirsfound(self, x):
    self.has_dirsfound_ = 1
    self.dirsfound_ = x

  def clear_dirsfound(self):
    self.has_dirsfound_ = 0
    self.dirsfound_ = 0

  def has_dirsfound(self): return self.has_dirsfound_

  def dirsmatch(self): return self.dirsmatch_

  def set_dirsmatch(self, x):
    self.has_dirsmatch_ = 1
    self.dirsmatch_ = x

  def clear_dirsmatch(self):
    self.has_dirsmatch_ = 0
    self.dirsmatch_ = 0

  def has_dirsmatch(self): return self.has_dirsmatch_

  def domain(self):
    if self.domain_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.domain_ is None: self.domain_ = UrlTrackerData()
      finally:
        self.lazy_init_lock_.release()
    return self.domain_

  def mutable_domain(self): self.has_domain_ = 1; return self.domain()

  def clear_domain(self):
    #Warning: this method does not acquire the lock.
    self.has_domain_ = 0;
    if self.domain_ is not None: self.domain_.Clear()

  def has_domain(self): return self.has_domain_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.urls_size()): self.add_urls().CopyFrom(x.urls(i))
    for i in xrange(x.dirs_size()): self.add_dirs().CopyFrom(x.dirs(i))
    if (x.has_statspercontenttype()): self.mutable_statspercontenttype().MergeFrom(x.statspercontenttype())
    if (x.has_searchedpath()): self.set_searchedpath(x.searchedpath())
    if (x.has_urlsfound()): self.set_urlsfound(x.urlsfound())
    if (x.has_urlsmatch()): self.set_urlsmatch(x.urlsmatch())
    if (x.has_dirsfound()): self.set_dirsfound(x.dirsfound())
    if (x.has_dirsmatch()): self.set_dirsmatch(x.dirsmatch())
    if (x.has_domain()): self.mutable_domain().MergeFrom(x.domain())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'UrlTrackerServerResponse', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'UrlTrackerServerResponse')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'UrlTrackerServerResponse', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'UrlTrackerServerResponse', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'UrlTrackerServerResponse', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.urls_) != len(x.urls_): return 0
    for e1, e2 in zip(self.urls_, x.urls_):
      if e1 != e2: return 0
    if len(self.dirs_) != len(x.dirs_): return 0
    for e1, e2 in zip(self.dirs_, x.dirs_):
      if e1 != e2: return 0
    if self.has_statspercontenttype_ != x.has_statspercontenttype_: return 0
    if self.has_statspercontenttype_ and self.statspercontenttype_ != x.statspercontenttype_: return 0
    if self.has_searchedpath_ != x.has_searchedpath_: return 0
    if self.has_searchedpath_ and self.searchedpath_ != x.searchedpath_: return 0
    if self.has_urlsfound_ != x.has_urlsfound_: return 0
    if self.has_urlsfound_ and self.urlsfound_ != x.urlsfound_: return 0
    if self.has_urlsmatch_ != x.has_urlsmatch_: return 0
    if self.has_urlsmatch_ and self.urlsmatch_ != x.urlsmatch_: return 0
    if self.has_dirsfound_ != x.has_dirsfound_: return 0
    if self.has_dirsfound_ and self.dirsfound_ != x.dirsfound_: return 0
    if self.has_dirsmatch_ != x.has_dirsmatch_: return 0
    if self.has_dirsmatch_ and self.dirsmatch_ != x.dirsmatch_: return 0
    if self.has_domain_ != x.has_domain_: return 0
    if self.has_domain_ and self.domain_ != x.domain_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.urls_)):
      if (not self.urls_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.dirs_)):
      if (not self.dirs_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_statspercontenttype_ and not self.statspercontenttype_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_domain_ and not self.domain_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.urls_)
    for i in xrange(len(self.urls_)): n += self.urls_[i].ByteSize()
    n += 2 * len(self.dirs_)
    for i in xrange(len(self.dirs_)): n += self.dirs_[i].ByteSize()
    if (self.has_statspercontenttype_): n += 1 + self.lengthString(self.statspercontenttype_.ByteSize())
    if (self.has_searchedpath_): n += 1 + self.lengthString(len(self.searchedpath_))
    if (self.has_urlsfound_): n += 1 + self.lengthVarInt64(self.urlsfound_)
    if (self.has_urlsmatch_): n += 1 + self.lengthVarInt64(self.urlsmatch_)
    if (self.has_dirsfound_): n += 1 + self.lengthVarInt64(self.dirsfound_)
    if (self.has_dirsmatch_): n += 1 + self.lengthVarInt64(self.dirsmatch_)
    if (self.has_domain_): n += 1 + self.lengthString(self.domain_.ByteSize())
    return n + 0

  def Clear(self):
    self.clear_urls()
    self.clear_dirs()
    self.clear_statspercontenttype()
    self.clear_searchedpath()
    self.clear_urlsfound()
    self.clear_urlsmatch()
    self.clear_dirsfound()
    self.clear_dirsmatch()
    self.clear_domain()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.urls_)):
      out.putVarInt32(11)
      self.urls_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    for i in xrange(len(self.dirs_)):
      out.putVarInt32(19)
      self.dirs_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    if (self.has_searchedpath_):
      out.putVarInt32(58)
      out.putPrefixedString(self.searchedpath_)
    if (self.has_urlsfound_):
      out.putVarInt32(64)
      out.putVarInt32(self.urlsfound_)
    if (self.has_urlsmatch_):
      out.putVarInt32(72)
      out.putVarInt32(self.urlsmatch_)
    if (self.has_dirsfound_):
      out.putVarInt32(80)
      out.putVarInt32(self.dirsfound_)
    if (self.has_dirsmatch_):
      out.putVarInt32(88)
      out.putVarInt32(self.dirsmatch_)
    if (self.has_domain_):
      out.putVarInt32(98)
      out.putVarInt32(self.domain_.ByteSize())
      self.domain_.OutputUnchecked(out)
    if (self.has_statspercontenttype_):
      out.putVarInt32(122)
      out.putVarInt32(self.statspercontenttype_.ByteSize())
      self.statspercontenttype_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_urls().TryMerge(d)
        continue
      if tt == 19:
        self.add_dirs().TryMerge(d)
        continue
      if tt == 58:
        self.set_searchedpath(d.getPrefixedString())
        continue
      if tt == 64:
        self.set_urlsfound(d.getVarInt32())
        continue
      if tt == 72:
        self.set_urlsmatch(d.getVarInt32())
        continue
      if tt == 80:
        self.set_dirsfound(d.getVarInt32())
        continue
      if tt == 88:
        self.set_dirsmatch(d.getVarInt32())
        continue
      if tt == 98:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_domain().TryMerge(tmp)
        continue
      if tt == 122:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_statspercontenttype().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.urls_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Urls%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.dirs_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Dirs%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_statspercontenttype_:
      res+=prefix+"StatsPerContentType <\n"
      res+=self.statspercontenttype_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_searchedpath_: res+=prefix+("SearchedPath: %s\n" % self.DebugFormatString(self.searchedpath_))
    if self.has_urlsfound_: res+=prefix+("UrlsFound: %s\n" % self.DebugFormatInt32(self.urlsfound_))
    if self.has_urlsmatch_: res+=prefix+("UrlsMatch: %s\n" % self.DebugFormatInt32(self.urlsmatch_))
    if self.has_dirsfound_: res+=prefix+("DirsFound: %s\n" % self.DebugFormatInt32(self.dirsfound_))
    if self.has_dirsmatch_: res+=prefix+("DirsMatch: %s\n" % self.DebugFormatInt32(self.dirsmatch_))
    if self.has_domain_:
      res+=prefix+"Domain <\n"
      res+=self.domain_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

  kUrlsGroup = 1
  kUrlsPath = 3
  kUrlslastCrawlTimestamp = 13
  kUrlsauthMethod = 14
  kUrlsData = 4
  kDirsGroup = 2
  kDirsPath = 5
  kDirsData = 6
  kStatsPerContentType = 15
  kSearchedPath = 7
  kUrlsFound = 8
  kUrlsMatch = 9
  kDirsFound = 10
  kDirsMatch = 11
  kDomain = 12

  _TEXT = (
   "ErrorCode",  #   0
   "Urls",  #   1
   "Dirs",  #   2
   "Path",  #   3
   "Data",  #   4
   "Path",  #   5
   "Data",  #   6
   "SearchedPath",  #   7
   "UrlsFound",  #   8
   "UrlsMatch",  #   9
   "DirsFound",  #  10
   "DirsMatch",  #  11
   "Domain",  #  12
   "lastCrawlTimestamp",  #  13
   "authMethod",  #  14
   "StatsPerContentType",  #  15
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.STRING,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.NUMERIC,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

   ProtocolBuffer.Encoder.STRING,  #  12

   ProtocolBuffer.Encoder.NUMERIC,  #  13

   ProtocolBuffer.Encoder.NUMERIC,  #  14

   ProtocolBuffer.Encoder.STRING,  #  15

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x20,
    0x77,
    0x65,
    0x62,
    0x75,
    0x74,
    0x69,
    0x6c,
    0x2f,
    0x75,
    0x72,
    0x6c,
    0x2f,
    0x75,
    0x72,
    0x6c,
    0x74,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x18,
    0x55,
    0x72,
    0x6c,
    0x54,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x53,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x72,
    0x6c,
    0x73,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x55,
    0x72,
    0x6c,
    0x73,
    0x2e,
    0x50,
    0x61,
    0x74,
    0x68,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x55,
    0x72,
    0x6c,
    0x73,
    0x2e,
    0x6c,
    0x61,
    0x73,
    0x74,
    0x43,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x0d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x55,
    0x72,
    0x6c,
    0x73,
    0x2e,
    0x61,
    0x75,
    0x74,
    0x68,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x20,
    0x0e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x55,
    0x72,
    0x6c,
    0x73,
    0x2e,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0e,
    0x55,
    0x72,
    0x6c,
    0x54,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x44,
    0x61,
    0x74,
    0x61,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x44,
    0x69,
    0x72,
    0x73,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x69,
    0x72,
    0x73,
    0x2e,
    0x50,
    0x61,
    0x74,
    0x68,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x05,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x69,
    0x72,
    0x73,
    0x2e,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0e,
    0x55,
    0x72,
    0x6c,
    0x54,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x44,
    0x61,
    0x74,
    0x61,
    0x60,
    0x05,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x50,
    0x65,
    0x72,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x0f,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x12,
    0x54,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x43,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x54,
    0x79,
    0x70,
    0x65,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x53,
    0x65,
    0x61,
    0x72,
    0x63,
    0x68,
    0x65,
    0x64,
    0x50,
    0x61,
    0x74,
    0x68,
    0x20,
    0x07,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x55,
    0x72,
    0x6c,
    0x73,
    0x46,
    0x6f,
    0x75,
    0x6e,
    0x64,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x55,
    0x72,
    0x6c,
    0x73,
    0x4d,
    0x61,
    0x74,
    0x63,
    0x68,
    0x20,
    0x09,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x69,
    0x72,
    0x73,
    0x46,
    0x6f,
    0x75,
    0x6e,
    0x64,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x69,
    0x72,
    0x73,
    0x4d,
    0x61,
    0x74,
    0x63,
    0x68,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x44,
    0x6f,
    0x6d,
    0x61,
    0x69,
    0x6e,
    0x20,
    0x0c,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0e,
    0x55,
    0x72,
    0x6c,
    0x54,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class VersionedCollections_CollectionGroup(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.versionid_ = 0
    self.collectionfps_ = []
    self.has_versionid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def versionid(self): return self.versionid_

  def set_versionid(self, x):
    self.has_versionid_ = 1
    self.versionid_ = x

  def clear_versionid(self):
    self.has_versionid_ = 0
    self.versionid_ = 0

  def has_versionid(self): return self.has_versionid_

  def collectionfps_size(self): return len(self.collectionfps_)
  def collectionfps_list(self): return self.collectionfps_

  def collectionfps(self, i):
    return self.collectionfps_[i]

  def set_collectionfps(self, i, x):
    self.collectionfps_[i] = x

  def add_collectionfps(self, x):
    self.collectionfps_.append(x)

  def clear_collectionfps(self):
    self.collectionfps_ = []


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_versionid()): self.set_versionid(x.versionid())
    for i in xrange(x.collectionfps_size()): self.add_collectionfps(x.collectionfps(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'VersionedCollections', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'VersionedCollections')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'VersionedCollections', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'VersionedCollections', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'VersionedCollections', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_versionid_ != x.has_versionid_: return 0
    if self.has_versionid_ and self.versionid_ != x.versionid_: return 0
    if len(self.collectionfps_) != len(x.collectionfps_): return 0
    for e1, e2 in zip(self.collectionfps_, x.collectionfps_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_versionid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: versionid not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.versionid_)
    n += 1 * len(self.collectionfps_)
    for i in xrange(len(self.collectionfps_)): n += self.lengthVarInt64(self.collectionfps_[i])
    return n + 1

  def Clear(self):
    self.clear_versionid()
    self.clear_collectionfps()

  def OutputUnchecked(self, out):
    out.putVarInt32(24)
    out.putVarInt32(self.versionid_)
    for i in xrange(len(self.collectionfps_)):
      out.putVarInt32(32)
      out.putVarUint64(self.collectionfps_[i])

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 24:
        self.set_versionid(d.getVarInt32())
        continue
      if tt == 32:
        self.add_collectionfps(d.getVarUint64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_versionid_: res+=prefix+("versionId: %s\n" % self.DebugFormatInt32(self.versionid_))
    cnt=0
    for e in self.collectionfps_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("collectionFps%s: %s\n" % (elm, self.DebugFormatInt64(e)))
      cnt+=1
    return res

class VersionedCollections(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.currentversionid_ = 0
    self.collectiongroup_ = []
    self.has_currentversionid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def currentversionid(self): return self.currentversionid_

  def set_currentversionid(self, x):
    self.has_currentversionid_ = 1
    self.currentversionid_ = x

  def clear_currentversionid(self):
    self.has_currentversionid_ = 0
    self.currentversionid_ = 0

  def has_currentversionid(self): return self.has_currentversionid_

  def collectiongroup_size(self): return len(self.collectiongroup_)
  def collectiongroup_list(self): return self.collectiongroup_

  def collectiongroup(self, i):
    return self.collectiongroup_[i]

  def mutable_collectiongroup(self, i):
    return self.collectiongroup_[i]

  def add_collectiongroup(self):
    x = VersionedCollections_CollectionGroup()
    self.collectiongroup_.append(x)
    return x

  def clear_collectiongroup(self):
    self.collectiongroup_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_currentversionid()): self.set_currentversionid(x.currentversionid())
    for i in xrange(x.collectiongroup_size()): self.add_collectiongroup().CopyFrom(x.collectiongroup(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'VersionedCollections', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'VersionedCollections')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'VersionedCollections', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'VersionedCollections', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'VersionedCollections', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_currentversionid_ != x.has_currentversionid_: return 0
    if self.has_currentversionid_ and self.currentversionid_ != x.currentversionid_: return 0
    if len(self.collectiongroup_) != len(x.collectiongroup_): return 0
    for e1, e2 in zip(self.collectiongroup_, x.collectiongroup_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_currentversionid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: currentversionid not set.')
    for i in xrange(len(self.collectiongroup_)):
      if (not self.collectiongroup_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.currentversionid_)
    n += 2 * len(self.collectiongroup_)
    for i in xrange(len(self.collectiongroup_)): n += self.collectiongroup_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_currentversionid()
    self.clear_collectiongroup()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.currentversionid_)
    for i in xrange(len(self.collectiongroup_)):
      out.putVarInt32(19)
      self.collectiongroup_[i].OutputUnchecked(out)
      out.putVarInt32(20)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_currentversionid(d.getVarInt32())
        continue
      if tt == 19:
        self.add_collectiongroup().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_currentversionid_: res+=prefix+("currentVersionId: %s\n" % self.DebugFormatInt32(self.currentversionid_))
    cnt=0
    for e in self.collectiongroup_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("CollectionGroup%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kcurrentVersionId = 1
  kCollectionGroupGroup = 2
  kCollectionGroupversionId = 3
  kCollectionGroupcollectionFps = 4

  _TEXT = (
   "ErrorCode",  #   0
   "currentVersionId",  #   1
   "CollectionGroup",  #   2
   "versionId",  #   3
   "collectionFps",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x20,
    0x77,
    0x65,
    0x62,
    0x75,
    0x74,
    0x69,
    0x6c,
    0x2f,
    0x75,
    0x72,
    0x6c,
    0x2f,
    0x75,
    0x72,
    0x6c,
    0x74,
    0x72,
    0x61,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x14,
    0x56,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x65,
    0x64,
    0x43,
    0x6f,
    0x6c,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x13,
    0x1a,
    0x10,
    0x63,
    0x75,
    0x72,
    0x72,
    0x65,
    0x6e,
    0x74,
    0x56,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x49,
    0x64,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x43,
    0x6f,
    0x6c,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x47,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x43,
    0x6f,
    0x6c,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x47,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x2e,
    0x76,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x49,
    0x64,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1d,
    0x43,
    0x6f,
    0x6c,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x47,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x2e,
    0x63,
    0x6f,
    0x6c,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x46,
    0x70,
    0x73,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x03,
    0x60,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['UrlTrackerData','UrlTrackerData_SetsCountsCounts','UrlTrackerData_States','UrlTrackerData_Counts','UrlTrackerData_SetsCounts','TrackerGathererCommand','TrackerGathererCommand_AddUrl','TrackerGathererCommand_DiscardBeforeEpoch','UrlTrackerServerCommand','TrackerContentType','TrackerContentType_Stats','UrlTrackerServerResponse','UrlTrackerServerResponse_Urls','UrlTrackerServerResponse_Dirs','VersionedCollections','VersionedCollections_CollectionGroup']
