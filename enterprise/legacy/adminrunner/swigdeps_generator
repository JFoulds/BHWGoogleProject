#!/usr/bin/python2.4
#
# Generated by google3/tools/generate_python_stub.py
#
# Main file: google3/enterprise/legacy/adminrunner/swigdeps_generator.py

import os
import re
import sys

# Find the program in the system path, return
# the full pathname, or die
def FindEnv(progname):
  for path in os.environ['PATH'].split(':'):
    fullname = os.path.join(path, progname)
    if os.access(fullname, os.X_OK):
      return fullname
  raise AssertionError("Could not find an executable named '%s' in the system path" % progname)


# Get the full path to the python executable specified in the first
# line of the given script.
def GetPythonPath(scriptname):
  scriptfile = open(scriptname) # May raise IOError
  first_line = scriptfile.readline()
  scriptfile.close()
  matchobj = re.match('#!(.+)', first_line)
  assert matchobj != None, "First line in %s doesn't start #!" % scriptname
  python_cmd = matchobj.group(1).strip()  # remove any ending white spaces
  assert python_cmd.find('python') >= 0

  # occasionally we have code starting with e.g., '/usr/bin/env python2.2'
  python_cmd_list = python_cmd.split()
  if len(python_cmd_list) > 1:
    assert len(python_cmd_list) == 2
    assert python_cmd_list[0].find('env') >= 0
    python_cmd = FindEnv(python_cmd_list[1])

  # Perform any python mappings specified at build time.
  python_mappings = None
  if python_mappings != None:
    assert python_mappings.has_key(python_cmd), (
        "In " + scriptname + ": " + python_cmd
	+ " is not supported by this build configuration")
    python_cmd = python_mappings[python_cmd]

  return python_cmd


# From the path to Python as presented in the python argument, try to
# get the path to pdb.py and return it in a list.  Otherwise, return
# ['-m', 'pdb'] and hope for the best. This latter technique will fail
# for Python 2.2.
def GetPdbArgs(python):
  # Usually, python is /usr/bin/pythonxx and pdb is /usr/lib/pythonxx/pdb.py
  components = python.split('/')
  if len(components) >= 2:
    pdb_path = '/'.join(components[0:-2] + ['lib'] +
                        components[-1:] + ['pdb.py'])
    if os.access(pdb_path, os.R_OK):
      return [pdb_path]

  # No pdb module found in the python path, default to -m pdb
  return ['-m', 'pdb']

def StripDelimiters(str, beg, end):
   if str[0] == beg:
     assert str[-1] == end
     return (str[1:-1], True)
   else:
     return (str, False)

def StripQuotes(str):
  (str, stripped) = StripDelimiters(str, '"', '"')
  if not stripped:
    (str, stripped) = StripDelimiters(str, "'", "'")
  return str

def PrintOurUsage():
  print "Stub script %s (auto-generated). Options:" % sys.argv[0]
  print "--help                   Show help for stub and invoke script with --help."
  print "--debug_binary           Run python under debugger specified by --debugger."
  print "--debugger=<debugger>    Debugger for --debug_binary. Default: 'gdb --args'."
  print "--debug_script           Run wrapped script with python debugger module (pdb)."
  print "--show_command_and_exit  Print command which would be executed and exit."
  print "These options must appear first in the command line, all others will be" + \
        " passed to the wrapped script."


def Main():
  args = sys.argv[1:]

  debug_binary = False
  debugger = "gdb --args"
  debug_script = False
  show_command_and_exit = False

  while len(args) > 0:
    if args[0] == "--help":
       PrintOurUsage()
       print "Now invoking wrapped script with --help."
       # Pass --help to wrapped script
       break
    if args[0] == "--debug_binary":
       debug_binary = True
       args = args[1:]
       continue
    if args[0] == "--debug_script":
       debug_script = True
       args = args[1:]
       continue
    if args[0] == "--show_command_and_exit":
       show_command_and_exit = True
       args = args[1:]
       continue
    matchobj = re.match("--debugger=(.+)", args[0])
    if matchobj != None:
       debugger = StripQuotes(matchobj.group(1))
       args = args[1:]
       continue
    break

  # allow environment to override runfiles search
  module_space = os.environ.get('PYTHON_RUNFILES', '')
  if not module_space:
    # Follow symlinks, looking for my module space
    stub_filename = os.path.abspath(sys.argv[0])
    while True:
      # Found it?
      module_space = stub_filename + '.runfiles'
      if os.path.isdir(module_space):
        break

      # Follow a symlink, try again?
      if os.path.islink(stub_filename):
        link = os.readlink(stub_filename)
        # Absolutize
        stub_filename = os.path.join(os.path.dirname(stub_filename),
                                   link)
        continue

      raise AssertionError('Cannot find .runfiles directory for %s' %
                           sys.argv[0])

  # Now look for my main python source file
  main_filename = os.path.join(module_space, 'google3/enterprise/legacy/adminrunner/swigdeps_generator.py')
  assert os.path.exists(main_filename),          'Cannot exec() %r: file not found.' % main_filename
  assert os.access(main_filename, os.R_OK),          'Cannot exec() %r: file not readable.' % main_filename
  assert os.access(main_filename, os.X_OK),          'Cannot exec() %r: file not executable.' % main_filename

  python_path = os.environ.get('PYTHONPATH', '')
  os.environ['PYTHONPATH'] = ':'.join([module_space] + python_path.split(':'))
  # immunize ourselves against sitecustomize
  os.environ['GOOGLEBASE'] = module_space

  args = [main_filename] + args

  # use environmental variable to enable Python code coverage collection
  # TODO(jwu): give a default value for 'cov_tool' via 'gconfig' settings
  if os.environ.has_key('PYTHON_COVERAGE'):
    cov_tool = os.environ['PYTHON_COVERAGE']
    # Inhibit infinite recursion:
    del os.environ['PYTHON_COVERAGE']
    assert os.path.exists(cov_tool), 'Python coverage tool %s not found.' % cov_tool
    program = GetPythonPath(main_filename)
    args = [program, cov_tool, '-x'] + args

  elif debug_binary:
    debugger_args = debugger.split()
    program = debugger_args[0]
    # If pathname is not absolute, determine full path using PATH
    if not os.path.isabs(program):
      program = FindEnv(program)
    python_path = GetPythonPath(main_filename)
    command_vec = [python_path]
    if debug_script:
       command_vec.extend(GetPdbArgs(python_path))
    args = [program] + debugger_args[1:] + command_vec + args

  elif debug_script:
    program = GetPythonPath(main_filename)
    args = [program] + GetPdbArgs(program) + args

  else:
    program = GetPythonPath(main_filename)
    args = [program] + args

  if show_command_and_exit:
    print 'program: "%s"' % program
    print 'args:', args
    sys.exit(0)

  try:
    sys.stdout.flush()
    os.execv(program, args)
  except EnvironmentError, e:
    if not getattr(e, 'filename', None):
     e.filename = program  # Add info to error message
    raise
  # endtry

if __name__ == '__main__':
  Main()
