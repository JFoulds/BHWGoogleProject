# This file automatically generated by protocol-compiler from borg/monitoring/borgmon/monitor.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python
try:
  __import__('google3.net.rpc.python.rpc_internals')
  __import__('google3.net.rpc.python.pywraprpc')
  import sys
  rpc_internals = sys.modules.get('google3.net.rpc.python.rpc_internals')
  pywraprpc = sys.modules.get('google3.net.rpc.python.pywraprpc')
  _client_stub_base_class = rpc_internals.StubbyRPCBaseStub
except ImportError:
  _client_stub_base_class = object

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

from google3.borg.monitoring.base.monitoring_pb import DownsamplingSpec
class RuleRequest(ProtocolBuffer.ProtocolMessage):

  add          =    0 
  remove       =    1 

  _operation_type_NAMES = {
    0: "add",
    1: "remove",
  }

  def operation_type_Name(cls, x): return cls._operation_type_NAMES.get(x, "")
  operation_type_Name = classmethod(operation_type_Name)

  def __init__(self, contents=None):
    self.operation_ = 0
    self.expression_ = ""
    self.has_operation_ = 0
    self.has_expression_ = 0
    if contents is not None: self.MergeFromString(contents)

  def operation(self): return self.operation_

  def set_operation(self, x):
    self.has_operation_ = 1
    self.operation_ = x

  def clear_operation(self):
    self.has_operation_ = 0
    self.operation_ = 0

  def has_operation(self): return self.has_operation_

  def expression(self): return self.expression_

  def set_expression(self, x):
    self.has_expression_ = 1
    self.expression_ = x

  def clear_expression(self):
    self.has_expression_ = 0
    self.expression_ = ""

  def has_expression(self): return self.has_expression_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_operation()): self.set_operation(x.operation())
    if (x.has_expression()): self.set_expression(x.expression())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'RuleRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'RuleRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'RuleRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'RuleRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'RuleRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_operation_ != x.has_operation_: return 0
    if self.has_operation_ and self.operation_ != x.operation_: return 0
    if self.has_expression_ != x.has_expression_: return 0
    if self.has_expression_ and self.expression_ != x.expression_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_operation_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: operation not set.')
    if (not self.has_expression_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: expression not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.operation_)
    n += self.lengthString(len(self.expression_))
    return n + 2

  def Clear(self):
    self.clear_operation()
    self.clear_expression()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.operation_)
    out.putVarInt32(18)
    out.putPrefixedString(self.expression_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_operation(d.getVarInt32())
        continue
      if tt == 18:
        self.set_expression(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_operation_: res+=prefix+("operation: %s\n" % self.DebugFormatInt32(self.operation_))
    if self.has_expression_: res+=prefix+("expression: %s\n" % self.DebugFormatString(self.expression_))
    return res

  koperation = 1
  kexpression = 2

  _TEXT = (
   "ErrorCode",  #   0
   "operation",  #   1
   "expression",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x25,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x2f,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0b,
    0x52,
    0x75,
    0x6c,
    0x65,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x09,
    0x6f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x65,
    0x78,
    0x70,
    0x72,
    0x65,
    0x73,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x73,
    0x7a,
    0x0e,
    0x6f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x03,
    0x61,
    0x64,
    0x64,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x06,
    0x72,
    0x65,
    0x6d,
    0x6f,
    0x76,
    0x65,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class SmartValue_Series(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = []
    self.times_ = []
    self.values_ = []
    self.string_values_ = []
    self.end_time_ = 0
    self.has_end_time_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name_size(self): return len(self.name_)
  def name_list(self): return self.name_

  def name(self, i):
    return self.name_[i]

  def set_name(self, i, x):
    self.name_[i] = x

  def add_name(self, x):
    self.name_.append(x)

  def clear_name(self):
    self.name_ = []

  def times_size(self): return len(self.times_)
  def times_list(self): return self.times_

  def times(self, i):
    return self.times_[i]

  def set_times(self, i, x):
    self.times_[i] = x

  def add_times(self, x):
    self.times_.append(x)

  def clear_times(self):
    self.times_ = []

  def values_size(self): return len(self.values_)
  def values_list(self): return self.values_

  def values(self, i):
    return self.values_[i]

  def set_values(self, i, x):
    self.values_[i] = x

  def add_values(self, x):
    self.values_.append(x)

  def clear_values(self):
    self.values_ = []

  def string_values_size(self): return len(self.string_values_)
  def string_values_list(self): return self.string_values_

  def string_values(self, i):
    return self.string_values_[i]

  def set_string_values(self, i, x):
    self.string_values_[i] = x

  def add_string_values(self, x):
    self.string_values_.append(x)

  def clear_string_values(self):
    self.string_values_ = []

  def end_time(self): return self.end_time_

  def set_end_time(self, x):
    self.has_end_time_ = 1
    self.end_time_ = x

  def clear_end_time(self):
    self.has_end_time_ = 0
    self.end_time_ = 0

  def has_end_time(self): return self.has_end_time_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.name_size()): self.add_name(x.name(i))
    for i in xrange(x.times_size()): self.add_times(x.times(i))
    for i in xrange(x.values_size()): self.add_values(x.values(i))
    for i in xrange(x.string_values_size()): self.add_string_values(x.string_values(i))
    if (x.has_end_time()): self.set_end_time(x.end_time())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'SmartValue', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'SmartValue')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'SmartValue', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'SmartValue', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'SmartValue', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.name_) != len(x.name_): return 0
    for e1, e2 in zip(self.name_, x.name_):
      if e1 != e2: return 0
    if len(self.times_) != len(x.times_): return 0
    for e1, e2 in zip(self.times_, x.times_):
      if e1 != e2: return 0
    if len(self.values_) != len(x.values_): return 0
    for e1, e2 in zip(self.values_, x.values_):
      if e1 != e2: return 0
    if len(self.string_values_) != len(x.string_values_): return 0
    for e1, e2 in zip(self.string_values_, x.string_values_):
      if e1 != e2: return 0
    if self.has_end_time_ != x.has_end_time_: return 0
    if self.has_end_time_ and self.end_time_ != x.end_time_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.name_)
    for i in xrange(len(self.name_)): n += self.lengthVarInt64(self.name_[i])
    n += 1 * len(self.times_)
    for i in xrange(len(self.times_)): n += self.lengthVarInt64(self.times_[i])
    n += 9 * len(self.values_)
    n += 1 * len(self.string_values_)
    for i in xrange(len(self.string_values_)): n += self.lengthString(len(self.string_values_[i]))
    if (self.has_end_time_): n += 1 + self.lengthVarInt64(self.end_time_)
    return n + 0

  def Clear(self):
    self.clear_name()
    self.clear_times()
    self.clear_values()
    self.clear_string_values()
    self.clear_end_time()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.name_)):
      out.putVarInt32(24)
      out.putVarInt32(self.name_[i])
    for i in xrange(len(self.times_)):
      out.putVarInt32(32)
      out.putVarInt64(self.times_[i])
    for i in xrange(len(self.values_)):
      out.putVarInt32(41)
      out.putDouble(self.values_[i])
    for i in xrange(len(self.string_values_)):
      out.putVarInt32(50)
      out.putPrefixedString(self.string_values_[i])
    if (self.has_end_time_):
      out.putVarInt32(64)
      out.putVarInt64(self.end_time_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 24:
        self.add_name(d.getVarInt32())
        continue
      if tt == 32:
        self.add_times(d.getVarInt64())
        continue
      if tt == 41:
        self.add_values(d.getDouble())
        continue
      if tt == 50:
        self.add_string_values(d.getPrefixedString())
        continue
      if tt == 64:
        self.set_end_time(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.name_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("name%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    cnt=0
    for e in self.times_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("times%s: %s\n" % (elm, self.DebugFormatInt64(e)))
      cnt+=1
    cnt=0
    for e in self.values_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("values%s: %s\n" % (elm, self.DebugFormat(e)))
      cnt+=1
    cnt=0
    for e in self.string_values_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("string_values%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_end_time_: res+=prefix+("end_time: %s\n" % self.DebugFormatInt64(self.end_time_))
    return res

class SmartValue(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.dictionary_ = []
    self.series_ = []
    self.log10_precision_ = 3
    self.has_log10_precision_ = 0
    if contents is not None: self.MergeFromString(contents)

  def dictionary_size(self): return len(self.dictionary_)
  def dictionary_list(self): return self.dictionary_

  def dictionary(self, i):
    return self.dictionary_[i]

  def set_dictionary(self, i, x):
    self.dictionary_[i] = x

  def add_dictionary(self, x):
    self.dictionary_.append(x)

  def clear_dictionary(self):
    self.dictionary_ = []

  def series_size(self): return len(self.series_)
  def series_list(self): return self.series_

  def series(self, i):
    return self.series_[i]

  def mutable_series(self, i):
    return self.series_[i]

  def add_series(self):
    x = SmartValue_Series()
    self.series_.append(x)
    return x

  def clear_series(self):
    self.series_ = []
  def log10_precision(self): return self.log10_precision_

  def set_log10_precision(self, x):
    self.has_log10_precision_ = 1
    self.log10_precision_ = x

  def clear_log10_precision(self):
    self.has_log10_precision_ = 0
    self.log10_precision_ = 3

  def has_log10_precision(self): return self.has_log10_precision_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.dictionary_size()): self.add_dictionary(x.dictionary(i))
    for i in xrange(x.series_size()): self.add_series().CopyFrom(x.series(i))
    if (x.has_log10_precision()): self.set_log10_precision(x.log10_precision())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'SmartValue', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'SmartValue')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'SmartValue', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'SmartValue', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'SmartValue', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.dictionary_) != len(x.dictionary_): return 0
    for e1, e2 in zip(self.dictionary_, x.dictionary_):
      if e1 != e2: return 0
    if len(self.series_) != len(x.series_): return 0
    for e1, e2 in zip(self.series_, x.series_):
      if e1 != e2: return 0
    if self.has_log10_precision_ != x.has_log10_precision_: return 0
    if self.has_log10_precision_ and self.log10_precision_ != x.log10_precision_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.series_)):
      if (not self.series_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.dictionary_)
    for i in xrange(len(self.dictionary_)): n += self.lengthString(len(self.dictionary_[i]))
    n += 2 * len(self.series_)
    for i in xrange(len(self.series_)): n += self.series_[i].ByteSize()
    if (self.has_log10_precision_): n += 1 + self.lengthVarInt64(self.log10_precision_)
    return n + 0

  def Clear(self):
    self.clear_dictionary()
    self.clear_series()
    self.clear_log10_precision()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.dictionary_)):
      out.putVarInt32(10)
      out.putPrefixedString(self.dictionary_[i])
    for i in xrange(len(self.series_)):
      out.putVarInt32(19)
      self.series_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    if (self.has_log10_precision_):
      out.putVarInt32(56)
      out.putVarInt32(self.log10_precision_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.add_dictionary(d.getPrefixedString())
        continue
      if tt == 19:
        self.add_series().TryMerge(d)
        continue
      if tt == 56:
        self.set_log10_precision(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.dictionary_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("dictionary%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    cnt=0
    for e in self.series_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Series%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_log10_precision_: res+=prefix+("log10_precision: %s\n" % self.DebugFormatInt32(self.log10_precision_))
    return res

  kdictionary = 1
  kSeriesGroup = 2
  kSeriesname = 3
  kSeriestimes = 4
  kSeriesvalues = 5
  kSeriesstring_values = 6
  kSeriesend_time = 8
  klog10_precision = 7

  _TEXT = (
   "ErrorCode",  #   0
   "dictionary",  #   1
   "Series",  #   2
   "name",  #   3
   "times",  #   4
   "values",  #   5
   "string_values",  #   6
   "log10_precision",  #   7
   "end_time",  #   8
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.DOUBLE,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x25,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x2f,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0a,
    0x53,
    0x6d,
    0x61,
    0x72,
    0x74,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x13,
    0x1a,
    0x0a,
    0x64,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x72,
    0x79,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x2e,
    0x74,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x03,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x73,
    0x20,
    0x05,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x03,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x2e,
    0x73,
    0x74,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x5f,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x73,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x2e,
    0x65,
    0x6e,
    0x64,
    0x5f,
    0x74,
    0x69,
    0x6d,
    0x65,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x6c,
    0x6f,
    0x67,
    0x31,
    0x30,
    0x5f,
    0x70,
    0x72,
    0x65,
    0x63,
    0x69,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x33,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x33,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class Value_SeriesPoint(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.time_ = 0.0
    self.value_ = 0.0
    self.has_time_ = 0
    self.has_value_ = 0
    if contents is not None: self.MergeFromString(contents)

  def time(self): return self.time_

  def set_time(self, x):
    self.has_time_ = 1
    self.time_ = x

  def clear_time(self):
    self.has_time_ = 0
    self.time_ = 0.0

  def has_time(self): return self.has_time_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = 0.0

  def has_value(self): return self.has_value_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_time()): self.set_time(x.time())
    if (x.has_value()): self.set_value(x.value())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'Value', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'Value')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'Value', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'Value', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'Value', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_time_ != x.has_time_: return 0
    if self.has_time_ and self.time_ != x.time_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_time_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: time not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    return n + 18

  def Clear(self):
    self.clear_time()
    self.clear_value()

  def OutputUnchecked(self, out):
    out.putVarInt32(33)
    out.putDouble(self.time_)
    out.putVarInt32(41)
    out.putDouble(self.value_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 28: break
      if tt == 33:
        self.set_time(d.getDouble())
        continue
      if tt == 41:
        self.set_value(d.getDouble())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_time_: res+=prefix+("time: %s\n" % self.DebugFormat(self.time_))
    if self.has_value_: res+=prefix+("value: %s\n" % self.DebugFormat(self.value_))
    return res

class Value_SeriesStringValue(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.value_ = ""
    self.has_value_ = 0
    if contents is not None: self.MergeFromString(contents)

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_value()): self.set_value(x.value())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'Value', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'Value')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'Value', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'Value', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'Value', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.value_))
    return n + 1

  def Clear(self):
    self.clear_value()

  def OutputUnchecked(self, out):
    out.putVarInt32(58)
    out.putPrefixedString(self.value_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 52: break
      if tt == 58:
        self.set_value(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_value_: res+=prefix+("value: %s\n" % self.DebugFormatString(self.value_))
    return res

class Value_Series(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.point_ = []
    self.stringvalue_ = []
    self.has_name_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def point_size(self): return len(self.point_)
  def point_list(self): return self.point_

  def point(self, i):
    return self.point_[i]

  def mutable_point(self, i):
    return self.point_[i]

  def add_point(self):
    x = Value_SeriesPoint()
    self.point_.append(x)
    return x

  def clear_point(self):
    self.point_ = []
  def stringvalue_size(self): return len(self.stringvalue_)
  def stringvalue_list(self): return self.stringvalue_

  def stringvalue(self, i):
    return self.stringvalue_[i]

  def mutable_stringvalue(self, i):
    return self.stringvalue_[i]

  def add_stringvalue(self):
    x = Value_SeriesStringValue()
    self.stringvalue_.append(x)
    return x

  def clear_stringvalue(self):
    self.stringvalue_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    for i in xrange(x.point_size()): self.add_point().CopyFrom(x.point(i))
    for i in xrange(x.stringvalue_size()): self.add_stringvalue().CopyFrom(x.stringvalue(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'Value', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'Value')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'Value', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'Value', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'Value', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if len(self.point_) != len(x.point_): return 0
    for e1, e2 in zip(self.point_, x.point_):
      if e1 != e2: return 0
    if len(self.stringvalue_) != len(x.stringvalue_): return 0
    for e1, e2 in zip(self.stringvalue_, x.stringvalue_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    for i in xrange(len(self.point_)):
      if (not self.point_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.stringvalue_)):
      if (not self.stringvalue_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    n += 2 * len(self.point_)
    for i in xrange(len(self.point_)): n += self.point_[i].ByteSize()
    n += 2 * len(self.stringvalue_)
    for i in xrange(len(self.stringvalue_)): n += self.stringvalue_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_name()
    self.clear_point()
    self.clear_stringvalue()

  def OutputUnchecked(self, out):
    out.putVarInt32(18)
    out.putPrefixedString(self.name_)
    for i in xrange(len(self.point_)):
      out.putVarInt32(27)
      self.point_[i].OutputUnchecked(out)
      out.putVarInt32(28)
    for i in xrange(len(self.stringvalue_)):
      out.putVarInt32(51)
      self.stringvalue_[i].OutputUnchecked(out)
      out.putVarInt32(52)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 27:
        self.add_point().TryMerge(d)
        continue
      if tt == 51:
        self.add_stringvalue().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    cnt=0
    for e in self.point_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Point%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.stringvalue_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("StringValue%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

class Value(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.series_ = []
    self.new_value_ = None
    self.has_new_value_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def series_size(self): return len(self.series_)
  def series_list(self): return self.series_

  def series(self, i):
    return self.series_[i]

  def mutable_series(self, i):
    return self.series_[i]

  def add_series(self):
    x = Value_Series()
    self.series_.append(x)
    return x

  def clear_series(self):
    self.series_ = []
  def new_value(self):
    if self.new_value_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.new_value_ is None: self.new_value_ = SmartValue()
      finally:
        self.lazy_init_lock_.release()
    return self.new_value_

  def mutable_new_value(self): self.has_new_value_ = 1; return self.new_value()

  def clear_new_value(self):
    #Warning: this method does not acquire the lock.
    self.has_new_value_ = 0;
    if self.new_value_ is not None: self.new_value_.Clear()

  def has_new_value(self): return self.has_new_value_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.series_size()): self.add_series().CopyFrom(x.series(i))
    if (x.has_new_value()): self.mutable_new_value().MergeFrom(x.new_value())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'Value', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'Value')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'Value', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'Value', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'Value', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.series_) != len(x.series_): return 0
    for e1, e2 in zip(self.series_, x.series_):
      if e1 != e2: return 0
    if self.has_new_value_ != x.has_new_value_: return 0
    if self.has_new_value_ and self.new_value_ != x.new_value_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.series_)):
      if (not self.series_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_new_value_ and not self.new_value_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.series_)
    for i in xrange(len(self.series_)): n += self.series_[i].ByteSize()
    if (self.has_new_value_): n += 1 + self.lengthString(self.new_value_.ByteSize())
    return n + 0

  def Clear(self):
    self.clear_series()
    self.clear_new_value()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.series_)):
      out.putVarInt32(11)
      self.series_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    if (self.has_new_value_):
      out.putVarInt32(66)
      out.putVarInt32(self.new_value_.ByteSize())
      self.new_value_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_series().TryMerge(d)
        continue
      if tt == 66:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_new_value().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.series_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Series%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_new_value_:
      res+=prefix+"new_value <\n"
      res+=self.new_value_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

  kSeriesGroup = 1
  kSeriesname = 2
  kSeriesPointGroup = 3
  kSeriesPointtime = 4
  kSeriesPointvalue = 5
  kSeriesStringValueGroup = 6
  kSeriesStringValuevalue = 7
  knew_value = 8

  _TEXT = (
   "ErrorCode",  #   0
   "Series",  #   1
   "name",  #   2
   "Point",  #   3
   "time",  #   4
   "value",  #   5
   "StringValue",  #   6
   "value",  #   7
   "new_value",  #   8
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STARTGROUP,  #   3

   ProtocolBuffer.Encoder.DOUBLE,  #   4

   ProtocolBuffer.Encoder.DOUBLE,  #   5

   ProtocolBuffer.Encoder.STARTGROUP,  #   6

   ProtocolBuffer.Encoder.STRING,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x25,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x2f,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x05,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x2e,
    0x50,
    0x6f,
    0x69,
    0x6e,
    0x74,
    0x20,
    0x03,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x2e,
    0x50,
    0x6f,
    0x69,
    0x6e,
    0x74,
    0x2e,
    0x74,
    0x69,
    0x6d,
    0x65,
    0x20,
    0x04,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x2e,
    0x50,
    0x6f,
    0x69,
    0x6e,
    0x74,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x05,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x2e,
    0x53,
    0x74,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x06,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x53,
    0x65,
    0x72,
    0x69,
    0x65,
    0x73,
    0x2e,
    0x53,
    0x74,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x07,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x05,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x6e,
    0x65,
    0x77,
    0x5f,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0a,
    0x53,
    0x6d,
    0x61,
    0x72,
    0x74,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class EvaluateRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.expression_ = ""
    self.has_expression_ = 0
    if contents is not None: self.MergeFromString(contents)

  def expression(self): return self.expression_

  def set_expression(self, x):
    self.has_expression_ = 1
    self.expression_ = x

  def clear_expression(self):
    self.has_expression_ = 0
    self.expression_ = ""

  def has_expression(self): return self.has_expression_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_expression()): self.set_expression(x.expression())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'EvaluateRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'EvaluateRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'EvaluateRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'EvaluateRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'EvaluateRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_expression_ != x.has_expression_: return 0
    if self.has_expression_ and self.expression_ != x.expression_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_expression_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: expression not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.expression_))
    return n + 1

  def Clear(self):
    self.clear_expression()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.expression_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_expression(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_expression_: res+=prefix+("expression: %s\n" % self.DebugFormatString(self.expression_))
    return res

  kexpression = 1

  _TEXT = (
   "ErrorCode",  #   0
   "expression",  #   1
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x25,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x2f,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0f,
    0x45,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x61,
    0x74,
    0x65,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x0a,
    0x65,
    0x78,
    0x70,
    0x72,
    0x65,
    0x73,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class EvaluateManyRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.requests_ = []
    self.consult_lookupserver_ = 0
    self.downsampling_ = None
    self.has_consult_lookupserver_ = 0
    self.has_downsampling_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def requests_size(self): return len(self.requests_)
  def requests_list(self): return self.requests_

  def requests(self, i):
    return self.requests_[i]

  def mutable_requests(self, i):
    return self.requests_[i]

  def add_requests(self):
    x = EvaluateRequest()
    self.requests_.append(x)
    return x

  def clear_requests(self):
    self.requests_ = []
  def consult_lookupserver(self): return self.consult_lookupserver_

  def set_consult_lookupserver(self, x):
    self.has_consult_lookupserver_ = 1
    self.consult_lookupserver_ = x

  def clear_consult_lookupserver(self):
    self.has_consult_lookupserver_ = 0
    self.consult_lookupserver_ = 0

  def has_consult_lookupserver(self): return self.has_consult_lookupserver_

  def downsampling(self):
    if self.downsampling_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.downsampling_ is None: self.downsampling_ = DownsamplingSpec()
      finally:
        self.lazy_init_lock_.release()
    return self.downsampling_

  def mutable_downsampling(self): self.has_downsampling_ = 1; return self.downsampling()

  def clear_downsampling(self):
    #Warning: this method does not acquire the lock.
    self.has_downsampling_ = 0;
    if self.downsampling_ is not None: self.downsampling_.Clear()

  def has_downsampling(self): return self.has_downsampling_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.requests_size()): self.add_requests().CopyFrom(x.requests(i))
    if (x.has_consult_lookupserver()): self.set_consult_lookupserver(x.consult_lookupserver())
    if (x.has_downsampling()): self.mutable_downsampling().MergeFrom(x.downsampling())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'EvaluateManyRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'EvaluateManyRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'EvaluateManyRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'EvaluateManyRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'EvaluateManyRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.requests_) != len(x.requests_): return 0
    for e1, e2 in zip(self.requests_, x.requests_):
      if e1 != e2: return 0
    if self.has_consult_lookupserver_ != x.has_consult_lookupserver_: return 0
    if self.has_consult_lookupserver_ and self.consult_lookupserver_ != x.consult_lookupserver_: return 0
    if self.has_downsampling_ != x.has_downsampling_: return 0
    if self.has_downsampling_ and self.downsampling_ != x.downsampling_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.requests_)):
      if (not self.requests_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_downsampling_ and not self.downsampling_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.requests_)
    for i in xrange(len(self.requests_)): n += self.lengthString(self.requests_[i].ByteSize())
    if (self.has_consult_lookupserver_): n += 2
    if (self.has_downsampling_): n += 1 + self.lengthString(self.downsampling_.ByteSize())
    return n + 0

  def Clear(self):
    self.clear_requests()
    self.clear_consult_lookupserver()
    self.clear_downsampling()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.requests_)):
      out.putVarInt32(10)
      out.putVarInt32(self.requests_[i].ByteSize())
      self.requests_[i].OutputUnchecked(out)
    if (self.has_consult_lookupserver_):
      out.putVarInt32(16)
      out.putBoolean(self.consult_lookupserver_)
    if (self.has_downsampling_):
      out.putVarInt32(26)
      out.putVarInt32(self.downsampling_.ByteSize())
      self.downsampling_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_requests().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_consult_lookupserver(d.getBoolean())
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_downsampling().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.requests_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("requests%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_consult_lookupserver_: res+=prefix+("consult_lookupserver: %s\n" % self.DebugFormatBool(self.consult_lookupserver_))
    if self.has_downsampling_:
      res+=prefix+"downsampling <\n"
      res+=self.downsampling_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

  krequests = 1
  kconsult_lookupserver = 2
  kdownsampling = 3

  _TEXT = (
   "ErrorCode",  #   0
   "requests",  #   1
   "consult_lookupserver",  #   2
   "downsampling",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x25,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x2f,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x13,
    0x45,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x61,
    0x74,
    0x65,
    0x4d,
    0x61,
    0x6e,
    0x79,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x08,
    0x72,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x73,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x0f,
    0x45,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x61,
    0x74,
    0x65,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x63,
    0x6f,
    0x6e,
    0x73,
    0x75,
    0x6c,
    0x74,
    0x5f,
    0x6c,
    0x6f,
    0x6f,
    0x6b,
    0x75,
    0x70,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x64,
    0x6f,
    0x77,
    0x6e,
    0x73,
    0x61,
    0x6d,
    0x70,
    0x6c,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x18,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2e,
    0x44,
    0x6f,
    0x77,
    0x6e,
    0x73,
    0x61,
    0x6d,
    0x70,
    0x6c,
    0x69,
    0x6e,
    0x67,
    0x53,
    0x70,
    0x65,
    0x63,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ManyValue(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.values_ = []
    self.fatal_errors_ = ""
    self.non_fatal_errors_ = ""
    self.has_fatal_errors_ = 0
    self.has_non_fatal_errors_ = 0
    if contents is not None: self.MergeFromString(contents)

  def values_size(self): return len(self.values_)
  def values_list(self): return self.values_

  def values(self, i):
    return self.values_[i]

  def mutable_values(self, i):
    return self.values_[i]

  def add_values(self):
    x = Value()
    self.values_.append(x)
    return x

  def clear_values(self):
    self.values_ = []
  def fatal_errors(self): return self.fatal_errors_

  def set_fatal_errors(self, x):
    self.has_fatal_errors_ = 1
    self.fatal_errors_ = x

  def clear_fatal_errors(self):
    self.has_fatal_errors_ = 0
    self.fatal_errors_ = ""

  def has_fatal_errors(self): return self.has_fatal_errors_

  def non_fatal_errors(self): return self.non_fatal_errors_

  def set_non_fatal_errors(self, x):
    self.has_non_fatal_errors_ = 1
    self.non_fatal_errors_ = x

  def clear_non_fatal_errors(self):
    self.has_non_fatal_errors_ = 0
    self.non_fatal_errors_ = ""

  def has_non_fatal_errors(self): return self.has_non_fatal_errors_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.values_size()): self.add_values().CopyFrom(x.values(i))
    if (x.has_fatal_errors()): self.set_fatal_errors(x.fatal_errors())
    if (x.has_non_fatal_errors()): self.set_non_fatal_errors(x.non_fatal_errors())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ManyValue', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ManyValue')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ManyValue', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ManyValue', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ManyValue', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.values_) != len(x.values_): return 0
    for e1, e2 in zip(self.values_, x.values_):
      if e1 != e2: return 0
    if self.has_fatal_errors_ != x.has_fatal_errors_: return 0
    if self.has_fatal_errors_ and self.fatal_errors_ != x.fatal_errors_: return 0
    if self.has_non_fatal_errors_ != x.has_non_fatal_errors_: return 0
    if self.has_non_fatal_errors_ and self.non_fatal_errors_ != x.non_fatal_errors_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.values_)):
      if (not self.values_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.values_)
    for i in xrange(len(self.values_)): n += self.lengthString(self.values_[i].ByteSize())
    if (self.has_fatal_errors_): n += 1 + self.lengthString(len(self.fatal_errors_))
    if (self.has_non_fatal_errors_): n += 1 + self.lengthString(len(self.non_fatal_errors_))
    return n + 0

  def Clear(self):
    self.clear_values()
    self.clear_fatal_errors()
    self.clear_non_fatal_errors()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.values_)):
      out.putVarInt32(10)
      out.putVarInt32(self.values_[i].ByteSize())
      self.values_[i].OutputUnchecked(out)
    if (self.has_fatal_errors_):
      out.putVarInt32(66)
      out.putPrefixedString(self.fatal_errors_)
    if (self.has_non_fatal_errors_):
      out.putVarInt32(74)
      out.putPrefixedString(self.non_fatal_errors_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_values().TryMerge(tmp)
        continue
      if tt == 66:
        self.set_fatal_errors(d.getPrefixedString())
        continue
      if tt == 74:
        self.set_non_fatal_errors(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.values_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("values%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_fatal_errors_: res+=prefix+("fatal_errors: %s\n" % self.DebugFormatString(self.fatal_errors_))
    if self.has_non_fatal_errors_: res+=prefix+("non_fatal_errors: %s\n" % self.DebugFormatString(self.non_fatal_errors_))
    return res

  kvalues = 1
  kfatal_errors = 8
  knon_fatal_errors = 9

  _TEXT = (
   "ErrorCode",  #   0
   "values",  #   1
   None,  #   2
   None,  #   3
   None,  #   4
   None,  #   5
   None,  #   6
   None,  #   7
   "fatal_errors",  #   8
   "non_fatal_errors",  #   9
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.MAX_TYPE,  #   2

   ProtocolBuffer.Encoder.MAX_TYPE,  #   3

   ProtocolBuffer.Encoder.MAX_TYPE,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.MAX_TYPE,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x25,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x2f,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x09,
    0x4d,
    0x61,
    0x6e,
    0x79,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x13,
    0x1a,
    0x06,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x73,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x05,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x66,
    0x61,
    0x74,
    0x61,
    0x6c,
    0x5f,
    0x65,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x73,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x6e,
    0x6f,
    0x6e,
    0x5f,
    0x66,
    0x61,
    0x74,
    0x61,
    0x6c,
    0x5f,
    0x65,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x73,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ValueStream_Value(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = []
    self.value_ = []
    self.string_value_ = []
    self.timestamp_ = []
    if contents is not None: self.MergeFromString(contents)

  def name_size(self): return len(self.name_)
  def name_list(self): return self.name_

  def name(self, i):
    return self.name_[i]

  def set_name(self, i, x):
    self.name_[i] = x

  def add_name(self, x):
    self.name_.append(x)

  def clear_name(self):
    self.name_ = []

  def value_size(self): return len(self.value_)
  def value_list(self): return self.value_

  def value(self, i):
    return self.value_[i]

  def set_value(self, i, x):
    self.value_[i] = x

  def add_value(self, x):
    self.value_.append(x)

  def clear_value(self):
    self.value_ = []

  def string_value_size(self): return len(self.string_value_)
  def string_value_list(self): return self.string_value_

  def string_value(self, i):
    return self.string_value_[i]

  def set_string_value(self, i, x):
    self.string_value_[i] = x

  def add_string_value(self, x):
    self.string_value_.append(x)

  def clear_string_value(self):
    self.string_value_ = []

  def timestamp_size(self): return len(self.timestamp_)
  def timestamp_list(self): return self.timestamp_

  def timestamp(self, i):
    return self.timestamp_[i]

  def set_timestamp(self, i, x):
    self.timestamp_[i] = x

  def add_timestamp(self, x):
    self.timestamp_.append(x)

  def clear_timestamp(self):
    self.timestamp_ = []


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.name_size()): self.add_name(x.name(i))
    for i in xrange(x.value_size()): self.add_value(x.value(i))
    for i in xrange(x.string_value_size()): self.add_string_value(x.string_value(i))
    for i in xrange(x.timestamp_size()): self.add_timestamp(x.timestamp(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ValueStream', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ValueStream')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ValueStream', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ValueStream', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ValueStream', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.name_) != len(x.name_): return 0
    for e1, e2 in zip(self.name_, x.name_):
      if e1 != e2: return 0
    if len(self.value_) != len(x.value_): return 0
    for e1, e2 in zip(self.value_, x.value_):
      if e1 != e2: return 0
    if len(self.string_value_) != len(x.string_value_): return 0
    for e1, e2 in zip(self.string_value_, x.string_value_):
      if e1 != e2: return 0
    if len(self.timestamp_) != len(x.timestamp_): return 0
    for e1, e2 in zip(self.timestamp_, x.timestamp_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.name_)
    for i in xrange(len(self.name_)): n += self.lengthVarInt64(self.name_[i])
    n += 9 * len(self.value_)
    n += 1 * len(self.string_value_)
    for i in xrange(len(self.string_value_)): n += self.lengthString(len(self.string_value_[i]))
    n += 9 * len(self.timestamp_)
    return n + 0

  def Clear(self):
    self.clear_name()
    self.clear_value()
    self.clear_string_value()
    self.clear_timestamp()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.name_)):
      out.putVarInt32(24)
      out.putVarInt32(self.name_[i])
    for i in xrange(len(self.value_)):
      out.putVarInt32(33)
      out.putDouble(self.value_[i])
    for i in xrange(len(self.timestamp_)):
      out.putVarInt32(41)
      out.putDouble(self.timestamp_[i])
    for i in xrange(len(self.string_value_)):
      out.putVarInt32(74)
      out.putPrefixedString(self.string_value_[i])

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 24:
        self.add_name(d.getVarInt32())
        continue
      if tt == 33:
        self.add_value(d.getDouble())
        continue
      if tt == 41:
        self.add_timestamp(d.getDouble())
        continue
      if tt == 74:
        self.add_string_value(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.name_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("name%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    cnt=0
    for e in self.value_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("value%s: %s\n" % (elm, self.DebugFormat(e)))
      cnt+=1
    cnt=0
    for e in self.string_value_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("string_value%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    cnt=0
    for e in self.timestamp_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("timestamp%s: %s\n" % (elm, self.DebugFormat(e)))
      cnt+=1
    return res

class ValueStream(ProtocolBuffer.ProtocolMessage):

  NO_ERROR     =    0 
  FULLMATCH_REQUIRED =    1 

  _Code_NAMES = {
    0: "NO_ERROR",
    1: "FULLMATCH_REQUIRED",
  }

  def Code_Name(cls, x): return cls._Code_NAMES.get(x, "")
  Code_Name = classmethod(Code_Name)

  def __init__(self, contents=None):
    self.dictionary_ = []
    self.value_ = []
    if contents is not None: self.MergeFromString(contents)

  def dictionary_size(self): return len(self.dictionary_)
  def dictionary_list(self): return self.dictionary_

  def dictionary(self, i):
    return self.dictionary_[i]

  def set_dictionary(self, i, x):
    self.dictionary_[i] = x

  def add_dictionary(self, x):
    self.dictionary_.append(x)

  def clear_dictionary(self):
    self.dictionary_ = []

  def value_size(self): return len(self.value_)
  def value_list(self): return self.value_

  def value(self, i):
    return self.value_[i]

  def mutable_value(self, i):
    return self.value_[i]

  def add_value(self):
    x = ValueStream_Value()
    self.value_.append(x)
    return x

  def clear_value(self):
    self.value_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.dictionary_size()): self.add_dictionary(x.dictionary(i))
    for i in xrange(x.value_size()): self.add_value().CopyFrom(x.value(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ValueStream', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ValueStream')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ValueStream', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ValueStream', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ValueStream', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.dictionary_) != len(x.dictionary_): return 0
    for e1, e2 in zip(self.dictionary_, x.dictionary_):
      if e1 != e2: return 0
    if len(self.value_) != len(x.value_): return 0
    for e1, e2 in zip(self.value_, x.value_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.value_)):
      if (not self.value_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.dictionary_)
    for i in xrange(len(self.dictionary_)): n += self.lengthString(len(self.dictionary_[i]))
    n += 2 * len(self.value_)
    for i in xrange(len(self.value_)): n += self.value_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_dictionary()
    self.clear_value()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.dictionary_)):
      out.putVarInt32(10)
      out.putPrefixedString(self.dictionary_[i])
    for i in xrange(len(self.value_)):
      out.putVarInt32(19)
      self.value_[i].OutputUnchecked(out)
      out.putVarInt32(20)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.add_dictionary(d.getPrefixedString())
        continue
      if tt == 19:
        self.add_value().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.dictionary_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("dictionary%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    cnt=0
    for e in self.value_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Value%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kdictionary = 1
  kValueGroup = 2
  kValuename = 3
  kValuevalue = 4
  kValuestring_value = 9
  kValuetimestamp = 5

  _TEXT = (
   "ErrorCode",  #   0
   "dictionary",  #   1
   "Value",  #   2
   "name",  #   3
   "value",  #   4
   "timestamp",  #   5
   None,  #   6
   None,  #   7
   None,  #   8
   "string_value",  #   9
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.DOUBLE,  #   4

   ProtocolBuffer.Encoder.DOUBLE,  #   5

   ProtocolBuffer.Encoder.MAX_TYPE,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.MAX_TYPE,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x25,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x2f,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0b,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x53,
    0x74,
    0x72,
    0x65,
    0x61,
    0x6d,
    0x13,
    0x1a,
    0x0a,
    0x64,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x72,
    0x79,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x04,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x03,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x2e,
    0x73,
    0x74,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x5f,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x2e,
    0x74,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x05,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x03,
    0x60,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x04,
    0x43,
    0x6f,
    0x64,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x4e,
    0x4f,
    0x5f,
    0x45,
    0x52,
    0x52,
    0x4f,
    0x52,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x46,
    0x55,
    0x4c,
    0x4c,
    0x4d,
    0x41,
    0x54,
    0x43,
    0x48,
    0x5f,
    0x52,
    0x45,
    0x51,
    0x55,
    0x49,
    0x52,
    0x45,
    0x44,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class KeyValueList_Entry(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.key_ = ""
    self.value_ = ""
    self.has_key_ = 0
    self.has_value_ = 0
    if contents is not None: self.MergeFromString(contents)

  def key(self): return self.key_

  def set_key(self, x):
    self.has_key_ = 1
    self.key_ = x

  def clear_key(self):
    self.has_key_ = 0
    self.key_ = ""

  def has_key(self): return self.has_key_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_key()): self.set_key(x.key())
    if (x.has_value()): self.set_value(x.value())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'KeyValueList', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'KeyValueList')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'KeyValueList', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'KeyValueList', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'KeyValueList', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_key_ != x.has_key_: return 0
    if self.has_key_ and self.key_ != x.key_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_key_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: key not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.key_))
    if (self.has_value_): n += 1 + self.lengthString(len(self.value_))
    return n + 1

  def Clear(self):
    self.clear_key()
    self.clear_value()

  def OutputUnchecked(self, out):
    out.putVarInt32(18)
    out.putPrefixedString(self.key_)
    if (self.has_value_):
      out.putVarInt32(26)
      out.putPrefixedString(self.value_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        self.set_key(d.getPrefixedString())
        continue
      if tt == 26:
        self.set_value(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_key_: res+=prefix+("key: %s\n" % self.DebugFormatString(self.key_))
    if self.has_value_: res+=prefix+("value: %s\n" % self.DebugFormatString(self.value_))
    return res

class KeyValueList(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.entry_ = []
    self.fullmatch_regex_ = 0
    self.has_fullmatch_regex_ = 0
    if contents is not None: self.MergeFromString(contents)

  def entry_size(self): return len(self.entry_)
  def entry_list(self): return self.entry_

  def entry(self, i):
    return self.entry_[i]

  def mutable_entry(self, i):
    return self.entry_[i]

  def add_entry(self):
    x = KeyValueList_Entry()
    self.entry_.append(x)
    return x

  def clear_entry(self):
    self.entry_ = []
  def fullmatch_regex(self): return self.fullmatch_regex_

  def set_fullmatch_regex(self, x):
    self.has_fullmatch_regex_ = 1
    self.fullmatch_regex_ = x

  def clear_fullmatch_regex(self):
    self.has_fullmatch_regex_ = 0
    self.fullmatch_regex_ = 0

  def has_fullmatch_regex(self): return self.has_fullmatch_regex_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.entry_size()): self.add_entry().CopyFrom(x.entry(i))
    if (x.has_fullmatch_regex()): self.set_fullmatch_regex(x.fullmatch_regex())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'KeyValueList', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'KeyValueList')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'KeyValueList', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'KeyValueList', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'KeyValueList', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.entry_) != len(x.entry_): return 0
    for e1, e2 in zip(self.entry_, x.entry_):
      if e1 != e2: return 0
    if self.has_fullmatch_regex_ != x.has_fullmatch_regex_: return 0
    if self.has_fullmatch_regex_ and self.fullmatch_regex_ != x.fullmatch_regex_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.entry_)):
      if (not self.entry_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.entry_)
    for i in xrange(len(self.entry_)): n += self.entry_[i].ByteSize()
    if (self.has_fullmatch_regex_): n += 2
    return n + 0

  def Clear(self):
    self.clear_entry()
    self.clear_fullmatch_regex()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.entry_)):
      out.putVarInt32(11)
      self.entry_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    if (self.has_fullmatch_regex_):
      out.putVarInt32(32)
      out.putBoolean(self.fullmatch_regex_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_entry().TryMerge(d)
        continue
      if tt == 32:
        self.set_fullmatch_regex(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.entry_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Entry%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_fullmatch_regex_: res+=prefix+("fullmatch_regex: %s\n" % self.DebugFormatBool(self.fullmatch_regex_))
    return res

  kEntryGroup = 1
  kEntrykey = 2
  kEntryvalue = 3
  kfullmatch_regex = 4

  _TEXT = (
   "ErrorCode",  #   0
   "Entry",  #   1
   "key",  #   2
   "value",  #   3
   "fullmatch_regex",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x25,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x2f,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0c,
    0x4b,
    0x65,
    0x79,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x4c,
    0x69,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x05,
    0x45,
    0x6e,
    0x74,
    0x72,
    0x79,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x45,
    0x6e,
    0x74,
    0x72,
    0x79,
    0x2e,
    0x6b,
    0x65,
    0x79,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x45,
    0x6e,
    0x74,
    0x72,
    0x79,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x66,
    0x75,
    0x6c,
    0x6c,
    0x6d,
    0x61,
    0x74,
    0x63,
    0x68,
    0x5f,
    0x72,
    0x65,
    0x67,
    0x65,
    0x78,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ValueStreamSpec(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.query_ = []
    self.return_varz_ = 0
    self.has_return_varz_ = 0
    if contents is not None: self.MergeFromString(contents)

  def query_size(self): return len(self.query_)
  def query_list(self): return self.query_

  def query(self, i):
    return self.query_[i]

  def mutable_query(self, i):
    return self.query_[i]

  def add_query(self):
    x = KeyValueList()
    self.query_.append(x)
    return x

  def clear_query(self):
    self.query_ = []
  def return_varz(self): return self.return_varz_

  def set_return_varz(self, x):
    self.has_return_varz_ = 1
    self.return_varz_ = x

  def clear_return_varz(self):
    self.has_return_varz_ = 0
    self.return_varz_ = 0

  def has_return_varz(self): return self.has_return_varz_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.query_size()): self.add_query().CopyFrom(x.query(i))
    if (x.has_return_varz()): self.set_return_varz(x.return_varz())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ValueStreamSpec', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ValueStreamSpec')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ValueStreamSpec', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ValueStreamSpec', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ValueStreamSpec', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.query_) != len(x.query_): return 0
    for e1, e2 in zip(self.query_, x.query_):
      if e1 != e2: return 0
    if self.has_return_varz_ != x.has_return_varz_: return 0
    if self.has_return_varz_ and self.return_varz_ != x.return_varz_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.query_)):
      if (not self.query_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.query_)
    for i in xrange(len(self.query_)): n += self.lengthString(self.query_[i].ByteSize())
    if (self.has_return_varz_): n += 2
    return n + 0

  def Clear(self):
    self.clear_query()
    self.clear_return_varz()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.query_)):
      out.putVarInt32(10)
      out.putVarInt32(self.query_[i].ByteSize())
      self.query_[i].OutputUnchecked(out)
    if (self.has_return_varz_):
      out.putVarInt32(16)
      out.putBoolean(self.return_varz_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_query().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_return_varz(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.query_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("query%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_return_varz_: res+=prefix+("return_varz: %s\n" % self.DebugFormatBool(self.return_varz_))
    return res

  kquery = 1
  kreturn_varz = 2

  _TEXT = (
   "ErrorCode",  #   0
   "query",  #   1
   "return_varz",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x25,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x2f,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0f,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x53,
    0x74,
    0x72,
    0x65,
    0x61,
    0x6d,
    0x53,
    0x70,
    0x65,
    0x63,
    0x13,
    0x1a,
    0x05,
    0x71,
    0x75,
    0x65,
    0x72,
    0x79,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x0c,
    0x4b,
    0x65,
    0x79,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x4c,
    0x69,
    0x73,
    0x74,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x72,
    0x65,
    0x74,
    0x75,
    0x72,
    0x6e,
    0x5f,
    0x76,
    0x61,
    0x72,
    0x7a,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class RemoteDataURLRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.url_ = ""
    self.queryparam_ = ""
    self.internal_execute_locally_ = 0
    self.has_url_ = 0
    self.has_queryparam_ = 0
    self.has_internal_execute_locally_ = 0
    if contents is not None: self.MergeFromString(contents)

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def queryparam(self): return self.queryparam_

  def set_queryparam(self, x):
    self.has_queryparam_ = 1
    self.queryparam_ = x

  def clear_queryparam(self):
    self.has_queryparam_ = 0
    self.queryparam_ = ""

  def has_queryparam(self): return self.has_queryparam_

  def internal_execute_locally(self): return self.internal_execute_locally_

  def set_internal_execute_locally(self, x):
    self.has_internal_execute_locally_ = 1
    self.internal_execute_locally_ = x

  def clear_internal_execute_locally(self):
    self.has_internal_execute_locally_ = 0
    self.internal_execute_locally_ = 0

  def has_internal_execute_locally(self): return self.has_internal_execute_locally_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_url()): self.set_url(x.url())
    if (x.has_queryparam()): self.set_queryparam(x.queryparam())
    if (x.has_internal_execute_locally()): self.set_internal_execute_locally(x.internal_execute_locally())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'RemoteDataURLRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'RemoteDataURLRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'RemoteDataURLRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'RemoteDataURLRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'RemoteDataURLRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if self.has_queryparam_ != x.has_queryparam_: return 0
    if self.has_queryparam_ and self.queryparam_ != x.queryparam_: return 0
    if self.has_internal_execute_locally_ != x.has_internal_execute_locally_: return 0
    if self.has_internal_execute_locally_ and self.internal_execute_locally_ != x.internal_execute_locally_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_url_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: url not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.url_))
    if (self.has_queryparam_): n += 1 + self.lengthString(len(self.queryparam_))
    if (self.has_internal_execute_locally_): n += 2
    return n + 1

  def Clear(self):
    self.clear_url()
    self.clear_queryparam()
    self.clear_internal_execute_locally()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.url_)
    if (self.has_queryparam_):
      out.putVarInt32(18)
      out.putPrefixedString(self.queryparam_)
    if (self.has_internal_execute_locally_):
      out.putVarInt32(24)
      out.putBoolean(self.internal_execute_locally_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_url(d.getPrefixedString())
        continue
      if tt == 18:
        self.set_queryparam(d.getPrefixedString())
        continue
      if tt == 24:
        self.set_internal_execute_locally(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_url_: res+=prefix+("url: %s\n" % self.DebugFormatString(self.url_))
    if self.has_queryparam_: res+=prefix+("queryparam: %s\n" % self.DebugFormatString(self.queryparam_))
    if self.has_internal_execute_locally_: res+=prefix+("internal_execute_locally: %s\n" % self.DebugFormatBool(self.internal_execute_locally_))
    return res

  kurl = 1
  kqueryparam = 2
  kinternal_execute_locally = 3

  _TEXT = (
   "ErrorCode",  #   0
   "url",  #   1
   "queryparam",  #   2
   "internal_execute_locally",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x25,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x2f,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x14,
    0x52,
    0x65,
    0x6d,
    0x6f,
    0x74,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x55,
    0x52,
    0x4c,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x03,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x71,
    0x75,
    0x65,
    0x72,
    0x79,
    0x70,
    0x61,
    0x72,
    0x61,
    0x6d,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x69,
    0x6e,
    0x74,
    0x65,
    0x72,
    0x6e,
    0x61,
    0x6c,
    0x5f,
    0x65,
    0x78,
    0x65,
    0x63,
    0x75,
    0x74,
    0x65,
    0x5f,
    0x6c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x6c,
    0x79,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class RemoteVariableRequest_Variable(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.labelset_ = KeyValueList()
    self.duration_ = 0.0
    self.start_after_ = 0.0
    self.start_time_ = 0.0
    self.finish_time_ = 0.0
    self.filter_stale_ = 0
    self.downsampling_ = None
    self.has_labelset_ = 0
    self.has_duration_ = 0
    self.has_start_after_ = 0
    self.has_start_time_ = 0
    self.has_finish_time_ = 0
    self.has_filter_stale_ = 0
    self.has_downsampling_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def labelset(self): return self.labelset_

  def mutable_labelset(self): self.has_labelset_ = 1; return self.labelset_

  def clear_labelset(self):self.has_labelset_ = 0; self.labelset_.Clear()

  def has_labelset(self): return self.has_labelset_

  def duration(self): return self.duration_

  def set_duration(self, x):
    self.has_duration_ = 1
    self.duration_ = x

  def clear_duration(self):
    self.has_duration_ = 0
    self.duration_ = 0.0

  def has_duration(self): return self.has_duration_

  def start_after(self): return self.start_after_

  def set_start_after(self, x):
    self.has_start_after_ = 1
    self.start_after_ = x

  def clear_start_after(self):
    self.has_start_after_ = 0
    self.start_after_ = 0.0

  def has_start_after(self): return self.has_start_after_

  def start_time(self): return self.start_time_

  def set_start_time(self, x):
    self.has_start_time_ = 1
    self.start_time_ = x

  def clear_start_time(self):
    self.has_start_time_ = 0
    self.start_time_ = 0.0

  def has_start_time(self): return self.has_start_time_

  def finish_time(self): return self.finish_time_

  def set_finish_time(self, x):
    self.has_finish_time_ = 1
    self.finish_time_ = x

  def clear_finish_time(self):
    self.has_finish_time_ = 0
    self.finish_time_ = 0.0

  def has_finish_time(self): return self.has_finish_time_

  def filter_stale(self): return self.filter_stale_

  def set_filter_stale(self, x):
    self.has_filter_stale_ = 1
    self.filter_stale_ = x

  def clear_filter_stale(self):
    self.has_filter_stale_ = 0
    self.filter_stale_ = 0

  def has_filter_stale(self): return self.has_filter_stale_

  def downsampling(self):
    if self.downsampling_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.downsampling_ is None: self.downsampling_ = DownsamplingSpec()
      finally:
        self.lazy_init_lock_.release()
    return self.downsampling_

  def mutable_downsampling(self): self.has_downsampling_ = 1; return self.downsampling()

  def clear_downsampling(self):
    #Warning: this method does not acquire the lock.
    self.has_downsampling_ = 0;
    if self.downsampling_ is not None: self.downsampling_.Clear()

  def has_downsampling(self): return self.has_downsampling_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_labelset()): self.mutable_labelset().MergeFrom(x.labelset())
    if (x.has_duration()): self.set_duration(x.duration())
    if (x.has_start_after()): self.set_start_after(x.start_after())
    if (x.has_start_time()): self.set_start_time(x.start_time())
    if (x.has_finish_time()): self.set_finish_time(x.finish_time())
    if (x.has_filter_stale()): self.set_filter_stale(x.filter_stale())
    if (x.has_downsampling()): self.mutable_downsampling().MergeFrom(x.downsampling())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'RemoteVariableRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'RemoteVariableRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'RemoteVariableRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'RemoteVariableRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'RemoteVariableRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_labelset_ != x.has_labelset_: return 0
    if self.has_labelset_ and self.labelset_ != x.labelset_: return 0
    if self.has_duration_ != x.has_duration_: return 0
    if self.has_duration_ and self.duration_ != x.duration_: return 0
    if self.has_start_after_ != x.has_start_after_: return 0
    if self.has_start_after_ and self.start_after_ != x.start_after_: return 0
    if self.has_start_time_ != x.has_start_time_: return 0
    if self.has_start_time_ and self.start_time_ != x.start_time_: return 0
    if self.has_finish_time_ != x.has_finish_time_: return 0
    if self.has_finish_time_ and self.finish_time_ != x.finish_time_: return 0
    if self.has_filter_stale_ != x.has_filter_stale_: return 0
    if self.has_filter_stale_ and self.filter_stale_ != x.filter_stale_: return 0
    if self.has_downsampling_ != x.has_downsampling_: return 0
    if self.has_downsampling_ and self.downsampling_ != x.downsampling_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_labelset_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: labelset not set.')
    elif not self.labelset_.IsInitialized(debug_strs): initialized = 0
    if (self.has_downsampling_ and not self.downsampling_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.labelset_.ByteSize())
    if (self.has_duration_): n += 9
    if (self.has_start_after_): n += 9
    if (self.has_start_time_): n += 9
    if (self.has_finish_time_): n += 9
    if (self.has_filter_stale_): n += 2
    if (self.has_downsampling_): n += 1 + self.lengthString(self.downsampling_.ByteSize())
    return n + 1

  def Clear(self):
    self.clear_labelset()
    self.clear_duration()
    self.clear_start_after()
    self.clear_start_time()
    self.clear_finish_time()
    self.clear_filter_stale()
    self.clear_downsampling()

  def OutputUnchecked(self, out):
    out.putVarInt32(18)
    out.putVarInt32(self.labelset_.ByteSize())
    self.labelset_.OutputUnchecked(out)
    if (self.has_duration_):
      out.putVarInt32(25)
      out.putDouble(self.duration_)
    if (self.has_start_after_):
      out.putVarInt32(33)
      out.putDouble(self.start_after_)
    if (self.has_start_time_):
      out.putVarInt32(41)
      out.putDouble(self.start_time_)
    if (self.has_finish_time_):
      out.putVarInt32(49)
      out.putDouble(self.finish_time_)
    if (self.has_filter_stale_):
      out.putVarInt32(56)
      out.putBoolean(self.filter_stale_)
    if (self.has_downsampling_):
      out.putVarInt32(66)
      out.putVarInt32(self.downsampling_.ByteSize())
      self.downsampling_.OutputUnchecked(out)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_labelset().TryMerge(tmp)
        continue
      if tt == 25:
        self.set_duration(d.getDouble())
        continue
      if tt == 33:
        self.set_start_after(d.getDouble())
        continue
      if tt == 41:
        self.set_start_time(d.getDouble())
        continue
      if tt == 49:
        self.set_finish_time(d.getDouble())
        continue
      if tt == 56:
        self.set_filter_stale(d.getBoolean())
        continue
      if tt == 66:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_downsampling().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_labelset_:
      res+=prefix+"labelset <\n"
      res+=self.labelset_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_duration_: res+=prefix+("duration: %s\n" % self.DebugFormat(self.duration_))
    if self.has_start_after_: res+=prefix+("start_after: %s\n" % self.DebugFormat(self.start_after_))
    if self.has_start_time_: res+=prefix+("start_time: %s\n" % self.DebugFormat(self.start_time_))
    if self.has_finish_time_: res+=prefix+("finish_time: %s\n" % self.DebugFormat(self.finish_time_))
    if self.has_filter_stale_: res+=prefix+("filter_stale: %s\n" % self.DebugFormatBool(self.filter_stale_))
    if self.has_downsampling_:
      res+=prefix+"downsampling <\n"
      res+=self.downsampling_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

class RemoteVariableRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.variable_ = []
    if contents is not None: self.MergeFromString(contents)

  def variable_size(self): return len(self.variable_)
  def variable_list(self): return self.variable_

  def variable(self, i):
    return self.variable_[i]

  def mutable_variable(self, i):
    return self.variable_[i]

  def add_variable(self):
    x = RemoteVariableRequest_Variable()
    self.variable_.append(x)
    return x

  def clear_variable(self):
    self.variable_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.variable_size()): self.add_variable().CopyFrom(x.variable(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'RemoteVariableRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'RemoteVariableRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'RemoteVariableRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'RemoteVariableRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'RemoteVariableRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.variable_) != len(x.variable_): return 0
    for e1, e2 in zip(self.variable_, x.variable_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.variable_)):
      if (not self.variable_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.variable_)
    for i in xrange(len(self.variable_)): n += self.variable_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_variable()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.variable_)):
      out.putVarInt32(11)
      self.variable_[i].OutputUnchecked(out)
      out.putVarInt32(12)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_variable().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.variable_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Variable%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kVariableGroup = 1
  kVariablelabelset = 2
  kVariableduration = 3
  kVariablestart_after = 4
  kVariablestart_time = 5
  kVariablefinish_time = 6
  kVariablefilter_stale = 7
  kVariabledownsampling = 8

  _TEXT = (
   "ErrorCode",  #   0
   "Variable",  #   1
   "labelset",  #   2
   "duration",  #   3
   "start_after",  #   4
   "start_time",  #   5
   "finish_time",  #   6
   "filter_stale",  #   7
   "downsampling",  #   8
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.DOUBLE,  #   3

   ProtocolBuffer.Encoder.DOUBLE,  #   4

   ProtocolBuffer.Encoder.DOUBLE,  #   5

   ProtocolBuffer.Encoder.DOUBLE,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x25,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x2f,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2f,
    0x6d,
    0x6f,
    0x6e,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x15,
    0x52,
    0x65,
    0x6d,
    0x6f,
    0x74,
    0x65,
    0x56,
    0x61,
    0x72,
    0x69,
    0x61,
    0x62,
    0x6c,
    0x65,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x08,
    0x56,
    0x61,
    0x72,
    0x69,
    0x61,
    0x62,
    0x6c,
    0x65,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x56,
    0x61,
    0x72,
    0x69,
    0x61,
    0x62,
    0x6c,
    0x65,
    0x2e,
    0x6c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x73,
    0x65,
    0x74,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x0c,
    0x4b,
    0x65,
    0x79,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x4c,
    0x69,
    0x73,
    0x74,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x56,
    0x61,
    0x72,
    0x69,
    0x61,
    0x62,
    0x6c,
    0x65,
    0x2e,
    0x64,
    0x75,
    0x72,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x03,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0x60,
    0x00,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x56,
    0x61,
    0x72,
    0x69,
    0x61,
    0x62,
    0x6c,
    0x65,
    0x2e,
    0x73,
    0x74,
    0x61,
    0x72,
    0x74,
    0x5f,
    0x61,
    0x66,
    0x74,
    0x65,
    0x72,
    0x20,
    0x04,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x56,
    0x61,
    0x72,
    0x69,
    0x61,
    0x62,
    0x6c,
    0x65,
    0x2e,
    0x73,
    0x74,
    0x61,
    0x72,
    0x74,
    0x5f,
    0x74,
    0x69,
    0x6d,
    0x65,
    0x20,
    0x05,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x56,
    0x61,
    0x72,
    0x69,
    0x61,
    0x62,
    0x6c,
    0x65,
    0x2e,
    0x66,
    0x69,
    0x6e,
    0x69,
    0x73,
    0x68,
    0x5f,
    0x74,
    0x69,
    0x6d,
    0x65,
    0x20,
    0x06,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x56,
    0x61,
    0x72,
    0x69,
    0x61,
    0x62,
    0x6c,
    0x65,
    0x2e,
    0x66,
    0x69,
    0x6c,
    0x74,
    0x65,
    0x72,
    0x5f,
    0x73,
    0x74,
    0x61,
    0x6c,
    0x65,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x56,
    0x61,
    0x72,
    0x69,
    0x61,
    0x62,
    0x6c,
    0x65,
    0x2e,
    0x64,
    0x6f,
    0x77,
    0x6e,
    0x73,
    0x61,
    0x6d,
    0x70,
    0x6c,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x18,
    0x62,
    0x6f,
    0x72,
    0x67,
    0x6d,
    0x6f,
    0x6e,
    0x2e,
    0x44,
    0x6f,
    0x77,
    0x6e,
    0x73,
    0x61,
    0x6d,
    0x70,
    0x6c,
    0x69,
    0x6e,
    0x67,
    0x53,
    0x70,
    0x65,
    0x63,
    0x60,
    0x00,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())


class _RuleEvaluator_ClientStub(_client_stub_base_class):
  """Makes Stubby RPC calls to a RuleEvaluator server."""

  __slots__ = (
      '_protorpc_Evaluate', '_full_name_Evaluate',
      '_protorpc_EvaluateMany', '_full_name_EvaluateMany',
  )

  def __init__(self, rpc_stub_parameters):
    rpc_internals.StubbyRPCBaseStub.__init__(self,
                                             'RuleEvaluator',
                                             rpc_stub_parameters)

    self._protorpc_Evaluate = pywraprpc.RPC()
    self._full_name_Evaluate = self._stub.GetFullMethodName(
        'Evaluate')

    self._protorpc_EvaluateMany = pywraprpc.RPC()
    self._full_name_EvaluateMany = self._stub.GetFullMethodName(
        'EvaluateMany')

  def Evaluate(self, request, rpc=None, callback=None):
    """Make a Evaluate RPC call.

    Args:
      request: a EvaluateRequest instance.
      rpc: Optional RPC instance to use for the call.
      callback: Optional callback. Will be called as
          callback(rpc, result). If None, the call synchronous.

    Returns:
      The Value if callback is None. Otherwise, returns None.
    """

    return self._MakeCall(rpc,
                          self._full_name_Evaluate,
                          'Evaluate',
                          request,
                          Value,
                          callback,
                          self._protorpc_Evaluate)

  def EvaluateMany(self, request, rpc=None, callback=None):
    """Make a EvaluateMany RPC call.

    Args:
      request: a EvaluateManyRequest instance.
      rpc: Optional RPC instance to use for the call.
      callback: Optional callback. Will be called as
          callback(rpc, result). If None, the call synchronous.

    Returns:
      The ManyValue if callback is None. Otherwise, returns None.
    """

    return self._MakeCall(rpc,
                          self._full_name_EvaluateMany,
                          'EvaluateMany',
                          request,
                          ManyValue,
                          callback,
                          self._protorpc_EvaluateMany)


class RuleEvaluator(object):
  """Base class for RuleEvaluator Stubby servers."""

  def __init__(self):
    raise NotImplementedError('Server stubs are not supported yet. '
                              'Use RuleEvaluator.NewStub(...) to '
                              'create a client stub')

  def NewStub(rpc_stub_parameters):
    """Creates a new RuleEvaluator Stubby client stub.

    Args:
      rpc_stub_parameters: an RPC_StubParameter instance.
    """

    if _client_stub_base_class is object:
      raise RuntimeError('Add //net/rpc/python as a dependency to use Stubby')
    return _RuleEvaluator_ClientStub(rpc_stub_parameters)
  NewStub = staticmethod(NewStub)


class _VariableExporter_ClientStub(_client_stub_base_class):
  """Makes Stubby RPC calls to a VariableExporter server."""

  __slots__ = (
      '_protorpc_ExportToValueStream', '_full_name_ExportToValueStream',
      '_protorpc_ValueStreamRequest', '_full_name_ValueStreamRequest',
  )

  def __init__(self, rpc_stub_parameters):
    rpc_internals.StubbyRPCBaseStub.__init__(self,
                                             'VariableExporter',
                                             rpc_stub_parameters)

    self._protorpc_ExportToValueStream = pywraprpc.RPC()
    self._full_name_ExportToValueStream = self._stub.GetFullMethodName(
        'ExportToValueStream')

    self._protorpc_ValueStreamRequest = pywraprpc.RPC()
    self._full_name_ValueStreamRequest = self._stub.GetFullMethodName(
        'ValueStreamRequest')

  def ExportToValueStream(self, request, rpc=None, callback=None):
    """Make a ExportToValueStream RPC call.

    Args:
      request: a KeyValueList instance.
      rpc: Optional RPC instance to use for the call.
      callback: Optional callback. Will be called as
          callback(rpc, result). If None, the call synchronous.

    Returns:
      The ValueStream if callback is None. Otherwise, returns None.
    """

    return self._MakeCall(rpc,
                          self._full_name_ExportToValueStream,
                          'ExportToValueStream',
                          request,
                          ValueStream,
                          callback,
                          self._protorpc_ExportToValueStream)

  def ValueStreamRequest(self, request, rpc=None, callback=None):
    """Make a ValueStreamRequest RPC call.

    Args:
      request: a ValueStreamSpec instance.
      rpc: Optional RPC instance to use for the call.
      callback: Optional callback. Will be called as
          callback(rpc, result). If None, the call synchronous.

    Returns:
      The ValueStream if callback is None. Otherwise, returns None.
    """

    return self._MakeCall(rpc,
                          self._full_name_ValueStreamRequest,
                          'ValueStreamRequest',
                          request,
                          ValueStream,
                          callback,
                          self._protorpc_ValueStreamRequest)


class VariableExporter(object):
  """Base class for VariableExporter Stubby servers."""

  def __init__(self):
    raise NotImplementedError('Server stubs are not supported yet. '
                              'Use VariableExporter.NewStub(...) to '
                              'create a client stub')

  def NewStub(rpc_stub_parameters):
    """Creates a new VariableExporter Stubby client stub.

    Args:
      rpc_stub_parameters: an RPC_StubParameter instance.
    """

    if _client_stub_base_class is object:
      raise RuntimeError('Add //net/rpc/python as a dependency to use Stubby')
    return _VariableExporter_ClientStub(rpc_stub_parameters)
  NewStub = staticmethod(NewStub)


class _RemoteDataSource_ClientStub(_client_stub_base_class):
  """Makes Stubby RPC calls to a RemoteDataSource server."""

  __slots__ = (
      '_protorpc_GetData', '_full_name_GetData',
      '_protorpc_RemoteVariableReference', '_full_name_RemoteVariableReference',
  )

  def __init__(self, rpc_stub_parameters):
    rpc_internals.StubbyRPCBaseStub.__init__(self,
                                             'RemoteDataSource',
                                             rpc_stub_parameters)

    self._protorpc_GetData = pywraprpc.RPC()
    self._protorpc_GetData.set_deadline(240)
    self._protorpc_GetData.set_fail_fast(True)
    self._full_name_GetData = self._stub.GetFullMethodName(
        'GetData')

    self._protorpc_RemoteVariableReference = pywraprpc.RPC()
    self._full_name_RemoteVariableReference = self._stub.GetFullMethodName(
        'RemoteVariableReference')

  def GetData(self, request, rpc=None, callback=None):
    """Make a GetData RPC call.

    Args:
      request: a RemoteDataURLRequest instance.
      rpc: Optional RPC instance to use for the call.
      callback: Optional callback. Will be called as
          callback(rpc, result). If None, the call synchronous.

    Returns:
      The ManyValue if callback is None. Otherwise, returns None.
    """

    return self._MakeCall(rpc,
                          self._full_name_GetData,
                          'GetData',
                          request,
                          ManyValue,
                          callback,
                          self._protorpc_GetData)

  def RemoteVariableReference(self, request, rpc=None, callback=None):
    """Make a RemoteVariableReference RPC call.

    Args:
      request: a RemoteVariableRequest instance.
      rpc: Optional RPC instance to use for the call.
      callback: Optional callback. Will be called as
          callback(rpc, result). If None, the call synchronous.

    Returns:
      The ValueStream if callback is None. Otherwise, returns None.
    """

    return self._MakeCall(rpc,
                          self._full_name_RemoteVariableReference,
                          'RemoteVariableReference',
                          request,
                          ValueStream,
                          callback,
                          self._protorpc_RemoteVariableReference)


class RemoteDataSource(object):
  """Base class for RemoteDataSource Stubby servers."""

  def __init__(self):
    raise NotImplementedError('Server stubs are not supported yet. '
                              'Use RemoteDataSource.NewStub(...) to '
                              'create a client stub')

  def NewStub(rpc_stub_parameters):
    """Creates a new RemoteDataSource Stubby client stub.

    Args:
      rpc_stub_parameters: an RPC_StubParameter instance.
    """

    if _client_stub_base_class is object:
      raise RuntimeError('Add //net/rpc/python as a dependency to use Stubby')
    return _RemoteDataSource_ClientStub(rpc_stub_parameters)
  NewStub = staticmethod(NewStub)

__all__ = ['RuleRequest','SmartValue','SmartValue_Series','Value','Value_SeriesPoint','Value_SeriesStringValue','Value_Series','EvaluateRequest','EvaluateManyRequest','ManyValue','ValueStream','ValueStream_Value','KeyValueList','KeyValueList_Entry','ValueStreamSpec','RemoteDataURLRequest','RemoteVariableRequest','RemoteVariableRequest_Variable']
