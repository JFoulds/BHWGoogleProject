# This file automatically generated by protocol-compiler from indexer/perdocdata/perdocdata.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

from google3.mustang.repository.navboost.proto.navboostmustang_pb import NavBoostDocument
from google3.wireless.mobile_restrict.indexer.carrier_metadata_pb import CarrierMetadata
from google3.spam.signaturematcher.proto.signaturedata_pb import SignatureData
from google3.net.proto.message_set import MessageSet
class PhilPerDocData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.philstring_ = ""
    self.philversion_ = 0
    self.has_philstring_ = 0
    self.has_philversion_ = 0
    if contents is not None: self.MergeFromString(contents)

  def philstring(self): return self.philstring_

  def set_philstring(self, x):
    self.has_philstring_ = 1
    self.philstring_ = x

  def clear_philstring(self):
    self.has_philstring_ = 0
    self.philstring_ = ""

  def has_philstring(self): return self.has_philstring_

  def philversion(self): return self.philversion_

  def set_philversion(self, x):
    self.has_philversion_ = 1
    self.philversion_ = x

  def clear_philversion(self):
    self.has_philversion_ = 0
    self.philversion_ = 0

  def has_philversion(self): return self.has_philversion_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_philstring()): self.set_philstring(x.philstring())
    if (x.has_philversion()): self.set_philversion(x.philversion())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'PhilPerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'PhilPerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'PhilPerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'PhilPerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'PhilPerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_philstring_ != x.has_philstring_: return 0
    if self.has_philstring_ and self.philstring_ != x.philstring_: return 0
    if self.has_philversion_ != x.has_philversion_: return 0
    if self.has_philversion_ and self.philversion_ != x.philversion_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_philstring_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: philstring not set.')
    if (not self.has_philversion_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: philversion not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.philstring_))
    n += self.lengthVarInt64(self.philversion_)
    return n + 2

  def Clear(self):
    self.clear_philstring()
    self.clear_philversion()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.philstring_)
    out.putVarInt32(16)
    out.putVarInt32(self.philversion_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_philstring(d.getPrefixedString())
        continue
      if tt == 16:
        self.set_philversion(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_philstring_: res+=prefix+("PhilString: %s\n" % self.DebugFormatString(self.philstring_))
    if self.has_philversion_: res+=prefix+("PhilVersion: %s\n" % self.DebugFormatInt32(self.philversion_))
    return res

  kPhilString = 1
  kPhilVersion = 2

  _TEXT = (
   "ErrorCode",  #   0
   "PhilString",  #   1
   "PhilVersion",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0e,
    0x50,
    0x68,
    0x69,
    0x6c,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x0a,
    0x50,
    0x68,
    0x69,
    0x6c,
    0x53,
    0x74,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x50,
    0x68,
    0x69,
    0x6c,
    0x56,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ImagePerDocData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.filename_ = ""
    self.height_ = 0
    self.width_ = 0
    self.flags_ = 0
    self.entropy_color_ = 0
    self.has_filename_ = 0
    self.has_height_ = 0
    self.has_width_ = 0
    self.has_flags_ = 0
    self.has_entropy_color_ = 0
    if contents is not None: self.MergeFromString(contents)

  def filename(self): return self.filename_

  def set_filename(self, x):
    self.has_filename_ = 1
    self.filename_ = x

  def clear_filename(self):
    self.has_filename_ = 0
    self.filename_ = ""

  def has_filename(self): return self.has_filename_

  def height(self): return self.height_

  def set_height(self, x):
    self.has_height_ = 1
    self.height_ = x

  def clear_height(self):
    self.has_height_ = 0
    self.height_ = 0

  def has_height(self): return self.has_height_

  def width(self): return self.width_

  def set_width(self, x):
    self.has_width_ = 1
    self.width_ = x

  def clear_width(self):
    self.has_width_ = 0
    self.width_ = 0

  def has_width(self): return self.has_width_

  def flags(self): return self.flags_

  def set_flags(self, x):
    self.has_flags_ = 1
    self.flags_ = x

  def clear_flags(self):
    self.has_flags_ = 0
    self.flags_ = 0

  def has_flags(self): return self.has_flags_

  def entropy_color(self): return self.entropy_color_

  def set_entropy_color(self, x):
    self.has_entropy_color_ = 1
    self.entropy_color_ = x

  def clear_entropy_color(self):
    self.has_entropy_color_ = 0
    self.entropy_color_ = 0

  def has_entropy_color(self): return self.has_entropy_color_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_filename()): self.set_filename(x.filename())
    if (x.has_height()): self.set_height(x.height())
    if (x.has_width()): self.set_width(x.width())
    if (x.has_flags()): self.set_flags(x.flags())
    if (x.has_entropy_color()): self.set_entropy_color(x.entropy_color())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ImagePerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ImagePerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ImagePerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ImagePerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ImagePerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_filename_ != x.has_filename_: return 0
    if self.has_filename_ and self.filename_ != x.filename_: return 0
    if self.has_height_ != x.has_height_: return 0
    if self.has_height_ and self.height_ != x.height_: return 0
    if self.has_width_ != x.has_width_: return 0
    if self.has_width_ and self.width_ != x.width_: return 0
    if self.has_flags_ != x.has_flags_: return 0
    if self.has_flags_ and self.flags_ != x.flags_: return 0
    if self.has_entropy_color_ != x.has_entropy_color_: return 0
    if self.has_entropy_color_ and self.entropy_color_ != x.entropy_color_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_filename_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: filename not set.')
    if (not self.has_height_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: height not set.')
    if (not self.has_width_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: width not set.')
    if (not self.has_flags_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: flags not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.filename_))
    n += self.lengthVarInt64(self.height_)
    n += self.lengthVarInt64(self.width_)
    n += self.lengthVarInt64(self.flags_)
    if (self.has_entropy_color_): n += 5
    return n + 4

  def Clear(self):
    self.clear_filename()
    self.clear_height()
    self.clear_width()
    self.clear_flags()
    self.clear_entropy_color()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.filename_)
    out.putVarInt32(16)
    out.putVarInt32(self.height_)
    out.putVarInt32(24)
    out.putVarInt32(self.width_)
    out.putVarInt32(32)
    out.putVarInt32(self.flags_)
    if (self.has_entropy_color_):
      out.putVarInt32(45)
      out.put32(self.entropy_color_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_filename(d.getPrefixedString())
        continue
      if tt == 16:
        self.set_height(d.getVarInt32())
        continue
      if tt == 24:
        self.set_width(d.getVarInt32())
        continue
      if tt == 32:
        self.set_flags(d.getVarInt32())
        continue
      if tt == 45:
        self.set_entropy_color(d.get32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_filename_: res+=prefix+("filename: %s\n" % self.DebugFormatString(self.filename_))
    if self.has_height_: res+=prefix+("height: %s\n" % self.DebugFormatInt32(self.height_))
    if self.has_width_: res+=prefix+("width: %s\n" % self.DebugFormatInt32(self.width_))
    if self.has_flags_: res+=prefix+("flags: %s\n" % self.DebugFormatInt32(self.flags_))
    if self.has_entropy_color_: res+=prefix+("entropy_color: %s\n" % self.DebugFormatFixed32(self.entropy_color_))
    return res

  kfilename = 1
  kheight = 2
  kwidth = 3
  kflags = 4
  kentropy_color = 5

  _TEXT = (
   "ErrorCode",  #   0
   "filename",  #   1
   "height",  #   2
   "width",  #   3
   "flags",  #   4
   "entropy_color",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.FLOAT,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0f,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x08,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x68,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x77,
    0x69,
    0x64,
    0x74,
    0x68,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x66,
    0x6c,
    0x61,
    0x67,
    0x73,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x65,
    0x6e,
    0x74,
    0x72,
    0x6f,
    0x70,
    0x79,
    0x5f,
    0x63,
    0x6f,
    0x6c,
    0x6f,
    0x72,
    0x20,
    0x05,
    0x28,
    0x05,
    0x30,
    0x07,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class KaltixPerDocData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.kaltixrank_ = 0
    self.sitekaltixrank_ = 0
    self.localkaltixrank_ = 0
    self.has_kaltixrank_ = 0
    self.has_sitekaltixrank_ = 0
    self.has_localkaltixrank_ = 0
    if contents is not None: self.MergeFromString(contents)

  def kaltixrank(self): return self.kaltixrank_

  def set_kaltixrank(self, x):
    self.has_kaltixrank_ = 1
    self.kaltixrank_ = x

  def clear_kaltixrank(self):
    self.has_kaltixrank_ = 0
    self.kaltixrank_ = 0

  def has_kaltixrank(self): return self.has_kaltixrank_

  def sitekaltixrank(self): return self.sitekaltixrank_

  def set_sitekaltixrank(self, x):
    self.has_sitekaltixrank_ = 1
    self.sitekaltixrank_ = x

  def clear_sitekaltixrank(self):
    self.has_sitekaltixrank_ = 0
    self.sitekaltixrank_ = 0

  def has_sitekaltixrank(self): return self.has_sitekaltixrank_

  def localkaltixrank(self): return self.localkaltixrank_

  def set_localkaltixrank(self, x):
    self.has_localkaltixrank_ = 1
    self.localkaltixrank_ = x

  def clear_localkaltixrank(self):
    self.has_localkaltixrank_ = 0
    self.localkaltixrank_ = 0

  def has_localkaltixrank(self): return self.has_localkaltixrank_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_kaltixrank()): self.set_kaltixrank(x.kaltixrank())
    if (x.has_sitekaltixrank()): self.set_sitekaltixrank(x.sitekaltixrank())
    if (x.has_localkaltixrank()): self.set_localkaltixrank(x.localkaltixrank())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'KaltixPerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'KaltixPerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'KaltixPerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'KaltixPerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'KaltixPerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_kaltixrank_ != x.has_kaltixrank_: return 0
    if self.has_kaltixrank_ and self.kaltixrank_ != x.kaltixrank_: return 0
    if self.has_sitekaltixrank_ != x.has_sitekaltixrank_: return 0
    if self.has_sitekaltixrank_ and self.sitekaltixrank_ != x.sitekaltixrank_: return 0
    if self.has_localkaltixrank_ != x.has_localkaltixrank_: return 0
    if self.has_localkaltixrank_ and self.localkaltixrank_ != x.localkaltixrank_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_kaltixrank_): n += 1 + self.lengthVarInt64(self.kaltixrank_)
    if (self.has_sitekaltixrank_): n += 1 + self.lengthVarInt64(self.sitekaltixrank_)
    if (self.has_localkaltixrank_): n += 1 + self.lengthVarInt64(self.localkaltixrank_)
    return n + 0

  def Clear(self):
    self.clear_kaltixrank()
    self.clear_sitekaltixrank()
    self.clear_localkaltixrank()

  def OutputUnchecked(self, out):
    if (self.has_kaltixrank_):
      out.putVarInt32(8)
      out.putVarInt32(self.kaltixrank_)
    if (self.has_sitekaltixrank_):
      out.putVarInt32(16)
      out.putVarInt32(self.sitekaltixrank_)
    if (self.has_localkaltixrank_):
      out.putVarInt32(24)
      out.putVarInt32(self.localkaltixrank_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_kaltixrank(d.getVarInt32())
        continue
      if tt == 16:
        self.set_sitekaltixrank(d.getVarInt32())
        continue
      if tt == 24:
        self.set_localkaltixrank(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_kaltixrank_: res+=prefix+("KaltixRank: %s\n" % self.DebugFormatInt32(self.kaltixrank_))
    if self.has_sitekaltixrank_: res+=prefix+("SiteKaltixRank: %s\n" % self.DebugFormatInt32(self.sitekaltixrank_))
    if self.has_localkaltixrank_: res+=prefix+("LocalKaltixRank: %s\n" % self.DebugFormatInt32(self.localkaltixrank_))
    return res

  kKaltixRank = 1
  kSiteKaltixRank = 2
  kLocalKaltixRank = 3

  _TEXT = (
   "ErrorCode",  #   0
   "KaltixRank",  #   1
   "SiteKaltixRank",  #   2
   "LocalKaltixRank",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x10,
    0x4b,
    0x61,
    0x6c,
    0x74,
    0x69,
    0x78,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x0a,
    0x4b,
    0x61,
    0x6c,
    0x74,
    0x69,
    0x78,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x53,
    0x69,
    0x74,
    0x65,
    0x4b,
    0x61,
    0x6c,
    0x74,
    0x69,
    0x78,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x4b,
    0x61,
    0x6c,
    0x74,
    0x69,
    0x78,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class CrowdingPerDocData_NewsCluster(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.clusterid_ = 0
    self.clustertimestamp_ = 0
    self.clustersize_ = 0
    self.has_clusterid_ = 0
    self.has_clustertimestamp_ = 0
    self.has_clustersize_ = 0
    if contents is not None: self.MergeFromString(contents)

  def clusterid(self): return self.clusterid_

  def set_clusterid(self, x):
    self.has_clusterid_ = 1
    self.clusterid_ = x

  def clear_clusterid(self):
    self.has_clusterid_ = 0
    self.clusterid_ = 0

  def has_clusterid(self): return self.has_clusterid_

  def clustertimestamp(self): return self.clustertimestamp_

  def set_clustertimestamp(self, x):
    self.has_clustertimestamp_ = 1
    self.clustertimestamp_ = x

  def clear_clustertimestamp(self):
    self.has_clustertimestamp_ = 0
    self.clustertimestamp_ = 0

  def has_clustertimestamp(self): return self.has_clustertimestamp_

  def clustersize(self): return self.clustersize_

  def set_clustersize(self, x):
    self.has_clustersize_ = 1
    self.clustersize_ = x

  def clear_clustersize(self):
    self.has_clustersize_ = 0
    self.clustersize_ = 0

  def has_clustersize(self): return self.has_clustersize_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_clusterid()): self.set_clusterid(x.clusterid())
    if (x.has_clustertimestamp()): self.set_clustertimestamp(x.clustertimestamp())
    if (x.has_clustersize()): self.set_clustersize(x.clustersize())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'CrowdingPerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'CrowdingPerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'CrowdingPerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'CrowdingPerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'CrowdingPerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_clusterid_ != x.has_clusterid_: return 0
    if self.has_clusterid_ and self.clusterid_ != x.clusterid_: return 0
    if self.has_clustertimestamp_ != x.has_clustertimestamp_: return 0
    if self.has_clustertimestamp_ and self.clustertimestamp_ != x.clustertimestamp_: return 0
    if self.has_clustersize_ != x.has_clustersize_: return 0
    if self.has_clustersize_ and self.clustersize_ != x.clustersize_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_clusterid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: clusterid not set.')
    if (not self.has_clustertimestamp_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: clustertimestamp not set.')
    if (not self.has_clustersize_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: clustersize not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.clustertimestamp_)
    n += self.lengthVarInt64(self.clustersize_)
    return n + 11

  def Clear(self):
    self.clear_clusterid()
    self.clear_clustertimestamp()
    self.clear_clustersize()

  def OutputUnchecked(self, out):
    out.putVarInt32(17)
    out.put64(self.clusterid_)
    out.putVarInt32(24)
    out.putVarInt32(self.clustertimestamp_)
    out.putVarInt32(32)
    out.putVarInt32(self.clustersize_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 17:
        self.set_clusterid(d.get64())
        continue
      if tt == 24:
        self.set_clustertimestamp(d.getVarInt32())
        continue
      if tt == 32:
        self.set_clustersize(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_clusterid_: res+=prefix+("ClusterId: %s\n" % self.DebugFormatFixed64(self.clusterid_))
    if self.has_clustertimestamp_: res+=prefix+("ClusterTimeStamp: %s\n" % self.DebugFormatInt32(self.clustertimestamp_))
    if self.has_clustersize_: res+=prefix+("ClusterSize: %s\n" % self.DebugFormatInt32(self.clustersize_))
    return res

class CrowdingPerDocData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.newscluster_ = []
    if contents is not None: self.MergeFromString(contents)

  def newscluster_size(self): return len(self.newscluster_)
  def newscluster_list(self): return self.newscluster_

  def newscluster(self, i):
    return self.newscluster_[i]

  def mutable_newscluster(self, i):
    return self.newscluster_[i]

  def add_newscluster(self):
    x = CrowdingPerDocData_NewsCluster()
    self.newscluster_.append(x)
    return x

  def clear_newscluster(self):
    self.newscluster_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.newscluster_size()): self.add_newscluster().CopyFrom(x.newscluster(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'CrowdingPerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'CrowdingPerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'CrowdingPerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'CrowdingPerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'CrowdingPerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.newscluster_) != len(x.newscluster_): return 0
    for e1, e2 in zip(self.newscluster_, x.newscluster_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.newscluster_)):
      if (not self.newscluster_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.newscluster_)
    for i in xrange(len(self.newscluster_)): n += self.newscluster_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_newscluster()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.newscluster_)):
      out.putVarInt32(11)
      self.newscluster_[i].OutputUnchecked(out)
      out.putVarInt32(12)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_newscluster().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.newscluster_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("NewsCluster%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kNewsClusterGroup = 1
  kNewsClusterClusterId = 2
  kNewsClusterClusterTimeStamp = 3
  kNewsClusterClusterSize = 4

  _TEXT = (
   "ErrorCode",  #   0
   "NewsCluster",  #   1
   "ClusterId",  #   2
   "ClusterTimeStamp",  #   3
   "ClusterSize",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.DOUBLE,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x12,
    0x43,
    0x72,
    0x6f,
    0x77,
    0x64,
    0x69,
    0x6e,
    0x67,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x0b,
    0x4e,
    0x65,
    0x77,
    0x73,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x4e,
    0x65,
    0x77,
    0x73,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x49,
    0x64,
    0x20,
    0x02,
    0x28,
    0x01,
    0x30,
    0x06,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x4e,
    0x65,
    0x77,
    0x73,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x53,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x4e,
    0x65,
    0x77,
    0x73,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x53,
    0x69,
    0x7a,
    0x65,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class OceanPerDocData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.volumeid_ = 0
    self.pageid_ = 0
    self.page_number_ = 0
    self.num_pages_ = 0
    self.flags_ = 0
    self.has_volumeid_ = 0
    self.has_pageid_ = 0
    self.has_page_number_ = 0
    self.has_num_pages_ = 0
    self.has_flags_ = 0
    if contents is not None: self.MergeFromString(contents)

  def volumeid(self): return self.volumeid_

  def set_volumeid(self, x):
    self.has_volumeid_ = 1
    self.volumeid_ = x

  def clear_volumeid(self):
    self.has_volumeid_ = 0
    self.volumeid_ = 0

  def has_volumeid(self): return self.has_volumeid_

  def pageid(self): return self.pageid_

  def set_pageid(self, x):
    self.has_pageid_ = 1
    self.pageid_ = x

  def clear_pageid(self):
    self.has_pageid_ = 0
    self.pageid_ = 0

  def has_pageid(self): return self.has_pageid_

  def page_number(self): return self.page_number_

  def set_page_number(self, x):
    self.has_page_number_ = 1
    self.page_number_ = x

  def clear_page_number(self):
    self.has_page_number_ = 0
    self.page_number_ = 0

  def has_page_number(self): return self.has_page_number_

  def num_pages(self): return self.num_pages_

  def set_num_pages(self, x):
    self.has_num_pages_ = 1
    self.num_pages_ = x

  def clear_num_pages(self):
    self.has_num_pages_ = 0
    self.num_pages_ = 0

  def has_num_pages(self): return self.has_num_pages_

  def flags(self): return self.flags_

  def set_flags(self, x):
    self.has_flags_ = 1
    self.flags_ = x

  def clear_flags(self):
    self.has_flags_ = 0
    self.flags_ = 0

  def has_flags(self): return self.has_flags_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_volumeid()): self.set_volumeid(x.volumeid())
    if (x.has_pageid()): self.set_pageid(x.pageid())
    if (x.has_page_number()): self.set_page_number(x.page_number())
    if (x.has_num_pages()): self.set_num_pages(x.num_pages())
    if (x.has_flags()): self.set_flags(x.flags())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanPerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanPerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanPerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanPerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanPerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_volumeid_ != x.has_volumeid_: return 0
    if self.has_volumeid_ and self.volumeid_ != x.volumeid_: return 0
    if self.has_pageid_ != x.has_pageid_: return 0
    if self.has_pageid_ and self.pageid_ != x.pageid_: return 0
    if self.has_page_number_ != x.has_page_number_: return 0
    if self.has_page_number_ and self.page_number_ != x.page_number_: return 0
    if self.has_num_pages_ != x.has_num_pages_: return 0
    if self.has_num_pages_ and self.num_pages_ != x.num_pages_: return 0
    if self.has_flags_ != x.has_flags_: return 0
    if self.has_flags_ and self.flags_ != x.flags_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_volumeid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: volumeid not set.')
    if (not self.has_pageid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: pageid not set.')
    if (not self.has_page_number_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: page_number not set.')
    if (not self.has_num_pages_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: num_pages not set.')
    if (not self.has_flags_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: flags not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.volumeid_)
    n += self.lengthVarInt64(self.pageid_)
    n += self.lengthVarInt64(self.page_number_)
    n += self.lengthVarInt64(self.num_pages_)
    n += self.lengthVarInt64(self.flags_)
    return n + 5

  def Clear(self):
    self.clear_volumeid()
    self.clear_pageid()
    self.clear_page_number()
    self.clear_num_pages()
    self.clear_flags()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarUint64(self.volumeid_)
    out.putVarInt32(16)
    out.putVarInt32(self.pageid_)
    out.putVarInt32(24)
    out.putVarInt32(self.page_number_)
    out.putVarInt32(32)
    out.putVarInt32(self.num_pages_)
    out.putVarInt32(40)
    out.putVarUint64(self.flags_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_volumeid(d.getVarUint64())
        continue
      if tt == 16:
        self.set_pageid(d.getVarInt32())
        continue
      if tt == 24:
        self.set_page_number(d.getVarInt32())
        continue
      if tt == 32:
        self.set_num_pages(d.getVarInt32())
        continue
      if tt == 40:
        self.set_flags(d.getVarUint64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_volumeid_: res+=prefix+("volumeid: %s\n" % self.DebugFormatInt64(self.volumeid_))
    if self.has_pageid_: res+=prefix+("pageid: %s\n" % self.DebugFormatInt32(self.pageid_))
    if self.has_page_number_: res+=prefix+("page_number: %s\n" % self.DebugFormatInt32(self.page_number_))
    if self.has_num_pages_: res+=prefix+("num_pages: %s\n" % self.DebugFormatInt32(self.num_pages_))
    if self.has_flags_: res+=prefix+("flags: %s\n" % self.DebugFormatInt64(self.flags_))
    return res

  kvolumeid = 1
  kpageid = 2
  kpage_number = 3
  knum_pages = 4
  kflags = 5

  _TEXT = (
   "ErrorCode",  #   0
   "volumeid",  #   1
   "pageid",  #   2
   "page_number",  #   3
   "num_pages",  #   4
   "flags",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0f,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x08,
    0x76,
    0x6f,
    0x6c,
    0x75,
    0x6d,
    0x65,
    0x69,
    0x64,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x70,
    0x61,
    0x67,
    0x65,
    0x69,
    0x64,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x6e,
    0x75,
    0x6d,
    0x5f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x66,
    0x6c,
    0x61,
    0x67,
    0x73,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class GroupsPerDocData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 1446266 

  _TypeId_NAMES = {
    1446266: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.groupid_ = 0
    self.authorid_ = 0
    self.threadid_ = 0
    self.has_groupid_ = 0
    self.has_authorid_ = 0
    self.has_threadid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def groupid(self): return self.groupid_

  def set_groupid(self, x):
    self.has_groupid_ = 1
    self.groupid_ = x

  def clear_groupid(self):
    self.has_groupid_ = 0
    self.groupid_ = 0

  def has_groupid(self): return self.has_groupid_

  def authorid(self): return self.authorid_

  def set_authorid(self, x):
    self.has_authorid_ = 1
    self.authorid_ = x

  def clear_authorid(self):
    self.has_authorid_ = 0
    self.authorid_ = 0

  def has_authorid(self): return self.has_authorid_

  def threadid(self): return self.threadid_

  def set_threadid(self, x):
    self.has_threadid_ = 1
    self.threadid_ = x

  def clear_threadid(self):
    self.has_threadid_ = 0
    self.threadid_ = 0

  def has_threadid(self): return self.has_threadid_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_groupid()): self.set_groupid(x.groupid())
    if (x.has_authorid()): self.set_authorid(x.authorid())
    if (x.has_threadid()): self.set_threadid(x.threadid())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'GroupsPerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'GroupsPerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'GroupsPerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'GroupsPerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'GroupsPerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_groupid_ != x.has_groupid_: return 0
    if self.has_groupid_ and self.groupid_ != x.groupid_: return 0
    if self.has_authorid_ != x.has_authorid_: return 0
    if self.has_authorid_ and self.authorid_ != x.authorid_: return 0
    if self.has_threadid_ != x.has_threadid_: return 0
    if self.has_threadid_ and self.threadid_ != x.threadid_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_groupid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: groupid not set.')
    if (not self.has_authorid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: authorid not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.groupid_)
    n += self.lengthVarInt64(self.authorid_)
    if (self.has_threadid_): n += 1 + self.lengthVarInt64(self.threadid_)
    return n + 2

  def Clear(self):
    self.clear_groupid()
    self.clear_authorid()
    self.clear_threadid()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarUint64(self.groupid_)
    out.putVarInt32(16)
    out.putVarUint64(self.authorid_)
    if (self.has_threadid_):
      out.putVarInt32(24)
      out.putVarUint64(self.threadid_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_groupid(d.getVarUint64())
        continue
      if tt == 16:
        self.set_authorid(d.getVarUint64())
        continue
      if tt == 24:
        self.set_threadid(d.getVarUint64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_groupid_: res+=prefix+("GroupId: %s\n" % self.DebugFormatInt64(self.groupid_))
    if self.has_authorid_: res+=prefix+("AuthorId: %s\n" % self.DebugFormatInt64(self.authorid_))
    if self.has_threadid_: res+=prefix+("ThreadId: %s\n" % self.DebugFormatInt64(self.threadid_))
    return res

  kGroupId = 1
  kAuthorId = 2
  kThreadId = 3

  _TEXT = (
   "ErrorCode",  #   0
   "GroupId",  #   1
   "AuthorId",  #   2
   "ThreadId",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x10,
    0x47,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x73,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x07,
    0x47,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x49,
    0x64,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x41,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x49,
    0x64,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x54,
    0x68,
    0x72,
    0x65,
    0x61,
    0x64,
    0x49,
    0x64,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xfa,
    0xa2,
    0x58,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class SciencePerDocData_Signal(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = 0
    self.index_ = 0
    self.count_ = 0
    self.weight_ = 1.0
    self.avg_citations_ = 0.0
    self.median_citations_ = 0.0
    self.ge_thres1_count_ = 0
    self.ge_thres2_count_ = 0
    self.has_type_ = 0
    self.has_index_ = 0
    self.has_count_ = 0
    self.has_weight_ = 0
    self.has_avg_citations_ = 0
    self.has_median_citations_ = 0
    self.has_ge_thres1_count_ = 0
    self.has_ge_thres2_count_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = 0

  def has_type(self): return self.has_type_

  def index(self): return self.index_

  def set_index(self, x):
    self.has_index_ = 1
    self.index_ = x

  def clear_index(self):
    self.has_index_ = 0
    self.index_ = 0

  def has_index(self): return self.has_index_

  def count(self): return self.count_

  def set_count(self, x):
    self.has_count_ = 1
    self.count_ = x

  def clear_count(self):
    self.has_count_ = 0
    self.count_ = 0

  def has_count(self): return self.has_count_

  def weight(self): return self.weight_

  def set_weight(self, x):
    self.has_weight_ = 1
    self.weight_ = x

  def clear_weight(self):
    self.has_weight_ = 0
    self.weight_ = 1.0

  def has_weight(self): return self.has_weight_

  def avg_citations(self): return self.avg_citations_

  def set_avg_citations(self, x):
    self.has_avg_citations_ = 1
    self.avg_citations_ = x

  def clear_avg_citations(self):
    self.has_avg_citations_ = 0
    self.avg_citations_ = 0.0

  def has_avg_citations(self): return self.has_avg_citations_

  def median_citations(self): return self.median_citations_

  def set_median_citations(self, x):
    self.has_median_citations_ = 1
    self.median_citations_ = x

  def clear_median_citations(self):
    self.has_median_citations_ = 0
    self.median_citations_ = 0.0

  def has_median_citations(self): return self.has_median_citations_

  def ge_thres1_count(self): return self.ge_thres1_count_

  def set_ge_thres1_count(self, x):
    self.has_ge_thres1_count_ = 1
    self.ge_thres1_count_ = x

  def clear_ge_thres1_count(self):
    self.has_ge_thres1_count_ = 0
    self.ge_thres1_count_ = 0

  def has_ge_thres1_count(self): return self.has_ge_thres1_count_

  def ge_thres2_count(self): return self.ge_thres2_count_

  def set_ge_thres2_count(self, x):
    self.has_ge_thres2_count_ = 1
    self.ge_thres2_count_ = x

  def clear_ge_thres2_count(self):
    self.has_ge_thres2_count_ = 0
    self.ge_thres2_count_ = 0

  def has_ge_thres2_count(self): return self.has_ge_thres2_count_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_index()): self.set_index(x.index())
    if (x.has_count()): self.set_count(x.count())
    if (x.has_weight()): self.set_weight(x.weight())
    if (x.has_avg_citations()): self.set_avg_citations(x.avg_citations())
    if (x.has_median_citations()): self.set_median_citations(x.median_citations())
    if (x.has_ge_thres1_count()): self.set_ge_thres1_count(x.ge_thres1_count())
    if (x.has_ge_thres2_count()): self.set_ge_thres2_count(x.ge_thres2_count())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'SciencePerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'SciencePerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'SciencePerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'SciencePerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'SciencePerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_index_ != x.has_index_: return 0
    if self.has_index_ and self.index_ != x.index_: return 0
    if self.has_count_ != x.has_count_: return 0
    if self.has_count_ and self.count_ != x.count_: return 0
    if self.has_weight_ != x.has_weight_: return 0
    if self.has_weight_ and self.weight_ != x.weight_: return 0
    if self.has_avg_citations_ != x.has_avg_citations_: return 0
    if self.has_avg_citations_ and self.avg_citations_ != x.avg_citations_: return 0
    if self.has_median_citations_ != x.has_median_citations_: return 0
    if self.has_median_citations_ and self.median_citations_ != x.median_citations_: return 0
    if self.has_ge_thres1_count_ != x.has_ge_thres1_count_: return 0
    if self.has_ge_thres1_count_ and self.ge_thres1_count_ != x.ge_thres1_count_: return 0
    if self.has_ge_thres2_count_ != x.has_ge_thres2_count_: return 0
    if self.has_ge_thres2_count_ and self.ge_thres2_count_ != x.ge_thres2_count_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (not self.has_count_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: count not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.type_)
    if (self.has_index_): n += 1 + self.lengthVarInt64(self.index_)
    n += self.lengthVarInt64(self.count_)
    if (self.has_weight_): n += 5
    if (self.has_avg_citations_): n += 5
    if (self.has_median_citations_): n += 5
    if (self.has_ge_thres1_count_): n += 1 + self.lengthVarInt64(self.ge_thres1_count_)
    if (self.has_ge_thres2_count_): n += 1 + self.lengthVarInt64(self.ge_thres2_count_)
    return n + 2

  def Clear(self):
    self.clear_type()
    self.clear_index()
    self.clear_count()
    self.clear_weight()
    self.clear_avg_citations()
    self.clear_median_citations()
    self.clear_ge_thres1_count()
    self.clear_ge_thres2_count()

  def OutputUnchecked(self, out):
    out.putVarInt32(24)
    out.putVarInt32(self.type_)
    if (self.has_index_):
      out.putVarInt32(32)
      out.putVarInt32(self.index_)
    out.putVarInt32(48)
    out.putVarInt32(self.count_)
    if (self.has_weight_):
      out.putVarInt32(61)
      out.putFloat(self.weight_)
    if (self.has_avg_citations_):
      out.putVarInt32(69)
      out.putFloat(self.avg_citations_)
    if (self.has_median_citations_):
      out.putVarInt32(77)
      out.putFloat(self.median_citations_)
    if (self.has_ge_thres1_count_):
      out.putVarInt32(80)
      out.putVarInt32(self.ge_thres1_count_)
    if (self.has_ge_thres2_count_):
      out.putVarInt32(88)
      out.putVarInt32(self.ge_thres2_count_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 24:
        self.set_type(d.getVarInt32())
        continue
      if tt == 32:
        self.set_index(d.getVarInt32())
        continue
      if tt == 48:
        self.set_count(d.getVarInt32())
        continue
      if tt == 61:
        self.set_weight(d.getFloat())
        continue
      if tt == 69:
        self.set_avg_citations(d.getFloat())
        continue
      if tt == 77:
        self.set_median_citations(d.getFloat())
        continue
      if tt == 80:
        self.set_ge_thres1_count(d.getVarInt32())
        continue
      if tt == 88:
        self.set_ge_thres2_count(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("type: %s\n" % self.DebugFormatInt32(self.type_))
    if self.has_index_: res+=prefix+("index: %s\n" % self.DebugFormatInt32(self.index_))
    if self.has_count_: res+=prefix+("count: %s\n" % self.DebugFormatInt32(self.count_))
    if self.has_weight_: res+=prefix+("weight: %s\n" % self.DebugFormatFloat(self.weight_))
    if self.has_avg_citations_: res+=prefix+("avg_citations: %s\n" % self.DebugFormatFloat(self.avg_citations_))
    if self.has_median_citations_: res+=prefix+("median_citations: %s\n" % self.DebugFormatFloat(self.median_citations_))
    if self.has_ge_thres1_count_: res+=prefix+("ge_thres1_count: %s\n" % self.DebugFormatInt32(self.ge_thres1_count_))
    if self.has_ge_thres2_count_: res+=prefix+("ge_thres2_count: %s\n" % self.DebugFormatInt32(self.ge_thres2_count_))
    return res

class SciencePerDocData_Author(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.lastname_ = ""
    self.othernames_ = ""
    self.iscjk_ = 0
    self.has_lastname_ = 0
    self.has_othernames_ = 0
    self.has_iscjk_ = 0
    if contents is not None: self.MergeFromString(contents)

  def lastname(self): return self.lastname_

  def set_lastname(self, x):
    self.has_lastname_ = 1
    self.lastname_ = x

  def clear_lastname(self):
    self.has_lastname_ = 0
    self.lastname_ = ""

  def has_lastname(self): return self.has_lastname_

  def othernames(self): return self.othernames_

  def set_othernames(self, x):
    self.has_othernames_ = 1
    self.othernames_ = x

  def clear_othernames(self):
    self.has_othernames_ = 0
    self.othernames_ = ""

  def has_othernames(self): return self.has_othernames_

  def iscjk(self): return self.iscjk_

  def set_iscjk(self, x):
    self.has_iscjk_ = 1
    self.iscjk_ = x

  def clear_iscjk(self):
    self.has_iscjk_ = 0
    self.iscjk_ = 0

  def has_iscjk(self): return self.has_iscjk_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_lastname()): self.set_lastname(x.lastname())
    if (x.has_othernames()): self.set_othernames(x.othernames())
    if (x.has_iscjk()): self.set_iscjk(x.iscjk())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'SciencePerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'SciencePerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'SciencePerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'SciencePerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'SciencePerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_lastname_ != x.has_lastname_: return 0
    if self.has_lastname_ and self.lastname_ != x.lastname_: return 0
    if self.has_othernames_ != x.has_othernames_: return 0
    if self.has_othernames_ and self.othernames_ != x.othernames_: return 0
    if self.has_iscjk_ != x.has_iscjk_: return 0
    if self.has_iscjk_ and self.iscjk_ != x.iscjk_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_lastname_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: lastname not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.lastname_))
    if (self.has_othernames_): n += 2 + self.lengthString(len(self.othernames_))
    if (self.has_iscjk_): n += 3
    return n + 2

  def Clear(self):
    self.clear_lastname()
    self.clear_othernames()
    self.clear_iscjk()

  def OutputUnchecked(self, out):
    out.putVarInt32(146)
    out.putPrefixedString(self.lastname_)
    if (self.has_othernames_):
      out.putVarInt32(154)
      out.putPrefixedString(self.othernames_)
    if (self.has_iscjk_):
      out.putVarInt32(160)
      out.putBoolean(self.iscjk_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 140: break
      if tt == 146:
        self.set_lastname(d.getPrefixedString())
        continue
      if tt == 154:
        self.set_othernames(d.getPrefixedString())
        continue
      if tt == 160:
        self.set_iscjk(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_lastname_: res+=prefix+("LastName: %s\n" % self.DebugFormatString(self.lastname_))
    if self.has_othernames_: res+=prefix+("OtherNames: %s\n" % self.DebugFormatString(self.othernames_))
    if self.has_iscjk_: res+=prefix+("IsCJK: %s\n" % self.DebugFormatBool(self.iscjk_))
    return res

class SciencePerDocData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 6193762 

  _TypeId_NAMES = {
    6193762: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)


  AUTHOR_COAUTHOR =    0 
  AUTHOR_TITLE_KEYWORD =    1 
  AUTHOR_SUBJECT =    2 
  JOURNAL      =    3 
  AUTHOR_JOURNAL =    4 
  NUM_SIGNAL_TYPES =    5 

  _SignalType_NAMES = {
    0: "AUTHOR_COAUTHOR",
    1: "AUTHOR_TITLE_KEYWORD",
    2: "AUTHOR_SUBJECT",
    3: "JOURNAL",
    4: "AUTHOR_JOURNAL",
    5: "NUM_SIGNAL_TYPES",
  }

  def SignalType_Name(cls, x): return cls._SignalType_NAMES.get(x, "")
  SignalType_Name = classmethod(SignalType_Name)

  def __init__(self, contents=None):
    self.subject_ = 0
    self.signal_ = []
    self.publicationyear_ = 0
    self.publicationmonth_ = 0
    self.publicationday_ = 0
    self.crawltime_ = 0
    self.numtitlewords_ = 0
    self.author_ = []
    self.numbackwardlinks_ = 0
    self.numversions_ = 0
    self.numrelated_ = 0
    self.scholarid_ = 0
    self.has_subject_ = 0
    self.has_publicationyear_ = 0
    self.has_publicationmonth_ = 0
    self.has_publicationday_ = 0
    self.has_crawltime_ = 0
    self.has_numtitlewords_ = 0
    self.has_numbackwardlinks_ = 0
    self.has_numversions_ = 0
    self.has_numrelated_ = 0
    self.has_scholarid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def subject(self): return self.subject_

  def set_subject(self, x):
    self.has_subject_ = 1
    self.subject_ = x

  def clear_subject(self):
    self.has_subject_ = 0
    self.subject_ = 0

  def has_subject(self): return self.has_subject_

  def signal_size(self): return len(self.signal_)
  def signal_list(self): return self.signal_

  def signal(self, i):
    return self.signal_[i]

  def mutable_signal(self, i):
    return self.signal_[i]

  def add_signal(self):
    x = SciencePerDocData_Signal()
    self.signal_.append(x)
    return x

  def clear_signal(self):
    self.signal_ = []
  def publicationyear(self): return self.publicationyear_

  def set_publicationyear(self, x):
    self.has_publicationyear_ = 1
    self.publicationyear_ = x

  def clear_publicationyear(self):
    self.has_publicationyear_ = 0
    self.publicationyear_ = 0

  def has_publicationyear(self): return self.has_publicationyear_

  def publicationmonth(self): return self.publicationmonth_

  def set_publicationmonth(self, x):
    self.has_publicationmonth_ = 1
    self.publicationmonth_ = x

  def clear_publicationmonth(self):
    self.has_publicationmonth_ = 0
    self.publicationmonth_ = 0

  def has_publicationmonth(self): return self.has_publicationmonth_

  def publicationday(self): return self.publicationday_

  def set_publicationday(self, x):
    self.has_publicationday_ = 1
    self.publicationday_ = x

  def clear_publicationday(self):
    self.has_publicationday_ = 0
    self.publicationday_ = 0

  def has_publicationday(self): return self.has_publicationday_

  def crawltime(self): return self.crawltime_

  def set_crawltime(self, x):
    self.has_crawltime_ = 1
    self.crawltime_ = x

  def clear_crawltime(self):
    self.has_crawltime_ = 0
    self.crawltime_ = 0

  def has_crawltime(self): return self.has_crawltime_

  def numtitlewords(self): return self.numtitlewords_

  def set_numtitlewords(self, x):
    self.has_numtitlewords_ = 1
    self.numtitlewords_ = x

  def clear_numtitlewords(self):
    self.has_numtitlewords_ = 0
    self.numtitlewords_ = 0

  def has_numtitlewords(self): return self.has_numtitlewords_

  def author_size(self): return len(self.author_)
  def author_list(self): return self.author_

  def author(self, i):
    return self.author_[i]

  def mutable_author(self, i):
    return self.author_[i]

  def add_author(self):
    x = SciencePerDocData_Author()
    self.author_.append(x)
    return x

  def clear_author(self):
    self.author_ = []
  def numbackwardlinks(self): return self.numbackwardlinks_

  def set_numbackwardlinks(self, x):
    self.has_numbackwardlinks_ = 1
    self.numbackwardlinks_ = x

  def clear_numbackwardlinks(self):
    self.has_numbackwardlinks_ = 0
    self.numbackwardlinks_ = 0

  def has_numbackwardlinks(self): return self.has_numbackwardlinks_

  def numversions(self): return self.numversions_

  def set_numversions(self, x):
    self.has_numversions_ = 1
    self.numversions_ = x

  def clear_numversions(self):
    self.has_numversions_ = 0
    self.numversions_ = 0

  def has_numversions(self): return self.has_numversions_

  def numrelated(self): return self.numrelated_

  def set_numrelated(self, x):
    self.has_numrelated_ = 1
    self.numrelated_ = x

  def clear_numrelated(self):
    self.has_numrelated_ = 0
    self.numrelated_ = 0

  def has_numrelated(self): return self.has_numrelated_

  def scholarid(self): return self.scholarid_

  def set_scholarid(self, x):
    self.has_scholarid_ = 1
    self.scholarid_ = x

  def clear_scholarid(self):
    self.has_scholarid_ = 0
    self.scholarid_ = 0

  def has_scholarid(self): return self.has_scholarid_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_subject()): self.set_subject(x.subject())
    for i in xrange(x.signal_size()): self.add_signal().CopyFrom(x.signal(i))
    if (x.has_publicationyear()): self.set_publicationyear(x.publicationyear())
    if (x.has_publicationmonth()): self.set_publicationmonth(x.publicationmonth())
    if (x.has_publicationday()): self.set_publicationday(x.publicationday())
    if (x.has_crawltime()): self.set_crawltime(x.crawltime())
    if (x.has_numtitlewords()): self.set_numtitlewords(x.numtitlewords())
    for i in xrange(x.author_size()): self.add_author().CopyFrom(x.author(i))
    if (x.has_numbackwardlinks()): self.set_numbackwardlinks(x.numbackwardlinks())
    if (x.has_numversions()): self.set_numversions(x.numversions())
    if (x.has_numrelated()): self.set_numrelated(x.numrelated())
    if (x.has_scholarid()): self.set_scholarid(x.scholarid())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'SciencePerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'SciencePerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'SciencePerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'SciencePerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'SciencePerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_subject_ != x.has_subject_: return 0
    if self.has_subject_ and self.subject_ != x.subject_: return 0
    if len(self.signal_) != len(x.signal_): return 0
    for e1, e2 in zip(self.signal_, x.signal_):
      if e1 != e2: return 0
    if self.has_publicationyear_ != x.has_publicationyear_: return 0
    if self.has_publicationyear_ and self.publicationyear_ != x.publicationyear_: return 0
    if self.has_publicationmonth_ != x.has_publicationmonth_: return 0
    if self.has_publicationmonth_ and self.publicationmonth_ != x.publicationmonth_: return 0
    if self.has_publicationday_ != x.has_publicationday_: return 0
    if self.has_publicationday_ and self.publicationday_ != x.publicationday_: return 0
    if self.has_crawltime_ != x.has_crawltime_: return 0
    if self.has_crawltime_ and self.crawltime_ != x.crawltime_: return 0
    if self.has_numtitlewords_ != x.has_numtitlewords_: return 0
    if self.has_numtitlewords_ and self.numtitlewords_ != x.numtitlewords_: return 0
    if len(self.author_) != len(x.author_): return 0
    for e1, e2 in zip(self.author_, x.author_):
      if e1 != e2: return 0
    if self.has_numbackwardlinks_ != x.has_numbackwardlinks_: return 0
    if self.has_numbackwardlinks_ and self.numbackwardlinks_ != x.numbackwardlinks_: return 0
    if self.has_numversions_ != x.has_numversions_: return 0
    if self.has_numversions_ and self.numversions_ != x.numversions_: return 0
    if self.has_numrelated_ != x.has_numrelated_: return 0
    if self.has_numrelated_ and self.numrelated_ != x.numrelated_: return 0
    if self.has_scholarid_ != x.has_scholarid_: return 0
    if self.has_scholarid_ and self.scholarid_ != x.scholarid_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.signal_)):
      if (not self.signal_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.author_)):
      if (not self.author_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_subject_): n += 5
    n += 2 * len(self.signal_)
    for i in xrange(len(self.signal_)): n += self.signal_[i].ByteSize()
    if (self.has_publicationyear_): n += 1 + self.lengthVarInt64(self.publicationyear_)
    if (self.has_publicationmonth_): n += 1 + self.lengthVarInt64(self.publicationmonth_)
    if (self.has_publicationday_): n += 1 + self.lengthVarInt64(self.publicationday_)
    if (self.has_crawltime_): n += 1 + self.lengthVarInt64(self.crawltime_)
    if (self.has_numtitlewords_): n += 2 + self.lengthVarInt64(self.numtitlewords_)
    n += 4 * len(self.author_)
    for i in xrange(len(self.author_)): n += self.author_[i].ByteSize()
    if (self.has_numbackwardlinks_): n += 2 + self.lengthVarInt64(self.numbackwardlinks_)
    if (self.has_numversions_): n += 2 + self.lengthVarInt64(self.numversions_)
    if (self.has_numrelated_): n += 2 + self.lengthVarInt64(self.numrelated_)
    if (self.has_scholarid_): n += 10
    return n + 0

  def Clear(self):
    self.clear_subject()
    self.clear_signal()
    self.clear_publicationyear()
    self.clear_publicationmonth()
    self.clear_publicationday()
    self.clear_crawltime()
    self.clear_numtitlewords()
    self.clear_author()
    self.clear_numbackwardlinks()
    self.clear_numversions()
    self.clear_numrelated()
    self.clear_scholarid()

  def OutputUnchecked(self, out):
    if (self.has_subject_):
      out.putVarInt32(13)
      out.put32(self.subject_)
    for i in xrange(len(self.signal_)):
      out.putVarInt32(19)
      self.signal_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    if (self.has_publicationyear_):
      out.putVarInt32(96)
      out.putVarInt32(self.publicationyear_)
    if (self.has_publicationmonth_):
      out.putVarInt32(104)
      out.putVarInt32(self.publicationmonth_)
    if (self.has_publicationday_):
      out.putVarInt32(112)
      out.putVarInt32(self.publicationday_)
    if (self.has_crawltime_):
      out.putVarInt32(120)
      out.putVarInt64(self.crawltime_)
    if (self.has_numtitlewords_):
      out.putVarInt32(128)
      out.putVarInt32(self.numtitlewords_)
    for i in xrange(len(self.author_)):
      out.putVarInt32(139)
      self.author_[i].OutputUnchecked(out)
      out.putVarInt32(140)
    if (self.has_numbackwardlinks_):
      out.putVarInt32(168)
      out.putVarInt32(self.numbackwardlinks_)
    if (self.has_numversions_):
      out.putVarInt32(176)
      out.putVarInt32(self.numversions_)
    if (self.has_numrelated_):
      out.putVarInt32(184)
      out.putVarInt32(self.numrelated_)
    if (self.has_scholarid_):
      out.putVarInt32(193)
      out.put64(self.scholarid_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 13:
        self.set_subject(d.get32())
        continue
      if tt == 19:
        self.add_signal().TryMerge(d)
        continue
      if tt == 96:
        self.set_publicationyear(d.getVarInt32())
        continue
      if tt == 104:
        self.set_publicationmonth(d.getVarInt32())
        continue
      if tt == 112:
        self.set_publicationday(d.getVarInt32())
        continue
      if tt == 120:
        self.set_crawltime(d.getVarInt64())
        continue
      if tt == 128:
        self.set_numtitlewords(d.getVarInt32())
        continue
      if tt == 139:
        self.add_author().TryMerge(d)
        continue
      if tt == 168:
        self.set_numbackwardlinks(d.getVarInt32())
        continue
      if tt == 176:
        self.set_numversions(d.getVarInt32())
        continue
      if tt == 184:
        self.set_numrelated(d.getVarInt32())
        continue
      if tt == 193:
        self.set_scholarid(d.get64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_subject_: res+=prefix+("Subject: %s\n" % self.DebugFormatFixed32(self.subject_))
    cnt=0
    for e in self.signal_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Signal%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_publicationyear_: res+=prefix+("PublicationYear: %s\n" % self.DebugFormatInt32(self.publicationyear_))
    if self.has_publicationmonth_: res+=prefix+("PublicationMonth: %s\n" % self.DebugFormatInt32(self.publicationmonth_))
    if self.has_publicationday_: res+=prefix+("PublicationDay: %s\n" % self.DebugFormatInt32(self.publicationday_))
    if self.has_crawltime_: res+=prefix+("CrawlTime: %s\n" % self.DebugFormatInt64(self.crawltime_))
    if self.has_numtitlewords_: res+=prefix+("NumTitleWords: %s\n" % self.DebugFormatInt32(self.numtitlewords_))
    cnt=0
    for e in self.author_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Author%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_numbackwardlinks_: res+=prefix+("NumBackwardLinks: %s\n" % self.DebugFormatInt32(self.numbackwardlinks_))
    if self.has_numversions_: res+=prefix+("NumVersions: %s\n" % self.DebugFormatInt32(self.numversions_))
    if self.has_numrelated_: res+=prefix+("NumRelated: %s\n" % self.DebugFormatInt32(self.numrelated_))
    if self.has_scholarid_: res+=prefix+("ScholarId: %s\n" % self.DebugFormatFixed64(self.scholarid_))
    return res

  kSubject = 1
  kSignalGroup = 2
  kSignaltype = 3
  kSignalindex = 4
  kSignalcount = 6
  kSignalweight = 7
  kSignalavg_citations = 8
  kSignalmedian_citations = 9
  kSignalge_thres1_count = 10
  kSignalge_thres2_count = 11
  kPublicationYear = 12
  kPublicationMonth = 13
  kPublicationDay = 14
  kCrawlTime = 15
  kNumTitleWords = 16
  kAuthorGroup = 17
  kAuthorLastName = 18
  kAuthorOtherNames = 19
  kAuthorIsCJK = 20
  kNumBackwardLinks = 21
  kNumVersions = 22
  kNumRelated = 23
  kScholarId = 24

  _TEXT = (
   "ErrorCode",  #   0
   "Subject",  #   1
   "Signal",  #   2
   "type",  #   3
   "index",  #   4
   None,  #   5
   "count",  #   6
   "weight",  #   7
   "avg_citations",  #   8
   "median_citations",  #   9
   "ge_thres1_count",  #  10
   "ge_thres2_count",  #  11
   "PublicationYear",  #  12
   "PublicationMonth",  #  13
   "PublicationDay",  #  14
   "CrawlTime",  #  15
   "NumTitleWords",  #  16
   "Author",  #  17
   "LastName",  #  18
   "OtherNames",  #  19
   "IsCJK",  #  20
   "NumBackwardLinks",  #  21
   "NumVersions",  #  22
   "NumRelated",  #  23
   "ScholarId",  #  24
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.FLOAT,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.FLOAT,  #   7

   ProtocolBuffer.Encoder.FLOAT,  #   8

   ProtocolBuffer.Encoder.FLOAT,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

   ProtocolBuffer.Encoder.NUMERIC,  #  12

   ProtocolBuffer.Encoder.NUMERIC,  #  13

   ProtocolBuffer.Encoder.NUMERIC,  #  14

   ProtocolBuffer.Encoder.NUMERIC,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

   ProtocolBuffer.Encoder.STARTGROUP,  #  17

   ProtocolBuffer.Encoder.STRING,  #  18

   ProtocolBuffer.Encoder.STRING,  #  19

   ProtocolBuffer.Encoder.NUMERIC,  #  20

   ProtocolBuffer.Encoder.NUMERIC,  #  21

   ProtocolBuffer.Encoder.NUMERIC,  #  22

   ProtocolBuffer.Encoder.NUMERIC,  #  23

   ProtocolBuffer.Encoder.DOUBLE,  #  24

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x11,
    0x53,
    0x63,
    0x69,
    0x65,
    0x6e,
    0x63,
    0x65,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x07,
    0x53,
    0x75,
    0x62,
    0x6a,
    0x65,
    0x63,
    0x74,
    0x20,
    0x01,
    0x28,
    0x05,
    0x30,
    0x07,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x2e,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x2e,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x2e,
    0x63,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x2e,
    0x77,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x07,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x42,
    0x03,
    0x31,
    0x2e,
    0x30,
    0x60,
    0x01,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x2e,
    0x61,
    0x76,
    0x67,
    0x5f,
    0x63,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x08,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x2e,
    0x6d,
    0x65,
    0x64,
    0x69,
    0x61,
    0x6e,
    0x5f,
    0x63,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x09,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x2e,
    0x67,
    0x65,
    0x5f,
    0x74,
    0x68,
    0x72,
    0x65,
    0x73,
    0x31,
    0x5f,
    0x63,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x2e,
    0x67,
    0x65,
    0x5f,
    0x74,
    0x68,
    0x72,
    0x65,
    0x73,
    0x32,
    0x5f,
    0x63,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x50,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x59,
    0x65,
    0x61,
    0x72,
    0x20,
    0x0c,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x50,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4d,
    0x6f,
    0x6e,
    0x74,
    0x68,
    0x20,
    0x0d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x50,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x44,
    0x61,
    0x79,
    0x20,
    0x0e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x43,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x20,
    0x0f,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x4e,
    0x75,
    0x6d,
    0x54,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x57,
    0x6f,
    0x72,
    0x64,
    0x73,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x41,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x20,
    0x11,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x41,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x2e,
    0x4c,
    0x61,
    0x73,
    0x74,
    0x4e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x12,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x0f,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x41,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x2e,
    0x4f,
    0x74,
    0x68,
    0x65,
    0x72,
    0x4e,
    0x61,
    0x6d,
    0x65,
    0x73,
    0x20,
    0x13,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x0f,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x41,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x2e,
    0x49,
    0x73,
    0x43,
    0x4a,
    0x4b,
    0x20,
    0x14,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x0f,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x4e,
    0x75,
    0x6d,
    0x42,
    0x61,
    0x63,
    0x6b,
    0x77,
    0x61,
    0x72,
    0x64,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x73,
    0x20,
    0x15,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x4e,
    0x75,
    0x6d,
    0x56,
    0x65,
    0x72,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x16,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x4e,
    0x75,
    0x6d,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x65,
    0x64,
    0x20,
    0x17,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x53,
    0x63,
    0x68,
    0x6f,
    0x6c,
    0x61,
    0x72,
    0x49,
    0x64,
    0x20,
    0x18,
    0x28,
    0x01,
    0x30,
    0x06,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xe2,
    0x84,
    0xfa,
    0x02,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x0a,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x41,
    0x55,
    0x54,
    0x48,
    0x4f,
    0x52,
    0x5f,
    0x43,
    0x4f,
    0x41,
    0x55,
    0x54,
    0x48,
    0x4f,
    0x52,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x14,
    0x41,
    0x55,
    0x54,
    0x48,
    0x4f,
    0x52,
    0x5f,
    0x54,
    0x49,
    0x54,
    0x4c,
    0x45,
    0x5f,
    0x4b,
    0x45,
    0x59,
    0x57,
    0x4f,
    0x52,
    0x44,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x41,
    0x55,
    0x54,
    0x48,
    0x4f,
    0x52,
    0x5f,
    0x53,
    0x55,
    0x42,
    0x4a,
    0x45,
    0x43,
    0x54,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x4a,
    0x4f,
    0x55,
    0x52,
    0x4e,
    0x41,
    0x4c,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x41,
    0x55,
    0x54,
    0x48,
    0x4f,
    0x52,
    0x5f,
    0x4a,
    0x4f,
    0x55,
    0x52,
    0x4e,
    0x41,
    0x4c,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x4e,
    0x55,
    0x4d,
    0x5f,
    0x53,
    0x49,
    0x47,
    0x4e,
    0x41,
    0x4c,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x53,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class PremiumPerDocData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 1993742 

  _TypeId_NAMES = {
    1993742: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.date_ = 0
    self.publication_ = 0
    self.price_ = 0
    self.currency_ = 0
    self.entitlement_ = []
    self.isarchival_ = 0
    self.isentitled_ = 0
    self.has_date_ = 0
    self.has_publication_ = 0
    self.has_price_ = 0
    self.has_currency_ = 0
    self.has_isarchival_ = 0
    self.has_isentitled_ = 0
    if contents is not None: self.MergeFromString(contents)

  def date(self): return self.date_

  def set_date(self, x):
    self.has_date_ = 1
    self.date_ = x

  def clear_date(self):
    self.has_date_ = 0
    self.date_ = 0

  def has_date(self): return self.has_date_

  def publication(self): return self.publication_

  def set_publication(self, x):
    self.has_publication_ = 1
    self.publication_ = x

  def clear_publication(self):
    self.has_publication_ = 0
    self.publication_ = 0

  def has_publication(self): return self.has_publication_

  def price(self): return self.price_

  def set_price(self, x):
    self.has_price_ = 1
    self.price_ = x

  def clear_price(self):
    self.has_price_ = 0
    self.price_ = 0

  def has_price(self): return self.has_price_

  def currency(self): return self.currency_

  def set_currency(self, x):
    self.has_currency_ = 1
    self.currency_ = x

  def clear_currency(self):
    self.has_currency_ = 0
    self.currency_ = 0

  def has_currency(self): return self.has_currency_

  def entitlement_size(self): return len(self.entitlement_)
  def entitlement_list(self): return self.entitlement_

  def entitlement(self, i):
    return self.entitlement_[i]

  def set_entitlement(self, i, x):
    self.entitlement_[i] = x

  def add_entitlement(self, x):
    self.entitlement_.append(x)

  def clear_entitlement(self):
    self.entitlement_ = []

  def isarchival(self): return self.isarchival_

  def set_isarchival(self, x):
    self.has_isarchival_ = 1
    self.isarchival_ = x

  def clear_isarchival(self):
    self.has_isarchival_ = 0
    self.isarchival_ = 0

  def has_isarchival(self): return self.has_isarchival_

  def isentitled(self): return self.isentitled_

  def set_isentitled(self, x):
    self.has_isentitled_ = 1
    self.isentitled_ = x

  def clear_isentitled(self):
    self.has_isentitled_ = 0
    self.isentitled_ = 0

  def has_isentitled(self): return self.has_isentitled_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_date()): self.set_date(x.date())
    if (x.has_publication()): self.set_publication(x.publication())
    if (x.has_price()): self.set_price(x.price())
    if (x.has_currency()): self.set_currency(x.currency())
    for i in xrange(x.entitlement_size()): self.add_entitlement(x.entitlement(i))
    if (x.has_isarchival()): self.set_isarchival(x.isarchival())
    if (x.has_isentitled()): self.set_isentitled(x.isentitled())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'PremiumPerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'PremiumPerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'PremiumPerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'PremiumPerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'PremiumPerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_date_ != x.has_date_: return 0
    if self.has_date_ and self.date_ != x.date_: return 0
    if self.has_publication_ != x.has_publication_: return 0
    if self.has_publication_ and self.publication_ != x.publication_: return 0
    if self.has_price_ != x.has_price_: return 0
    if self.has_price_ and self.price_ != x.price_: return 0
    if self.has_currency_ != x.has_currency_: return 0
    if self.has_currency_ and self.currency_ != x.currency_: return 0
    if len(self.entitlement_) != len(x.entitlement_): return 0
    for e1, e2 in zip(self.entitlement_, x.entitlement_):
      if e1 != e2: return 0
    if self.has_isarchival_ != x.has_isarchival_: return 0
    if self.has_isarchival_ and self.isarchival_ != x.isarchival_: return 0
    if self.has_isentitled_ != x.has_isentitled_: return 0
    if self.has_isentitled_ and self.isentitled_ != x.isentitled_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_date_): n += 1 + self.lengthVarInt64(self.date_)
    if (self.has_publication_): n += 1 + self.lengthVarInt64(self.publication_)
    if (self.has_price_): n += 1 + self.lengthVarInt64(self.price_)
    if (self.has_currency_): n += 1 + self.lengthVarInt64(self.currency_)
    n += 1 * len(self.entitlement_)
    for i in xrange(len(self.entitlement_)): n += self.lengthVarInt64(self.entitlement_[i])
    if (self.has_isarchival_): n += 2
    if (self.has_isentitled_): n += 2
    return n + 0

  def Clear(self):
    self.clear_date()
    self.clear_publication()
    self.clear_price()
    self.clear_currency()
    self.clear_entitlement()
    self.clear_isarchival()
    self.clear_isentitled()

  def OutputUnchecked(self, out):
    if (self.has_date_):
      out.putVarInt32(8)
      out.putVarInt64(self.date_)
    if (self.has_publication_):
      out.putVarInt32(16)
      out.putVarUint64(self.publication_)
    if (self.has_price_):
      out.putVarInt32(24)
      out.putVarInt32(self.price_)
    if (self.has_currency_):
      out.putVarInt32(32)
      out.putVarInt32(self.currency_)
    for i in xrange(len(self.entitlement_)):
      out.putVarInt32(40)
      out.putVarInt32(self.entitlement_[i])
    if (self.has_isentitled_):
      out.putVarInt32(48)
      out.putBoolean(self.isentitled_)
    if (self.has_isarchival_):
      out.putVarInt32(56)
      out.putBoolean(self.isarchival_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_date(d.getVarInt64())
        continue
      if tt == 16:
        self.set_publication(d.getVarUint64())
        continue
      if tt == 24:
        self.set_price(d.getVarInt32())
        continue
      if tt == 32:
        self.set_currency(d.getVarInt32())
        continue
      if tt == 40:
        self.add_entitlement(d.getVarInt32())
        continue
      if tt == 48:
        self.set_isentitled(d.getBoolean())
        continue
      if tt == 56:
        self.set_isarchival(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_date_: res+=prefix+("Date: %s\n" % self.DebugFormatInt64(self.date_))
    if self.has_publication_: res+=prefix+("Publication: %s\n" % self.DebugFormatInt64(self.publication_))
    if self.has_price_: res+=prefix+("Price: %s\n" % self.DebugFormatInt32(self.price_))
    if self.has_currency_: res+=prefix+("Currency: %s\n" % self.DebugFormatInt32(self.currency_))
    cnt=0
    for e in self.entitlement_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Entitlement%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    if self.has_isarchival_: res+=prefix+("IsArchival: %s\n" % self.DebugFormatBool(self.isarchival_))
    if self.has_isentitled_: res+=prefix+("IsEntitled: %s\n" % self.DebugFormatBool(self.isentitled_))
    return res

  kDate = 1
  kPublication = 2
  kPrice = 3
  kCurrency = 4
  kEntitlement = 5
  kIsArchival = 7
  kIsEntitled = 6

  _TEXT = (
   "ErrorCode",  #   0
   "Date",  #   1
   "Publication",  #   2
   "Price",  #   3
   "Currency",  #   4
   "Entitlement",  #   5
   "IsEntitled",  #   6
   "IsArchival",  #   7
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x11,
    0x50,
    0x72,
    0x65,
    0x6d,
    0x69,
    0x75,
    0x6d,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x04,
    0x44,
    0x61,
    0x74,
    0x65,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x50,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x50,
    0x72,
    0x69,
    0x63,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x43,
    0x75,
    0x72,
    0x72,
    0x65,
    0x6e,
    0x63,
    0x79,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x45,
    0x6e,
    0x74,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x49,
    0x73,
    0x41,
    0x72,
    0x63,
    0x68,
    0x69,
    0x76,
    0x61,
    0x6c,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x49,
    0x73,
    0x45,
    0x6e,
    0x74,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x64,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0x8e,
    0xd8,
    0x79,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class BookCitationPerDocData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 4295477 

  _TypeId_NAMES = {
    4295477: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.book_id_ = 0
    self.discretized_citation_score_ = 0
    self.second_book_id_ = 0
    self.second_discretized_citation_score_ = 0
    self.has_book_id_ = 0
    self.has_discretized_citation_score_ = 0
    self.has_second_book_id_ = 0
    self.has_second_discretized_citation_score_ = 0
    if contents is not None: self.MergeFromString(contents)

  def book_id(self): return self.book_id_

  def set_book_id(self, x):
    self.has_book_id_ = 1
    self.book_id_ = x

  def clear_book_id(self):
    self.has_book_id_ = 0
    self.book_id_ = 0

  def has_book_id(self): return self.has_book_id_

  def discretized_citation_score(self): return self.discretized_citation_score_

  def set_discretized_citation_score(self, x):
    self.has_discretized_citation_score_ = 1
    self.discretized_citation_score_ = x

  def clear_discretized_citation_score(self):
    self.has_discretized_citation_score_ = 0
    self.discretized_citation_score_ = 0

  def has_discretized_citation_score(self): return self.has_discretized_citation_score_

  def second_book_id(self): return self.second_book_id_

  def set_second_book_id(self, x):
    self.has_second_book_id_ = 1
    self.second_book_id_ = x

  def clear_second_book_id(self):
    self.has_second_book_id_ = 0
    self.second_book_id_ = 0

  def has_second_book_id(self): return self.has_second_book_id_

  def second_discretized_citation_score(self): return self.second_discretized_citation_score_

  def set_second_discretized_citation_score(self, x):
    self.has_second_discretized_citation_score_ = 1
    self.second_discretized_citation_score_ = x

  def clear_second_discretized_citation_score(self):
    self.has_second_discretized_citation_score_ = 0
    self.second_discretized_citation_score_ = 0

  def has_second_discretized_citation_score(self): return self.has_second_discretized_citation_score_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_book_id()): self.set_book_id(x.book_id())
    if (x.has_discretized_citation_score()): self.set_discretized_citation_score(x.discretized_citation_score())
    if (x.has_second_book_id()): self.set_second_book_id(x.second_book_id())
    if (x.has_second_discretized_citation_score()): self.set_second_discretized_citation_score(x.second_discretized_citation_score())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'BookCitationPerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'BookCitationPerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'BookCitationPerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'BookCitationPerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'BookCitationPerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_book_id_ != x.has_book_id_: return 0
    if self.has_book_id_ and self.book_id_ != x.book_id_: return 0
    if self.has_discretized_citation_score_ != x.has_discretized_citation_score_: return 0
    if self.has_discretized_citation_score_ and self.discretized_citation_score_ != x.discretized_citation_score_: return 0
    if self.has_second_book_id_ != x.has_second_book_id_: return 0
    if self.has_second_book_id_ and self.second_book_id_ != x.second_book_id_: return 0
    if self.has_second_discretized_citation_score_ != x.has_second_discretized_citation_score_: return 0
    if self.has_second_discretized_citation_score_ and self.second_discretized_citation_score_ != x.second_discretized_citation_score_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_book_id_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: book_id not set.')
    if (not self.has_discretized_citation_score_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: discretized_citation_score not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.book_id_)
    n += self.lengthVarInt64(self.discretized_citation_score_)
    if (self.has_second_book_id_): n += 1 + self.lengthVarInt64(self.second_book_id_)
    if (self.has_second_discretized_citation_score_): n += 1 + self.lengthVarInt64(self.second_discretized_citation_score_)
    return n + 2

  def Clear(self):
    self.clear_book_id()
    self.clear_discretized_citation_score()
    self.clear_second_book_id()
    self.clear_second_discretized_citation_score()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt64(self.book_id_)
    out.putVarInt32(16)
    out.putVarInt32(self.discretized_citation_score_)
    if (self.has_second_book_id_):
      out.putVarInt32(24)
      out.putVarInt64(self.second_book_id_)
    if (self.has_second_discretized_citation_score_):
      out.putVarInt32(32)
      out.putVarInt32(self.second_discretized_citation_score_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_book_id(d.getVarInt64())
        continue
      if tt == 16:
        self.set_discretized_citation_score(d.getVarInt32())
        continue
      if tt == 24:
        self.set_second_book_id(d.getVarInt64())
        continue
      if tt == 32:
        self.set_second_discretized_citation_score(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_book_id_: res+=prefix+("book_id: %s\n" % self.DebugFormatInt64(self.book_id_))
    if self.has_discretized_citation_score_: res+=prefix+("discretized_citation_score: %s\n" % self.DebugFormatInt32(self.discretized_citation_score_))
    if self.has_second_book_id_: res+=prefix+("second_book_id: %s\n" % self.DebugFormatInt64(self.second_book_id_))
    if self.has_second_discretized_citation_score_: res+=prefix+("second_discretized_citation_score: %s\n" % self.DebugFormatInt32(self.second_discretized_citation_score_))
    return res

  kbook_id = 1
  kdiscretized_citation_score = 2
  ksecond_book_id = 3
  ksecond_discretized_citation_score = 4

  _TEXT = (
   "ErrorCode",  #   0
   "book_id",  #   1
   "discretized_citation_score",  #   2
   "second_book_id",  #   3
   "second_discretized_citation_score",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x16,
    0x42,
    0x6f,
    0x6f,
    0x6b,
    0x43,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x07,
    0x62,
    0x6f,
    0x6f,
    0x6b,
    0x5f,
    0x69,
    0x64,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x64,
    0x69,
    0x73,
    0x63,
    0x72,
    0x65,
    0x74,
    0x69,
    0x7a,
    0x65,
    0x64,
    0x5f,
    0x63,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x73,
    0x65,
    0x63,
    0x6f,
    0x6e,
    0x64,
    0x5f,
    0x62,
    0x6f,
    0x6f,
    0x6b,
    0x5f,
    0x69,
    0x64,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x21,
    0x73,
    0x65,
    0x63,
    0x6f,
    0x6e,
    0x64,
    0x5f,
    0x64,
    0x69,
    0x73,
    0x63,
    0x72,
    0x65,
    0x74,
    0x69,
    0x7a,
    0x65,
    0x64,
    0x5f,
    0x63,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xb5,
    0x96,
    0x86,
    0x02,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class MobilePerDocData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 5328701 

  _TypeId_NAMES = {
    5328701: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.flags_ = 0
    self.mobileurl_ = ""
    self.has_flags_ = 0
    self.has_mobileurl_ = 0
    if contents is not None: self.MergeFromString(contents)

  def flags(self): return self.flags_

  def set_flags(self, x):
    self.has_flags_ = 1
    self.flags_ = x

  def clear_flags(self):
    self.has_flags_ = 0
    self.flags_ = 0

  def has_flags(self): return self.has_flags_

  def mobileurl(self): return self.mobileurl_

  def set_mobileurl(self, x):
    self.has_mobileurl_ = 1
    self.mobileurl_ = x

  def clear_mobileurl(self):
    self.has_mobileurl_ = 0
    self.mobileurl_ = ""

  def has_mobileurl(self): return self.has_mobileurl_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_flags()): self.set_flags(x.flags())
    if (x.has_mobileurl()): self.set_mobileurl(x.mobileurl())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'MobilePerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'MobilePerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'MobilePerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'MobilePerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'MobilePerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_flags_ != x.has_flags_: return 0
    if self.has_flags_ and self.flags_ != x.flags_: return 0
    if self.has_mobileurl_ != x.has_mobileurl_: return 0
    if self.has_mobileurl_ and self.mobileurl_ != x.mobileurl_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_flags_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: flags not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.flags_)
    if (self.has_mobileurl_): n += 1 + self.lengthString(len(self.mobileurl_))
    return n + 1

  def Clear(self):
    self.clear_flags()
    self.clear_mobileurl()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.flags_)
    if (self.has_mobileurl_):
      out.putVarInt32(18)
      out.putPrefixedString(self.mobileurl_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_flags(d.getVarInt32())
        continue
      if tt == 18:
        self.set_mobileurl(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_flags_: res+=prefix+("flags: %s\n" % self.DebugFormatInt32(self.flags_))
    if self.has_mobileurl_: res+=prefix+("mobileurl: %s\n" % self.DebugFormatString(self.mobileurl_))
    return res

  kflags = 1
  kmobileurl = 2

  _TEXT = (
   "ErrorCode",  #   0
   "flags",  #   1
   "mobileurl",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x10,
    0x4d,
    0x6f,
    0x62,
    0x69,
    0x6c,
    0x65,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x05,
    0x66,
    0x6c,
    0x61,
    0x67,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x6d,
    0x6f,
    0x62,
    0x69,
    0x6c,
    0x65,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xbd,
    0x9e,
    0xc5,
    0x02,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ToolBarPerDocData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.visitorspastday_ = 0
    self.has_visitorspastday_ = 0
    if contents is not None: self.MergeFromString(contents)

  def visitorspastday(self): return self.visitorspastday_

  def set_visitorspastday(self, x):
    self.has_visitorspastday_ = 1
    self.visitorspastday_ = x

  def clear_visitorspastday(self):
    self.has_visitorspastday_ = 0
    self.visitorspastday_ = 0

  def has_visitorspastday(self): return self.has_visitorspastday_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_visitorspastday()): self.set_visitorspastday(x.visitorspastday())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ToolBarPerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ToolBarPerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ToolBarPerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ToolBarPerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ToolBarPerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_visitorspastday_ != x.has_visitorspastday_: return 0
    if self.has_visitorspastday_ and self.visitorspastday_ != x.visitorspastday_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_visitorspastday_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: visitorspastday not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.visitorspastday_)
    return n + 1

  def Clear(self):
    self.clear_visitorspastday()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.visitorspastday_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_visitorspastday(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_visitorspastday_: res+=prefix+("VisitorsPastDay: %s\n" % self.DebugFormatInt32(self.visitorspastday_))
    return res

  kVisitorsPastDay = 1

  _TEXT = (
   "ErrorCode",  #   0
   "VisitorsPastDay",  #   1
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x11,
    0x54,
    0x6f,
    0x6f,
    0x6c,
    0x42,
    0x61,
    0x72,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x0f,
    0x56,
    0x69,
    0x73,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x50,
    0x61,
    0x73,
    0x74,
    0x44,
    0x61,
    0x79,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class PerDocDebugEvent(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.timestamp_ = 0
    self.source_ = ""
    self.value_ = 0
    self.message_ = ""
    self.has_timestamp_ = 0
    self.has_source_ = 0
    self.has_value_ = 0
    self.has_message_ = 0
    if contents is not None: self.MergeFromString(contents)

  def timestamp(self): return self.timestamp_

  def set_timestamp(self, x):
    self.has_timestamp_ = 1
    self.timestamp_ = x

  def clear_timestamp(self):
    self.has_timestamp_ = 0
    self.timestamp_ = 0

  def has_timestamp(self): return self.has_timestamp_

  def source(self): return self.source_

  def set_source(self, x):
    self.has_source_ = 1
    self.source_ = x

  def clear_source(self):
    self.has_source_ = 0
    self.source_ = ""

  def has_source(self): return self.has_source_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = 0

  def has_value(self): return self.has_value_

  def message(self): return self.message_

  def set_message(self, x):
    self.has_message_ = 1
    self.message_ = x

  def clear_message(self):
    self.has_message_ = 0
    self.message_ = ""

  def has_message(self): return self.has_message_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_timestamp()): self.set_timestamp(x.timestamp())
    if (x.has_source()): self.set_source(x.source())
    if (x.has_value()): self.set_value(x.value())
    if (x.has_message()): self.set_message(x.message())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'PerDocDebugEvent', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'PerDocDebugEvent')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'PerDocDebugEvent', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'PerDocDebugEvent', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'PerDocDebugEvent', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_timestamp_ != x.has_timestamp_: return 0
    if self.has_timestamp_ and self.timestamp_ != x.timestamp_: return 0
    if self.has_source_ != x.has_source_: return 0
    if self.has_source_ and self.source_ != x.source_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    if self.has_message_ != x.has_message_: return 0
    if self.has_message_ and self.message_ != x.message_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_timestamp_): n += 1 + self.lengthVarInt64(self.timestamp_)
    if (self.has_source_): n += 1 + self.lengthString(len(self.source_))
    if (self.has_value_): n += 1 + self.lengthVarInt64(self.value_)
    if (self.has_message_): n += 1 + self.lengthString(len(self.message_))
    return n + 0

  def Clear(self):
    self.clear_timestamp()
    self.clear_source()
    self.clear_value()
    self.clear_message()

  def OutputUnchecked(self, out):
    if (self.has_timestamp_):
      out.putVarInt32(8)
      out.putVarInt32(self.timestamp_)
    if (self.has_source_):
      out.putVarInt32(18)
      out.putPrefixedString(self.source_)
    if (self.has_value_):
      out.putVarInt32(24)
      out.putVarInt64(self.value_)
    if (self.has_message_):
      out.putVarInt32(34)
      out.putPrefixedString(self.message_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_timestamp(d.getVarInt32())
        continue
      if tt == 18:
        self.set_source(d.getPrefixedString())
        continue
      if tt == 24:
        self.set_value(d.getVarInt64())
        continue
      if tt == 34:
        self.set_message(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_timestamp_: res+=prefix+("Timestamp: %s\n" % self.DebugFormatInt32(self.timestamp_))
    if self.has_source_: res+=prefix+("Source: %s\n" % self.DebugFormatString(self.source_))
    if self.has_value_: res+=prefix+("Value: %s\n" % self.DebugFormatInt64(self.value_))
    if self.has_message_: res+=prefix+("Message: %s\n" % self.DebugFormatString(self.message_))
    return res

  kTimestamp = 1
  kSource = 2
  kValue = 3
  kMessage = 4

  _TEXT = (
   "ErrorCode",  #   0
   "Timestamp",  #   1
   "Source",  #   2
   "Value",  #   3
   "Message",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x10,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x65,
    0x62,
    0x75,
    0x67,
    0x45,
    0x76,
    0x65,
    0x6e,
    0x74,
    0x13,
    0x1a,
    0x09,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x4d,
    0x65,
    0x73,
    0x73,
    0x61,
    0x67,
    0x65,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class BlogPerDocData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.spam_score_ = 0
    self.copycat_score_ = 0
    self.quality_score_ = 0
    self.blogurl_fp_ = 0
    self.has_spam_score_ = 0
    self.has_copycat_score_ = 0
    self.has_quality_score_ = 0
    self.has_blogurl_fp_ = 0
    if contents is not None: self.MergeFromString(contents)

  def spam_score(self): return self.spam_score_

  def set_spam_score(self, x):
    self.has_spam_score_ = 1
    self.spam_score_ = x

  def clear_spam_score(self):
    self.has_spam_score_ = 0
    self.spam_score_ = 0

  def has_spam_score(self): return self.has_spam_score_

  def copycat_score(self): return self.copycat_score_

  def set_copycat_score(self, x):
    self.has_copycat_score_ = 1
    self.copycat_score_ = x

  def clear_copycat_score(self):
    self.has_copycat_score_ = 0
    self.copycat_score_ = 0

  def has_copycat_score(self): return self.has_copycat_score_

  def quality_score(self): return self.quality_score_

  def set_quality_score(self, x):
    self.has_quality_score_ = 1
    self.quality_score_ = x

  def clear_quality_score(self):
    self.has_quality_score_ = 0
    self.quality_score_ = 0

  def has_quality_score(self): return self.has_quality_score_

  def blogurl_fp(self): return self.blogurl_fp_

  def set_blogurl_fp(self, x):
    self.has_blogurl_fp_ = 1
    self.blogurl_fp_ = x

  def clear_blogurl_fp(self):
    self.has_blogurl_fp_ = 0
    self.blogurl_fp_ = 0

  def has_blogurl_fp(self): return self.has_blogurl_fp_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_spam_score()): self.set_spam_score(x.spam_score())
    if (x.has_copycat_score()): self.set_copycat_score(x.copycat_score())
    if (x.has_quality_score()): self.set_quality_score(x.quality_score())
    if (x.has_blogurl_fp()): self.set_blogurl_fp(x.blogurl_fp())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'BlogPerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'BlogPerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'BlogPerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'BlogPerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'BlogPerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_spam_score_ != x.has_spam_score_: return 0
    if self.has_spam_score_ and self.spam_score_ != x.spam_score_: return 0
    if self.has_copycat_score_ != x.has_copycat_score_: return 0
    if self.has_copycat_score_ and self.copycat_score_ != x.copycat_score_: return 0
    if self.has_quality_score_ != x.has_quality_score_: return 0
    if self.has_quality_score_ and self.quality_score_ != x.quality_score_: return 0
    if self.has_blogurl_fp_ != x.has_blogurl_fp_: return 0
    if self.has_blogurl_fp_ and self.blogurl_fp_ != x.blogurl_fp_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_spam_score_): n += 1 + self.lengthVarInt64(self.spam_score_)
    if (self.has_copycat_score_): n += 1 + self.lengthVarInt64(self.copycat_score_)
    if (self.has_quality_score_): n += 1 + self.lengthVarInt64(self.quality_score_)
    if (self.has_blogurl_fp_): n += 1 + self.lengthVarInt64(self.blogurl_fp_)
    return n + 0

  def Clear(self):
    self.clear_spam_score()
    self.clear_copycat_score()
    self.clear_quality_score()
    self.clear_blogurl_fp()

  def OutputUnchecked(self, out):
    if (self.has_spam_score_):
      out.putVarInt32(8)
      out.putVarInt32(self.spam_score_)
    if (self.has_copycat_score_):
      out.putVarInt32(16)
      out.putVarInt32(self.copycat_score_)
    if (self.has_quality_score_):
      out.putVarInt32(24)
      out.putVarInt32(self.quality_score_)
    if (self.has_blogurl_fp_):
      out.putVarInt32(32)
      out.putVarUint64(self.blogurl_fp_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_spam_score(d.getVarInt32())
        continue
      if tt == 16:
        self.set_copycat_score(d.getVarInt32())
        continue
      if tt == 24:
        self.set_quality_score(d.getVarInt32())
        continue
      if tt == 32:
        self.set_blogurl_fp(d.getVarUint64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_spam_score_: res+=prefix+("spam_score: %s\n" % self.DebugFormatInt32(self.spam_score_))
    if self.has_copycat_score_: res+=prefix+("copycat_score: %s\n" % self.DebugFormatInt32(self.copycat_score_))
    if self.has_quality_score_: res+=prefix+("quality_score: %s\n" % self.DebugFormatInt32(self.quality_score_))
    if self.has_blogurl_fp_: res+=prefix+("blogurl_fp: %s\n" % self.DebugFormatInt64(self.blogurl_fp_))
    return res

  kspam_score = 1
  kcopycat_score = 2
  kquality_score = 3
  kblogurl_fp = 4

  _TEXT = (
   "ErrorCode",  #   0
   "spam_score",  #   1
   "copycat_score",  #   2
   "quality_score",  #   3
   "blogurl_fp",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0e,
    0x42,
    0x6c,
    0x6f,
    0x67,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x0a,
    0x73,
    0x70,
    0x61,
    0x6d,
    0x5f,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x63,
    0x6f,
    0x70,
    0x79,
    0x63,
    0x61,
    0x74,
    0x5f,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x5f,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x62,
    0x6c,
    0x6f,
    0x67,
    0x75,
    0x72,
    0x6c,
    0x5f,
    0x66,
    0x70,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class PerDocData(ProtocolBuffer.ProtocolMessage):

  GUESTBOOK    =    0 
  FORUM        =    1 
  MAILING_LIST =    2 
  BLOG_COMMENT =    3 
  BLOG         =    4 
  PPC          =    5 
  PAID_LINK    =    6 
  REFERRER_LINK =    8 
  AFFILIATE    =    7 
  SPAM_SIGNATURE_NOPROP =    9 
  FRIENDLINK_PAGE =   16 
  WIKI         =   17 
  SPAM_SIGNATURE_KILL =   18 
  KEYWORD_STUFFED =   19 
  LINKEXCHANGE =   20 
  GIBBERISH    =   21 
  HIGHEST_VALID_TAG =   22 
  TMP_BLOG_COMMENT_LINK_FROM_ALEXIS = 1001 

  _PageTag_NAMES = {
    0: "GUESTBOOK",
    1: "FORUM",
    2: "MAILING_LIST",
    3: "BLOG_COMMENT",
    4: "BLOG",
    5: "PPC",
    6: "PAID_LINK",
    8: "REFERRER_LINK",
    7: "AFFILIATE",
    9: "SPAM_SIGNATURE_NOPROP",
    16: "FRIENDLINK_PAGE",
    17: "WIKI",
    18: "SPAM_SIGNATURE_KILL",
    19: "KEYWORD_STUFFED",
    20: "LINKEXCHANGE",
    21: "GIBBERISH",
    22: "HIGHEST_VALID_TAG",
    1001: "TMP_BLOG_COMMENT_LINK_FROM_ALEXIS",
  }

  def PageTag_Name(cls, x): return cls._PageTag_NAMES.get(x, "")
  PageTag_Name = classmethod(PageTag_Name)


  UNFORWARDED  =    0 
  FORWARDED    =    1 
  SIBLING_SEGMENT =    2 
  ORIGINAL_CANONICAL =    3 

  _Origin_NAMES = {
    0: "UNFORWARDED",
    1: "FORWARDED",
    2: "SIBLING_SEGMENT",
    3: "ORIGINAL_CANONICAL",
  }

  def Origin_Name(cls, x): return cls._Origin_NAMES.get(x, "")
  Origin_Name = classmethod(Origin_Name)


  NOT_HOMEPAGE =    0 
  NOT_TRUSTED  =    1 
  PARTIALLY_TRUSTED =    2 
  FULLY_TRUSTED =    3 

  _HomePageInfo_NAMES = {
    0: "NOT_HOMEPAGE",
    1: "NOT_TRUSTED",
    2: "PARTIALLY_TRUSTED",
    3: "FULLY_TRUSTED",
  }

  def HomePageInfo_Name(cls, x): return cls._HomePageInfo_NAMES.get(x, "")
  HomePageInfo_Name = classmethod(HomePageInfo_Name)

  def __init__(self, contents=None):
    self.phildata_ = None
    self.scaledindyrank_ = 0
    self.scaledexptindyrank_ = 0
    self.scaledexptindyrank2_ = 0
    self.scaledexptindyrank3_ = 0
    self.scaledspamscoreeric_ = 0
    self.scaledspamscoreyoram_ = 0
    self.scaledexptspamscoreeric_ = 0
    self.scaledexptspamscoreyoram_ = 0
    self.scaledlinkagespamscore_ = 0
    self.keywordstuffingscore_ = 0
    self.doclevelspamscore_ = 0
    self.spamwordscore_ = 0
    self.quarantinewhitelist_ = 0
    self.gibberishscore_ = 0
    self.whirlpooldiscount_ = 1.0
    self.geodata_ = ""
    self.imagedata_ = None
    self.kaltixdata_ = None
    self.crowdingdata_ = None
    self.oceandata_ = None
    self.page_tags_ = []
    self.languages_ = []
    self.compressed_url_ = ""
    self.spamrank_ = 0
    self.deprecated_matched_spam_signature_ = ""
    self.signaturedata_ = None
    self.pageregions_ = ""
    self.pagerank_ = 0.0
    self.pagerank0_ = 0.0
    self.pagerank1_ = 0.0
    self.pagerank2_ = 0.0
    self.smearing_max_total_offdomain_anchors_ = 0
    self.event_ = []
    self.origin_ = 0
    self.crawl_pagerank_ = 0
    self.groupsdata_ = None
    self.sciencedata_ = None
    self.premiumdata_ = None
    self.mobiledata_ = None
    self.carriermetadata_ = None
    self.navboostdata_ = None
    self.clickrdata_ = None
    self.home_page_info_ = 0
    self.num_urls_ = 1
    self.bookcitationdata_ = None
    self.toolbardata_ = None
    self.blogdata_ = None
    self.semantic_date_ = 0
    self.semantic_date_confidence_ = 0
    self.semantic_date_info_ = 0
    self.url_after_redirects_fp_ = 0
    self.webmirror_ecn_fp_ = 0
    self.extra_data_ = None
    self.has_phildata_ = 0
    self.has_scaledindyrank_ = 0
    self.has_scaledexptindyrank_ = 0
    self.has_scaledexptindyrank2_ = 0
    self.has_scaledexptindyrank3_ = 0
    self.has_scaledspamscoreeric_ = 0
    self.has_scaledspamscoreyoram_ = 0
    self.has_scaledexptspamscoreeric_ = 0
    self.has_scaledexptspamscoreyoram_ = 0
    self.has_scaledlinkagespamscore_ = 0
    self.has_keywordstuffingscore_ = 0
    self.has_doclevelspamscore_ = 0
    self.has_spamwordscore_ = 0
    self.has_quarantinewhitelist_ = 0
    self.has_gibberishscore_ = 0
    self.has_whirlpooldiscount_ = 0
    self.has_geodata_ = 0
    self.has_imagedata_ = 0
    self.has_kaltixdata_ = 0
    self.has_crowdingdata_ = 0
    self.has_oceandata_ = 0
    self.has_compressed_url_ = 0
    self.has_spamrank_ = 0
    self.has_deprecated_matched_spam_signature_ = 0
    self.has_signaturedata_ = 0
    self.has_pageregions_ = 0
    self.has_pagerank_ = 0
    self.has_pagerank0_ = 0
    self.has_pagerank1_ = 0
    self.has_pagerank2_ = 0
    self.has_smearing_max_total_offdomain_anchors_ = 0
    self.has_origin_ = 0
    self.has_crawl_pagerank_ = 0
    self.has_groupsdata_ = 0
    self.has_sciencedata_ = 0
    self.has_premiumdata_ = 0
    self.has_mobiledata_ = 0
    self.has_carriermetadata_ = 0
    self.has_navboostdata_ = 0
    self.has_clickrdata_ = 0
    self.has_home_page_info_ = 0
    self.has_num_urls_ = 0
    self.has_bookcitationdata_ = 0
    self.has_toolbardata_ = 0
    self.has_blogdata_ = 0
    self.has_semantic_date_ = 0
    self.has_semantic_date_confidence_ = 0
    self.has_semantic_date_info_ = 0
    self.has_url_after_redirects_fp_ = 0
    self.has_webmirror_ecn_fp_ = 0
    self.has_extra_data_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def phildata(self):
    if self.phildata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.phildata_ is None: self.phildata_ = PhilPerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.phildata_

  def mutable_phildata(self): self.has_phildata_ = 1; return self.phildata()

  def clear_phildata(self):
    #Warning: this method does not acquire the lock.
    self.has_phildata_ = 0;
    if self.phildata_ is not None: self.phildata_.Clear()

  def has_phildata(self): return self.has_phildata_

  def scaledindyrank(self): return self.scaledindyrank_

  def set_scaledindyrank(self, x):
    self.has_scaledindyrank_ = 1
    self.scaledindyrank_ = x

  def clear_scaledindyrank(self):
    self.has_scaledindyrank_ = 0
    self.scaledindyrank_ = 0

  def has_scaledindyrank(self): return self.has_scaledindyrank_

  def scaledexptindyrank(self): return self.scaledexptindyrank_

  def set_scaledexptindyrank(self, x):
    self.has_scaledexptindyrank_ = 1
    self.scaledexptindyrank_ = x

  def clear_scaledexptindyrank(self):
    self.has_scaledexptindyrank_ = 0
    self.scaledexptindyrank_ = 0

  def has_scaledexptindyrank(self): return self.has_scaledexptindyrank_

  def scaledexptindyrank2(self): return self.scaledexptindyrank2_

  def set_scaledexptindyrank2(self, x):
    self.has_scaledexptindyrank2_ = 1
    self.scaledexptindyrank2_ = x

  def clear_scaledexptindyrank2(self):
    self.has_scaledexptindyrank2_ = 0
    self.scaledexptindyrank2_ = 0

  def has_scaledexptindyrank2(self): return self.has_scaledexptindyrank2_

  def scaledexptindyrank3(self): return self.scaledexptindyrank3_

  def set_scaledexptindyrank3(self, x):
    self.has_scaledexptindyrank3_ = 1
    self.scaledexptindyrank3_ = x

  def clear_scaledexptindyrank3(self):
    self.has_scaledexptindyrank3_ = 0
    self.scaledexptindyrank3_ = 0

  def has_scaledexptindyrank3(self): return self.has_scaledexptindyrank3_

  def scaledspamscoreeric(self): return self.scaledspamscoreeric_

  def set_scaledspamscoreeric(self, x):
    self.has_scaledspamscoreeric_ = 1
    self.scaledspamscoreeric_ = x

  def clear_scaledspamscoreeric(self):
    self.has_scaledspamscoreeric_ = 0
    self.scaledspamscoreeric_ = 0

  def has_scaledspamscoreeric(self): return self.has_scaledspamscoreeric_

  def scaledspamscoreyoram(self): return self.scaledspamscoreyoram_

  def set_scaledspamscoreyoram(self, x):
    self.has_scaledspamscoreyoram_ = 1
    self.scaledspamscoreyoram_ = x

  def clear_scaledspamscoreyoram(self):
    self.has_scaledspamscoreyoram_ = 0
    self.scaledspamscoreyoram_ = 0

  def has_scaledspamscoreyoram(self): return self.has_scaledspamscoreyoram_

  def scaledexptspamscoreeric(self): return self.scaledexptspamscoreeric_

  def set_scaledexptspamscoreeric(self, x):
    self.has_scaledexptspamscoreeric_ = 1
    self.scaledexptspamscoreeric_ = x

  def clear_scaledexptspamscoreeric(self):
    self.has_scaledexptspamscoreeric_ = 0
    self.scaledexptspamscoreeric_ = 0

  def has_scaledexptspamscoreeric(self): return self.has_scaledexptspamscoreeric_

  def scaledexptspamscoreyoram(self): return self.scaledexptspamscoreyoram_

  def set_scaledexptspamscoreyoram(self, x):
    self.has_scaledexptspamscoreyoram_ = 1
    self.scaledexptspamscoreyoram_ = x

  def clear_scaledexptspamscoreyoram(self):
    self.has_scaledexptspamscoreyoram_ = 0
    self.scaledexptspamscoreyoram_ = 0

  def has_scaledexptspamscoreyoram(self): return self.has_scaledexptspamscoreyoram_

  def scaledlinkagespamscore(self): return self.scaledlinkagespamscore_

  def set_scaledlinkagespamscore(self, x):
    self.has_scaledlinkagespamscore_ = 1
    self.scaledlinkagespamscore_ = x

  def clear_scaledlinkagespamscore(self):
    self.has_scaledlinkagespamscore_ = 0
    self.scaledlinkagespamscore_ = 0

  def has_scaledlinkagespamscore(self): return self.has_scaledlinkagespamscore_

  def keywordstuffingscore(self): return self.keywordstuffingscore_

  def set_keywordstuffingscore(self, x):
    self.has_keywordstuffingscore_ = 1
    self.keywordstuffingscore_ = x

  def clear_keywordstuffingscore(self):
    self.has_keywordstuffingscore_ = 0
    self.keywordstuffingscore_ = 0

  def has_keywordstuffingscore(self): return self.has_keywordstuffingscore_

  def doclevelspamscore(self): return self.doclevelspamscore_

  def set_doclevelspamscore(self, x):
    self.has_doclevelspamscore_ = 1
    self.doclevelspamscore_ = x

  def clear_doclevelspamscore(self):
    self.has_doclevelspamscore_ = 0
    self.doclevelspamscore_ = 0

  def has_doclevelspamscore(self): return self.has_doclevelspamscore_

  def spamwordscore(self): return self.spamwordscore_

  def set_spamwordscore(self, x):
    self.has_spamwordscore_ = 1
    self.spamwordscore_ = x

  def clear_spamwordscore(self):
    self.has_spamwordscore_ = 0
    self.spamwordscore_ = 0

  def has_spamwordscore(self): return self.has_spamwordscore_

  def quarantinewhitelist(self): return self.quarantinewhitelist_

  def set_quarantinewhitelist(self, x):
    self.has_quarantinewhitelist_ = 1
    self.quarantinewhitelist_ = x

  def clear_quarantinewhitelist(self):
    self.has_quarantinewhitelist_ = 0
    self.quarantinewhitelist_ = 0

  def has_quarantinewhitelist(self): return self.has_quarantinewhitelist_

  def gibberishscore(self): return self.gibberishscore_

  def set_gibberishscore(self, x):
    self.has_gibberishscore_ = 1
    self.gibberishscore_ = x

  def clear_gibberishscore(self):
    self.has_gibberishscore_ = 0
    self.gibberishscore_ = 0

  def has_gibberishscore(self): return self.has_gibberishscore_

  def whirlpooldiscount(self): return self.whirlpooldiscount_

  def set_whirlpooldiscount(self, x):
    self.has_whirlpooldiscount_ = 1
    self.whirlpooldiscount_ = x

  def clear_whirlpooldiscount(self):
    self.has_whirlpooldiscount_ = 0
    self.whirlpooldiscount_ = 1.0

  def has_whirlpooldiscount(self): return self.has_whirlpooldiscount_

  def geodata(self): return self.geodata_

  def set_geodata(self, x):
    self.has_geodata_ = 1
    self.geodata_ = x

  def clear_geodata(self):
    self.has_geodata_ = 0
    self.geodata_ = ""

  def has_geodata(self): return self.has_geodata_

  def imagedata(self):
    if self.imagedata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.imagedata_ is None: self.imagedata_ = ImagePerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.imagedata_

  def mutable_imagedata(self): self.has_imagedata_ = 1; return self.imagedata()

  def clear_imagedata(self):
    #Warning: this method does not acquire the lock.
    self.has_imagedata_ = 0;
    if self.imagedata_ is not None: self.imagedata_.Clear()

  def has_imagedata(self): return self.has_imagedata_

  def kaltixdata(self):
    if self.kaltixdata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.kaltixdata_ is None: self.kaltixdata_ = KaltixPerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.kaltixdata_

  def mutable_kaltixdata(self): self.has_kaltixdata_ = 1; return self.kaltixdata()

  def clear_kaltixdata(self):
    #Warning: this method does not acquire the lock.
    self.has_kaltixdata_ = 0;
    if self.kaltixdata_ is not None: self.kaltixdata_.Clear()

  def has_kaltixdata(self): return self.has_kaltixdata_

  def crowdingdata(self):
    if self.crowdingdata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.crowdingdata_ is None: self.crowdingdata_ = CrowdingPerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.crowdingdata_

  def mutable_crowdingdata(self): self.has_crowdingdata_ = 1; return self.crowdingdata()

  def clear_crowdingdata(self):
    #Warning: this method does not acquire the lock.
    self.has_crowdingdata_ = 0;
    if self.crowdingdata_ is not None: self.crowdingdata_.Clear()

  def has_crowdingdata(self): return self.has_crowdingdata_

  def oceandata(self):
    if self.oceandata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.oceandata_ is None: self.oceandata_ = OceanPerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.oceandata_

  def mutable_oceandata(self): self.has_oceandata_ = 1; return self.oceandata()

  def clear_oceandata(self):
    #Warning: this method does not acquire the lock.
    self.has_oceandata_ = 0;
    if self.oceandata_ is not None: self.oceandata_.Clear()

  def has_oceandata(self): return self.has_oceandata_

  def page_tags_size(self): return len(self.page_tags_)
  def page_tags_list(self): return self.page_tags_

  def page_tags(self, i):
    return self.page_tags_[i]

  def set_page_tags(self, i, x):
    self.page_tags_[i] = x

  def add_page_tags(self, x):
    self.page_tags_.append(x)

  def clear_page_tags(self):
    self.page_tags_ = []

  def languages_size(self): return len(self.languages_)
  def languages_list(self): return self.languages_

  def languages(self, i):
    return self.languages_[i]

  def set_languages(self, i, x):
    self.languages_[i] = x

  def add_languages(self, x):
    self.languages_.append(x)

  def clear_languages(self):
    self.languages_ = []

  def compressed_url(self): return self.compressed_url_

  def set_compressed_url(self, x):
    self.has_compressed_url_ = 1
    self.compressed_url_ = x

  def clear_compressed_url(self):
    self.has_compressed_url_ = 0
    self.compressed_url_ = ""

  def has_compressed_url(self): return self.has_compressed_url_

  def spamrank(self): return self.spamrank_

  def set_spamrank(self, x):
    self.has_spamrank_ = 1
    self.spamrank_ = x

  def clear_spamrank(self):
    self.has_spamrank_ = 0
    self.spamrank_ = 0

  def has_spamrank(self): return self.has_spamrank_

  def deprecated_matched_spam_signature(self): return self.deprecated_matched_spam_signature_

  def set_deprecated_matched_spam_signature(self, x):
    self.has_deprecated_matched_spam_signature_ = 1
    self.deprecated_matched_spam_signature_ = x

  def clear_deprecated_matched_spam_signature(self):
    self.has_deprecated_matched_spam_signature_ = 0
    self.deprecated_matched_spam_signature_ = ""

  def has_deprecated_matched_spam_signature(self): return self.has_deprecated_matched_spam_signature_

  def signaturedata(self):
    if self.signaturedata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.signaturedata_ is None: self.signaturedata_ = SignatureData()
      finally:
        self.lazy_init_lock_.release()
    return self.signaturedata_

  def mutable_signaturedata(self): self.has_signaturedata_ = 1; return self.signaturedata()

  def clear_signaturedata(self):
    #Warning: this method does not acquire the lock.
    self.has_signaturedata_ = 0;
    if self.signaturedata_ is not None: self.signaturedata_.Clear()

  def has_signaturedata(self): return self.has_signaturedata_

  def pageregions(self): return self.pageregions_

  def set_pageregions(self, x):
    self.has_pageregions_ = 1
    self.pageregions_ = x

  def clear_pageregions(self):
    self.has_pageregions_ = 0
    self.pageregions_ = ""

  def has_pageregions(self): return self.has_pageregions_

  def pagerank(self): return self.pagerank_

  def set_pagerank(self, x):
    self.has_pagerank_ = 1
    self.pagerank_ = x

  def clear_pagerank(self):
    self.has_pagerank_ = 0
    self.pagerank_ = 0.0

  def has_pagerank(self): return self.has_pagerank_

  def pagerank0(self): return self.pagerank0_

  def set_pagerank0(self, x):
    self.has_pagerank0_ = 1
    self.pagerank0_ = x

  def clear_pagerank0(self):
    self.has_pagerank0_ = 0
    self.pagerank0_ = 0.0

  def has_pagerank0(self): return self.has_pagerank0_

  def pagerank1(self): return self.pagerank1_

  def set_pagerank1(self, x):
    self.has_pagerank1_ = 1
    self.pagerank1_ = x

  def clear_pagerank1(self):
    self.has_pagerank1_ = 0
    self.pagerank1_ = 0.0

  def has_pagerank1(self): return self.has_pagerank1_

  def pagerank2(self): return self.pagerank2_

  def set_pagerank2(self, x):
    self.has_pagerank2_ = 1
    self.pagerank2_ = x

  def clear_pagerank2(self):
    self.has_pagerank2_ = 0
    self.pagerank2_ = 0.0

  def has_pagerank2(self): return self.has_pagerank2_

  def smearing_max_total_offdomain_anchors(self): return self.smearing_max_total_offdomain_anchors_

  def set_smearing_max_total_offdomain_anchors(self, x):
    self.has_smearing_max_total_offdomain_anchors_ = 1
    self.smearing_max_total_offdomain_anchors_ = x

  def clear_smearing_max_total_offdomain_anchors(self):
    self.has_smearing_max_total_offdomain_anchors_ = 0
    self.smearing_max_total_offdomain_anchors_ = 0

  def has_smearing_max_total_offdomain_anchors(self): return self.has_smearing_max_total_offdomain_anchors_

  def event_size(self): return len(self.event_)
  def event_list(self): return self.event_

  def event(self, i):
    return self.event_[i]

  def mutable_event(self, i):
    return self.event_[i]

  def add_event(self):
    x = PerDocDebugEvent()
    self.event_.append(x)
    return x

  def clear_event(self):
    self.event_ = []
  def origin(self): return self.origin_

  def set_origin(self, x):
    self.has_origin_ = 1
    self.origin_ = x

  def clear_origin(self):
    self.has_origin_ = 0
    self.origin_ = 0

  def has_origin(self): return self.has_origin_

  def crawl_pagerank(self): return self.crawl_pagerank_

  def set_crawl_pagerank(self, x):
    self.has_crawl_pagerank_ = 1
    self.crawl_pagerank_ = x

  def clear_crawl_pagerank(self):
    self.has_crawl_pagerank_ = 0
    self.crawl_pagerank_ = 0

  def has_crawl_pagerank(self): return self.has_crawl_pagerank_

  def groupsdata(self):
    if self.groupsdata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.groupsdata_ is None: self.groupsdata_ = GroupsPerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.groupsdata_

  def mutable_groupsdata(self): self.has_groupsdata_ = 1; return self.groupsdata()

  def clear_groupsdata(self):
    #Warning: this method does not acquire the lock.
    self.has_groupsdata_ = 0;
    if self.groupsdata_ is not None: self.groupsdata_.Clear()

  def has_groupsdata(self): return self.has_groupsdata_

  def sciencedata(self):
    if self.sciencedata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.sciencedata_ is None: self.sciencedata_ = SciencePerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.sciencedata_

  def mutable_sciencedata(self): self.has_sciencedata_ = 1; return self.sciencedata()

  def clear_sciencedata(self):
    #Warning: this method does not acquire the lock.
    self.has_sciencedata_ = 0;
    if self.sciencedata_ is not None: self.sciencedata_.Clear()

  def has_sciencedata(self): return self.has_sciencedata_

  def premiumdata(self):
    if self.premiumdata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.premiumdata_ is None: self.premiumdata_ = PremiumPerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.premiumdata_

  def mutable_premiumdata(self): self.has_premiumdata_ = 1; return self.premiumdata()

  def clear_premiumdata(self):
    #Warning: this method does not acquire the lock.
    self.has_premiumdata_ = 0;
    if self.premiumdata_ is not None: self.premiumdata_.Clear()

  def has_premiumdata(self): return self.has_premiumdata_

  def mobiledata(self):
    if self.mobiledata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.mobiledata_ is None: self.mobiledata_ = MobilePerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.mobiledata_

  def mutable_mobiledata(self): self.has_mobiledata_ = 1; return self.mobiledata()

  def clear_mobiledata(self):
    #Warning: this method does not acquire the lock.
    self.has_mobiledata_ = 0;
    if self.mobiledata_ is not None: self.mobiledata_.Clear()

  def has_mobiledata(self): return self.has_mobiledata_

  def carriermetadata(self):
    if self.carriermetadata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.carriermetadata_ is None: self.carriermetadata_ = CarrierMetadata()
      finally:
        self.lazy_init_lock_.release()
    return self.carriermetadata_

  def mutable_carriermetadata(self): self.has_carriermetadata_ = 1; return self.carriermetadata()

  def clear_carriermetadata(self):
    #Warning: this method does not acquire the lock.
    self.has_carriermetadata_ = 0;
    if self.carriermetadata_ is not None: self.carriermetadata_.Clear()

  def has_carriermetadata(self): return self.has_carriermetadata_

  def navboostdata(self):
    if self.navboostdata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.navboostdata_ is None: self.navboostdata_ = NavBoostDocument()
      finally:
        self.lazy_init_lock_.release()
    return self.navboostdata_

  def mutable_navboostdata(self): self.has_navboostdata_ = 1; return self.navboostdata()

  def clear_navboostdata(self):
    #Warning: this method does not acquire the lock.
    self.has_navboostdata_ = 0;
    if self.navboostdata_ is not None: self.navboostdata_.Clear()

  def has_navboostdata(self): return self.has_navboostdata_

  def clickrdata(self):
    if self.clickrdata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.clickrdata_ is None: self.clickrdata_ = NavBoostDocument()
      finally:
        self.lazy_init_lock_.release()
    return self.clickrdata_

  def mutable_clickrdata(self): self.has_clickrdata_ = 1; return self.clickrdata()

  def clear_clickrdata(self):
    #Warning: this method does not acquire the lock.
    self.has_clickrdata_ = 0;
    if self.clickrdata_ is not None: self.clickrdata_.Clear()

  def has_clickrdata(self): return self.has_clickrdata_

  def home_page_info(self): return self.home_page_info_

  def set_home_page_info(self, x):
    self.has_home_page_info_ = 1
    self.home_page_info_ = x

  def clear_home_page_info(self):
    self.has_home_page_info_ = 0
    self.home_page_info_ = 0

  def has_home_page_info(self): return self.has_home_page_info_

  def num_urls(self): return self.num_urls_

  def set_num_urls(self, x):
    self.has_num_urls_ = 1
    self.num_urls_ = x

  def clear_num_urls(self):
    self.has_num_urls_ = 0
    self.num_urls_ = 1

  def has_num_urls(self): return self.has_num_urls_

  def bookcitationdata(self):
    if self.bookcitationdata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.bookcitationdata_ is None: self.bookcitationdata_ = BookCitationPerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.bookcitationdata_

  def mutable_bookcitationdata(self): self.has_bookcitationdata_ = 1; return self.bookcitationdata()

  def clear_bookcitationdata(self):
    #Warning: this method does not acquire the lock.
    self.has_bookcitationdata_ = 0;
    if self.bookcitationdata_ is not None: self.bookcitationdata_.Clear()

  def has_bookcitationdata(self): return self.has_bookcitationdata_

  def toolbardata(self):
    if self.toolbardata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.toolbardata_ is None: self.toolbardata_ = ToolBarPerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.toolbardata_

  def mutable_toolbardata(self): self.has_toolbardata_ = 1; return self.toolbardata()

  def clear_toolbardata(self):
    #Warning: this method does not acquire the lock.
    self.has_toolbardata_ = 0;
    if self.toolbardata_ is not None: self.toolbardata_.Clear()

  def has_toolbardata(self): return self.has_toolbardata_

  def blogdata(self):
    if self.blogdata_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.blogdata_ is None: self.blogdata_ = BlogPerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.blogdata_

  def mutable_blogdata(self): self.has_blogdata_ = 1; return self.blogdata()

  def clear_blogdata(self):
    #Warning: this method does not acquire the lock.
    self.has_blogdata_ = 0;
    if self.blogdata_ is not None: self.blogdata_.Clear()

  def has_blogdata(self): return self.has_blogdata_

  def semantic_date(self): return self.semantic_date_

  def set_semantic_date(self, x):
    self.has_semantic_date_ = 1
    self.semantic_date_ = x

  def clear_semantic_date(self):
    self.has_semantic_date_ = 0
    self.semantic_date_ = 0

  def has_semantic_date(self): return self.has_semantic_date_

  def semantic_date_confidence(self): return self.semantic_date_confidence_

  def set_semantic_date_confidence(self, x):
    self.has_semantic_date_confidence_ = 1
    self.semantic_date_confidence_ = x

  def clear_semantic_date_confidence(self):
    self.has_semantic_date_confidence_ = 0
    self.semantic_date_confidence_ = 0

  def has_semantic_date_confidence(self): return self.has_semantic_date_confidence_

  def semantic_date_info(self): return self.semantic_date_info_

  def set_semantic_date_info(self, x):
    self.has_semantic_date_info_ = 1
    self.semantic_date_info_ = x

  def clear_semantic_date_info(self):
    self.has_semantic_date_info_ = 0
    self.semantic_date_info_ = 0

  def has_semantic_date_info(self): return self.has_semantic_date_info_

  def url_after_redirects_fp(self): return self.url_after_redirects_fp_

  def set_url_after_redirects_fp(self, x):
    self.has_url_after_redirects_fp_ = 1
    self.url_after_redirects_fp_ = x

  def clear_url_after_redirects_fp(self):
    self.has_url_after_redirects_fp_ = 0
    self.url_after_redirects_fp_ = 0

  def has_url_after_redirects_fp(self): return self.has_url_after_redirects_fp_

  def webmirror_ecn_fp(self): return self.webmirror_ecn_fp_

  def set_webmirror_ecn_fp(self, x):
    self.has_webmirror_ecn_fp_ = 1
    self.webmirror_ecn_fp_ = x

  def clear_webmirror_ecn_fp(self):
    self.has_webmirror_ecn_fp_ = 0
    self.webmirror_ecn_fp_ = 0

  def has_webmirror_ecn_fp(self): return self.has_webmirror_ecn_fp_

  def extra_data(self):
    if self.extra_data_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.extra_data_ is None: self.extra_data_ = MessageSet()
      finally:
        self.lazy_init_lock_.release()
    return self.extra_data_

  def mutable_extra_data(self): self.has_extra_data_ = 1; return self.extra_data()

  def clear_extra_data(self):
    #Warning: this method does not acquire the lock.
    self.has_extra_data_ = 0;
    if self.extra_data_ is not None: self.extra_data_.Clear()

  def has_extra_data(self): return self.has_extra_data_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_phildata()): self.mutable_phildata().MergeFrom(x.phildata())
    if (x.has_scaledindyrank()): self.set_scaledindyrank(x.scaledindyrank())
    if (x.has_scaledexptindyrank()): self.set_scaledexptindyrank(x.scaledexptindyrank())
    if (x.has_scaledexptindyrank2()): self.set_scaledexptindyrank2(x.scaledexptindyrank2())
    if (x.has_scaledexptindyrank3()): self.set_scaledexptindyrank3(x.scaledexptindyrank3())
    if (x.has_scaledspamscoreeric()): self.set_scaledspamscoreeric(x.scaledspamscoreeric())
    if (x.has_scaledspamscoreyoram()): self.set_scaledspamscoreyoram(x.scaledspamscoreyoram())
    if (x.has_scaledexptspamscoreeric()): self.set_scaledexptspamscoreeric(x.scaledexptspamscoreeric())
    if (x.has_scaledexptspamscoreyoram()): self.set_scaledexptspamscoreyoram(x.scaledexptspamscoreyoram())
    if (x.has_scaledlinkagespamscore()): self.set_scaledlinkagespamscore(x.scaledlinkagespamscore())
    if (x.has_keywordstuffingscore()): self.set_keywordstuffingscore(x.keywordstuffingscore())
    if (x.has_doclevelspamscore()): self.set_doclevelspamscore(x.doclevelspamscore())
    if (x.has_spamwordscore()): self.set_spamwordscore(x.spamwordscore())
    if (x.has_quarantinewhitelist()): self.set_quarantinewhitelist(x.quarantinewhitelist())
    if (x.has_gibberishscore()): self.set_gibberishscore(x.gibberishscore())
    if (x.has_whirlpooldiscount()): self.set_whirlpooldiscount(x.whirlpooldiscount())
    if (x.has_geodata()): self.set_geodata(x.geodata())
    if (x.has_imagedata()): self.mutable_imagedata().MergeFrom(x.imagedata())
    if (x.has_kaltixdata()): self.mutable_kaltixdata().MergeFrom(x.kaltixdata())
    if (x.has_crowdingdata()): self.mutable_crowdingdata().MergeFrom(x.crowdingdata())
    if (x.has_oceandata()): self.mutable_oceandata().MergeFrom(x.oceandata())
    for i in xrange(x.page_tags_size()): self.add_page_tags(x.page_tags(i))
    for i in xrange(x.languages_size()): self.add_languages(x.languages(i))
    if (x.has_compressed_url()): self.set_compressed_url(x.compressed_url())
    if (x.has_spamrank()): self.set_spamrank(x.spamrank())
    if (x.has_deprecated_matched_spam_signature()): self.set_deprecated_matched_spam_signature(x.deprecated_matched_spam_signature())
    if (x.has_signaturedata()): self.mutable_signaturedata().MergeFrom(x.signaturedata())
    if (x.has_pageregions()): self.set_pageregions(x.pageregions())
    if (x.has_pagerank()): self.set_pagerank(x.pagerank())
    if (x.has_pagerank0()): self.set_pagerank0(x.pagerank0())
    if (x.has_pagerank1()): self.set_pagerank1(x.pagerank1())
    if (x.has_pagerank2()): self.set_pagerank2(x.pagerank2())
    if (x.has_smearing_max_total_offdomain_anchors()): self.set_smearing_max_total_offdomain_anchors(x.smearing_max_total_offdomain_anchors())
    for i in xrange(x.event_size()): self.add_event().CopyFrom(x.event(i))
    if (x.has_origin()): self.set_origin(x.origin())
    if (x.has_crawl_pagerank()): self.set_crawl_pagerank(x.crawl_pagerank())
    if (x.has_groupsdata()): self.mutable_groupsdata().MergeFrom(x.groupsdata())
    if (x.has_sciencedata()): self.mutable_sciencedata().MergeFrom(x.sciencedata())
    if (x.has_premiumdata()): self.mutable_premiumdata().MergeFrom(x.premiumdata())
    if (x.has_mobiledata()): self.mutable_mobiledata().MergeFrom(x.mobiledata())
    if (x.has_carriermetadata()): self.mutable_carriermetadata().MergeFrom(x.carriermetadata())
    if (x.has_navboostdata()): self.mutable_navboostdata().MergeFrom(x.navboostdata())
    if (x.has_clickrdata()): self.mutable_clickrdata().MergeFrom(x.clickrdata())
    if (x.has_home_page_info()): self.set_home_page_info(x.home_page_info())
    if (x.has_num_urls()): self.set_num_urls(x.num_urls())
    if (x.has_bookcitationdata()): self.mutable_bookcitationdata().MergeFrom(x.bookcitationdata())
    if (x.has_toolbardata()): self.mutable_toolbardata().MergeFrom(x.toolbardata())
    if (x.has_blogdata()): self.mutable_blogdata().MergeFrom(x.blogdata())
    if (x.has_semantic_date()): self.set_semantic_date(x.semantic_date())
    if (x.has_semantic_date_confidence()): self.set_semantic_date_confidence(x.semantic_date_confidence())
    if (x.has_semantic_date_info()): self.set_semantic_date_info(x.semantic_date_info())
    if (x.has_url_after_redirects_fp()): self.set_url_after_redirects_fp(x.url_after_redirects_fp())
    if (x.has_webmirror_ecn_fp()): self.set_webmirror_ecn_fp(x.webmirror_ecn_fp())
    if (x.has_extra_data()): self.mutable_extra_data().MergeFrom(x.extra_data())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'PerDocData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'PerDocData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'PerDocData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'PerDocData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'PerDocData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_phildata_ != x.has_phildata_: return 0
    if self.has_phildata_ and self.phildata_ != x.phildata_: return 0
    if self.has_scaledindyrank_ != x.has_scaledindyrank_: return 0
    if self.has_scaledindyrank_ and self.scaledindyrank_ != x.scaledindyrank_: return 0
    if self.has_scaledexptindyrank_ != x.has_scaledexptindyrank_: return 0
    if self.has_scaledexptindyrank_ and self.scaledexptindyrank_ != x.scaledexptindyrank_: return 0
    if self.has_scaledexptindyrank2_ != x.has_scaledexptindyrank2_: return 0
    if self.has_scaledexptindyrank2_ and self.scaledexptindyrank2_ != x.scaledexptindyrank2_: return 0
    if self.has_scaledexptindyrank3_ != x.has_scaledexptindyrank3_: return 0
    if self.has_scaledexptindyrank3_ and self.scaledexptindyrank3_ != x.scaledexptindyrank3_: return 0
    if self.has_scaledspamscoreeric_ != x.has_scaledspamscoreeric_: return 0
    if self.has_scaledspamscoreeric_ and self.scaledspamscoreeric_ != x.scaledspamscoreeric_: return 0
    if self.has_scaledspamscoreyoram_ != x.has_scaledspamscoreyoram_: return 0
    if self.has_scaledspamscoreyoram_ and self.scaledspamscoreyoram_ != x.scaledspamscoreyoram_: return 0
    if self.has_scaledexptspamscoreeric_ != x.has_scaledexptspamscoreeric_: return 0
    if self.has_scaledexptspamscoreeric_ and self.scaledexptspamscoreeric_ != x.scaledexptspamscoreeric_: return 0
    if self.has_scaledexptspamscoreyoram_ != x.has_scaledexptspamscoreyoram_: return 0
    if self.has_scaledexptspamscoreyoram_ and self.scaledexptspamscoreyoram_ != x.scaledexptspamscoreyoram_: return 0
    if self.has_scaledlinkagespamscore_ != x.has_scaledlinkagespamscore_: return 0
    if self.has_scaledlinkagespamscore_ and self.scaledlinkagespamscore_ != x.scaledlinkagespamscore_: return 0
    if self.has_keywordstuffingscore_ != x.has_keywordstuffingscore_: return 0
    if self.has_keywordstuffingscore_ and self.keywordstuffingscore_ != x.keywordstuffingscore_: return 0
    if self.has_doclevelspamscore_ != x.has_doclevelspamscore_: return 0
    if self.has_doclevelspamscore_ and self.doclevelspamscore_ != x.doclevelspamscore_: return 0
    if self.has_spamwordscore_ != x.has_spamwordscore_: return 0
    if self.has_spamwordscore_ and self.spamwordscore_ != x.spamwordscore_: return 0
    if self.has_quarantinewhitelist_ != x.has_quarantinewhitelist_: return 0
    if self.has_quarantinewhitelist_ and self.quarantinewhitelist_ != x.quarantinewhitelist_: return 0
    if self.has_gibberishscore_ != x.has_gibberishscore_: return 0
    if self.has_gibberishscore_ and self.gibberishscore_ != x.gibberishscore_: return 0
    if self.has_whirlpooldiscount_ != x.has_whirlpooldiscount_: return 0
    if self.has_whirlpooldiscount_ and self.whirlpooldiscount_ != x.whirlpooldiscount_: return 0
    if self.has_geodata_ != x.has_geodata_: return 0
    if self.has_geodata_ and self.geodata_ != x.geodata_: return 0
    if self.has_imagedata_ != x.has_imagedata_: return 0
    if self.has_imagedata_ and self.imagedata_ != x.imagedata_: return 0
    if self.has_kaltixdata_ != x.has_kaltixdata_: return 0
    if self.has_kaltixdata_ and self.kaltixdata_ != x.kaltixdata_: return 0
    if self.has_crowdingdata_ != x.has_crowdingdata_: return 0
    if self.has_crowdingdata_ and self.crowdingdata_ != x.crowdingdata_: return 0
    if self.has_oceandata_ != x.has_oceandata_: return 0
    if self.has_oceandata_ and self.oceandata_ != x.oceandata_: return 0
    if len(self.page_tags_) != len(x.page_tags_): return 0
    for e1, e2 in zip(self.page_tags_, x.page_tags_):
      if e1 != e2: return 0
    if len(self.languages_) != len(x.languages_): return 0
    for e1, e2 in zip(self.languages_, x.languages_):
      if e1 != e2: return 0
    if self.has_compressed_url_ != x.has_compressed_url_: return 0
    if self.has_compressed_url_ and self.compressed_url_ != x.compressed_url_: return 0
    if self.has_spamrank_ != x.has_spamrank_: return 0
    if self.has_spamrank_ and self.spamrank_ != x.spamrank_: return 0
    if self.has_deprecated_matched_spam_signature_ != x.has_deprecated_matched_spam_signature_: return 0
    if self.has_deprecated_matched_spam_signature_ and self.deprecated_matched_spam_signature_ != x.deprecated_matched_spam_signature_: return 0
    if self.has_signaturedata_ != x.has_signaturedata_: return 0
    if self.has_signaturedata_ and self.signaturedata_ != x.signaturedata_: return 0
    if self.has_pageregions_ != x.has_pageregions_: return 0
    if self.has_pageregions_ and self.pageregions_ != x.pageregions_: return 0
    if self.has_pagerank_ != x.has_pagerank_: return 0
    if self.has_pagerank_ and self.pagerank_ != x.pagerank_: return 0
    if self.has_pagerank0_ != x.has_pagerank0_: return 0
    if self.has_pagerank0_ and self.pagerank0_ != x.pagerank0_: return 0
    if self.has_pagerank1_ != x.has_pagerank1_: return 0
    if self.has_pagerank1_ and self.pagerank1_ != x.pagerank1_: return 0
    if self.has_pagerank2_ != x.has_pagerank2_: return 0
    if self.has_pagerank2_ and self.pagerank2_ != x.pagerank2_: return 0
    if self.has_smearing_max_total_offdomain_anchors_ != x.has_smearing_max_total_offdomain_anchors_: return 0
    if self.has_smearing_max_total_offdomain_anchors_ and self.smearing_max_total_offdomain_anchors_ != x.smearing_max_total_offdomain_anchors_: return 0
    if len(self.event_) != len(x.event_): return 0
    for e1, e2 in zip(self.event_, x.event_):
      if e1 != e2: return 0
    if self.has_origin_ != x.has_origin_: return 0
    if self.has_origin_ and self.origin_ != x.origin_: return 0
    if self.has_crawl_pagerank_ != x.has_crawl_pagerank_: return 0
    if self.has_crawl_pagerank_ and self.crawl_pagerank_ != x.crawl_pagerank_: return 0
    if self.has_groupsdata_ != x.has_groupsdata_: return 0
    if self.has_groupsdata_ and self.groupsdata_ != x.groupsdata_: return 0
    if self.has_sciencedata_ != x.has_sciencedata_: return 0
    if self.has_sciencedata_ and self.sciencedata_ != x.sciencedata_: return 0
    if self.has_premiumdata_ != x.has_premiumdata_: return 0
    if self.has_premiumdata_ and self.premiumdata_ != x.premiumdata_: return 0
    if self.has_mobiledata_ != x.has_mobiledata_: return 0
    if self.has_mobiledata_ and self.mobiledata_ != x.mobiledata_: return 0
    if self.has_carriermetadata_ != x.has_carriermetadata_: return 0
    if self.has_carriermetadata_ and self.carriermetadata_ != x.carriermetadata_: return 0
    if self.has_navboostdata_ != x.has_navboostdata_: return 0
    if self.has_navboostdata_ and self.navboostdata_ != x.navboostdata_: return 0
    if self.has_clickrdata_ != x.has_clickrdata_: return 0
    if self.has_clickrdata_ and self.clickrdata_ != x.clickrdata_: return 0
    if self.has_home_page_info_ != x.has_home_page_info_: return 0
    if self.has_home_page_info_ and self.home_page_info_ != x.home_page_info_: return 0
    if self.has_num_urls_ != x.has_num_urls_: return 0
    if self.has_num_urls_ and self.num_urls_ != x.num_urls_: return 0
    if self.has_bookcitationdata_ != x.has_bookcitationdata_: return 0
    if self.has_bookcitationdata_ and self.bookcitationdata_ != x.bookcitationdata_: return 0
    if self.has_toolbardata_ != x.has_toolbardata_: return 0
    if self.has_toolbardata_ and self.toolbardata_ != x.toolbardata_: return 0
    if self.has_blogdata_ != x.has_blogdata_: return 0
    if self.has_blogdata_ and self.blogdata_ != x.blogdata_: return 0
    if self.has_semantic_date_ != x.has_semantic_date_: return 0
    if self.has_semantic_date_ and self.semantic_date_ != x.semantic_date_: return 0
    if self.has_semantic_date_confidence_ != x.has_semantic_date_confidence_: return 0
    if self.has_semantic_date_confidence_ and self.semantic_date_confidence_ != x.semantic_date_confidence_: return 0
    if self.has_semantic_date_info_ != x.has_semantic_date_info_: return 0
    if self.has_semantic_date_info_ and self.semantic_date_info_ != x.semantic_date_info_: return 0
    if self.has_url_after_redirects_fp_ != x.has_url_after_redirects_fp_: return 0
    if self.has_url_after_redirects_fp_ and self.url_after_redirects_fp_ != x.url_after_redirects_fp_: return 0
    if self.has_webmirror_ecn_fp_ != x.has_webmirror_ecn_fp_: return 0
    if self.has_webmirror_ecn_fp_ and self.webmirror_ecn_fp_ != x.webmirror_ecn_fp_: return 0
    if self.has_extra_data_ != x.has_extra_data_: return 0
    if self.has_extra_data_ and self.extra_data_ != x.extra_data_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (self.has_phildata_ and not self.phildata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_imagedata_ and not self.imagedata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_kaltixdata_ and not self.kaltixdata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_crowdingdata_ and not self.crowdingdata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_oceandata_ and not self.oceandata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_signaturedata_ and not self.signaturedata_.IsInitialized(debug_strs)): initialized = 0
    for i in xrange(len(self.event_)):
      if (not self.event_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_groupsdata_ and not self.groupsdata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_sciencedata_ and not self.sciencedata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_premiumdata_ and not self.premiumdata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_mobiledata_ and not self.mobiledata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_carriermetadata_ and not self.carriermetadata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_navboostdata_ and not self.navboostdata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_clickrdata_ and not self.clickrdata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_bookcitationdata_ and not self.bookcitationdata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_toolbardata_ and not self.toolbardata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_blogdata_ and not self.blogdata_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_extra_data_ and not self.extra_data_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_phildata_): n += 1 + self.lengthString(self.phildata_.ByteSize())
    if (self.has_scaledindyrank_): n += 1 + self.lengthVarInt64(self.scaledindyrank_)
    if (self.has_scaledexptindyrank_): n += 2 + self.lengthVarInt64(self.scaledexptindyrank_)
    if (self.has_scaledexptindyrank2_): n += 2 + self.lengthVarInt64(self.scaledexptindyrank2_)
    if (self.has_scaledexptindyrank3_): n += 2 + self.lengthVarInt64(self.scaledexptindyrank3_)
    if (self.has_scaledspamscoreeric_): n += 2 + self.lengthVarInt64(self.scaledspamscoreeric_)
    if (self.has_scaledspamscoreyoram_): n += 2 + self.lengthVarInt64(self.scaledspamscoreyoram_)
    if (self.has_scaledexptspamscoreeric_): n += 2 + self.lengthVarInt64(self.scaledexptspamscoreeric_)
    if (self.has_scaledexptspamscoreyoram_): n += 2 + self.lengthVarInt64(self.scaledexptspamscoreyoram_)
    if (self.has_scaledlinkagespamscore_): n += 2 + self.lengthVarInt64(self.scaledlinkagespamscore_)
    if (self.has_keywordstuffingscore_): n += 2 + self.lengthVarInt64(self.keywordstuffingscore_)
    if (self.has_doclevelspamscore_): n += 2 + self.lengthVarInt64(self.doclevelspamscore_)
    if (self.has_spamwordscore_): n += 2 + self.lengthVarInt64(self.spamwordscore_)
    if (self.has_quarantinewhitelist_): n += 3
    if (self.has_gibberishscore_): n += 2 + self.lengthVarInt64(self.gibberishscore_)
    if (self.has_whirlpooldiscount_): n += 6
    if (self.has_geodata_): n += 1 + self.lengthString(len(self.geodata_))
    if (self.has_imagedata_): n += 1 + self.lengthString(self.imagedata_.ByteSize())
    if (self.has_kaltixdata_): n += 1 + self.lengthString(self.kaltixdata_.ByteSize())
    if (self.has_crowdingdata_): n += 1 + self.lengthString(self.crowdingdata_.ByteSize())
    if (self.has_oceandata_): n += 2 + self.lengthString(self.oceandata_.ByteSize())
    n += 2 * len(self.page_tags_)
    for i in xrange(len(self.page_tags_)): n += self.lengthVarInt64(self.page_tags_[i])
    n += 1 * len(self.languages_)
    for i in xrange(len(self.languages_)): n += self.lengthVarInt64(self.languages_[i])
    if (self.has_compressed_url_): n += 2 + self.lengthString(len(self.compressed_url_))
    if (self.has_spamrank_): n += 2 + self.lengthVarInt64(self.spamrank_)
    if (self.has_deprecated_matched_spam_signature_): n += 2 + self.lengthString(len(self.deprecated_matched_spam_signature_))
    if (self.has_signaturedata_): n += 2 + self.lengthString(self.signaturedata_.ByteSize())
    if (self.has_pageregions_): n += 1 + self.lengthString(len(self.pageregions_))
    if (self.has_pagerank_): n += 5
    if (self.has_pagerank0_): n += 6
    if (self.has_pagerank1_): n += 6
    if (self.has_pagerank2_): n += 6
    if (self.has_smearing_max_total_offdomain_anchors_): n += 2 + self.lengthVarInt64(self.smearing_max_total_offdomain_anchors_)
    n += 2 * len(self.event_)
    for i in xrange(len(self.event_)): n += self.lengthString(self.event_[i].ByteSize())
    if (self.has_origin_): n += 2 + self.lengthVarInt64(self.origin_)
    if (self.has_crawl_pagerank_): n += 2 + self.lengthVarInt64(self.crawl_pagerank_)
    if (self.has_groupsdata_): n += 2 + self.lengthString(self.groupsdata_.ByteSize())
    if (self.has_sciencedata_): n += 2 + self.lengthString(self.sciencedata_.ByteSize())
    if (self.has_premiumdata_): n += 2 + self.lengthString(self.premiumdata_.ByteSize())
    if (self.has_mobiledata_): n += 2 + self.lengthString(self.mobiledata_.ByteSize())
    if (self.has_carriermetadata_): n += 2 + self.lengthString(self.carriermetadata_.ByteSize())
    if (self.has_navboostdata_): n += 2 + self.lengthString(self.navboostdata_.ByteSize())
    if (self.has_clickrdata_): n += 2 + self.lengthString(self.clickrdata_.ByteSize())
    if (self.has_home_page_info_): n += 2 + self.lengthVarInt64(self.home_page_info_)
    if (self.has_num_urls_): n += 2 + self.lengthVarInt64(self.num_urls_)
    if (self.has_bookcitationdata_): n += 2 + self.lengthString(self.bookcitationdata_.ByteSize())
    if (self.has_toolbardata_): n += 2 + self.lengthString(self.toolbardata_.ByteSize())
    if (self.has_blogdata_): n += 2 + self.lengthString(self.blogdata_.ByteSize())
    if (self.has_semantic_date_): n += 2 + self.lengthVarInt64(self.semantic_date_)
    if (self.has_semantic_date_confidence_): n += 2 + self.lengthVarInt64(self.semantic_date_confidence_)
    if (self.has_semantic_date_info_): n += 2 + self.lengthVarInt64(self.semantic_date_info_)
    if (self.has_url_after_redirects_fp_): n += 10
    if (self.has_webmirror_ecn_fp_): n += 10
    if (self.has_extra_data_): n += 2 + self.lengthString(self.extra_data_.ByteSize())
    return n + 0

  def Clear(self):
    self.clear_phildata()
    self.clear_scaledindyrank()
    self.clear_scaledexptindyrank()
    self.clear_scaledexptindyrank2()
    self.clear_scaledexptindyrank3()
    self.clear_scaledspamscoreeric()
    self.clear_scaledspamscoreyoram()
    self.clear_scaledexptspamscoreeric()
    self.clear_scaledexptspamscoreyoram()
    self.clear_scaledlinkagespamscore()
    self.clear_keywordstuffingscore()
    self.clear_doclevelspamscore()
    self.clear_spamwordscore()
    self.clear_quarantinewhitelist()
    self.clear_gibberishscore()
    self.clear_whirlpooldiscount()
    self.clear_geodata()
    self.clear_imagedata()
    self.clear_kaltixdata()
    self.clear_crowdingdata()
    self.clear_oceandata()
    self.clear_page_tags()
    self.clear_languages()
    self.clear_compressed_url()
    self.clear_spamrank()
    self.clear_deprecated_matched_spam_signature()
    self.clear_signaturedata()
    self.clear_pageregions()
    self.clear_pagerank()
    self.clear_pagerank0()
    self.clear_pagerank1()
    self.clear_pagerank2()
    self.clear_smearing_max_total_offdomain_anchors()
    self.clear_event()
    self.clear_origin()
    self.clear_crawl_pagerank()
    self.clear_groupsdata()
    self.clear_sciencedata()
    self.clear_premiumdata()
    self.clear_mobiledata()
    self.clear_carriermetadata()
    self.clear_navboostdata()
    self.clear_clickrdata()
    self.clear_home_page_info()
    self.clear_num_urls()
    self.clear_bookcitationdata()
    self.clear_toolbardata()
    self.clear_blogdata()
    self.clear_semantic_date()
    self.clear_semantic_date_confidence()
    self.clear_semantic_date_info()
    self.clear_url_after_redirects_fp()
    self.clear_webmirror_ecn_fp()
    self.clear_extra_data()

  def OutputUnchecked(self, out):
    if (self.has_phildata_):
      out.putVarInt32(10)
      out.putVarInt32(self.phildata_.ByteSize())
      self.phildata_.OutputUnchecked(out)
    if (self.has_pagerank_):
      out.putVarInt32(21)
      out.putFloat(self.pagerank_)
    if (self.has_geodata_):
      out.putVarInt32(26)
      out.putPrefixedString(self.geodata_)
    if (self.has_scaledindyrank_):
      out.putVarInt32(32)
      out.putVarInt32(self.scaledindyrank_)
    if (self.has_imagedata_):
      out.putVarInt32(42)
      out.putVarInt32(self.imagedata_.ByteSize())
      self.imagedata_.OutputUnchecked(out)
    if (self.has_kaltixdata_):
      out.putVarInt32(50)
      out.putVarInt32(self.kaltixdata_.ByteSize())
      self.kaltixdata_.OutputUnchecked(out)
    for i in xrange(len(self.languages_)):
      out.putVarInt32(56)
      out.putVarInt32(self.languages_[i])
    if (self.has_pageregions_):
      out.putVarInt32(66)
      out.putPrefixedString(self.pageregions_)
    if (self.has_crowdingdata_):
      out.putVarInt32(74)
      out.putVarInt32(self.crowdingdata_.ByteSize())
      self.crowdingdata_.OutputUnchecked(out)
    if (self.has_oceandata_):
      out.putVarInt32(130)
      out.putVarInt32(self.oceandata_.ByteSize())
      self.oceandata_.OutputUnchecked(out)
    for i in xrange(len(self.page_tags_)):
      out.putVarInt32(160)
      out.putVarInt32(self.page_tags_[i])
    if (self.has_compressed_url_):
      out.putVarInt32(242)
      out.putPrefixedString(self.compressed_url_)
    if (self.has_spamrank_):
      out.putVarInt32(248)
      out.putVarInt32(self.spamrank_)
    if (self.has_pagerank0_):
      out.putVarInt32(805)
      out.putFloat(self.pagerank0_)
    if (self.has_pagerank1_):
      out.putVarInt32(813)
      out.putFloat(self.pagerank1_)
    if (self.has_pagerank2_):
      out.putVarInt32(821)
      out.putFloat(self.pagerank2_)
    if (self.has_smearing_max_total_offdomain_anchors_):
      out.putVarInt32(824)
      out.putVarInt32(self.smearing_max_total_offdomain_anchors_)
    for i in xrange(len(self.event_)):
      out.putVarInt32(834)
      out.putVarInt32(self.event_[i].ByteSize())
      self.event_[i].OutputUnchecked(out)
    if (self.has_scaledspamscoreeric_):
      out.putVarInt32(840)
      out.putVarInt32(self.scaledspamscoreeric_)
    if (self.has_scaledspamscoreyoram_):
      out.putVarInt32(848)
      out.putVarInt32(self.scaledspamscoreyoram_)
    if (self.has_scaledexptindyrank_):
      out.putVarInt32(856)
      out.putVarInt32(self.scaledexptindyrank_)
    if (self.has_scaledexptindyrank2_):
      out.putVarInt32(864)
      out.putVarInt32(self.scaledexptindyrank2_)
    if (self.has_scaledexptindyrank3_):
      out.putVarInt32(872)
      out.putVarInt32(self.scaledexptindyrank3_)
    if (self.has_origin_):
      out.putVarInt32(880)
      out.putVarInt32(self.origin_)
    if (self.has_groupsdata_):
      out.putVarInt32(890)
      out.putVarInt32(self.groupsdata_.ByteSize())
      self.groupsdata_.OutputUnchecked(out)
    if (self.has_crawl_pagerank_):
      out.putVarInt32(896)
      out.putVarInt32(self.crawl_pagerank_)
    if (self.has_scaledexptspamscoreeric_):
      out.putVarInt32(904)
      out.putVarInt32(self.scaledexptspamscoreeric_)
    if (self.has_scaledexptspamscoreyoram_):
      out.putVarInt32(912)
      out.putVarInt32(self.scaledexptspamscoreyoram_)
    if (self.has_sciencedata_):
      out.putVarInt32(922)
      out.putVarInt32(self.sciencedata_.ByteSize())
      self.sciencedata_.OutputUnchecked(out)
    if (self.has_navboostdata_):
      out.putVarInt32(930)
      out.putVarInt32(self.navboostdata_.ByteSize())
      self.navboostdata_.OutputUnchecked(out)
    if (self.has_whirlpooldiscount_):
      out.putVarInt32(941)
      out.putFloat(self.whirlpooldiscount_)
    if (self.has_clickrdata_):
      out.putVarInt32(946)
      out.putVarInt32(self.clickrdata_.ByteSize())
      self.clickrdata_.OutputUnchecked(out)
    if (self.has_premiumdata_):
      out.putVarInt32(954)
      out.putVarInt32(self.premiumdata_.ByteSize())
      self.premiumdata_.OutputUnchecked(out)
    if (self.has_home_page_info_):
      out.putVarInt32(960)
      out.putVarInt32(self.home_page_info_)
    if (self.has_deprecated_matched_spam_signature_):
      out.putVarInt32(970)
      out.putPrefixedString(self.deprecated_matched_spam_signature_)
    if (self.has_carriermetadata_):
      out.putVarInt32(978)
      out.putVarInt32(self.carriermetadata_.ByteSize())
      self.carriermetadata_.OutputUnchecked(out)
    if (self.has_extra_data_):
      out.putVarInt32(986)
      out.putVarInt32(self.extra_data_.ByteSize())
      self.extra_data_.OutputUnchecked(out)
    if (self.has_scaledlinkagespamscore_):
      out.putVarInt32(992)
      out.putVarInt32(self.scaledlinkagespamscore_)
    if (self.has_keywordstuffingscore_):
      out.putVarInt32(1000)
      out.putVarInt32(self.keywordstuffingscore_)
    if (self.has_bookcitationdata_):
      out.putVarInt32(1010)
      out.putVarInt32(self.bookcitationdata_.ByteSize())
      self.bookcitationdata_.OutputUnchecked(out)
    if (self.has_mobiledata_):
      out.putVarInt32(1018)
      out.putVarInt32(self.mobiledata_.ByteSize())
      self.mobiledata_.OutputUnchecked(out)
    if (self.has_doclevelspamscore_):
      out.putVarInt32(1024)
      out.putVarInt32(self.doclevelspamscore_)
    if (self.has_toolbardata_):
      out.putVarInt32(1034)
      out.putVarInt32(self.toolbardata_.ByteSize())
      self.toolbardata_.OutputUnchecked(out)
    if (self.has_signaturedata_):
      out.putVarInt32(1042)
      out.putVarInt32(self.signaturedata_.ByteSize())
      self.signaturedata_.OutputUnchecked(out)
    if (self.has_blogdata_):
      out.putVarInt32(1050)
      out.putVarInt32(self.blogdata_.ByteSize())
      self.blogdata_.OutputUnchecked(out)
    if (self.has_num_urls_):
      out.putVarInt32(1056)
      out.putVarInt32(self.num_urls_)
    if (self.has_semantic_date_):
      out.putVarInt32(1064)
      out.putVarInt32(self.semantic_date_)
    if (self.has_semantic_date_confidence_):
      out.putVarInt32(1072)
      out.putVarInt32(self.semantic_date_confidence_)
    if (self.has_spamwordscore_):
      out.putVarInt32(1080)
      out.putVarInt32(self.spamwordscore_)
    if (self.has_quarantinewhitelist_):
      out.putVarInt32(1088)
      out.putBoolean(self.quarantinewhitelist_)
    if (self.has_url_after_redirects_fp_):
      out.putVarInt32(1097)
      out.put64(self.url_after_redirects_fp_)
    if (self.has_webmirror_ecn_fp_):
      out.putVarInt32(1105)
      out.put64(self.webmirror_ecn_fp_)
    if (self.has_semantic_date_info_):
      out.putVarInt32(1112)
      out.putVarInt32(self.semantic_date_info_)
    if (self.has_gibberishscore_):
      out.putVarInt32(1120)
      out.putVarInt32(self.gibberishscore_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_phildata().TryMerge(tmp)
        continue
      if tt == 21:
        self.set_pagerank(d.getFloat())
        continue
      if tt == 26:
        self.set_geodata(d.getPrefixedString())
        continue
      if tt == 32:
        self.set_scaledindyrank(d.getVarInt32())
        continue
      if tt == 42:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_imagedata().TryMerge(tmp)
        continue
      if tt == 50:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_kaltixdata().TryMerge(tmp)
        continue
      if tt == 56:
        self.add_languages(d.getVarInt32())
        continue
      if tt == 66:
        self.set_pageregions(d.getPrefixedString())
        continue
      if tt == 74:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_crowdingdata().TryMerge(tmp)
        continue
      if tt == 130:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_oceandata().TryMerge(tmp)
        continue
      if tt == 160:
        self.add_page_tags(d.getVarInt32())
        continue
      if tt == 242:
        self.set_compressed_url(d.getPrefixedString())
        continue
      if tt == 248:
        self.set_spamrank(d.getVarInt32())
        continue
      if tt == 805:
        self.set_pagerank0(d.getFloat())
        continue
      if tt == 813:
        self.set_pagerank1(d.getFloat())
        continue
      if tt == 821:
        self.set_pagerank2(d.getFloat())
        continue
      if tt == 824:
        self.set_smearing_max_total_offdomain_anchors(d.getVarInt32())
        continue
      if tt == 834:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_event().TryMerge(tmp)
        continue
      if tt == 840:
        self.set_scaledspamscoreeric(d.getVarInt32())
        continue
      if tt == 848:
        self.set_scaledspamscoreyoram(d.getVarInt32())
        continue
      if tt == 856:
        self.set_scaledexptindyrank(d.getVarInt32())
        continue
      if tt == 864:
        self.set_scaledexptindyrank2(d.getVarInt32())
        continue
      if tt == 872:
        self.set_scaledexptindyrank3(d.getVarInt32())
        continue
      if tt == 880:
        self.set_origin(d.getVarInt32())
        continue
      if tt == 890:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_groupsdata().TryMerge(tmp)
        continue
      if tt == 896:
        self.set_crawl_pagerank(d.getVarInt32())
        continue
      if tt == 904:
        self.set_scaledexptspamscoreeric(d.getVarInt32())
        continue
      if tt == 912:
        self.set_scaledexptspamscoreyoram(d.getVarInt32())
        continue
      if tt == 922:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_sciencedata().TryMerge(tmp)
        continue
      if tt == 930:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_navboostdata().TryMerge(tmp)
        continue
      if tt == 941:
        self.set_whirlpooldiscount(d.getFloat())
        continue
      if tt == 946:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_clickrdata().TryMerge(tmp)
        continue
      if tt == 954:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_premiumdata().TryMerge(tmp)
        continue
      if tt == 960:
        self.set_home_page_info(d.getVarInt32())
        continue
      if tt == 970:
        self.set_deprecated_matched_spam_signature(d.getPrefixedString())
        continue
      if tt == 978:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_carriermetadata().TryMerge(tmp)
        continue
      if tt == 986:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_extra_data().TryMerge(tmp)
        continue
      if tt == 992:
        self.set_scaledlinkagespamscore(d.getVarInt32())
        continue
      if tt == 1000:
        self.set_keywordstuffingscore(d.getVarInt32())
        continue
      if tt == 1010:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_bookcitationdata().TryMerge(tmp)
        continue
      if tt == 1018:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_mobiledata().TryMerge(tmp)
        continue
      if tt == 1024:
        self.set_doclevelspamscore(d.getVarInt32())
        continue
      if tt == 1034:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_toolbardata().TryMerge(tmp)
        continue
      if tt == 1042:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_signaturedata().TryMerge(tmp)
        continue
      if tt == 1050:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_blogdata().TryMerge(tmp)
        continue
      if tt == 1056:
        self.set_num_urls(d.getVarInt32())
        continue
      if tt == 1064:
        self.set_semantic_date(d.getVarInt32())
        continue
      if tt == 1072:
        self.set_semantic_date_confidence(d.getVarInt32())
        continue
      if tt == 1080:
        self.set_spamwordscore(d.getVarInt32())
        continue
      if tt == 1088:
        self.set_quarantinewhitelist(d.getBoolean())
        continue
      if tt == 1097:
        self.set_url_after_redirects_fp(d.get64())
        continue
      if tt == 1105:
        self.set_webmirror_ecn_fp(d.get64())
        continue
      if tt == 1112:
        self.set_semantic_date_info(d.getVarInt32())
        continue
      if tt == 1120:
        self.set_gibberishscore(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_phildata_:
      res+=prefix+"phildata <\n"
      res+=self.phildata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_scaledindyrank_: res+=prefix+("ScaledIndyRank: %s\n" % self.DebugFormatInt32(self.scaledindyrank_))
    if self.has_scaledexptindyrank_: res+=prefix+("ScaledExptIndyRank: %s\n" % self.DebugFormatInt32(self.scaledexptindyrank_))
    if self.has_scaledexptindyrank2_: res+=prefix+("ScaledExptIndyRank2: %s\n" % self.DebugFormatInt32(self.scaledexptindyrank2_))
    if self.has_scaledexptindyrank3_: res+=prefix+("ScaledExptIndyRank3: %s\n" % self.DebugFormatInt32(self.scaledexptindyrank3_))
    if self.has_scaledspamscoreeric_: res+=prefix+("ScaledSpamScoreEric: %s\n" % self.DebugFormatInt32(self.scaledspamscoreeric_))
    if self.has_scaledspamscoreyoram_: res+=prefix+("ScaledSpamScoreYoram: %s\n" % self.DebugFormatInt32(self.scaledspamscoreyoram_))
    if self.has_scaledexptspamscoreeric_: res+=prefix+("ScaledExptSpamScoreEric: %s\n" % self.DebugFormatInt32(self.scaledexptspamscoreeric_))
    if self.has_scaledexptspamscoreyoram_: res+=prefix+("ScaledExptSpamScoreYoram: %s\n" % self.DebugFormatInt32(self.scaledexptspamscoreyoram_))
    if self.has_scaledlinkagespamscore_: res+=prefix+("ScaledLinkAgeSpamScore: %s\n" % self.DebugFormatInt32(self.scaledlinkagespamscore_))
    if self.has_keywordstuffingscore_: res+=prefix+("KeywordStuffingScore: %s\n" % self.DebugFormatInt32(self.keywordstuffingscore_))
    if self.has_doclevelspamscore_: res+=prefix+("DocLevelSpamScore: %s\n" % self.DebugFormatInt32(self.doclevelspamscore_))
    if self.has_spamwordscore_: res+=prefix+("SpamWordScore: %s\n" % self.DebugFormatInt32(self.spamwordscore_))
    if self.has_quarantinewhitelist_: res+=prefix+("QuarantineWhitelist: %s\n" % self.DebugFormatBool(self.quarantinewhitelist_))
    if self.has_gibberishscore_: res+=prefix+("GibberishScore: %s\n" % self.DebugFormatInt32(self.gibberishscore_))
    if self.has_whirlpooldiscount_: res+=prefix+("WhirlpoolDiscount: %s\n" % self.DebugFormatFloat(self.whirlpooldiscount_))
    if self.has_geodata_: res+=prefix+("geodata: %s\n" % self.DebugFormatString(self.geodata_))
    if self.has_imagedata_:
      res+=prefix+"imagedata <\n"
      res+=self.imagedata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_kaltixdata_:
      res+=prefix+"kaltixdata <\n"
      res+=self.kaltixdata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_crowdingdata_:
      res+=prefix+"crowdingdata <\n"
      res+=self.crowdingdata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_oceandata_:
      res+=prefix+"oceandata <\n"
      res+=self.oceandata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.page_tags_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("page_tags%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    cnt=0
    for e in self.languages_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("languages%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    if self.has_compressed_url_: res+=prefix+("compressed_url: %s\n" % self.DebugFormatString(self.compressed_url_))
    if self.has_spamrank_: res+=prefix+("spamrank: %s\n" % self.DebugFormatInt32(self.spamrank_))
    if self.has_deprecated_matched_spam_signature_: res+=prefix+("DEPRECATED_matched_spam_signature: %s\n" % self.DebugFormatString(self.deprecated_matched_spam_signature_))
    if self.has_signaturedata_:
      res+=prefix+"SignatureData <\n"
      res+=self.signaturedata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_pageregions_: res+=prefix+("pageregions: %s\n" % self.DebugFormatString(self.pageregions_))
    if self.has_pagerank_: res+=prefix+("pagerank: %s\n" % self.DebugFormatFloat(self.pagerank_))
    if self.has_pagerank0_: res+=prefix+("pagerank0: %s\n" % self.DebugFormatFloat(self.pagerank0_))
    if self.has_pagerank1_: res+=prefix+("pagerank1: %s\n" % self.DebugFormatFloat(self.pagerank1_))
    if self.has_pagerank2_: res+=prefix+("pagerank2: %s\n" % self.DebugFormatFloat(self.pagerank2_))
    if self.has_smearing_max_total_offdomain_anchors_: res+=prefix+("smearing_max_total_offdomain_anchors: %s\n" % self.DebugFormatInt32(self.smearing_max_total_offdomain_anchors_))
    cnt=0
    for e in self.event_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Event%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_origin_: res+=prefix+("origin: %s\n" % self.DebugFormatInt32(self.origin_))
    if self.has_crawl_pagerank_: res+=prefix+("crawl_pagerank: %s\n" % self.DebugFormatInt32(self.crawl_pagerank_))
    if self.has_groupsdata_:
      res+=prefix+"GroupsData <\n"
      res+=self.groupsdata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_sciencedata_:
      res+=prefix+"ScienceData <\n"
      res+=self.sciencedata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_premiumdata_:
      res+=prefix+"PremiumData <\n"
      res+=self.premiumdata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_mobiledata_:
      res+=prefix+"MobileData <\n"
      res+=self.mobiledata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_carriermetadata_:
      res+=prefix+"CarrierMetadata <\n"
      res+=self.carriermetadata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_navboostdata_:
      res+=prefix+"navboostdata <\n"
      res+=self.navboostdata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_clickrdata_:
      res+=prefix+"clickrdata <\n"
      res+=self.clickrdata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_home_page_info_: res+=prefix+("home_page_info: %s\n" % self.DebugFormatInt32(self.home_page_info_))
    if self.has_num_urls_: res+=prefix+("num_urls: %s\n" % self.DebugFormatInt32(self.num_urls_))
    if self.has_bookcitationdata_:
      res+=prefix+"BookCitationData <\n"
      res+=self.bookcitationdata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_toolbardata_:
      res+=prefix+"ToolBarData <\n"
      res+=self.toolbardata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_blogdata_:
      res+=prefix+"BlogData <\n"
      res+=self.blogdata_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_semantic_date_: res+=prefix+("semantic_date: %s\n" % self.DebugFormatInt32(self.semantic_date_))
    if self.has_semantic_date_confidence_: res+=prefix+("semantic_date_confidence: %s\n" % self.DebugFormatInt32(self.semantic_date_confidence_))
    if self.has_semantic_date_info_: res+=prefix+("semantic_date_info: %s\n" % self.DebugFormatInt32(self.semantic_date_info_))
    if self.has_url_after_redirects_fp_: res+=prefix+("url_after_redirects_fp: %s\n" % self.DebugFormatFixed64(self.url_after_redirects_fp_))
    if self.has_webmirror_ecn_fp_: res+=prefix+("webmirror_ecn_fp: %s\n" % self.DebugFormatFixed64(self.webmirror_ecn_fp_))
    if self.has_extra_data_:
      res+=prefix+"extra_data <\n"
      res+=self.extra_data_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

  kphildata = 1
  kScaledIndyRank = 4
  kScaledExptIndyRank = 107
  kScaledExptIndyRank2 = 108
  kScaledExptIndyRank3 = 109
  kScaledSpamScoreEric = 105
  kScaledSpamScoreYoram = 106
  kScaledExptSpamScoreEric = 113
  kScaledExptSpamScoreYoram = 114
  kScaledLinkAgeSpamScore = 124
  kKeywordStuffingScore = 125
  kDocLevelSpamScore = 128
  kSpamWordScore = 135
  kQuarantineWhitelist = 136
  kGibberishScore = 140
  kWhirlpoolDiscount = 117
  kgeodata = 3
  kimagedata = 5
  kkaltixdata = 6
  kcrowdingdata = 9
  koceandata = 16
  kpage_tags = 20
  klanguages = 7
  kcompressed_url = 30
  kspamrank = 31
  kDEPRECATED_matched_spam_signature = 121
  kSignatureData = 130
  kpageregions = 8
  kpagerank = 2
  kpagerank0 = 100
  kpagerank1 = 101
  kpagerank2 = 102
  ksmearing_max_total_offdomain_anchors = 103
  kEvent = 104
  korigin = 110
  kcrawl_pagerank = 112
  kGroupsData = 111
  kScienceData = 115
  kPremiumData = 119
  kMobileData = 127
  kCarrierMetadata = 122
  knavboostdata = 116
  kclickrdata = 118
  khome_page_info = 120
  knum_urls = 132
  kBookCitationData = 126
  kToolBarData = 129
  kBlogData = 131
  ksemantic_date = 133
  ksemantic_date_confidence = 134
  ksemantic_date_info = 139
  kurl_after_redirects_fp = 137
  kwebmirror_ecn_fp = 138
  kextra_data = 123

  _TEXT = (
   "ErrorCode",  #   0
   "phildata",  #   1
   "pagerank",  #   2
   "geodata",  #   3
   "ScaledIndyRank",  #   4
   "imagedata",  #   5
   "kaltixdata",  #   6
   "languages",  #   7
   "pageregions",  #   8
   "crowdingdata",  #   9
   None,  #  10
   None,  #  11
   None,  #  12
   None,  #  13
   None,  #  14
   None,  #  15
   "oceandata",  #  16
   None,  #  17
   None,  #  18
   None,  #  19
   "page_tags",  #  20
   None,  #  21
   None,  #  22
   None,  #  23
   None,  #  24
   None,  #  25
   None,  #  26
   None,  #  27
   None,  #  28
   None,  #  29
   "compressed_url",  #  30
   "spamrank",  #  31
   None,  #  32
   None,  #  33
   None,  #  34
   None,  #  35
   None,  #  36
   None,  #  37
   None,  #  38
   None,  #  39
   None,  #  40
   None,  #  41
   None,  #  42
   None,  #  43
   None,  #  44
   None,  #  45
   None,  #  46
   None,  #  47
   None,  #  48
   None,  #  49
   None,  #  50
   None,  #  51
   None,  #  52
   None,  #  53
   None,  #  54
   None,  #  55
   None,  #  56
   None,  #  57
   None,  #  58
   None,  #  59
   None,  #  60
   None,  #  61
   None,  #  62
   None,  #  63
   None,  #  64
   None,  #  65
   None,  #  66
   None,  #  67
   None,  #  68
   None,  #  69
   None,  #  70
   None,  #  71
   None,  #  72
   None,  #  73
   None,  #  74
   None,  #  75
   None,  #  76
   None,  #  77
   None,  #  78
   None,  #  79
   None,  #  80
   None,  #  81
   None,  #  82
   None,  #  83
   None,  #  84
   None,  #  85
   None,  #  86
   None,  #  87
   None,  #  88
   None,  #  89
   None,  #  90
   None,  #  91
   None,  #  92
   None,  #  93
   None,  #  94
   None,  #  95
   None,  #  96
   None,  #  97
   None,  #  98
   None,  #  99
   "pagerank0",  # 100
   "pagerank1",  # 101
   "pagerank2",  # 102
   "smearing_max_total_offdomain_anchors",  # 103
   "Event",  # 104
   "ScaledSpamScoreEric",  # 105
   "ScaledSpamScoreYoram",  # 106
   "ScaledExptIndyRank",  # 107
   "ScaledExptIndyRank2",  # 108
   "ScaledExptIndyRank3",  # 109
   "origin",  # 110
   "GroupsData",  # 111
   "crawl_pagerank",  # 112
   "ScaledExptSpamScoreEric",  # 113
   "ScaledExptSpamScoreYoram",  # 114
   "ScienceData",  # 115
   "navboostdata",  # 116
   "WhirlpoolDiscount",  # 117
   "clickrdata",  # 118
   "PremiumData",  # 119
   "home_page_info",  # 120
   "DEPRECATED_matched_spam_signature",  # 121
   "CarrierMetadata",  # 122
   "extra_data",  # 123
   "ScaledLinkAgeSpamScore",  # 124
   "KeywordStuffingScore",  # 125
   "BookCitationData",  # 126
   "MobileData",  # 127
   "DocLevelSpamScore",  # 128
   "ToolBarData",  # 129
   "SignatureData",  # 130
   "BlogData",  # 131
   "num_urls",  # 132
   "semantic_date",  # 133
   "semantic_date_confidence",  # 134
   "SpamWordScore",  # 135
   "QuarantineWhitelist",  # 136
   "url_after_redirects_fp",  # 137
   "webmirror_ecn_fp",  # 138
   "semantic_date_info",  # 139
   "GibberishScore",  # 140
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.FLOAT,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.MAX_TYPE,  #  10

   ProtocolBuffer.Encoder.MAX_TYPE,  #  11

   ProtocolBuffer.Encoder.MAX_TYPE,  #  12

   ProtocolBuffer.Encoder.MAX_TYPE,  #  13

   ProtocolBuffer.Encoder.MAX_TYPE,  #  14

   ProtocolBuffer.Encoder.MAX_TYPE,  #  15

   ProtocolBuffer.Encoder.STRING,  #  16

   ProtocolBuffer.Encoder.MAX_TYPE,  #  17

   ProtocolBuffer.Encoder.MAX_TYPE,  #  18

   ProtocolBuffer.Encoder.MAX_TYPE,  #  19

   ProtocolBuffer.Encoder.NUMERIC,  #  20

   ProtocolBuffer.Encoder.MAX_TYPE,  #  21

   ProtocolBuffer.Encoder.MAX_TYPE,  #  22

   ProtocolBuffer.Encoder.MAX_TYPE,  #  23

   ProtocolBuffer.Encoder.MAX_TYPE,  #  24

   ProtocolBuffer.Encoder.MAX_TYPE,  #  25

   ProtocolBuffer.Encoder.MAX_TYPE,  #  26

   ProtocolBuffer.Encoder.MAX_TYPE,  #  27

   ProtocolBuffer.Encoder.MAX_TYPE,  #  28

   ProtocolBuffer.Encoder.MAX_TYPE,  #  29

   ProtocolBuffer.Encoder.STRING,  #  30

   ProtocolBuffer.Encoder.NUMERIC,  #  31

   ProtocolBuffer.Encoder.MAX_TYPE,  #  32

   ProtocolBuffer.Encoder.MAX_TYPE,  #  33

   ProtocolBuffer.Encoder.MAX_TYPE,  #  34

   ProtocolBuffer.Encoder.MAX_TYPE,  #  35

   ProtocolBuffer.Encoder.MAX_TYPE,  #  36

   ProtocolBuffer.Encoder.MAX_TYPE,  #  37

   ProtocolBuffer.Encoder.MAX_TYPE,  #  38

   ProtocolBuffer.Encoder.MAX_TYPE,  #  39

   ProtocolBuffer.Encoder.MAX_TYPE,  #  40

   ProtocolBuffer.Encoder.MAX_TYPE,  #  41

   ProtocolBuffer.Encoder.MAX_TYPE,  #  42

   ProtocolBuffer.Encoder.MAX_TYPE,  #  43

   ProtocolBuffer.Encoder.MAX_TYPE,  #  44

   ProtocolBuffer.Encoder.MAX_TYPE,  #  45

   ProtocolBuffer.Encoder.MAX_TYPE,  #  46

   ProtocolBuffer.Encoder.MAX_TYPE,  #  47

   ProtocolBuffer.Encoder.MAX_TYPE,  #  48

   ProtocolBuffer.Encoder.MAX_TYPE,  #  49

   ProtocolBuffer.Encoder.MAX_TYPE,  #  50

   ProtocolBuffer.Encoder.MAX_TYPE,  #  51

   ProtocolBuffer.Encoder.MAX_TYPE,  #  52

   ProtocolBuffer.Encoder.MAX_TYPE,  #  53

   ProtocolBuffer.Encoder.MAX_TYPE,  #  54

   ProtocolBuffer.Encoder.MAX_TYPE,  #  55

   ProtocolBuffer.Encoder.MAX_TYPE,  #  56

   ProtocolBuffer.Encoder.MAX_TYPE,  #  57

   ProtocolBuffer.Encoder.MAX_TYPE,  #  58

   ProtocolBuffer.Encoder.MAX_TYPE,  #  59

   ProtocolBuffer.Encoder.MAX_TYPE,  #  60

   ProtocolBuffer.Encoder.MAX_TYPE,  #  61

   ProtocolBuffer.Encoder.MAX_TYPE,  #  62

   ProtocolBuffer.Encoder.MAX_TYPE,  #  63

   ProtocolBuffer.Encoder.MAX_TYPE,  #  64

   ProtocolBuffer.Encoder.MAX_TYPE,  #  65

   ProtocolBuffer.Encoder.MAX_TYPE,  #  66

   ProtocolBuffer.Encoder.MAX_TYPE,  #  67

   ProtocolBuffer.Encoder.MAX_TYPE,  #  68

   ProtocolBuffer.Encoder.MAX_TYPE,  #  69

   ProtocolBuffer.Encoder.MAX_TYPE,  #  70

   ProtocolBuffer.Encoder.MAX_TYPE,  #  71

   ProtocolBuffer.Encoder.MAX_TYPE,  #  72

   ProtocolBuffer.Encoder.MAX_TYPE,  #  73

   ProtocolBuffer.Encoder.MAX_TYPE,  #  74

   ProtocolBuffer.Encoder.MAX_TYPE,  #  75

   ProtocolBuffer.Encoder.MAX_TYPE,  #  76

   ProtocolBuffer.Encoder.MAX_TYPE,  #  77

   ProtocolBuffer.Encoder.MAX_TYPE,  #  78

   ProtocolBuffer.Encoder.MAX_TYPE,  #  79

   ProtocolBuffer.Encoder.MAX_TYPE,  #  80

   ProtocolBuffer.Encoder.MAX_TYPE,  #  81

   ProtocolBuffer.Encoder.MAX_TYPE,  #  82

   ProtocolBuffer.Encoder.MAX_TYPE,  #  83

   ProtocolBuffer.Encoder.MAX_TYPE,  #  84

   ProtocolBuffer.Encoder.MAX_TYPE,  #  85

   ProtocolBuffer.Encoder.MAX_TYPE,  #  86

   ProtocolBuffer.Encoder.MAX_TYPE,  #  87

   ProtocolBuffer.Encoder.MAX_TYPE,  #  88

   ProtocolBuffer.Encoder.MAX_TYPE,  #  89

   ProtocolBuffer.Encoder.MAX_TYPE,  #  90

   ProtocolBuffer.Encoder.MAX_TYPE,  #  91

   ProtocolBuffer.Encoder.MAX_TYPE,  #  92

   ProtocolBuffer.Encoder.MAX_TYPE,  #  93

   ProtocolBuffer.Encoder.MAX_TYPE,  #  94

   ProtocolBuffer.Encoder.MAX_TYPE,  #  95

   ProtocolBuffer.Encoder.MAX_TYPE,  #  96

   ProtocolBuffer.Encoder.MAX_TYPE,  #  97

   ProtocolBuffer.Encoder.MAX_TYPE,  #  98

   ProtocolBuffer.Encoder.MAX_TYPE,  #  99

   ProtocolBuffer.Encoder.FLOAT,  # 100

   ProtocolBuffer.Encoder.FLOAT,  # 101

   ProtocolBuffer.Encoder.FLOAT,  # 102

   ProtocolBuffer.Encoder.NUMERIC,  # 103

   ProtocolBuffer.Encoder.STRING,  # 104

   ProtocolBuffer.Encoder.NUMERIC,  # 105

   ProtocolBuffer.Encoder.NUMERIC,  # 106

   ProtocolBuffer.Encoder.NUMERIC,  # 107

   ProtocolBuffer.Encoder.NUMERIC,  # 108

   ProtocolBuffer.Encoder.NUMERIC,  # 109

   ProtocolBuffer.Encoder.NUMERIC,  # 110

   ProtocolBuffer.Encoder.STRING,  # 111

   ProtocolBuffer.Encoder.NUMERIC,  # 112

   ProtocolBuffer.Encoder.NUMERIC,  # 113

   ProtocolBuffer.Encoder.NUMERIC,  # 114

   ProtocolBuffer.Encoder.STRING,  # 115

   ProtocolBuffer.Encoder.STRING,  # 116

   ProtocolBuffer.Encoder.FLOAT,  # 117

   ProtocolBuffer.Encoder.STRING,  # 118

   ProtocolBuffer.Encoder.STRING,  # 119

   ProtocolBuffer.Encoder.NUMERIC,  # 120

   ProtocolBuffer.Encoder.STRING,  # 121

   ProtocolBuffer.Encoder.STRING,  # 122

   ProtocolBuffer.Encoder.STRING,  # 123

   ProtocolBuffer.Encoder.NUMERIC,  # 124

   ProtocolBuffer.Encoder.NUMERIC,  # 125

   ProtocolBuffer.Encoder.STRING,  # 126

   ProtocolBuffer.Encoder.STRING,  # 127

   ProtocolBuffer.Encoder.NUMERIC,  # 128

   ProtocolBuffer.Encoder.STRING,  # 129

   ProtocolBuffer.Encoder.STRING,  # 130

   ProtocolBuffer.Encoder.STRING,  # 131

   ProtocolBuffer.Encoder.NUMERIC,  # 132

   ProtocolBuffer.Encoder.NUMERIC,  # 133

   ProtocolBuffer.Encoder.NUMERIC,  # 134

   ProtocolBuffer.Encoder.NUMERIC,  # 135

   ProtocolBuffer.Encoder.NUMERIC,  # 136

   ProtocolBuffer.Encoder.DOUBLE,  # 137

   ProtocolBuffer.Encoder.DOUBLE,  # 138

   ProtocolBuffer.Encoder.NUMERIC,  # 139

   ProtocolBuffer.Encoder.NUMERIC,  # 140

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x72,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x70,
    0x65,
    0x72,
    0x64,
    0x6f,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0a,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x08,
    0x70,
    0x68,
    0x69,
    0x6c,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0e,
    0x50,
    0x68,
    0x69,
    0x6c,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x53,
    0x63,
    0x61,
    0x6c,
    0x65,
    0x64,
    0x49,
    0x6e,
    0x64,
    0x79,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x53,
    0x63,
    0x61,
    0x6c,
    0x65,
    0x64,
    0x45,
    0x78,
    0x70,
    0x74,
    0x49,
    0x6e,
    0x64,
    0x79,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x6b,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x53,
    0x63,
    0x61,
    0x6c,
    0x65,
    0x64,
    0x45,
    0x78,
    0x70,
    0x74,
    0x49,
    0x6e,
    0x64,
    0x79,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x32,
    0x20,
    0x6c,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x53,
    0x63,
    0x61,
    0x6c,
    0x65,
    0x64,
    0x45,
    0x78,
    0x70,
    0x74,
    0x49,
    0x6e,
    0x64,
    0x79,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x33,
    0x20,
    0x6d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x53,
    0x63,
    0x61,
    0x6c,
    0x65,
    0x64,
    0x53,
    0x70,
    0x61,
    0x6d,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x45,
    0x72,
    0x69,
    0x63,
    0x20,
    0x69,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x53,
    0x63,
    0x61,
    0x6c,
    0x65,
    0x64,
    0x53,
    0x70,
    0x61,
    0x6d,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x59,
    0x6f,
    0x72,
    0x61,
    0x6d,
    0x20,
    0x6a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x53,
    0x63,
    0x61,
    0x6c,
    0x65,
    0x64,
    0x45,
    0x78,
    0x70,
    0x74,
    0x53,
    0x70,
    0x61,
    0x6d,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x45,
    0x72,
    0x69,
    0x63,
    0x20,
    0x71,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x53,
    0x63,
    0x61,
    0x6c,
    0x65,
    0x64,
    0x45,
    0x78,
    0x70,
    0x74,
    0x53,
    0x70,
    0x61,
    0x6d,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x59,
    0x6f,
    0x72,
    0x61,
    0x6d,
    0x20,
    0x72,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x53,
    0x63,
    0x61,
    0x6c,
    0x65,
    0x64,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x41,
    0x67,
    0x65,
    0x53,
    0x70,
    0x61,
    0x6d,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x7c,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x4b,
    0x65,
    0x79,
    0x77,
    0x6f,
    0x72,
    0x64,
    0x53,
    0x74,
    0x75,
    0x66,
    0x66,
    0x69,
    0x6e,
    0x67,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x7d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x44,
    0x6f,
    0x63,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x53,
    0x70,
    0x61,
    0x6d,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x80,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x53,
    0x70,
    0x61,
    0x6d,
    0x57,
    0x6f,
    0x72,
    0x64,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x87,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x51,
    0x75,
    0x61,
    0x72,
    0x61,
    0x6e,
    0x74,
    0x69,
    0x6e,
    0x65,
    0x57,
    0x68,
    0x69,
    0x74,
    0x65,
    0x6c,
    0x69,
    0x73,
    0x74,
    0x20,
    0x88,
    0x01,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x47,
    0x69,
    0x62,
    0x62,
    0x65,
    0x72,
    0x69,
    0x73,
    0x68,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x8c,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x57,
    0x68,
    0x69,
    0x72,
    0x6c,
    0x70,
    0x6f,
    0x6f,
    0x6c,
    0x44,
    0x69,
    0x73,
    0x63,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x75,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x42,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x67,
    0x65,
    0x6f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x69,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0f,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x6b,
    0x61,
    0x6c,
    0x74,
    0x69,
    0x78,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x10,
    0x4b,
    0x61,
    0x6c,
    0x74,
    0x69,
    0x78,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x63,
    0x72,
    0x6f,
    0x77,
    0x64,
    0x69,
    0x6e,
    0x67,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x12,
    0x43,
    0x72,
    0x6f,
    0x77,
    0x64,
    0x69,
    0x6e,
    0x67,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x10,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0f,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x74,
    0x61,
    0x67,
    0x73,
    0x20,
    0x14,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x6c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x63,
    0x6f,
    0x6d,
    0x70,
    0x72,
    0x65,
    0x73,
    0x73,
    0x65,
    0x64,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x1e,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x73,
    0x70,
    0x61,
    0x6d,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x1f,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x21,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x5f,
    0x6d,
    0x61,
    0x74,
    0x63,
    0x68,
    0x65,
    0x64,
    0x5f,
    0x73,
    0x70,
    0x61,
    0x6d,
    0x5f,
    0x73,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x74,
    0x75,
    0x72,
    0x65,
    0x20,
    0x79,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x74,
    0x75,
    0x72,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x82,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x29,
    0x73,
    0x70,
    0x61,
    0x6d,
    0x5f,
    0x73,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x74,
    0x75,
    0x72,
    0x65,
    0x6d,
    0x61,
    0x74,
    0x63,
    0x68,
    0x65,
    0x72,
    0x5f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2e,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x74,
    0x75,
    0x72,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x70,
    0x61,
    0x67,
    0x65,
    0x72,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x70,
    0x61,
    0x67,
    0x65,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x02,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x70,
    0x61,
    0x67,
    0x65,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x30,
    0x20,
    0x64,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x70,
    0x61,
    0x67,
    0x65,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x31,
    0x20,
    0x65,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x70,
    0x61,
    0x67,
    0x65,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x32,
    0x20,
    0x66,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x24,
    0x73,
    0x6d,
    0x65,
    0x61,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x5f,
    0x6d,
    0x61,
    0x78,
    0x5f,
    0x74,
    0x6f,
    0x74,
    0x61,
    0x6c,
    0x5f,
    0x6f,
    0x66,
    0x66,
    0x64,
    0x6f,
    0x6d,
    0x61,
    0x69,
    0x6e,
    0x5f,
    0x61,
    0x6e,
    0x63,
    0x68,
    0x6f,
    0x72,
    0x73,
    0x20,
    0x67,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x45,
    0x76,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x68,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x10,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x65,
    0x62,
    0x75,
    0x67,
    0x45,
    0x76,
    0x65,
    0x6e,
    0x74,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x6f,
    0x72,
    0x69,
    0x67,
    0x69,
    0x6e,
    0x20,
    0x6e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x5f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x70,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x47,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x73,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x6f,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x10,
    0x47,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x73,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x53,
    0x63,
    0x69,
    0x65,
    0x6e,
    0x63,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x73,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x11,
    0x53,
    0x63,
    0x69,
    0x65,
    0x6e,
    0x63,
    0x65,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x50,
    0x72,
    0x65,
    0x6d,
    0x69,
    0x75,
    0x6d,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x77,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x11,
    0x50,
    0x72,
    0x65,
    0x6d,
    0x69,
    0x75,
    0x6d,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x4d,
    0x6f,
    0x62,
    0x69,
    0x6c,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x7f,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x10,
    0x4d,
    0x6f,
    0x62,
    0x69,
    0x6c,
    0x65,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x43,
    0x61,
    0x72,
    0x72,
    0x69,
    0x65,
    0x72,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x7a,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x28,
    0x77,
    0x69,
    0x72,
    0x65,
    0x6c,
    0x65,
    0x73,
    0x73,
    0x5f,
    0x6d,
    0x6f,
    0x62,
    0x69,
    0x6c,
    0x65,
    0x5f,
    0x72,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x2e,
    0x43,
    0x61,
    0x72,
    0x72,
    0x69,
    0x65,
    0x72,
    0x4d,
    0x65,
    0x74,
    0x61,
    0x64,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x6e,
    0x61,
    0x76,
    0x62,
    0x6f,
    0x6f,
    0x73,
    0x74,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x74,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x10,
    0x4e,
    0x61,
    0x76,
    0x42,
    0x6f,
    0x6f,
    0x73,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x04,
    0x77,
    0x65,
    0x61,
    0x6b,
    0xb2,
    0x01,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x63,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x72,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x76,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x10,
    0x4e,
    0x61,
    0x76,
    0x42,
    0x6f,
    0x6f,
    0x73,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x04,
    0x77,
    0x65,
    0x61,
    0x6b,
    0xb2,
    0x01,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x68,
    0x6f,
    0x6d,
    0x65,
    0x5f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x78,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x6e,
    0x75,
    0x6d,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x73,
    0x20,
    0x84,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x31,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x31,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x42,
    0x6f,
    0x6f,
    0x6b,
    0x43,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x7e,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x16,
    0x42,
    0x6f,
    0x6f,
    0x6b,
    0x43,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x54,
    0x6f,
    0x6f,
    0x6c,
    0x42,
    0x61,
    0x72,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x81,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x11,
    0x54,
    0x6f,
    0x6f,
    0x6c,
    0x42,
    0x61,
    0x72,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x42,
    0x6c,
    0x6f,
    0x67,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x83,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0e,
    0x42,
    0x6c,
    0x6f,
    0x67,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x73,
    0x65,
    0x6d,
    0x61,
    0x6e,
    0x74,
    0x69,
    0x63,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x65,
    0x20,
    0x85,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x73,
    0x65,
    0x6d,
    0x61,
    0x6e,
    0x74,
    0x69,
    0x63,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x65,
    0x5f,
    0x63,
    0x6f,
    0x6e,
    0x66,
    0x69,
    0x64,
    0x65,
    0x6e,
    0x63,
    0x65,
    0x20,
    0x86,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x73,
    0x65,
    0x6d,
    0x61,
    0x6e,
    0x74,
    0x69,
    0x63,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x65,
    0x5f,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x8b,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x75,
    0x72,
    0x6c,
    0x5f,
    0x61,
    0x66,
    0x74,
    0x65,
    0x72,
    0x5f,
    0x72,
    0x65,
    0x64,
    0x69,
    0x72,
    0x65,
    0x63,
    0x74,
    0x73,
    0x5f,
    0x66,
    0x70,
    0x20,
    0x89,
    0x01,
    0x28,
    0x01,
    0x30,
    0x06,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x77,
    0x65,
    0x62,
    0x6d,
    0x69,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x5f,
    0x65,
    0x63,
    0x6e,
    0x5f,
    0x66,
    0x70,
    0x20,
    0x8a,
    0x01,
    0x28,
    0x01,
    0x30,
    0x06,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x65,
    0x78,
    0x74,
    0x72,
    0x61,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x7b,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0a,
    0x4d,
    0x65,
    0x73,
    0x73,
    0x61,
    0x67,
    0x65,
    0x53,
    0x65,
    0x74,
    0x14,
    0x73,
    0x7a,
    0x07,
    0x50,
    0x61,
    0x67,
    0x65,
    0x54,
    0x61,
    0x67,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x47,
    0x55,
    0x45,
    0x53,
    0x54,
    0x42,
    0x4f,
    0x4f,
    0x4b,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x05,
    0x46,
    0x4f,
    0x52,
    0x55,
    0x4d,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x4d,
    0x41,
    0x49,
    0x4c,
    0x49,
    0x4e,
    0x47,
    0x5f,
    0x4c,
    0x49,
    0x53,
    0x54,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x42,
    0x4c,
    0x4f,
    0x47,
    0x5f,
    0x43,
    0x4f,
    0x4d,
    0x4d,
    0x45,
    0x4e,
    0x54,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x04,
    0x42,
    0x4c,
    0x4f,
    0x47,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x03,
    0x50,
    0x50,
    0x43,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x50,
    0x41,
    0x49,
    0x44,
    0x5f,
    0x4c,
    0x49,
    0x4e,
    0x4b,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x52,
    0x45,
    0x46,
    0x45,
    0x52,
    0x52,
    0x45,
    0x52,
    0x5f,
    0x4c,
    0x49,
    0x4e,
    0x4b,
    0x98,
    0x01,
    0x08,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x41,
    0x46,
    0x46,
    0x49,
    0x4c,
    0x49,
    0x41,
    0x54,
    0x45,
    0x98,
    0x01,
    0x07,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x15,
    0x53,
    0x50,
    0x41,
    0x4d,
    0x5f,
    0x53,
    0x49,
    0x47,
    0x4e,
    0x41,
    0x54,
    0x55,
    0x52,
    0x45,
    0x5f,
    0x4e,
    0x4f,
    0x50,
    0x52,
    0x4f,
    0x50,
    0x98,
    0x01,
    0x09,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x46,
    0x52,
    0x49,
    0x45,
    0x4e,
    0x44,
    0x4c,
    0x49,
    0x4e,
    0x4b,
    0x5f,
    0x50,
    0x41,
    0x47,
    0x45,
    0x98,
    0x01,
    0x10,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x04,
    0x57,
    0x49,
    0x4b,
    0x49,
    0x98,
    0x01,
    0x11,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x13,
    0x53,
    0x50,
    0x41,
    0x4d,
    0x5f,
    0x53,
    0x49,
    0x47,
    0x4e,
    0x41,
    0x54,
    0x55,
    0x52,
    0x45,
    0x5f,
    0x4b,
    0x49,
    0x4c,
    0x4c,
    0x98,
    0x01,
    0x12,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4b,
    0x45,
    0x59,
    0x57,
    0x4f,
    0x52,
    0x44,
    0x5f,
    0x53,
    0x54,
    0x55,
    0x46,
    0x46,
    0x45,
    0x44,
    0x98,
    0x01,
    0x13,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x4c,
    0x49,
    0x4e,
    0x4b,
    0x45,
    0x58,
    0x43,
    0x48,
    0x41,
    0x4e,
    0x47,
    0x45,
    0x98,
    0x01,
    0x14,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x47,
    0x49,
    0x42,
    0x42,
    0x45,
    0x52,
    0x49,
    0x53,
    0x48,
    0x98,
    0x01,
    0x15,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x48,
    0x49,
    0x47,
    0x48,
    0x45,
    0x53,
    0x54,
    0x5f,
    0x56,
    0x41,
    0x4c,
    0x49,
    0x44,
    0x5f,
    0x54,
    0x41,
    0x47,
    0x98,
    0x01,
    0x16,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x21,
    0x54,
    0x4d,
    0x50,
    0x5f,
    0x42,
    0x4c,
    0x4f,
    0x47,
    0x5f,
    0x43,
    0x4f,
    0x4d,
    0x4d,
    0x45,
    0x4e,
    0x54,
    0x5f,
    0x4c,
    0x49,
    0x4e,
    0x4b,
    0x5f,
    0x46,
    0x52,
    0x4f,
    0x4d,
    0x5f,
    0x41,
    0x4c,
    0x45,
    0x58,
    0x49,
    0x53,
    0x98,
    0x01,
    0xe9,
    0x07,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x06,
    0x4f,
    0x72,
    0x69,
    0x67,
    0x69,
    0x6e,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x55,
    0x4e,
    0x46,
    0x4f,
    0x52,
    0x57,
    0x41,
    0x52,
    0x44,
    0x45,
    0x44,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x46,
    0x4f,
    0x52,
    0x57,
    0x41,
    0x52,
    0x44,
    0x45,
    0x44,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x53,
    0x49,
    0x42,
    0x4c,
    0x49,
    0x4e,
    0x47,
    0x5f,
    0x53,
    0x45,
    0x47,
    0x4d,
    0x45,
    0x4e,
    0x54,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x4f,
    0x52,
    0x49,
    0x47,
    0x49,
    0x4e,
    0x41,
    0x4c,
    0x5f,
    0x43,
    0x41,
    0x4e,
    0x4f,
    0x4e,
    0x49,
    0x43,
    0x41,
    0x4c,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x0c,
    0x48,
    0x6f,
    0x6d,
    0x65,
    0x50,
    0x61,
    0x67,
    0x65,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x4e,
    0x4f,
    0x54,
    0x5f,
    0x48,
    0x4f,
    0x4d,
    0x45,
    0x50,
    0x41,
    0x47,
    0x45,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x4e,
    0x4f,
    0x54,
    0x5f,
    0x54,
    0x52,
    0x55,
    0x53,
    0x54,
    0x45,
    0x44,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x50,
    0x41,
    0x52,
    0x54,
    0x49,
    0x41,
    0x4c,
    0x4c,
    0x59,
    0x5f,
    0x54,
    0x52,
    0x55,
    0x53,
    0x54,
    0x45,
    0x44,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x46,
    0x55,
    0x4c,
    0x4c,
    0x59,
    0x5f,
    0x54,
    0x52,
    0x55,
    0x53,
    0x54,
    0x45,
    0x44,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['PhilPerDocData','ImagePerDocData','KaltixPerDocData','CrowdingPerDocData','CrowdingPerDocData_NewsCluster','OceanPerDocData','GroupsPerDocData','SciencePerDocData','SciencePerDocData_Signal','SciencePerDocData_Author','PremiumPerDocData','BookCitationPerDocData','MobilePerDocData','ToolBarPerDocData','PerDocDebugEvent','BlogPerDocData','PerDocData']
