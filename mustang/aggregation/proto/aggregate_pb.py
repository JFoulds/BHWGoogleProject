# This file automatically generated by protocol-compiler from mustang/aggregation/proto/aggregate.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

class AggregationRequest_TriggerInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.arguments_ = ""
    self.has_name_ = 0
    self.has_arguments_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def arguments(self): return self.arguments_

  def set_arguments(self, x):
    self.has_arguments_ = 1
    self.arguments_ = x

  def clear_arguments(self):
    self.has_arguments_ = 0
    self.arguments_ = ""

  def has_arguments(self): return self.has_arguments_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_arguments()): self.set_arguments(x.arguments())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'AggregationRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'AggregationRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'AggregationRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'AggregationRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'AggregationRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_arguments_ != x.has_arguments_: return 0
    if self.has_arguments_ and self.arguments_ != x.arguments_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    if (self.has_arguments_): n += 1 + self.lengthString(len(self.arguments_))
    return n + 1

  def Clear(self):
    self.clear_name()
    self.clear_arguments()

  def OutputUnchecked(self, out):
    out.putVarInt32(18)
    out.putPrefixedString(self.name_)
    if (self.has_arguments_):
      out.putVarInt32(26)
      out.putPrefixedString(self.arguments_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 26:
        self.set_arguments(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_arguments_: res+=prefix+("arguments: %s\n" % self.DebugFormatString(self.arguments_))
    return res

class AggregationRequest(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 1638208 

  _TypeId_NAMES = {
    1638208: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.triggerinfo_ = []
    if contents is not None: self.MergeFromString(contents)

  def triggerinfo_size(self): return len(self.triggerinfo_)
  def triggerinfo_list(self): return self.triggerinfo_

  def triggerinfo(self, i):
    return self.triggerinfo_[i]

  def mutable_triggerinfo(self, i):
    return self.triggerinfo_[i]

  def add_triggerinfo(self):
    x = AggregationRequest_TriggerInfo()
    self.triggerinfo_.append(x)
    return x

  def clear_triggerinfo(self):
    self.triggerinfo_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.triggerinfo_size()): self.add_triggerinfo().CopyFrom(x.triggerinfo(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'AggregationRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'AggregationRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'AggregationRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'AggregationRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'AggregationRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.triggerinfo_) != len(x.triggerinfo_): return 0
    for e1, e2 in zip(self.triggerinfo_, x.triggerinfo_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.triggerinfo_)):
      if (not self.triggerinfo_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.triggerinfo_)
    for i in xrange(len(self.triggerinfo_)): n += self.triggerinfo_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_triggerinfo()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.triggerinfo_)):
      out.putVarInt32(11)
      self.triggerinfo_[i].OutputUnchecked(out)
      out.putVarInt32(12)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_triggerinfo().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.triggerinfo_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("TriggerInfo%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kTriggerInfoGroup = 1
  kTriggerInfoname = 2
  kTriggerInfoarguments = 3

  _TEXT = (
   "ErrorCode",  #   0
   "TriggerInfo",  #   1
   "name",  #   2
   "arguments",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x29,
    0x6d,
    0x75,
    0x73,
    0x74,
    0x61,
    0x6e,
    0x67,
    0x2f,
    0x61,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x61,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x12,
    0x41,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x0b,
    0x54,
    0x72,
    0x69,
    0x67,
    0x67,
    0x65,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x54,
    0x72,
    0x69,
    0x67,
    0x67,
    0x65,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x54,
    0x72,
    0x69,
    0x67,
    0x67,
    0x65,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x61,
    0x72,
    0x67,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xc0,
    0xfe,
    0x63,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class AggregationFeatureInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.value_ = 0.0
    self.oper_ = 0
    self.id_ = 0
    self.has_name_ = 0
    self.has_value_ = 0
    self.has_oper_ = 0
    self.has_id_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = 0.0

  def has_value(self): return self.has_value_

  def oper(self): return self.oper_

  def set_oper(self, x):
    self.has_oper_ = 1
    self.oper_ = x

  def clear_oper(self):
    self.has_oper_ = 0
    self.oper_ = 0

  def has_oper(self): return self.has_oper_

  def id(self): return self.id_

  def set_id(self, x):
    self.has_id_ = 1
    self.id_ = x

  def clear_id(self):
    self.has_id_ = 0
    self.id_ = 0

  def has_id(self): return self.has_id_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_value()): self.set_value(x.value())
    if (x.has_oper()): self.set_oper(x.oper())
    if (x.has_id()): self.set_id(x.id())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'AggregationFeatureInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'AggregationFeatureInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'AggregationFeatureInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'AggregationFeatureInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'AggregationFeatureInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    if self.has_oper_ != x.has_oper_: return 0
    if self.has_oper_ and self.oper_ != x.oper_: return 0
    if self.has_id_ != x.has_id_: return 0
    if self.has_id_ and self.id_ != x.id_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_name_): n += 1 + self.lengthString(len(self.name_))
    if (self.has_value_): n += 5
    if (self.has_oper_): n += 1 + self.lengthVarInt64(self.oper_)
    if (self.has_id_): n += 1 + self.lengthVarInt64(self.id_)
    return n + 0

  def Clear(self):
    self.clear_name()
    self.clear_value()
    self.clear_oper()
    self.clear_id()

  def OutputUnchecked(self, out):
    if (self.has_name_):
      out.putVarInt32(10)
      out.putPrefixedString(self.name_)
    if (self.has_value_):
      out.putVarInt32(21)
      out.putFloat(self.value_)
    if (self.has_oper_):
      out.putVarInt32(24)
      out.putVarInt32(self.oper_)
    if (self.has_id_):
      out.putVarInt32(40)
      out.putVarInt32(self.id_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 21:
        self.set_value(d.getFloat())
        continue
      if tt == 24:
        self.set_oper(d.getVarInt32())
        continue
      if tt == 40:
        self.set_id(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_value_: res+=prefix+("value: %s\n" % self.DebugFormatFloat(self.value_))
    if self.has_oper_: res+=prefix+("oper: %s\n" % self.DebugFormatInt32(self.oper_))
    if self.has_id_: res+=prefix+("id: %s\n" % self.DebugFormatInt32(self.id_))
    return res

  kname = 1
  kvalue = 2
  koper = 3
  kid = 5

  _TEXT = (
   "ErrorCode",  #   0
   "name",  #   1
   "value",  #   2
   "oper",  #   3
   None,  #   4
   "id",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.FLOAT,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.MAX_TYPE,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x29,
    0x6d,
    0x75,
    0x73,
    0x74,
    0x61,
    0x6e,
    0x67,
    0x2f,
    0x61,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x61,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x16,
    0x41,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x46,
    0x65,
    0x61,
    0x74,
    0x75,
    0x72,
    0x65,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x13,
    0x1a,
    0x04,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x02,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x6f,
    0x70,
    0x65,
    0x72,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x02,
    0x69,
    0x64,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class AggregationOperatorInfo_OperatorInstance(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.id_ = 0
    self.docinfo_multiplier_ = 1.0
    self.docinfo_adder_ = 0.0
    self.has_id_ = 0
    self.has_docinfo_multiplier_ = 0
    self.has_docinfo_adder_ = 0
    if contents is not None: self.MergeFromString(contents)

  def id(self): return self.id_

  def set_id(self, x):
    self.has_id_ = 1
    self.id_ = x

  def clear_id(self):
    self.has_id_ = 0
    self.id_ = 0

  def has_id(self): return self.has_id_

  def docinfo_multiplier(self): return self.docinfo_multiplier_

  def set_docinfo_multiplier(self, x):
    self.has_docinfo_multiplier_ = 1
    self.docinfo_multiplier_ = x

  def clear_docinfo_multiplier(self):
    self.has_docinfo_multiplier_ = 0
    self.docinfo_multiplier_ = 1.0

  def has_docinfo_multiplier(self): return self.has_docinfo_multiplier_

  def docinfo_adder(self): return self.docinfo_adder_

  def set_docinfo_adder(self, x):
    self.has_docinfo_adder_ = 1
    self.docinfo_adder_ = x

  def clear_docinfo_adder(self):
    self.has_docinfo_adder_ = 0
    self.docinfo_adder_ = 0.0

  def has_docinfo_adder(self): return self.has_docinfo_adder_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_id()): self.set_id(x.id())
    if (x.has_docinfo_multiplier()): self.set_docinfo_multiplier(x.docinfo_multiplier())
    if (x.has_docinfo_adder()): self.set_docinfo_adder(x.docinfo_adder())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'AggregationOperatorInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'AggregationOperatorInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'AggregationOperatorInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'AggregationOperatorInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'AggregationOperatorInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_id_ != x.has_id_: return 0
    if self.has_id_ and self.id_ != x.id_: return 0
    if self.has_docinfo_multiplier_ != x.has_docinfo_multiplier_: return 0
    if self.has_docinfo_multiplier_ and self.docinfo_multiplier_ != x.docinfo_multiplier_: return 0
    if self.has_docinfo_adder_ != x.has_docinfo_adder_: return 0
    if self.has_docinfo_adder_ and self.docinfo_adder_ != x.docinfo_adder_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_id_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: id not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.id_)
    if (self.has_docinfo_multiplier_): n += 5
    if (self.has_docinfo_adder_): n += 5
    return n + 1

  def Clear(self):
    self.clear_id()
    self.clear_docinfo_multiplier()
    self.clear_docinfo_adder()

  def OutputUnchecked(self, out):
    out.putVarInt32(24)
    out.putVarInt32(self.id_)
    if (self.has_docinfo_multiplier_):
      out.putVarInt32(37)
      out.putFloat(self.docinfo_multiplier_)
    if (self.has_docinfo_adder_):
      out.putVarInt32(45)
      out.putFloat(self.docinfo_adder_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 24:
        self.set_id(d.getVarInt32())
        continue
      if tt == 37:
        self.set_docinfo_multiplier(d.getFloat())
        continue
      if tt == 45:
        self.set_docinfo_adder(d.getFloat())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_id_: res+=prefix+("id: %s\n" % self.DebugFormatInt32(self.id_))
    if self.has_docinfo_multiplier_: res+=prefix+("docinfo_multiplier: %s\n" % self.DebugFormatFloat(self.docinfo_multiplier_))
    if self.has_docinfo_adder_: res+=prefix+("docinfo_adder: %s\n" % self.DebugFormatFloat(self.docinfo_adder_))
    return res

class AggregationOperatorInfo(ProtocolBuffer.ProtocolMessage):

  SUM          =    0 
  MAX          =    1 
  MIN          =    2 

  _MergeOperator_NAMES = {
    0: "SUM",
    1: "MAX",
    2: "MIN",
  }

  def MergeOperator_Name(cls, x): return cls._MergeOperator_NAMES.get(x, "")
  MergeOperator_Name = classmethod(MergeOperator_Name)

  def __init__(self, contents=None):
    self.name_ = ""
    self.operatorinstance_ = []
    self.needed_for_snippets_ = 0
    self.highlight_in_snippets_ = 0
    self.merge_operator_ = 0
    self.has_name_ = 0
    self.has_needed_for_snippets_ = 0
    self.has_highlight_in_snippets_ = 0
    self.has_merge_operator_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def operatorinstance_size(self): return len(self.operatorinstance_)
  def operatorinstance_list(self): return self.operatorinstance_

  def operatorinstance(self, i):
    return self.operatorinstance_[i]

  def mutable_operatorinstance(self, i):
    return self.operatorinstance_[i]

  def add_operatorinstance(self):
    x = AggregationOperatorInfo_OperatorInstance()
    self.operatorinstance_.append(x)
    return x

  def clear_operatorinstance(self):
    self.operatorinstance_ = []
  def needed_for_snippets(self): return self.needed_for_snippets_

  def set_needed_for_snippets(self, x):
    self.has_needed_for_snippets_ = 1
    self.needed_for_snippets_ = x

  def clear_needed_for_snippets(self):
    self.has_needed_for_snippets_ = 0
    self.needed_for_snippets_ = 0

  def has_needed_for_snippets(self): return self.has_needed_for_snippets_

  def highlight_in_snippets(self): return self.highlight_in_snippets_

  def set_highlight_in_snippets(self, x):
    self.has_highlight_in_snippets_ = 1
    self.highlight_in_snippets_ = x

  def clear_highlight_in_snippets(self):
    self.has_highlight_in_snippets_ = 0
    self.highlight_in_snippets_ = 0

  def has_highlight_in_snippets(self): return self.has_highlight_in_snippets_

  def merge_operator(self): return self.merge_operator_

  def set_merge_operator(self, x):
    self.has_merge_operator_ = 1
    self.merge_operator_ = x

  def clear_merge_operator(self):
    self.has_merge_operator_ = 0
    self.merge_operator_ = 0

  def has_merge_operator(self): return self.has_merge_operator_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    for i in xrange(x.operatorinstance_size()): self.add_operatorinstance().CopyFrom(x.operatorinstance(i))
    if (x.has_needed_for_snippets()): self.set_needed_for_snippets(x.needed_for_snippets())
    if (x.has_highlight_in_snippets()): self.set_highlight_in_snippets(x.highlight_in_snippets())
    if (x.has_merge_operator()): self.set_merge_operator(x.merge_operator())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'AggregationOperatorInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'AggregationOperatorInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'AggregationOperatorInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'AggregationOperatorInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'AggregationOperatorInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if len(self.operatorinstance_) != len(x.operatorinstance_): return 0
    for e1, e2 in zip(self.operatorinstance_, x.operatorinstance_):
      if e1 != e2: return 0
    if self.has_needed_for_snippets_ != x.has_needed_for_snippets_: return 0
    if self.has_needed_for_snippets_ and self.needed_for_snippets_ != x.needed_for_snippets_: return 0
    if self.has_highlight_in_snippets_ != x.has_highlight_in_snippets_: return 0
    if self.has_highlight_in_snippets_ and self.highlight_in_snippets_ != x.highlight_in_snippets_: return 0
    if self.has_merge_operator_ != x.has_merge_operator_: return 0
    if self.has_merge_operator_ and self.merge_operator_ != x.merge_operator_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    for i in xrange(len(self.operatorinstance_)):
      if (not self.operatorinstance_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    n += 2 * len(self.operatorinstance_)
    for i in xrange(len(self.operatorinstance_)): n += self.operatorinstance_[i].ByteSize()
    if (self.has_needed_for_snippets_): n += 2
    if (self.has_highlight_in_snippets_): n += 2
    if (self.has_merge_operator_): n += 1 + self.lengthVarInt64(self.merge_operator_)
    return n + 1

  def Clear(self):
    self.clear_name()
    self.clear_operatorinstance()
    self.clear_needed_for_snippets()
    self.clear_highlight_in_snippets()
    self.clear_merge_operator()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.name_)
    for i in xrange(len(self.operatorinstance_)):
      out.putVarInt32(19)
      self.operatorinstance_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    if (self.has_needed_for_snippets_):
      out.putVarInt32(48)
      out.putBoolean(self.needed_for_snippets_)
    if (self.has_highlight_in_snippets_):
      out.putVarInt32(56)
      out.putBoolean(self.highlight_in_snippets_)
    if (self.has_merge_operator_):
      out.putVarInt32(64)
      out.putVarInt32(self.merge_operator_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 19:
        self.add_operatorinstance().TryMerge(d)
        continue
      if tt == 48:
        self.set_needed_for_snippets(d.getBoolean())
        continue
      if tt == 56:
        self.set_highlight_in_snippets(d.getBoolean())
        continue
      if tt == 64:
        self.set_merge_operator(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    cnt=0
    for e in self.operatorinstance_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("OperatorInstance%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_needed_for_snippets_: res+=prefix+("needed_for_snippets: %s\n" % self.DebugFormatBool(self.needed_for_snippets_))
    if self.has_highlight_in_snippets_: res+=prefix+("highlight_in_snippets: %s\n" % self.DebugFormatBool(self.highlight_in_snippets_))
    if self.has_merge_operator_: res+=prefix+("merge_operator: %s\n" % self.DebugFormatInt32(self.merge_operator_))
    return res

  kname = 1
  kOperatorInstanceGroup = 2
  kOperatorInstanceid = 3
  kOperatorInstancedocinfo_multiplier = 4
  kOperatorInstancedocinfo_adder = 5
  kneeded_for_snippets = 6
  khighlight_in_snippets = 7
  kmerge_operator = 8

  _TEXT = (
   "ErrorCode",  #   0
   "name",  #   1
   "OperatorInstance",  #   2
   "id",  #   3
   "docinfo_multiplier",  #   4
   "docinfo_adder",  #   5
   "needed_for_snippets",  #   6
   "highlight_in_snippets",  #   7
   "merge_operator",  #   8
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.FLOAT,  #   4

   ProtocolBuffer.Encoder.FLOAT,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x29,
    0x6d,
    0x75,
    0x73,
    0x74,
    0x61,
    0x6e,
    0x67,
    0x2f,
    0x61,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x61,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x17,
    0x41,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x6f,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x13,
    0x1a,
    0x04,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x4f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x6f,
    0x72,
    0x49,
    0x6e,
    0x73,
    0x74,
    0x61,
    0x6e,
    0x63,
    0x65,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x4f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x6f,
    0x72,
    0x49,
    0x6e,
    0x73,
    0x74,
    0x61,
    0x6e,
    0x63,
    0x65,
    0x2e,
    0x69,
    0x64,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x23,
    0x4f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x6f,
    0x72,
    0x49,
    0x6e,
    0x73,
    0x74,
    0x61,
    0x6e,
    0x63,
    0x65,
    0x2e,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x5f,
    0x6d,
    0x75,
    0x6c,
    0x74,
    0x69,
    0x70,
    0x6c,
    0x69,
    0x65,
    0x72,
    0x20,
    0x04,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x42,
    0x03,
    0x31,
    0x2e,
    0x30,
    0x60,
    0x01,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x4f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x6f,
    0x72,
    0x49,
    0x6e,
    0x73,
    0x74,
    0x61,
    0x6e,
    0x63,
    0x65,
    0x2e,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x5f,
    0x61,
    0x64,
    0x64,
    0x65,
    0x72,
    0x20,
    0x05,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0x60,
    0x01,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x6e,
    0x65,
    0x65,
    0x64,
    0x65,
    0x64,
    0x5f,
    0x66,
    0x6f,
    0x72,
    0x5f,
    0x73,
    0x6e,
    0x69,
    0x70,
    0x70,
    0x65,
    0x74,
    0x73,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x68,
    0x69,
    0x67,
    0x68,
    0x6c,
    0x69,
    0x67,
    0x68,
    0x74,
    0x5f,
    0x69,
    0x6e,
    0x5f,
    0x73,
    0x6e,
    0x69,
    0x70,
    0x70,
    0x65,
    0x74,
    0x73,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x6d,
    0x65,
    0x72,
    0x67,
    0x65,
    0x5f,
    0x6f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x6f,
    0x72,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0x68,
    0x00,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x53,
    0x55,
    0x4d,
    0xa4,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x0d,
    0x4d,
    0x65,
    0x72,
    0x67,
    0x65,
    0x4f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x6f,
    0x72,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x03,
    0x53,
    0x55,
    0x4d,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x03,
    0x4d,
    0x41,
    0x58,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x03,
    0x4d,
    0x49,
    0x4e,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class IndexResultsAggregation(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.aggregationfeatureinfo_ = []
    self.aggregationoperatorinfo_ = []
    if contents is not None: self.MergeFromString(contents)

  def aggregationfeatureinfo_size(self): return len(self.aggregationfeatureinfo_)
  def aggregationfeatureinfo_list(self): return self.aggregationfeatureinfo_

  def aggregationfeatureinfo(self, i):
    return self.aggregationfeatureinfo_[i]

  def mutable_aggregationfeatureinfo(self, i):
    return self.aggregationfeatureinfo_[i]

  def add_aggregationfeatureinfo(self):
    x = AggregationFeatureInfo()
    self.aggregationfeatureinfo_.append(x)
    return x

  def clear_aggregationfeatureinfo(self):
    self.aggregationfeatureinfo_ = []
  def aggregationoperatorinfo_size(self): return len(self.aggregationoperatorinfo_)
  def aggregationoperatorinfo_list(self): return self.aggregationoperatorinfo_

  def aggregationoperatorinfo(self, i):
    return self.aggregationoperatorinfo_[i]

  def mutable_aggregationoperatorinfo(self, i):
    return self.aggregationoperatorinfo_[i]

  def add_aggregationoperatorinfo(self):
    x = AggregationOperatorInfo()
    self.aggregationoperatorinfo_.append(x)
    return x

  def clear_aggregationoperatorinfo(self):
    self.aggregationoperatorinfo_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.aggregationfeatureinfo_size()): self.add_aggregationfeatureinfo().CopyFrom(x.aggregationfeatureinfo(i))
    for i in xrange(x.aggregationoperatorinfo_size()): self.add_aggregationoperatorinfo().CopyFrom(x.aggregationoperatorinfo(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'IndexResultsAggregation', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'IndexResultsAggregation')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'IndexResultsAggregation', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'IndexResultsAggregation', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'IndexResultsAggregation', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.aggregationfeatureinfo_) != len(x.aggregationfeatureinfo_): return 0
    for e1, e2 in zip(self.aggregationfeatureinfo_, x.aggregationfeatureinfo_):
      if e1 != e2: return 0
    if len(self.aggregationoperatorinfo_) != len(x.aggregationoperatorinfo_): return 0
    for e1, e2 in zip(self.aggregationoperatorinfo_, x.aggregationoperatorinfo_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.aggregationfeatureinfo_)):
      if (not self.aggregationfeatureinfo_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.aggregationoperatorinfo_)):
      if (not self.aggregationoperatorinfo_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.aggregationfeatureinfo_)
    for i in xrange(len(self.aggregationfeatureinfo_)): n += self.lengthString(self.aggregationfeatureinfo_[i].ByteSize())
    n += 1 * len(self.aggregationoperatorinfo_)
    for i in xrange(len(self.aggregationoperatorinfo_)): n += self.lengthString(self.aggregationoperatorinfo_[i].ByteSize())
    return n + 0

  def Clear(self):
    self.clear_aggregationfeatureinfo()
    self.clear_aggregationoperatorinfo()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.aggregationfeatureinfo_)):
      out.putVarInt32(10)
      out.putVarInt32(self.aggregationfeatureinfo_[i].ByteSize())
      self.aggregationfeatureinfo_[i].OutputUnchecked(out)
    for i in xrange(len(self.aggregationoperatorinfo_)):
      out.putVarInt32(18)
      out.putVarInt32(self.aggregationoperatorinfo_[i].ByteSize())
      self.aggregationoperatorinfo_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_aggregationfeatureinfo().TryMerge(tmp)
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_aggregationoperatorinfo().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.aggregationfeatureinfo_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("AggregationFeatureInfo%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.aggregationoperatorinfo_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("AggregationOperatorInfo%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

  kAggregationFeatureInfo = 1
  kAggregationOperatorInfo = 2

  _TEXT = (
   "ErrorCode",  #   0
   "AggregationFeatureInfo",  #   1
   "AggregationOperatorInfo",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x29,
    0x6d,
    0x75,
    0x73,
    0x74,
    0x61,
    0x6e,
    0x67,
    0x2f,
    0x61,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x61,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x17,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x52,
    0x65,
    0x73,
    0x75,
    0x6c,
    0x74,
    0x73,
    0x41,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x13,
    0x1a,
    0x16,
    0x41,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x46,
    0x65,
    0x61,
    0x74,
    0x75,
    0x72,
    0x65,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x16,
    0x41,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x46,
    0x65,
    0x61,
    0x74,
    0x75,
    0x72,
    0x65,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x41,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x6f,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x17,
    0x41,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x6f,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class AggregationResultInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.additive_score_base_ = 0.0
    self.multiplicative_score_base_ = 1.0
    self.feature_info_ = []
    self.operator_info_ = []
    self.has_additive_score_base_ = 0
    self.has_multiplicative_score_base_ = 0
    if contents is not None: self.MergeFromString(contents)

  def additive_score_base(self): return self.additive_score_base_

  def set_additive_score_base(self, x):
    self.has_additive_score_base_ = 1
    self.additive_score_base_ = x

  def clear_additive_score_base(self):
    self.has_additive_score_base_ = 0
    self.additive_score_base_ = 0.0

  def has_additive_score_base(self): return self.has_additive_score_base_

  def multiplicative_score_base(self): return self.multiplicative_score_base_

  def set_multiplicative_score_base(self, x):
    self.has_multiplicative_score_base_ = 1
    self.multiplicative_score_base_ = x

  def clear_multiplicative_score_base(self):
    self.has_multiplicative_score_base_ = 0
    self.multiplicative_score_base_ = 1.0

  def has_multiplicative_score_base(self): return self.has_multiplicative_score_base_

  def feature_info_size(self): return len(self.feature_info_)
  def feature_info_list(self): return self.feature_info_

  def feature_info(self, i):
    return self.feature_info_[i]

  def mutable_feature_info(self, i):
    return self.feature_info_[i]

  def add_feature_info(self):
    x = AggregationFeatureInfo()
    self.feature_info_.append(x)
    return x

  def clear_feature_info(self):
    self.feature_info_ = []
  def operator_info_size(self): return len(self.operator_info_)
  def operator_info_list(self): return self.operator_info_

  def operator_info(self, i):
    return self.operator_info_[i]

  def mutable_operator_info(self, i):
    return self.operator_info_[i]

  def add_operator_info(self):
    x = AggregationOperatorInfo()
    self.operator_info_.append(x)
    return x

  def clear_operator_info(self):
    self.operator_info_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_additive_score_base()): self.set_additive_score_base(x.additive_score_base())
    if (x.has_multiplicative_score_base()): self.set_multiplicative_score_base(x.multiplicative_score_base())
    for i in xrange(x.feature_info_size()): self.add_feature_info().CopyFrom(x.feature_info(i))
    for i in xrange(x.operator_info_size()): self.add_operator_info().CopyFrom(x.operator_info(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'AggregationResultInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'AggregationResultInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'AggregationResultInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'AggregationResultInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'AggregationResultInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_additive_score_base_ != x.has_additive_score_base_: return 0
    if self.has_additive_score_base_ and self.additive_score_base_ != x.additive_score_base_: return 0
    if self.has_multiplicative_score_base_ != x.has_multiplicative_score_base_: return 0
    if self.has_multiplicative_score_base_ and self.multiplicative_score_base_ != x.multiplicative_score_base_: return 0
    if len(self.feature_info_) != len(x.feature_info_): return 0
    for e1, e2 in zip(self.feature_info_, x.feature_info_):
      if e1 != e2: return 0
    if len(self.operator_info_) != len(x.operator_info_): return 0
    for e1, e2 in zip(self.operator_info_, x.operator_info_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.feature_info_)):
      if (not self.feature_info_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.operator_info_)):
      if (not self.operator_info_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_additive_score_base_): n += 5
    if (self.has_multiplicative_score_base_): n += 5
    n += 1 * len(self.feature_info_)
    for i in xrange(len(self.feature_info_)): n += self.lengthString(self.feature_info_[i].ByteSize())
    n += 1 * len(self.operator_info_)
    for i in xrange(len(self.operator_info_)): n += self.lengthString(self.operator_info_[i].ByteSize())
    return n + 0

  def Clear(self):
    self.clear_additive_score_base()
    self.clear_multiplicative_score_base()
    self.clear_feature_info()
    self.clear_operator_info()

  def OutputUnchecked(self, out):
    if (self.has_additive_score_base_):
      out.putVarInt32(21)
      out.putFloat(self.additive_score_base_)
    if (self.has_multiplicative_score_base_):
      out.putVarInt32(29)
      out.putFloat(self.multiplicative_score_base_)
    for i in xrange(len(self.feature_info_)):
      out.putVarInt32(34)
      out.putVarInt32(self.feature_info_[i].ByteSize())
      self.feature_info_[i].OutputUnchecked(out)
    for i in xrange(len(self.operator_info_)):
      out.putVarInt32(42)
      out.putVarInt32(self.operator_info_[i].ByteSize())
      self.operator_info_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 21:
        self.set_additive_score_base(d.getFloat())
        continue
      if tt == 29:
        self.set_multiplicative_score_base(d.getFloat())
        continue
      if tt == 34:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_feature_info().TryMerge(tmp)
        continue
      if tt == 42:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_operator_info().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_additive_score_base_: res+=prefix+("additive_score_base: %s\n" % self.DebugFormatFloat(self.additive_score_base_))
    if self.has_multiplicative_score_base_: res+=prefix+("multiplicative_score_base: %s\n" % self.DebugFormatFloat(self.multiplicative_score_base_))
    cnt=0
    for e in self.feature_info_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("feature_info%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.operator_info_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("operator_info%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

  kadditive_score_base = 2
  kmultiplicative_score_base = 3
  kfeature_info = 4
  koperator_info = 5

  _TEXT = (
   "ErrorCode",  #   0
   None,  #   1
   "additive_score_base",  #   2
   "multiplicative_score_base",  #   3
   "feature_info",  #   4
   "operator_info",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.MAX_TYPE,  #   1

   ProtocolBuffer.Encoder.FLOAT,  #   2

   ProtocolBuffer.Encoder.FLOAT,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x29,
    0x6d,
    0x75,
    0x73,
    0x74,
    0x61,
    0x6e,
    0x67,
    0x2f,
    0x61,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x61,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x15,
    0x41,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x75,
    0x6c,
    0x74,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x13,
    0x1a,
    0x13,
    0x61,
    0x64,
    0x64,
    0x69,
    0x74,
    0x69,
    0x76,
    0x65,
    0x5f,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x5f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x20,
    0x02,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x6d,
    0x75,
    0x6c,
    0x74,
    0x69,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x76,
    0x65,
    0x5f,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x5f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x20,
    0x03,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x42,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x66,
    0x65,
    0x61,
    0x74,
    0x75,
    0x72,
    0x65,
    0x5f,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x16,
    0x41,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x46,
    0x65,
    0x61,
    0x74,
    0x75,
    0x72,
    0x65,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x6f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x6f,
    0x72,
    0x5f,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x17,
    0x41,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4f,
    0x70,
    0x65,
    0x72,
    0x61,
    0x74,
    0x6f,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['AggregationRequest','AggregationRequest_TriggerInfo','AggregationFeatureInfo','AggregationOperatorInfo','AggregationOperatorInfo_OperatorInstance','IndexResultsAggregation','AggregationResultInfo']
