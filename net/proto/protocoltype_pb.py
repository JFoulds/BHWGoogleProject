# This file automatically generated by protocol-compiler from net/proto/protocoltype.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

class ProtocolDescriptor_EnumTypeTag(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.value_ = 0
    self.has_name_ = 0
    self.has_value_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = 0

  def has_value(self): return self.has_value_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_value()): self.set_value(x.value())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ProtocolDescriptor', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ProtocolDescriptor')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ProtocolDescriptor', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ProtocolDescriptor', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ProtocolDescriptor', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    n += self.lengthVarInt64(self.value_)
    return n + 4

  def Clear(self):
    self.clear_name()
    self.clear_value()

  def OutputUnchecked(self, out):
    out.putVarInt32(146)
    out.putPrefixedString(self.name_)
    out.putVarInt32(152)
    out.putVarInt32(self.value_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 140: break
      if tt == 146:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 152:
        self.set_value(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_value_: res+=prefix+("value: %s\n" % self.DebugFormatInt32(self.value_))
    return res

class ProtocolDescriptor_TagOption(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.value_ = ""
    self.has_name_ = 0
    self.has_value_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_value()): self.set_value(x.value())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ProtocolDescriptor', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ProtocolDescriptor')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ProtocolDescriptor', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ProtocolDescriptor', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ProtocolDescriptor', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    n += self.lengthString(len(self.value_))
    return n + 4

  def Clear(self):
    self.clear_name()
    self.clear_value()

  def OutputUnchecked(self, out):
    out.putVarInt32(170)
    out.putPrefixedString(self.name_)
    out.putVarInt32(178)
    out.putPrefixedString(self.value_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 164: break
      if tt == 170:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 178:
        self.set_value(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_value_: res+=prefix+("value: %s\n" % self.DebugFormatString(self.value_))
    return res

class ProtocolDescriptor_Tag(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.number_ = 0
    self.wire_type_ = 0
    self.declared_type_ = 0
    self.label_ = 0
    self.default_value_ = ""
    self.foreign_ = ""
    self.flags_ = 0
    self.parent_ = -1
    self.enum_id_ = -1
    self.option_ = []
    self.has_name_ = 0
    self.has_number_ = 0
    self.has_wire_type_ = 0
    self.has_declared_type_ = 0
    self.has_label_ = 0
    self.has_default_value_ = 0
    self.has_foreign_ = 0
    self.has_flags_ = 0
    self.has_parent_ = 0
    self.has_enum_id_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def number(self): return self.number_

  def set_number(self, x):
    self.has_number_ = 1
    self.number_ = x

  def clear_number(self):
    self.has_number_ = 0
    self.number_ = 0

  def has_number(self): return self.has_number_

  def wire_type(self): return self.wire_type_

  def set_wire_type(self, x):
    self.has_wire_type_ = 1
    self.wire_type_ = x

  def clear_wire_type(self):
    self.has_wire_type_ = 0
    self.wire_type_ = 0

  def has_wire_type(self): return self.has_wire_type_

  def declared_type(self): return self.declared_type_

  def set_declared_type(self, x):
    self.has_declared_type_ = 1
    self.declared_type_ = x

  def clear_declared_type(self):
    self.has_declared_type_ = 0
    self.declared_type_ = 0

  def has_declared_type(self): return self.has_declared_type_

  def label(self): return self.label_

  def set_label(self, x):
    self.has_label_ = 1
    self.label_ = x

  def clear_label(self):
    self.has_label_ = 0
    self.label_ = 0

  def has_label(self): return self.has_label_

  def default_value(self): return self.default_value_

  def set_default_value(self, x):
    self.has_default_value_ = 1
    self.default_value_ = x

  def clear_default_value(self):
    self.has_default_value_ = 0
    self.default_value_ = ""

  def has_default_value(self): return self.has_default_value_

  def foreign(self): return self.foreign_

  def set_foreign(self, x):
    self.has_foreign_ = 1
    self.foreign_ = x

  def clear_foreign(self):
    self.has_foreign_ = 0
    self.foreign_ = ""

  def has_foreign(self): return self.has_foreign_

  def flags(self): return self.flags_

  def set_flags(self, x):
    self.has_flags_ = 1
    self.flags_ = x

  def clear_flags(self):
    self.has_flags_ = 0
    self.flags_ = 0

  def has_flags(self): return self.has_flags_

  def parent(self): return self.parent_

  def set_parent(self, x):
    self.has_parent_ = 1
    self.parent_ = x

  def clear_parent(self):
    self.has_parent_ = 0
    self.parent_ = -1

  def has_parent(self): return self.has_parent_

  def enum_id(self): return self.enum_id_

  def set_enum_id(self, x):
    self.has_enum_id_ = 1
    self.enum_id_ = x

  def clear_enum_id(self):
    self.has_enum_id_ = 0
    self.enum_id_ = -1

  def has_enum_id(self): return self.has_enum_id_

  def option_size(self): return len(self.option_)
  def option_list(self): return self.option_

  def option(self, i):
    return self.option_[i]

  def mutable_option(self, i):
    return self.option_[i]

  def add_option(self):
    x = ProtocolDescriptor_TagOption()
    self.option_.append(x)
    return x

  def clear_option(self):
    self.option_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_number()): self.set_number(x.number())
    if (x.has_wire_type()): self.set_wire_type(x.wire_type())
    if (x.has_declared_type()): self.set_declared_type(x.declared_type())
    if (x.has_label()): self.set_label(x.label())
    if (x.has_default_value()): self.set_default_value(x.default_value())
    if (x.has_foreign()): self.set_foreign(x.foreign())
    if (x.has_flags()): self.set_flags(x.flags())
    if (x.has_parent()): self.set_parent(x.parent())
    if (x.has_enum_id()): self.set_enum_id(x.enum_id())
    for i in xrange(x.option_size()): self.add_option().CopyFrom(x.option(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ProtocolDescriptor', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ProtocolDescriptor')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ProtocolDescriptor', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ProtocolDescriptor', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ProtocolDescriptor', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_number_ != x.has_number_: return 0
    if self.has_number_ and self.number_ != x.number_: return 0
    if self.has_wire_type_ != x.has_wire_type_: return 0
    if self.has_wire_type_ and self.wire_type_ != x.wire_type_: return 0
    if self.has_declared_type_ != x.has_declared_type_: return 0
    if self.has_declared_type_ and self.declared_type_ != x.declared_type_: return 0
    if self.has_label_ != x.has_label_: return 0
    if self.has_label_ and self.label_ != x.label_: return 0
    if self.has_default_value_ != x.has_default_value_: return 0
    if self.has_default_value_ and self.default_value_ != x.default_value_: return 0
    if self.has_foreign_ != x.has_foreign_: return 0
    if self.has_foreign_ and self.foreign_ != x.foreign_: return 0
    if self.has_flags_ != x.has_flags_: return 0
    if self.has_flags_ and self.flags_ != x.flags_: return 0
    if self.has_parent_ != x.has_parent_: return 0
    if self.has_parent_ and self.parent_ != x.parent_: return 0
    if self.has_enum_id_ != x.has_enum_id_: return 0
    if self.has_enum_id_ and self.enum_id_ != x.enum_id_: return 0
    if len(self.option_) != len(x.option_): return 0
    for e1, e2 in zip(self.option_, x.option_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    if (not self.has_number_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: number not set.')
    if (not self.has_wire_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: wire_type not set.')
    if (not self.has_declared_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: declared_type not set.')
    if (not self.has_label_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: label not set.')
    for i in xrange(len(self.option_)):
      if (not self.option_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    n += self.lengthVarInt64(self.number_)
    n += self.lengthVarInt64(self.wire_type_)
    n += self.lengthVarInt64(self.declared_type_)
    n += self.lengthVarInt64(self.label_)
    if (self.has_default_value_): n += 1 + self.lengthString(len(self.default_value_))
    if (self.has_foreign_): n += 1 + self.lengthString(len(self.foreign_))
    if (self.has_flags_): n += 1 + self.lengthVarInt64(self.flags_)
    if (self.has_parent_): n += 1 + self.lengthVarInt64(self.parent_)
    if (self.has_enum_id_): n += 1 + self.lengthVarInt64(self.enum_id_)
    n += 4 * len(self.option_)
    for i in xrange(len(self.option_)): n += self.option_[i].ByteSize()
    return n + 5

  def Clear(self):
    self.clear_name()
    self.clear_number()
    self.clear_wire_type()
    self.clear_declared_type()
    self.clear_label()
    self.clear_default_value()
    self.clear_foreign()
    self.clear_flags()
    self.clear_parent()
    self.clear_enum_id()
    self.clear_option()

  def OutputUnchecked(self, out):
    out.putVarInt32(26)
    out.putPrefixedString(self.name_)
    out.putVarInt32(32)
    out.putVarInt32(self.number_)
    out.putVarInt32(40)
    out.putVarInt32(self.wire_type_)
    out.putVarInt32(48)
    out.putVarInt32(self.declared_type_)
    out.putVarInt32(56)
    out.putVarInt32(self.label_)
    if (self.has_default_value_):
      out.putVarInt32(66)
      out.putPrefixedString(self.default_value_)
    if (self.has_foreign_):
      out.putVarInt32(74)
      out.putPrefixedString(self.foreign_)
    if (self.has_flags_):
      out.putVarInt32(80)
      out.putVarInt32(self.flags_)
    if (self.has_parent_):
      out.putVarInt32(96)
      out.putVarInt32(self.parent_)
    if (self.has_enum_id_):
      out.putVarInt32(104)
      out.putVarInt32(self.enum_id_)
    for i in xrange(len(self.option_)):
      out.putVarInt32(163)
      self.option_[i].OutputUnchecked(out)
      out.putVarInt32(164)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 26:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 32:
        self.set_number(d.getVarInt32())
        continue
      if tt == 40:
        self.set_wire_type(d.getVarInt32())
        continue
      if tt == 48:
        self.set_declared_type(d.getVarInt32())
        continue
      if tt == 56:
        self.set_label(d.getVarInt32())
        continue
      if tt == 66:
        self.set_default_value(d.getPrefixedString())
        continue
      if tt == 74:
        self.set_foreign(d.getPrefixedString())
        continue
      if tt == 80:
        self.set_flags(d.getVarInt32())
        continue
      if tt == 96:
        self.set_parent(d.getVarInt32())
        continue
      if tt == 104:
        self.set_enum_id(d.getVarInt32())
        continue
      if tt == 163:
        self.add_option().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_number_: res+=prefix+("number: %s\n" % self.DebugFormatInt32(self.number_))
    if self.has_wire_type_: res+=prefix+("wire_type: %s\n" % self.DebugFormatInt32(self.wire_type_))
    if self.has_declared_type_: res+=prefix+("declared_type: %s\n" % self.DebugFormatInt32(self.declared_type_))
    if self.has_label_: res+=prefix+("label: %s\n" % self.DebugFormatInt32(self.label_))
    if self.has_default_value_: res+=prefix+("default_value: %s\n" % self.DebugFormatString(self.default_value_))
    if self.has_foreign_: res+=prefix+("foreign: %s\n" % self.DebugFormatString(self.foreign_))
    if self.has_flags_: res+=prefix+("flags: %s\n" % self.DebugFormatInt32(self.flags_))
    if self.has_parent_: res+=prefix+("parent: %s\n" % self.DebugFormatInt32(self.parent_))
    if self.has_enum_id_: res+=prefix+("enum_id: %s\n" % self.DebugFormatInt32(self.enum_id_))
    cnt=0
    for e in self.option_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Option%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

class ProtocolDescriptor_EnumType(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.parent_ = 0
    self.tag_ = []
    self.has_name_ = 0
    self.has_parent_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def parent(self): return self.parent_

  def set_parent(self, x):
    self.has_parent_ = 1
    self.parent_ = x

  def clear_parent(self):
    self.has_parent_ = 0
    self.parent_ = 0

  def has_parent(self): return self.has_parent_

  def tag_size(self): return len(self.tag_)
  def tag_list(self): return self.tag_

  def tag(self, i):
    return self.tag_[i]

  def mutable_tag(self, i):
    return self.tag_[i]

  def add_tag(self):
    x = ProtocolDescriptor_EnumTypeTag()
    self.tag_.append(x)
    return x

  def clear_tag(self):
    self.tag_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_parent()): self.set_parent(x.parent())
    for i in xrange(x.tag_size()): self.add_tag().CopyFrom(x.tag(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ProtocolDescriptor', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ProtocolDescriptor')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ProtocolDescriptor', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ProtocolDescriptor', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ProtocolDescriptor', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_parent_ != x.has_parent_: return 0
    if self.has_parent_ and self.parent_ != x.parent_: return 0
    if len(self.tag_) != len(x.tag_): return 0
    for e1, e2 in zip(self.tag_, x.tag_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    for i in xrange(len(self.tag_)):
      if (not self.tag_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    if (self.has_parent_): n += 2 + self.lengthVarInt64(self.parent_)
    n += 4 * len(self.tag_)
    for i in xrange(len(self.tag_)): n += self.tag_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_name()
    self.clear_parent()
    self.clear_tag()

  def OutputUnchecked(self, out):
    out.putVarInt32(122)
    out.putPrefixedString(self.name_)
    if (self.has_parent_):
      out.putVarInt32(128)
      out.putVarInt32(self.parent_)
    for i in xrange(len(self.tag_)):
      out.putVarInt32(139)
      self.tag_[i].OutputUnchecked(out)
      out.putVarInt32(140)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 116: break
      if tt == 122:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 128:
        self.set_parent(d.getVarInt32())
        continue
      if tt == 139:
        self.add_tag().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_parent_: res+=prefix+("parent: %s\n" % self.DebugFormatInt32(self.parent_))
    cnt=0
    for e in self.tag_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Tag%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

class ProtocolDescriptor(ProtocolBuffer.ProtocolMessage):

  WIRETYPE_NUMERIC =    0 
  WIRETYPE_DOUBLE =    1 
  WIRETYPE_STRING =    2 
  WIRETYPE_STARTGROUP =    3 
  WIRETYPE_ENDGROUP =    4 
  WIRETYPE_FLOAT =    5 

  _WireType_NAMES = {
    0: "WIRETYPE_NUMERIC",
    1: "WIRETYPE_DOUBLE",
    2: "WIRETYPE_STRING",
    3: "WIRETYPE_STARTGROUP",
    4: "WIRETYPE_ENDGROUP",
    5: "WIRETYPE_FLOAT",
  }

  def WireType_Name(cls, x): return cls._WireType_NAMES.get(x, "")
  WireType_Name = classmethod(WireType_Name)


  LABEL_OPTIONAL =    1 
  LABEL_REQUIRED =    2 
  LABEL_REPEATED =    3 

  _Label_NAMES = {
    1: "LABEL_OPTIONAL",
    2: "LABEL_REQUIRED",
    3: "LABEL_REPEATED",
  }

  def Label_Name(cls, x): return cls._Label_NAMES.get(x, "")
  Label_Name = classmethod(Label_Name)


  TYPE_DOUBLE  =    1 
  TYPE_FLOAT   =    2 
  TYPE_INT64   =    3 
  TYPE_UINT64  =    4 
  TYPE_INT32   =    5 
  TYPE_FIXED64 =    6 
  TYPE_FIXED32 =    7 
  TYPE_BOOL    =    8 
  TYPE_STRING  =    9 
  TYPE_GROUP   =   10 
  TYPE_FOREIGN =   11 

  _DeclaredType_NAMES = {
    1: "TYPE_DOUBLE",
    2: "TYPE_FLOAT",
    3: "TYPE_INT64",
    4: "TYPE_UINT64",
    5: "TYPE_INT32",
    6: "TYPE_FIXED64",
    7: "TYPE_FIXED32",
    8: "TYPE_BOOL",
    9: "TYPE_STRING",
    10: "TYPE_GROUP",
    11: "TYPE_FOREIGN",
  }

  def DeclaredType_Name(cls, x): return cls._DeclaredType_NAMES.get(x, "")
  DeclaredType_Name = classmethod(DeclaredType_Name)

  def __init__(self, contents=None):
    self.filename_ = ""
    self.name_ = ""
    self.tag_ = []
    self.enumtype_ = []
    self.has_filename_ = 0
    self.has_name_ = 0
    if contents is not None: self.MergeFromString(contents)

  def filename(self): return self.filename_

  def set_filename(self, x):
    self.has_filename_ = 1
    self.filename_ = x

  def clear_filename(self):
    self.has_filename_ = 0
    self.filename_ = ""

  def has_filename(self): return self.has_filename_

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def tag_size(self): return len(self.tag_)
  def tag_list(self): return self.tag_

  def tag(self, i):
    return self.tag_[i]

  def mutable_tag(self, i):
    return self.tag_[i]

  def add_tag(self):
    x = ProtocolDescriptor_Tag()
    self.tag_.append(x)
    return x

  def clear_tag(self):
    self.tag_ = []
  def enumtype_size(self): return len(self.enumtype_)
  def enumtype_list(self): return self.enumtype_

  def enumtype(self, i):
    return self.enumtype_[i]

  def mutable_enumtype(self, i):
    return self.enumtype_[i]

  def add_enumtype(self):
    x = ProtocolDescriptor_EnumType()
    self.enumtype_.append(x)
    return x

  def clear_enumtype(self):
    self.enumtype_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_filename()): self.set_filename(x.filename())
    if (x.has_name()): self.set_name(x.name())
    for i in xrange(x.tag_size()): self.add_tag().CopyFrom(x.tag(i))
    for i in xrange(x.enumtype_size()): self.add_enumtype().CopyFrom(x.enumtype(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ProtocolDescriptor', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ProtocolDescriptor')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ProtocolDescriptor', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ProtocolDescriptor', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ProtocolDescriptor', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_filename_ != x.has_filename_: return 0
    if self.has_filename_ and self.filename_ != x.filename_: return 0
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if len(self.tag_) != len(x.tag_): return 0
    for e1, e2 in zip(self.tag_, x.tag_):
      if e1 != e2: return 0
    if len(self.enumtype_) != len(x.enumtype_): return 0
    for e1, e2 in zip(self.enumtype_, x.enumtype_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_filename_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: filename not set.')
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    for i in xrange(len(self.tag_)):
      if (not self.tag_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.enumtype_)):
      if (not self.enumtype_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.filename_))
    n += self.lengthString(len(self.name_))
    n += 2 * len(self.tag_)
    for i in xrange(len(self.tag_)): n += self.tag_[i].ByteSize()
    n += 2 * len(self.enumtype_)
    for i in xrange(len(self.enumtype_)): n += self.enumtype_[i].ByteSize()
    return n + 2

  def Clear(self):
    self.clear_filename()
    self.clear_name()
    self.clear_tag()
    self.clear_enumtype()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.name_)
    for i in xrange(len(self.tag_)):
      out.putVarInt32(19)
      self.tag_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    out.putVarInt32(90)
    out.putPrefixedString(self.filename_)
    for i in xrange(len(self.enumtype_)):
      out.putVarInt32(115)
      self.enumtype_[i].OutputUnchecked(out)
      out.putVarInt32(116)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 19:
        self.add_tag().TryMerge(d)
        continue
      if tt == 90:
        self.set_filename(d.getPrefixedString())
        continue
      if tt == 115:
        self.add_enumtype().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_filename_: res+=prefix+("filename: %s\n" % self.DebugFormatString(self.filename_))
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    cnt=0
    for e in self.tag_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Tag%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.enumtype_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("EnumType%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kfilename = 11
  kname = 1
  kTagGroup = 2
  kTagname = 3
  kTagnumber = 4
  kTagwire_type = 5
  kTagdeclared_type = 6
  kTaglabel = 7
  kTagdefault_value = 8
  kTagforeign = 9
  kTagflags = 10
  kTagparent = 12
  kTagenum_id = 13
  kTagOptionGroup = 20
  kTagOptionname = 21
  kTagOptionvalue = 22
  kEnumTypeGroup = 14
  kEnumTypename = 15
  kEnumTypeparent = 16
  kEnumTypeTagGroup = 17
  kEnumTypeTagname = 18
  kEnumTypeTagvalue = 19

  _TEXT = (
   "ErrorCode",  #   0
   "name",  #   1
   "Tag",  #   2
   "name",  #   3
   "number",  #   4
   "wire_type",  #   5
   "declared_type",  #   6
   "label",  #   7
   "default_value",  #   8
   "foreign",  #   9
   "flags",  #  10
   "filename",  #  11
   "parent",  #  12
   "enum_id",  #  13
   "EnumType",  #  14
   "name",  #  15
   "parent",  #  16
   "Tag",  #  17
   "name",  #  18
   "value",  #  19
   "Option",  #  20
   "name",  #  21
   "value",  #  22
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.STRING,  #  11

   ProtocolBuffer.Encoder.NUMERIC,  #  12

   ProtocolBuffer.Encoder.NUMERIC,  #  13

   ProtocolBuffer.Encoder.STARTGROUP,  #  14

   ProtocolBuffer.Encoder.STRING,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

   ProtocolBuffer.Encoder.STARTGROUP,  #  17

   ProtocolBuffer.Encoder.STRING,  #  18

   ProtocolBuffer.Encoder.NUMERIC,  #  19

   ProtocolBuffer.Encoder.STARTGROUP,  #  20

   ProtocolBuffer.Encoder.STRING,  #  21

   ProtocolBuffer.Encoder.STRING,  #  22

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x1c,
    0x6e,
    0x65,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x63,
    0x6f,
    0x6c,
    0x74,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x12,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x63,
    0x6f,
    0x6c,
    0x44,
    0x65,
    0x73,
    0x63,
    0x72,
    0x69,
    0x70,
    0x74,
    0x6f,
    0x72,
    0x13,
    0x1a,
    0x08,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x0b,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x03,
    0x54,
    0x61,
    0x67,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x77,
    0x69,
    0x72,
    0x65,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x64,
    0x65,
    0x63,
    0x6c,
    0x61,
    0x72,
    0x65,
    0x64,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x6c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0x5f,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x66,
    0x6f,
    0x72,
    0x65,
    0x69,
    0x67,
    0x6e,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x66,
    0x6c,
    0x61,
    0x67,
    0x73,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x70,
    0x61,
    0x72,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x0c,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x02,
    0x2d,
    0x31,
    0x60,
    0x02,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x2d,
    0x31,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x65,
    0x6e,
    0x75,
    0x6d,
    0x5f,
    0x69,
    0x64,
    0x20,
    0x0d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x02,
    0x2d,
    0x31,
    0x60,
    0x02,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x2d,
    0x31,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x4f,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x14,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x4f,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x15,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x4f,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x16,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x45,
    0x6e,
    0x75,
    0x6d,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x0e,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x45,
    0x6e,
    0x75,
    0x6d,
    0x54,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x0f,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x10,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x45,
    0x6e,
    0x75,
    0x6d,
    0x54,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x70,
    0x61,
    0x72,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x10,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x45,
    0x6e,
    0x75,
    0x6d,
    0x54,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x54,
    0x61,
    0x67,
    0x20,
    0x11,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x10,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x45,
    0x6e,
    0x75,
    0x6d,
    0x54,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x12,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x13,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x45,
    0x6e,
    0x75,
    0x6d,
    0x54,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x54,
    0x61,
    0x67,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x13,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x13,
    0x14,
    0x73,
    0x7a,
    0x08,
    0x57,
    0x69,
    0x72,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x57,
    0x49,
    0x52,
    0x45,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x4e,
    0x55,
    0x4d,
    0x45,
    0x52,
    0x49,
    0x43,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x57,
    0x49,
    0x52,
    0x45,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x44,
    0x4f,
    0x55,
    0x42,
    0x4c,
    0x45,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x57,
    0x49,
    0x52,
    0x45,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x53,
    0x54,
    0x52,
    0x49,
    0x4e,
    0x47,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x13,
    0x57,
    0x49,
    0x52,
    0x45,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x53,
    0x54,
    0x41,
    0x52,
    0x54,
    0x47,
    0x52,
    0x4f,
    0x55,
    0x50,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x57,
    0x49,
    0x52,
    0x45,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x45,
    0x4e,
    0x44,
    0x47,
    0x52,
    0x4f,
    0x55,
    0x50,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x57,
    0x49,
    0x52,
    0x45,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x46,
    0x4c,
    0x4f,
    0x41,
    0x54,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x05,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x4c,
    0x41,
    0x42,
    0x45,
    0x4c,
    0x5f,
    0x4f,
    0x50,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x41,
    0x4c,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x4c,
    0x41,
    0x42,
    0x45,
    0x4c,
    0x5f,
    0x52,
    0x45,
    0x51,
    0x55,
    0x49,
    0x52,
    0x45,
    0x44,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x4c,
    0x41,
    0x42,
    0x45,
    0x4c,
    0x5f,
    0x52,
    0x45,
    0x50,
    0x45,
    0x41,
    0x54,
    0x45,
    0x44,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x0c,
    0x44,
    0x65,
    0x63,
    0x6c,
    0x61,
    0x72,
    0x65,
    0x64,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x44,
    0x4f,
    0x55,
    0x42,
    0x4c,
    0x45,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x46,
    0x4c,
    0x4f,
    0x41,
    0x54,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x4e,
    0x54,
    0x36,
    0x34,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x55,
    0x49,
    0x4e,
    0x54,
    0x36,
    0x34,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x4e,
    0x54,
    0x33,
    0x32,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x46,
    0x49,
    0x58,
    0x45,
    0x44,
    0x36,
    0x34,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x46,
    0x49,
    0x58,
    0x45,
    0x44,
    0x33,
    0x32,
    0x98,
    0x01,
    0x07,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x42,
    0x4f,
    0x4f,
    0x4c,
    0x98,
    0x01,
    0x08,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x53,
    0x54,
    0x52,
    0x49,
    0x4e,
    0x47,
    0x98,
    0x01,
    0x09,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x47,
    0x52,
    0x4f,
    0x55,
    0x50,
    0x98,
    0x01,
    0x0a,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x46,
    0x4f,
    0x52,
    0x45,
    0x49,
    0x47,
    0x4e,
    0x98,
    0x01,
    0x0b,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ProtocolFileDescriptor(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.filename_ = ""
    self.type_ = []
    self.service_ = []
    self.has_filename_ = 0
    if contents is not None: self.MergeFromString(contents)

  def filename(self): return self.filename_

  def set_filename(self, x):
    self.has_filename_ = 1
    self.filename_ = x

  def clear_filename(self):
    self.has_filename_ = 0
    self.filename_ = ""

  def has_filename(self): return self.has_filename_

  def type_size(self): return len(self.type_)
  def type_list(self): return self.type_

  def type(self, i):
    return self.type_[i]

  def set_type(self, i, x):
    self.type_[i] = x

  def add_type(self, x):
    self.type_.append(x)

  def clear_type(self):
    self.type_ = []

  def service_size(self): return len(self.service_)
  def service_list(self): return self.service_

  def service(self, i):
    return self.service_[i]

  def set_service(self, i, x):
    self.service_[i] = x

  def add_service(self, x):
    self.service_.append(x)

  def clear_service(self):
    self.service_ = []


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_filename()): self.set_filename(x.filename())
    for i in xrange(x.type_size()): self.add_type(x.type(i))
    for i in xrange(x.service_size()): self.add_service(x.service(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ProtocolFileDescriptor', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ProtocolFileDescriptor')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ProtocolFileDescriptor', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ProtocolFileDescriptor', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ProtocolFileDescriptor', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_filename_ != x.has_filename_: return 0
    if self.has_filename_ and self.filename_ != x.filename_: return 0
    if len(self.type_) != len(x.type_): return 0
    for e1, e2 in zip(self.type_, x.type_):
      if e1 != e2: return 0
    if len(self.service_) != len(x.service_): return 0
    for e1, e2 in zip(self.service_, x.service_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_filename_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: filename not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.filename_))
    n += 1 * len(self.type_)
    for i in xrange(len(self.type_)): n += self.lengthString(len(self.type_[i]))
    n += 1 * len(self.service_)
    for i in xrange(len(self.service_)): n += self.lengthString(len(self.service_[i]))
    return n + 1

  def Clear(self):
    self.clear_filename()
    self.clear_type()
    self.clear_service()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.filename_)
    for i in xrange(len(self.type_)):
      out.putVarInt32(18)
      out.putPrefixedString(self.type_[i])
    for i in xrange(len(self.service_)):
      out.putVarInt32(26)
      out.putPrefixedString(self.service_[i])

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_filename(d.getPrefixedString())
        continue
      if tt == 18:
        self.add_type(d.getPrefixedString())
        continue
      if tt == 26:
        self.add_service(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_filename_: res+=prefix+("filename: %s\n" % self.DebugFormatString(self.filename_))
    cnt=0
    for e in self.type_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("type%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    cnt=0
    for e in self.service_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("service%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    return res

  kfilename = 1
  ktype = 2
  kservice = 3

  _TEXT = (
   "ErrorCode",  #   0
   "filename",  #   1
   "type",  #   2
   "service",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x1c,
    0x6e,
    0x65,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x63,
    0x6f,
    0x6c,
    0x74,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x16,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x63,
    0x6f,
    0x6c,
    0x46,
    0x69,
    0x6c,
    0x65,
    0x44,
    0x65,
    0x73,
    0x63,
    0x72,
    0x69,
    0x70,
    0x74,
    0x6f,
    0x72,
    0x13,
    0x1a,
    0x08,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x73,
    0x65,
    0x72,
    0x76,
    0x69,
    0x63,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class RPC_ServiceDescriptor_Method(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.argument_type_ = ""
    self.result_type_ = ""
    self.stream_type_ = ""
    self.protocol_ = ""
    self.deadline_ = 0.0
    self.duplicate_suppression_ = 0
    self.fail_fast_ = 0
    self.client_logging_ = 0
    self.server_logging_ = 0
    self.security_level_ = ""
    self.response_format_ = ""
    self.request_format_ = ""
    self.has_name_ = 0
    self.has_argument_type_ = 0
    self.has_result_type_ = 0
    self.has_stream_type_ = 0
    self.has_protocol_ = 0
    self.has_deadline_ = 0
    self.has_duplicate_suppression_ = 0
    self.has_fail_fast_ = 0
    self.has_client_logging_ = 0
    self.has_server_logging_ = 0
    self.has_security_level_ = 0
    self.has_response_format_ = 0
    self.has_request_format_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def argument_type(self): return self.argument_type_

  def set_argument_type(self, x):
    self.has_argument_type_ = 1
    self.argument_type_ = x

  def clear_argument_type(self):
    self.has_argument_type_ = 0
    self.argument_type_ = ""

  def has_argument_type(self): return self.has_argument_type_

  def result_type(self): return self.result_type_

  def set_result_type(self, x):
    self.has_result_type_ = 1
    self.result_type_ = x

  def clear_result_type(self):
    self.has_result_type_ = 0
    self.result_type_ = ""

  def has_result_type(self): return self.has_result_type_

  def stream_type(self): return self.stream_type_

  def set_stream_type(self, x):
    self.has_stream_type_ = 1
    self.stream_type_ = x

  def clear_stream_type(self):
    self.has_stream_type_ = 0
    self.stream_type_ = ""

  def has_stream_type(self): return self.has_stream_type_

  def protocol(self): return self.protocol_

  def set_protocol(self, x):
    self.has_protocol_ = 1
    self.protocol_ = x

  def clear_protocol(self):
    self.has_protocol_ = 0
    self.protocol_ = ""

  def has_protocol(self): return self.has_protocol_

  def deadline(self): return self.deadline_

  def set_deadline(self, x):
    self.has_deadline_ = 1
    self.deadline_ = x

  def clear_deadline(self):
    self.has_deadline_ = 0
    self.deadline_ = 0.0

  def has_deadline(self): return self.has_deadline_

  def duplicate_suppression(self): return self.duplicate_suppression_

  def set_duplicate_suppression(self, x):
    self.has_duplicate_suppression_ = 1
    self.duplicate_suppression_ = x

  def clear_duplicate_suppression(self):
    self.has_duplicate_suppression_ = 0
    self.duplicate_suppression_ = 0

  def has_duplicate_suppression(self): return self.has_duplicate_suppression_

  def fail_fast(self): return self.fail_fast_

  def set_fail_fast(self, x):
    self.has_fail_fast_ = 1
    self.fail_fast_ = x

  def clear_fail_fast(self):
    self.has_fail_fast_ = 0
    self.fail_fast_ = 0

  def has_fail_fast(self): return self.has_fail_fast_

  def client_logging(self): return self.client_logging_

  def set_client_logging(self, x):
    self.has_client_logging_ = 1
    self.client_logging_ = x

  def clear_client_logging(self):
    self.has_client_logging_ = 0
    self.client_logging_ = 0

  def has_client_logging(self): return self.has_client_logging_

  def server_logging(self): return self.server_logging_

  def set_server_logging(self, x):
    self.has_server_logging_ = 1
    self.server_logging_ = x

  def clear_server_logging(self):
    self.has_server_logging_ = 0
    self.server_logging_ = 0

  def has_server_logging(self): return self.has_server_logging_

  def security_level(self): return self.security_level_

  def set_security_level(self, x):
    self.has_security_level_ = 1
    self.security_level_ = x

  def clear_security_level(self):
    self.has_security_level_ = 0
    self.security_level_ = ""

  def has_security_level(self): return self.has_security_level_

  def response_format(self): return self.response_format_

  def set_response_format(self, x):
    self.has_response_format_ = 1
    self.response_format_ = x

  def clear_response_format(self):
    self.has_response_format_ = 0
    self.response_format_ = ""

  def has_response_format(self): return self.has_response_format_

  def request_format(self): return self.request_format_

  def set_request_format(self, x):
    self.has_request_format_ = 1
    self.request_format_ = x

  def clear_request_format(self):
    self.has_request_format_ = 0
    self.request_format_ = ""

  def has_request_format(self): return self.has_request_format_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_argument_type()): self.set_argument_type(x.argument_type())
    if (x.has_result_type()): self.set_result_type(x.result_type())
    if (x.has_stream_type()): self.set_stream_type(x.stream_type())
    if (x.has_protocol()): self.set_protocol(x.protocol())
    if (x.has_deadline()): self.set_deadline(x.deadline())
    if (x.has_duplicate_suppression()): self.set_duplicate_suppression(x.duplicate_suppression())
    if (x.has_fail_fast()): self.set_fail_fast(x.fail_fast())
    if (x.has_client_logging()): self.set_client_logging(x.client_logging())
    if (x.has_server_logging()): self.set_server_logging(x.server_logging())
    if (x.has_security_level()): self.set_security_level(x.security_level())
    if (x.has_response_format()): self.set_response_format(x.response_format())
    if (x.has_request_format()): self.set_request_format(x.request_format())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'RPC_ServiceDescriptor', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'RPC_ServiceDescriptor')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'RPC_ServiceDescriptor', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'RPC_ServiceDescriptor', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'RPC_ServiceDescriptor', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_argument_type_ != x.has_argument_type_: return 0
    if self.has_argument_type_ and self.argument_type_ != x.argument_type_: return 0
    if self.has_result_type_ != x.has_result_type_: return 0
    if self.has_result_type_ and self.result_type_ != x.result_type_: return 0
    if self.has_stream_type_ != x.has_stream_type_: return 0
    if self.has_stream_type_ and self.stream_type_ != x.stream_type_: return 0
    if self.has_protocol_ != x.has_protocol_: return 0
    if self.has_protocol_ and self.protocol_ != x.protocol_: return 0
    if self.has_deadline_ != x.has_deadline_: return 0
    if self.has_deadline_ and self.deadline_ != x.deadline_: return 0
    if self.has_duplicate_suppression_ != x.has_duplicate_suppression_: return 0
    if self.has_duplicate_suppression_ and self.duplicate_suppression_ != x.duplicate_suppression_: return 0
    if self.has_fail_fast_ != x.has_fail_fast_: return 0
    if self.has_fail_fast_ and self.fail_fast_ != x.fail_fast_: return 0
    if self.has_client_logging_ != x.has_client_logging_: return 0
    if self.has_client_logging_ and self.client_logging_ != x.client_logging_: return 0
    if self.has_server_logging_ != x.has_server_logging_: return 0
    if self.has_server_logging_ and self.server_logging_ != x.server_logging_: return 0
    if self.has_security_level_ != x.has_security_level_: return 0
    if self.has_security_level_ and self.security_level_ != x.security_level_: return 0
    if self.has_response_format_ != x.has_response_format_: return 0
    if self.has_response_format_ and self.response_format_ != x.response_format_: return 0
    if self.has_request_format_ != x.has_request_format_: return 0
    if self.has_request_format_ and self.request_format_ != x.request_format_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    if (not self.has_argument_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: argument_type not set.')
    if (not self.has_result_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: result_type not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    n += self.lengthString(len(self.argument_type_))
    n += self.lengthString(len(self.result_type_))
    if (self.has_stream_type_): n += 1 + self.lengthString(len(self.stream_type_))
    if (self.has_protocol_): n += 1 + self.lengthString(len(self.protocol_))
    if (self.has_deadline_): n += 9
    if (self.has_duplicate_suppression_): n += 2
    if (self.has_fail_fast_): n += 2
    if (self.has_client_logging_): n += 1 + self.lengthVarInt64(self.client_logging_)
    if (self.has_server_logging_): n += 1 + self.lengthVarInt64(self.server_logging_)
    if (self.has_security_level_): n += 1 + self.lengthString(len(self.security_level_))
    if (self.has_response_format_): n += 1 + self.lengthString(len(self.response_format_))
    if (self.has_request_format_): n += 2 + self.lengthString(len(self.request_format_))
    return n + 3

  def Clear(self):
    self.clear_name()
    self.clear_argument_type()
    self.clear_result_type()
    self.clear_stream_type()
    self.clear_protocol()
    self.clear_deadline()
    self.clear_duplicate_suppression()
    self.clear_fail_fast()
    self.clear_client_logging()
    self.clear_server_logging()
    self.clear_security_level()
    self.clear_response_format()
    self.clear_request_format()

  def OutputUnchecked(self, out):
    out.putVarInt32(34)
    out.putPrefixedString(self.name_)
    out.putVarInt32(42)
    out.putPrefixedString(self.argument_type_)
    out.putVarInt32(50)
    out.putPrefixedString(self.result_type_)
    if (self.has_protocol_):
      out.putVarInt32(58)
      out.putPrefixedString(self.protocol_)
    if (self.has_deadline_):
      out.putVarInt32(65)
      out.putDouble(self.deadline_)
    if (self.has_duplicate_suppression_):
      out.putVarInt32(72)
      out.putBoolean(self.duplicate_suppression_)
    if (self.has_fail_fast_):
      out.putVarInt32(80)
      out.putBoolean(self.fail_fast_)
    if (self.has_client_logging_):
      out.putVarInt32(88)
      out.putVarInt32(self.client_logging_)
    if (self.has_server_logging_):
      out.putVarInt32(96)
      out.putVarInt32(self.server_logging_)
    if (self.has_security_level_):
      out.putVarInt32(106)
      out.putPrefixedString(self.security_level_)
    if (self.has_stream_type_):
      out.putVarInt32(114)
      out.putPrefixedString(self.stream_type_)
    if (self.has_response_format_):
      out.putVarInt32(122)
      out.putPrefixedString(self.response_format_)
    if (self.has_request_format_):
      out.putVarInt32(138)
      out.putPrefixedString(self.request_format_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 28: break
      if tt == 34:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 42:
        self.set_argument_type(d.getPrefixedString())
        continue
      if tt == 50:
        self.set_result_type(d.getPrefixedString())
        continue
      if tt == 58:
        self.set_protocol(d.getPrefixedString())
        continue
      if tt == 65:
        self.set_deadline(d.getDouble())
        continue
      if tt == 72:
        self.set_duplicate_suppression(d.getBoolean())
        continue
      if tt == 80:
        self.set_fail_fast(d.getBoolean())
        continue
      if tt == 88:
        self.set_client_logging(d.getVarInt32())
        continue
      if tt == 96:
        self.set_server_logging(d.getVarInt32())
        continue
      if tt == 106:
        self.set_security_level(d.getPrefixedString())
        continue
      if tt == 114:
        self.set_stream_type(d.getPrefixedString())
        continue
      if tt == 122:
        self.set_response_format(d.getPrefixedString())
        continue
      if tt == 138:
        self.set_request_format(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_argument_type_: res+=prefix+("argument_type: %s\n" % self.DebugFormatString(self.argument_type_))
    if self.has_result_type_: res+=prefix+("result_type: %s\n" % self.DebugFormatString(self.result_type_))
    if self.has_stream_type_: res+=prefix+("stream_type: %s\n" % self.DebugFormatString(self.stream_type_))
    if self.has_protocol_: res+=prefix+("protocol: %s\n" % self.DebugFormatString(self.protocol_))
    if self.has_deadline_: res+=prefix+("deadline: %s\n" % self.DebugFormat(self.deadline_))
    if self.has_duplicate_suppression_: res+=prefix+("duplicate_suppression: %s\n" % self.DebugFormatBool(self.duplicate_suppression_))
    if self.has_fail_fast_: res+=prefix+("fail_fast: %s\n" % self.DebugFormatBool(self.fail_fast_))
    if self.has_client_logging_: res+=prefix+("client_logging: %s\n" % self.DebugFormatInt32(self.client_logging_))
    if self.has_server_logging_: res+=prefix+("server_logging: %s\n" % self.DebugFormatInt32(self.server_logging_))
    if self.has_security_level_: res+=prefix+("security_level: %s\n" % self.DebugFormatString(self.security_level_))
    if self.has_response_format_: res+=prefix+("response_format: %s\n" % self.DebugFormatString(self.response_format_))
    if self.has_request_format_: res+=prefix+("request_format: %s\n" % self.DebugFormatString(self.request_format_))
    return res

class RPC_ServiceDescriptor(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.filename_ = ""
    self.name_ = ""
    self.full_name_ = ""
    self.failure_detection_delay_ = 0.0
    self.method_ = []
    self.has_filename_ = 0
    self.has_name_ = 0
    self.has_full_name_ = 0
    self.has_failure_detection_delay_ = 0
    if contents is not None: self.MergeFromString(contents)

  def filename(self): return self.filename_

  def set_filename(self, x):
    self.has_filename_ = 1
    self.filename_ = x

  def clear_filename(self):
    self.has_filename_ = 0
    self.filename_ = ""

  def has_filename(self): return self.has_filename_

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def full_name(self): return self.full_name_

  def set_full_name(self, x):
    self.has_full_name_ = 1
    self.full_name_ = x

  def clear_full_name(self):
    self.has_full_name_ = 0
    self.full_name_ = ""

  def has_full_name(self): return self.has_full_name_

  def failure_detection_delay(self): return self.failure_detection_delay_

  def set_failure_detection_delay(self, x):
    self.has_failure_detection_delay_ = 1
    self.failure_detection_delay_ = x

  def clear_failure_detection_delay(self):
    self.has_failure_detection_delay_ = 0
    self.failure_detection_delay_ = 0.0

  def has_failure_detection_delay(self): return self.has_failure_detection_delay_

  def method_size(self): return len(self.method_)
  def method_list(self): return self.method_

  def method(self, i):
    return self.method_[i]

  def mutable_method(self, i):
    return self.method_[i]

  def add_method(self):
    x = RPC_ServiceDescriptor_Method()
    self.method_.append(x)
    return x

  def clear_method(self):
    self.method_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_filename()): self.set_filename(x.filename())
    if (x.has_name()): self.set_name(x.name())
    if (x.has_full_name()): self.set_full_name(x.full_name())
    if (x.has_failure_detection_delay()): self.set_failure_detection_delay(x.failure_detection_delay())
    for i in xrange(x.method_size()): self.add_method().CopyFrom(x.method(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'RPC_ServiceDescriptor', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'RPC_ServiceDescriptor')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'RPC_ServiceDescriptor', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'RPC_ServiceDescriptor', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'RPC_ServiceDescriptor', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_filename_ != x.has_filename_: return 0
    if self.has_filename_ and self.filename_ != x.filename_: return 0
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_full_name_ != x.has_full_name_: return 0
    if self.has_full_name_ and self.full_name_ != x.full_name_: return 0
    if self.has_failure_detection_delay_ != x.has_failure_detection_delay_: return 0
    if self.has_failure_detection_delay_ and self.failure_detection_delay_ != x.failure_detection_delay_: return 0
    if len(self.method_) != len(x.method_): return 0
    for e1, e2 in zip(self.method_, x.method_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_filename_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: filename not set.')
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    for i in xrange(len(self.method_)):
      if (not self.method_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.filename_))
    n += self.lengthString(len(self.name_))
    if (self.has_full_name_): n += 2 + self.lengthString(len(self.full_name_))
    if (self.has_failure_detection_delay_): n += 10
    n += 2 * len(self.method_)
    for i in xrange(len(self.method_)): n += self.method_[i].ByteSize()
    return n + 2

  def Clear(self):
    self.clear_filename()
    self.clear_name()
    self.clear_full_name()
    self.clear_failure_detection_delay()
    self.clear_method()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.filename_)
    out.putVarInt32(18)
    out.putPrefixedString(self.name_)
    for i in xrange(len(self.method_)):
      out.putVarInt32(27)
      self.method_[i].OutputUnchecked(out)
      out.putVarInt32(28)
    if (self.has_failure_detection_delay_):
      out.putVarInt32(129)
      out.putDouble(self.failure_detection_delay_)
    if (self.has_full_name_):
      out.putVarInt32(146)
      out.putPrefixedString(self.full_name_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_filename(d.getPrefixedString())
        continue
      if tt == 18:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 27:
        self.add_method().TryMerge(d)
        continue
      if tt == 129:
        self.set_failure_detection_delay(d.getDouble())
        continue
      if tt == 146:
        self.set_full_name(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_filename_: res+=prefix+("filename: %s\n" % self.DebugFormatString(self.filename_))
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_full_name_: res+=prefix+("full_name: %s\n" % self.DebugFormatString(self.full_name_))
    if self.has_failure_detection_delay_: res+=prefix+("failure_detection_delay: %s\n" % self.DebugFormat(self.failure_detection_delay_))
    cnt=0
    for e in self.method_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Method%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kfilename = 1
  kname = 2
  kfull_name = 18
  kfailure_detection_delay = 16
  kMethodGroup = 3
  kMethodname = 4
  kMethodargument_type = 5
  kMethodresult_type = 6
  kMethodstream_type = 14
  kMethodprotocol = 7
  kMethoddeadline = 8
  kMethodduplicate_suppression = 9
  kMethodfail_fast = 10
  kMethodclient_logging = 11
  kMethodserver_logging = 12
  kMethodsecurity_level = 13
  kMethodresponse_format = 15
  kMethodrequest_format = 17

  _TEXT = (
   "ErrorCode",  #   0
   "filename",  #   1
   "name",  #   2
   "Method",  #   3
   "name",  #   4
   "argument_type",  #   5
   "result_type",  #   6
   "protocol",  #   7
   "deadline",  #   8
   "duplicate_suppression",  #   9
   "fail_fast",  #  10
   "client_logging",  #  11
   "server_logging",  #  12
   "security_level",  #  13
   "stream_type",  #  14
   "response_format",  #  15
   "failure_detection_delay",  #  16
   "request_format",  #  17
   "full_name",  #  18
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STARTGROUP,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.STRING,  #   7

   ProtocolBuffer.Encoder.DOUBLE,  #   8

   ProtocolBuffer.Encoder.NUMERIC,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

   ProtocolBuffer.Encoder.NUMERIC,  #  12

   ProtocolBuffer.Encoder.STRING,  #  13

   ProtocolBuffer.Encoder.STRING,  #  14

   ProtocolBuffer.Encoder.STRING,  #  15

   ProtocolBuffer.Encoder.DOUBLE,  #  16

   ProtocolBuffer.Encoder.STRING,  #  17

   ProtocolBuffer.Encoder.STRING,  #  18

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x1c,
    0x6e,
    0x65,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x63,
    0x6f,
    0x6c,
    0x74,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x15,
    0x52,
    0x50,
    0x43,
    0x5f,
    0x53,
    0x65,
    0x72,
    0x76,
    0x69,
    0x63,
    0x65,
    0x44,
    0x65,
    0x73,
    0x63,
    0x72,
    0x69,
    0x70,
    0x74,
    0x6f,
    0x72,
    0x13,
    0x1a,
    0x08,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x66,
    0x75,
    0x6c,
    0x6c,
    0x5f,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x12,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x66,
    0x61,
    0x69,
    0x6c,
    0x75,
    0x72,
    0x65,
    0x5f,
    0x64,
    0x65,
    0x74,
    0x65,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x64,
    0x65,
    0x6c,
    0x61,
    0x79,
    0x20,
    0x10,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x20,
    0x03,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x61,
    0x72,
    0x67,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x72,
    0x65,
    0x73,
    0x75,
    0x6c,
    0x74,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x73,
    0x74,
    0x72,
    0x65,
    0x61,
    0x6d,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x0e,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x63,
    0x6f,
    0x6c,
    0x20,
    0x07,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x64,
    0x65,
    0x61,
    0x64,
    0x6c,
    0x69,
    0x6e,
    0x65,
    0x20,
    0x08,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x64,
    0x75,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x65,
    0x5f,
    0x73,
    0x75,
    0x70,
    0x70,
    0x72,
    0x65,
    0x73,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x09,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x66,
    0x61,
    0x69,
    0x6c,
    0x5f,
    0x66,
    0x61,
    0x73,
    0x74,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x63,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x6c,
    0x6f,
    0x67,
    0x67,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x5f,
    0x6c,
    0x6f,
    0x67,
    0x67,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x0c,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x73,
    0x65,
    0x63,
    0x75,
    0x72,
    0x69,
    0x74,
    0x79,
    0x5f,
    0x6c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x20,
    0x0d,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x72,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x5f,
    0x66,
    0x6f,
    0x72,
    0x6d,
    0x61,
    0x74,
    0x20,
    0x0f,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x4d,
    0x65,
    0x74,
    0x68,
    0x6f,
    0x64,
    0x2e,
    0x72,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x5f,
    0x66,
    0x6f,
    0x72,
    0x6d,
    0x61,
    0x74,
    0x20,
    0x11,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['ProtocolDescriptor','ProtocolDescriptor_EnumTypeTag','ProtocolDescriptor_TagOption','ProtocolDescriptor_Tag','ProtocolDescriptor_EnumType','ProtocolFileDescriptor','RPC_ServiceDescriptor','RPC_ServiceDescriptor_Method']
