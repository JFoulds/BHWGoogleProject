# This file automatically generated by protocol-compiler from crawler/contentconverter/linkrecord.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

from google3.indexer.perdocdata.perdocdata_pb import PerDocData
from google3.segindexer.anchors_pb import Anchors
from google3.quality.labels.proto.google_label_data_pb import GoogleLabelData
from google3.quality.rankboost.indexing.rankboost_cdoc_attachment_pb import RankBoostDocAttachment
from google3.image.mustang.indexer.proto.imagelinks_pb import PageImageLinkInfo
class WebmirrorInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.representative_urlfp96_ = ""
    self.dropped_by_webmirror_ = 0
    self.has_representative_urlfp96_ = 0
    self.has_dropped_by_webmirror_ = 0
    if contents is not None: self.MergeFromString(contents)

  def representative_urlfp96(self): return self.representative_urlfp96_

  def set_representative_urlfp96(self, x):
    self.has_representative_urlfp96_ = 1
    self.representative_urlfp96_ = x

  def clear_representative_urlfp96(self):
    self.has_representative_urlfp96_ = 0
    self.representative_urlfp96_ = ""

  def has_representative_urlfp96(self): return self.has_representative_urlfp96_

  def dropped_by_webmirror(self): return self.dropped_by_webmirror_

  def set_dropped_by_webmirror(self, x):
    self.has_dropped_by_webmirror_ = 1
    self.dropped_by_webmirror_ = x

  def clear_dropped_by_webmirror(self):
    self.has_dropped_by_webmirror_ = 0
    self.dropped_by_webmirror_ = 0

  def has_dropped_by_webmirror(self): return self.has_dropped_by_webmirror_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_representative_urlfp96()): self.set_representative_urlfp96(x.representative_urlfp96())
    if (x.has_dropped_by_webmirror()): self.set_dropped_by_webmirror(x.dropped_by_webmirror())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'content_converter.WebmirrorInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'content_converter.WebmirrorInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'content_converter.WebmirrorInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'content_converter.WebmirrorInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'content_converter.WebmirrorInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_representative_urlfp96_ != x.has_representative_urlfp96_: return 0
    if self.has_representative_urlfp96_ and self.representative_urlfp96_ != x.representative_urlfp96_: return 0
    if self.has_dropped_by_webmirror_ != x.has_dropped_by_webmirror_: return 0
    if self.has_dropped_by_webmirror_ and self.dropped_by_webmirror_ != x.dropped_by_webmirror_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_representative_urlfp96_): n += 1 + self.lengthString(len(self.representative_urlfp96_))
    if (self.has_dropped_by_webmirror_): n += 2
    return n + 0

  def Clear(self):
    self.clear_representative_urlfp96()
    self.clear_dropped_by_webmirror()

  def OutputUnchecked(self, out):
    if (self.has_representative_urlfp96_):
      out.putVarInt32(10)
      out.putPrefixedString(self.representative_urlfp96_)
    if (self.has_dropped_by_webmirror_):
      out.putVarInt32(16)
      out.putBoolean(self.dropped_by_webmirror_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_representative_urlfp96(d.getPrefixedString())
        continue
      if tt == 16:
        self.set_dropped_by_webmirror(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_representative_urlfp96_: res+=prefix+("representative_urlfp96: %s\n" % self.DebugFormatString(self.representative_urlfp96_))
    if self.has_dropped_by_webmirror_: res+=prefix+("dropped_by_webmirror: %s\n" % self.DebugFormatBool(self.dropped_by_webmirror_))
    return res

  krepresentative_urlfp96 = 1
  kdropped_by_webmirror = 2

  _TEXT = (
   "ErrorCode",  #   0
   "representative_urlfp96",  #   1
   "dropped_by_webmirror",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x29,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x63,
    0x6f,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x72,
    0x65,
    0x63,
    0x6f,
    0x72,
    0x64,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1f,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x63,
    0x6f,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x57,
    0x65,
    0x62,
    0x6d,
    0x69,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x13,
    0x1a,
    0x16,
    0x72,
    0x65,
    0x70,
    0x72,
    0x65,
    0x73,
    0x65,
    0x6e,
    0x74,
    0x61,
    0x74,
    0x69,
    0x76,
    0x65,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x66,
    0x70,
    0x39,
    0x36,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x42,
    0x00,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x22,
    0x22,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x64,
    0x72,
    0x6f,
    0x70,
    0x70,
    0x65,
    0x64,
    0x5f,
    0x62,
    0x79,
    0x5f,
    0x77,
    0x65,
    0x62,
    0x6d,
    0x69,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class Link(ProtocolBuffer.ProtocolMessage):

  UNKNOWN_DISCOVERY =    0 
  JAVASCRIPT_EXECUTION_DISCOVERY =    1 
  JAVASCRIPT_FORM_EXECUTION_DISCOVERY =    2 
  FORM_SUBMISSION_DISCOVERY =    3 

  _DiscoveryType_NAMES = {
    0: "UNKNOWN_DISCOVERY",
    1: "JAVASCRIPT_EXECUTION_DISCOVERY",
    2: "JAVASCRIPT_FORM_EXECUTION_DISCOVERY",
    3: "FORM_SUBMISSION_DISCOVERY",
  }

  def DiscoveryType_Name(cls, x): return cls._DiscoveryType_NAMES.get(x, "")
  DiscoveryType_Name = classmethod(DiscoveryType_Name)

  def __init__(self, contents=None):
    self.url_ = ""
    self.webmirror_info_ = None
    self.anchor_ = None
    self.pagerank_weight_ = 1.0
    self.discovery_type_ = 0
    self.has_url_ = 0
    self.has_webmirror_info_ = 0
    self.has_anchor_ = 0
    self.has_pagerank_weight_ = 0
    self.has_discovery_type_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def webmirror_info(self):
    if self.webmirror_info_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.webmirror_info_ is None: self.webmirror_info_ = WebmirrorInfo()
      finally:
        self.lazy_init_lock_.release()
    return self.webmirror_info_

  def mutable_webmirror_info(self): self.has_webmirror_info_ = 1; return self.webmirror_info()

  def clear_webmirror_info(self):
    #Warning: this method does not acquire the lock.
    self.has_webmirror_info_ = 0;
    if self.webmirror_info_ is not None: self.webmirror_info_.Clear()

  def has_webmirror_info(self): return self.has_webmirror_info_

  def anchor(self):
    if self.anchor_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.anchor_ is None: self.anchor_ = Anchors()
      finally:
        self.lazy_init_lock_.release()
    return self.anchor_

  def mutable_anchor(self): self.has_anchor_ = 1; return self.anchor()

  def clear_anchor(self):
    #Warning: this method does not acquire the lock.
    self.has_anchor_ = 0;
    if self.anchor_ is not None: self.anchor_.Clear()

  def has_anchor(self): return self.has_anchor_

  def pagerank_weight(self): return self.pagerank_weight_

  def set_pagerank_weight(self, x):
    self.has_pagerank_weight_ = 1
    self.pagerank_weight_ = x

  def clear_pagerank_weight(self):
    self.has_pagerank_weight_ = 0
    self.pagerank_weight_ = 1.0

  def has_pagerank_weight(self): return self.has_pagerank_weight_

  def discovery_type(self): return self.discovery_type_

  def set_discovery_type(self, x):
    self.has_discovery_type_ = 1
    self.discovery_type_ = x

  def clear_discovery_type(self):
    self.has_discovery_type_ = 0
    self.discovery_type_ = 0

  def has_discovery_type(self): return self.has_discovery_type_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_url()): self.set_url(x.url())
    if (x.has_webmirror_info()): self.mutable_webmirror_info().MergeFrom(x.webmirror_info())
    if (x.has_anchor()): self.mutable_anchor().MergeFrom(x.anchor())
    if (x.has_pagerank_weight()): self.set_pagerank_weight(x.pagerank_weight())
    if (x.has_discovery_type()): self.set_discovery_type(x.discovery_type())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'content_converter.Link', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'content_converter.Link')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'content_converter.Link', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'content_converter.Link', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'content_converter.Link', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if self.has_webmirror_info_ != x.has_webmirror_info_: return 0
    if self.has_webmirror_info_ and self.webmirror_info_ != x.webmirror_info_: return 0
    if self.has_anchor_ != x.has_anchor_: return 0
    if self.has_anchor_ and self.anchor_ != x.anchor_: return 0
    if self.has_pagerank_weight_ != x.has_pagerank_weight_: return 0
    if self.has_pagerank_weight_ and self.pagerank_weight_ != x.pagerank_weight_: return 0
    if self.has_discovery_type_ != x.has_discovery_type_: return 0
    if self.has_discovery_type_ and self.discovery_type_ != x.discovery_type_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_url_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: url not set.')
    if (self.has_webmirror_info_ and not self.webmirror_info_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_anchor_ and not self.anchor_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.url_))
    if (self.has_webmirror_info_): n += 1 + self.lengthString(self.webmirror_info_.ByteSize())
    if (self.has_anchor_): n += 1 + self.lengthString(self.anchor_.ByteSize())
    if (self.has_pagerank_weight_): n += 6
    if (self.has_discovery_type_): n += 2 + self.lengthVarInt64(self.discovery_type_)
    return n + 1

  def Clear(self):
    self.clear_url()
    self.clear_webmirror_info()
    self.clear_anchor()
    self.clear_pagerank_weight()
    self.clear_discovery_type()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.url_)
    if (self.has_webmirror_info_):
      out.putVarInt32(18)
      out.putVarInt32(self.webmirror_info_.ByteSize())
      self.webmirror_info_.OutputUnchecked(out)
    if (self.has_anchor_):
      out.putVarInt32(26)
      out.putVarInt32(self.anchor_.ByteSize())
      self.anchor_.OutputUnchecked(out)
    if (self.has_pagerank_weight_):
      out.putVarInt32(133)
      out.putFloat(self.pagerank_weight_)
    if (self.has_discovery_type_):
      out.putVarInt32(136)
      out.putVarInt32(self.discovery_type_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_url(d.getPrefixedString())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_webmirror_info().TryMerge(tmp)
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_anchor().TryMerge(tmp)
        continue
      if tt == 133:
        self.set_pagerank_weight(d.getFloat())
        continue
      if tt == 136:
        self.set_discovery_type(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_url_: res+=prefix+("url: %s\n" % self.DebugFormatString(self.url_))
    if self.has_webmirror_info_:
      res+=prefix+"webmirror_info <\n"
      res+=self.webmirror_info_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_anchor_:
      res+=prefix+"anchor <\n"
      res+=self.anchor_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_pagerank_weight_: res+=prefix+("pagerank_weight: %s\n" % self.DebugFormatFloat(self.pagerank_weight_))
    if self.has_discovery_type_: res+=prefix+("discovery_type: %s\n" % self.DebugFormatInt32(self.discovery_type_))
    return res

  kurl = 1
  kwebmirror_info = 2
  kanchor = 3
  kpagerank_weight = 16
  kdiscovery_type = 17

  _TEXT = (
   "ErrorCode",  #   0
   "url",  #   1
   "webmirror_info",  #   2
   "anchor",  #   3
   None,  #   4
   None,  #   5
   None,  #   6
   None,  #   7
   None,  #   8
   None,  #   9
   None,  #  10
   None,  #  11
   None,  #  12
   None,  #  13
   None,  #  14
   None,  #  15
   "pagerank_weight",  #  16
   "discovery_type",  #  17
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.MAX_TYPE,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.MAX_TYPE,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.MAX_TYPE,  #   8

   ProtocolBuffer.Encoder.MAX_TYPE,  #   9

   ProtocolBuffer.Encoder.MAX_TYPE,  #  10

   ProtocolBuffer.Encoder.MAX_TYPE,  #  11

   ProtocolBuffer.Encoder.MAX_TYPE,  #  12

   ProtocolBuffer.Encoder.MAX_TYPE,  #  13

   ProtocolBuffer.Encoder.MAX_TYPE,  #  14

   ProtocolBuffer.Encoder.MAX_TYPE,  #  15

   ProtocolBuffer.Encoder.FLOAT,  #  16

   ProtocolBuffer.Encoder.NUMERIC,  #  17

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x29,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x63,
    0x6f,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x72,
    0x65,
    0x63,
    0x6f,
    0x72,
    0x64,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x16,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x63,
    0x6f,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x13,
    0x1a,
    0x03,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x77,
    0x65,
    0x62,
    0x6d,
    0x69,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x5f,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x1f,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x63,
    0x6f,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x57,
    0x65,
    0x62,
    0x6d,
    0x69,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x61,
    0x6e,
    0x63,
    0x68,
    0x6f,
    0x72,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x07,
    0x41,
    0x6e,
    0x63,
    0x68,
    0x6f,
    0x72,
    0x73,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x5f,
    0x77,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x10,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x42,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x64,
    0x69,
    0x73,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x79,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x11,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x0d,
    0x44,
    0x69,
    0x73,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x79,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x55,
    0x4e,
    0x4b,
    0x4e,
    0x4f,
    0x57,
    0x4e,
    0x5f,
    0x44,
    0x49,
    0x53,
    0x43,
    0x4f,
    0x56,
    0x45,
    0x52,
    0x59,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x1e,
    0x4a,
    0x41,
    0x56,
    0x41,
    0x53,
    0x43,
    0x52,
    0x49,
    0x50,
    0x54,
    0x5f,
    0x45,
    0x58,
    0x45,
    0x43,
    0x55,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x44,
    0x49,
    0x53,
    0x43,
    0x4f,
    0x56,
    0x45,
    0x52,
    0x59,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x23,
    0x4a,
    0x41,
    0x56,
    0x41,
    0x53,
    0x43,
    0x52,
    0x49,
    0x50,
    0x54,
    0x5f,
    0x46,
    0x4f,
    0x52,
    0x4d,
    0x5f,
    0x45,
    0x58,
    0x45,
    0x43,
    0x55,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x44,
    0x49,
    0x53,
    0x43,
    0x4f,
    0x56,
    0x45,
    0x52,
    0x59,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x19,
    0x46,
    0x4f,
    0x52,
    0x4d,
    0x5f,
    0x53,
    0x55,
    0x42,
    0x4d,
    0x49,
    0x53,
    0x53,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x44,
    0x49,
    0x53,
    0x43,
    0x4f,
    0x56,
    0x45,
    0x52,
    0x59,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class LinkRecord_PipelineSignals(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.pagerank_ = 0
    self.pagerank_ns_ = 0
    self.skip_during_indexing_ = 0
    self.skip_during_collapse_ = 0
    self.is_sitemove_penalized_source_ = 0
    self.has_pagerank_ = 0
    self.has_pagerank_ns_ = 0
    self.has_skip_during_indexing_ = 0
    self.has_skip_during_collapse_ = 0
    self.has_is_sitemove_penalized_source_ = 0
    if contents is not None: self.MergeFromString(contents)

  def pagerank(self): return self.pagerank_

  def set_pagerank(self, x):
    self.has_pagerank_ = 1
    self.pagerank_ = x

  def clear_pagerank(self):
    self.has_pagerank_ = 0
    self.pagerank_ = 0

  def has_pagerank(self): return self.has_pagerank_

  def pagerank_ns(self): return self.pagerank_ns_

  def set_pagerank_ns(self, x):
    self.has_pagerank_ns_ = 1
    self.pagerank_ns_ = x

  def clear_pagerank_ns(self):
    self.has_pagerank_ns_ = 0
    self.pagerank_ns_ = 0

  def has_pagerank_ns(self): return self.has_pagerank_ns_

  def skip_during_indexing(self): return self.skip_during_indexing_

  def set_skip_during_indexing(self, x):
    self.has_skip_during_indexing_ = 1
    self.skip_during_indexing_ = x

  def clear_skip_during_indexing(self):
    self.has_skip_during_indexing_ = 0
    self.skip_during_indexing_ = 0

  def has_skip_during_indexing(self): return self.has_skip_during_indexing_

  def skip_during_collapse(self): return self.skip_during_collapse_

  def set_skip_during_collapse(self, x):
    self.has_skip_during_collapse_ = 1
    self.skip_during_collapse_ = x

  def clear_skip_during_collapse(self):
    self.has_skip_during_collapse_ = 0
    self.skip_during_collapse_ = 0

  def has_skip_during_collapse(self): return self.has_skip_during_collapse_

  def is_sitemove_penalized_source(self): return self.is_sitemove_penalized_source_

  def set_is_sitemove_penalized_source(self, x):
    self.has_is_sitemove_penalized_source_ = 1
    self.is_sitemove_penalized_source_ = x

  def clear_is_sitemove_penalized_source(self):
    self.has_is_sitemove_penalized_source_ = 0
    self.is_sitemove_penalized_source_ = 0

  def has_is_sitemove_penalized_source(self): return self.has_is_sitemove_penalized_source_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_pagerank()): self.set_pagerank(x.pagerank())
    if (x.has_pagerank_ns()): self.set_pagerank_ns(x.pagerank_ns())
    if (x.has_skip_during_indexing()): self.set_skip_during_indexing(x.skip_during_indexing())
    if (x.has_skip_during_collapse()): self.set_skip_during_collapse(x.skip_during_collapse())
    if (x.has_is_sitemove_penalized_source()): self.set_is_sitemove_penalized_source(x.is_sitemove_penalized_source())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'content_converter.LinkRecord', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'content_converter.LinkRecord')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'content_converter.LinkRecord', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'content_converter.LinkRecord', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'content_converter.LinkRecord', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_pagerank_ != x.has_pagerank_: return 0
    if self.has_pagerank_ and self.pagerank_ != x.pagerank_: return 0
    if self.has_pagerank_ns_ != x.has_pagerank_ns_: return 0
    if self.has_pagerank_ns_ and self.pagerank_ns_ != x.pagerank_ns_: return 0
    if self.has_skip_during_indexing_ != x.has_skip_during_indexing_: return 0
    if self.has_skip_during_indexing_ and self.skip_during_indexing_ != x.skip_during_indexing_: return 0
    if self.has_skip_during_collapse_ != x.has_skip_during_collapse_: return 0
    if self.has_skip_during_collapse_ and self.skip_during_collapse_ != x.skip_during_collapse_: return 0
    if self.has_is_sitemove_penalized_source_ != x.has_is_sitemove_penalized_source_: return 0
    if self.has_is_sitemove_penalized_source_ and self.is_sitemove_penalized_source_ != x.is_sitemove_penalized_source_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_pagerank_): n += 2 + self.lengthVarInt64(self.pagerank_)
    if (self.has_pagerank_ns_): n += 2 + self.lengthVarInt64(self.pagerank_ns_)
    if (self.has_skip_during_indexing_): n += 3
    if (self.has_skip_during_collapse_): n += 3
    if (self.has_is_sitemove_penalized_source_): n += 3
    return n + 0

  def Clear(self):
    self.clear_pagerank()
    self.clear_pagerank_ns()
    self.clear_skip_during_indexing()
    self.clear_skip_during_collapse()
    self.clear_is_sitemove_penalized_source()

  def OutputUnchecked(self, out):
    if (self.has_pagerank_):
      out.putVarInt32(192)
      out.putVarInt32(self.pagerank_)
    if (self.has_skip_during_indexing_):
      out.putVarInt32(200)
      out.putBoolean(self.skip_during_indexing_)
    if (self.has_skip_during_collapse_):
      out.putVarInt32(208)
      out.putBoolean(self.skip_during_collapse_)
    if (self.has_pagerank_ns_):
      out.putVarInt32(216)
      out.putVarInt32(self.pagerank_ns_)
    if (self.has_is_sitemove_penalized_source_):
      out.putVarInt32(240)
      out.putBoolean(self.is_sitemove_penalized_source_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 188: break
      if tt == 192:
        self.set_pagerank(d.getVarInt32())
        continue
      if tt == 200:
        self.set_skip_during_indexing(d.getBoolean())
        continue
      if tt == 208:
        self.set_skip_during_collapse(d.getBoolean())
        continue
      if tt == 216:
        self.set_pagerank_ns(d.getVarInt32())
        continue
      if tt == 240:
        self.set_is_sitemove_penalized_source(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_pagerank_: res+=prefix+("pagerank: %s\n" % self.DebugFormatInt32(self.pagerank_))
    if self.has_pagerank_ns_: res+=prefix+("pagerank_ns: %s\n" % self.DebugFormatInt32(self.pagerank_ns_))
    if self.has_skip_during_indexing_: res+=prefix+("skip_during_indexing: %s\n" % self.DebugFormatBool(self.skip_during_indexing_))
    if self.has_skip_during_collapse_: res+=prefix+("skip_during_collapse: %s\n" % self.DebugFormatBool(self.skip_during_collapse_))
    if self.has_is_sitemove_penalized_source_: res+=prefix+("is_sitemove_penalized_source: %s\n" % self.DebugFormatBool(self.is_sitemove_penalized_source_))
    return res

class LinkRecord(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.url_ = ""
    self.page_webmirror_info_ = None
    self.timestamp_ = 0
    self.links_ = []
    self.per_doc_data_ = None
    self.label_data_ = None
    self.rank_boost_doc_attachment_ = None
    self.is_no_index_ = 0
    self.ipaddress_ = 0
    self.src_anchor_ = None
    self.pipelinesignals_ = None
    self.page_image_link_info_ = None
    self.is_redirect_ = 0
    self.delete_linkgraph_node_ = 0
    self.faked_from_microrepmap_ = 0
    self.faked_from_prnode_ = 0
    self.outlinkdegree_ = 0
    self.faked_from_linkextractor_ = 0
    self.has_url_ = 0
    self.has_page_webmirror_info_ = 0
    self.has_timestamp_ = 0
    self.has_per_doc_data_ = 0
    self.has_label_data_ = 0
    self.has_rank_boost_doc_attachment_ = 0
    self.has_is_no_index_ = 0
    self.has_ipaddress_ = 0
    self.has_src_anchor_ = 0
    self.has_pipelinesignals_ = 0
    self.has_page_image_link_info_ = 0
    self.has_is_redirect_ = 0
    self.has_delete_linkgraph_node_ = 0
    self.has_faked_from_microrepmap_ = 0
    self.has_faked_from_prnode_ = 0
    self.has_outlinkdegree_ = 0
    self.has_faked_from_linkextractor_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def page_webmirror_info(self):
    if self.page_webmirror_info_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.page_webmirror_info_ is None: self.page_webmirror_info_ = WebmirrorInfo()
      finally:
        self.lazy_init_lock_.release()
    return self.page_webmirror_info_

  def mutable_page_webmirror_info(self): self.has_page_webmirror_info_ = 1; return self.page_webmirror_info()

  def clear_page_webmirror_info(self):
    #Warning: this method does not acquire the lock.
    self.has_page_webmirror_info_ = 0;
    if self.page_webmirror_info_ is not None: self.page_webmirror_info_.Clear()

  def has_page_webmirror_info(self): return self.has_page_webmirror_info_

  def timestamp(self): return self.timestamp_

  def set_timestamp(self, x):
    self.has_timestamp_ = 1
    self.timestamp_ = x

  def clear_timestamp(self):
    self.has_timestamp_ = 0
    self.timestamp_ = 0

  def has_timestamp(self): return self.has_timestamp_

  def links_size(self): return len(self.links_)
  def links_list(self): return self.links_

  def links(self, i):
    return self.links_[i]

  def mutable_links(self, i):
    return self.links_[i]

  def add_links(self):
    x = Link()
    self.links_.append(x)
    return x

  def clear_links(self):
    self.links_ = []
  def per_doc_data(self):
    if self.per_doc_data_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.per_doc_data_ is None: self.per_doc_data_ = PerDocData()
      finally:
        self.lazy_init_lock_.release()
    return self.per_doc_data_

  def mutable_per_doc_data(self): self.has_per_doc_data_ = 1; return self.per_doc_data()

  def clear_per_doc_data(self):
    #Warning: this method does not acquire the lock.
    self.has_per_doc_data_ = 0;
    if self.per_doc_data_ is not None: self.per_doc_data_.Clear()

  def has_per_doc_data(self): return self.has_per_doc_data_

  def label_data(self):
    if self.label_data_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.label_data_ is None: self.label_data_ = GoogleLabelData()
      finally:
        self.lazy_init_lock_.release()
    return self.label_data_

  def mutable_label_data(self): self.has_label_data_ = 1; return self.label_data()

  def clear_label_data(self):
    #Warning: this method does not acquire the lock.
    self.has_label_data_ = 0;
    if self.label_data_ is not None: self.label_data_.Clear()

  def has_label_data(self): return self.has_label_data_

  def rank_boost_doc_attachment(self):
    if self.rank_boost_doc_attachment_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.rank_boost_doc_attachment_ is None: self.rank_boost_doc_attachment_ = RankBoostDocAttachment()
      finally:
        self.lazy_init_lock_.release()
    return self.rank_boost_doc_attachment_

  def mutable_rank_boost_doc_attachment(self): self.has_rank_boost_doc_attachment_ = 1; return self.rank_boost_doc_attachment()

  def clear_rank_boost_doc_attachment(self):
    #Warning: this method does not acquire the lock.
    self.has_rank_boost_doc_attachment_ = 0;
    if self.rank_boost_doc_attachment_ is not None: self.rank_boost_doc_attachment_.Clear()

  def has_rank_boost_doc_attachment(self): return self.has_rank_boost_doc_attachment_

  def is_no_index(self): return self.is_no_index_

  def set_is_no_index(self, x):
    self.has_is_no_index_ = 1
    self.is_no_index_ = x

  def clear_is_no_index(self):
    self.has_is_no_index_ = 0
    self.is_no_index_ = 0

  def has_is_no_index(self): return self.has_is_no_index_

  def ipaddress(self): return self.ipaddress_

  def set_ipaddress(self, x):
    self.has_ipaddress_ = 1
    self.ipaddress_ = x

  def clear_ipaddress(self):
    self.has_ipaddress_ = 0
    self.ipaddress_ = 0

  def has_ipaddress(self): return self.has_ipaddress_

  def src_anchor(self):
    if self.src_anchor_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.src_anchor_ is None: self.src_anchor_ = Anchors()
      finally:
        self.lazy_init_lock_.release()
    return self.src_anchor_

  def mutable_src_anchor(self): self.has_src_anchor_ = 1; return self.src_anchor()

  def clear_src_anchor(self):
    #Warning: this method does not acquire the lock.
    self.has_src_anchor_ = 0;
    if self.src_anchor_ is not None: self.src_anchor_.Clear()

  def has_src_anchor(self): return self.has_src_anchor_

  def pipelinesignals(self):
    if self.pipelinesignals_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.pipelinesignals_ is None: self.pipelinesignals_ = LinkRecord_PipelineSignals()
      finally:
        self.lazy_init_lock_.release()
    return self.pipelinesignals_

  def mutable_pipelinesignals(self): self.has_pipelinesignals_ = 1; return self.pipelinesignals()

  def clear_pipelinesignals(self):
    #Warning: this method does not acquire the lock.
    self.has_pipelinesignals_ = 0;
    if self.pipelinesignals_ is not None: self.pipelinesignals_.Clear()

  def has_pipelinesignals(self): return self.has_pipelinesignals_

  def page_image_link_info(self):
    if self.page_image_link_info_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.page_image_link_info_ is None: self.page_image_link_info_ = PageImageLinkInfo()
      finally:
        self.lazy_init_lock_.release()
    return self.page_image_link_info_

  def mutable_page_image_link_info(self): self.has_page_image_link_info_ = 1; return self.page_image_link_info()

  def clear_page_image_link_info(self):
    #Warning: this method does not acquire the lock.
    self.has_page_image_link_info_ = 0;
    if self.page_image_link_info_ is not None: self.page_image_link_info_.Clear()

  def has_page_image_link_info(self): return self.has_page_image_link_info_

  def is_redirect(self): return self.is_redirect_

  def set_is_redirect(self, x):
    self.has_is_redirect_ = 1
    self.is_redirect_ = x

  def clear_is_redirect(self):
    self.has_is_redirect_ = 0
    self.is_redirect_ = 0

  def has_is_redirect(self): return self.has_is_redirect_

  def delete_linkgraph_node(self): return self.delete_linkgraph_node_

  def set_delete_linkgraph_node(self, x):
    self.has_delete_linkgraph_node_ = 1
    self.delete_linkgraph_node_ = x

  def clear_delete_linkgraph_node(self):
    self.has_delete_linkgraph_node_ = 0
    self.delete_linkgraph_node_ = 0

  def has_delete_linkgraph_node(self): return self.has_delete_linkgraph_node_

  def faked_from_microrepmap(self): return self.faked_from_microrepmap_

  def set_faked_from_microrepmap(self, x):
    self.has_faked_from_microrepmap_ = 1
    self.faked_from_microrepmap_ = x

  def clear_faked_from_microrepmap(self):
    self.has_faked_from_microrepmap_ = 0
    self.faked_from_microrepmap_ = 0

  def has_faked_from_microrepmap(self): return self.has_faked_from_microrepmap_

  def faked_from_prnode(self): return self.faked_from_prnode_

  def set_faked_from_prnode(self, x):
    self.has_faked_from_prnode_ = 1
    self.faked_from_prnode_ = x

  def clear_faked_from_prnode(self):
    self.has_faked_from_prnode_ = 0
    self.faked_from_prnode_ = 0

  def has_faked_from_prnode(self): return self.has_faked_from_prnode_

  def outlinkdegree(self): return self.outlinkdegree_

  def set_outlinkdegree(self, x):
    self.has_outlinkdegree_ = 1
    self.outlinkdegree_ = x

  def clear_outlinkdegree(self):
    self.has_outlinkdegree_ = 0
    self.outlinkdegree_ = 0

  def has_outlinkdegree(self): return self.has_outlinkdegree_

  def faked_from_linkextractor(self): return self.faked_from_linkextractor_

  def set_faked_from_linkextractor(self, x):
    self.has_faked_from_linkextractor_ = 1
    self.faked_from_linkextractor_ = x

  def clear_faked_from_linkextractor(self):
    self.has_faked_from_linkextractor_ = 0
    self.faked_from_linkextractor_ = 0

  def has_faked_from_linkextractor(self): return self.has_faked_from_linkextractor_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_url()): self.set_url(x.url())
    if (x.has_page_webmirror_info()): self.mutable_page_webmirror_info().MergeFrom(x.page_webmirror_info())
    if (x.has_timestamp()): self.set_timestamp(x.timestamp())
    for i in xrange(x.links_size()): self.add_links().CopyFrom(x.links(i))
    if (x.has_per_doc_data()): self.mutable_per_doc_data().MergeFrom(x.per_doc_data())
    if (x.has_label_data()): self.mutable_label_data().MergeFrom(x.label_data())
    if (x.has_rank_boost_doc_attachment()): self.mutable_rank_boost_doc_attachment().MergeFrom(x.rank_boost_doc_attachment())
    if (x.has_is_no_index()): self.set_is_no_index(x.is_no_index())
    if (x.has_ipaddress()): self.set_ipaddress(x.ipaddress())
    if (x.has_src_anchor()): self.mutable_src_anchor().MergeFrom(x.src_anchor())
    if (x.has_pipelinesignals()): self.mutable_pipelinesignals().MergeFrom(x.pipelinesignals())
    if (x.has_page_image_link_info()): self.mutable_page_image_link_info().MergeFrom(x.page_image_link_info())
    if (x.has_is_redirect()): self.set_is_redirect(x.is_redirect())
    if (x.has_delete_linkgraph_node()): self.set_delete_linkgraph_node(x.delete_linkgraph_node())
    if (x.has_faked_from_microrepmap()): self.set_faked_from_microrepmap(x.faked_from_microrepmap())
    if (x.has_faked_from_prnode()): self.set_faked_from_prnode(x.faked_from_prnode())
    if (x.has_outlinkdegree()): self.set_outlinkdegree(x.outlinkdegree())
    if (x.has_faked_from_linkextractor()): self.set_faked_from_linkextractor(x.faked_from_linkextractor())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'content_converter.LinkRecord', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'content_converter.LinkRecord')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'content_converter.LinkRecord', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'content_converter.LinkRecord', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'content_converter.LinkRecord', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if self.has_page_webmirror_info_ != x.has_page_webmirror_info_: return 0
    if self.has_page_webmirror_info_ and self.page_webmirror_info_ != x.page_webmirror_info_: return 0
    if self.has_timestamp_ != x.has_timestamp_: return 0
    if self.has_timestamp_ and self.timestamp_ != x.timestamp_: return 0
    if len(self.links_) != len(x.links_): return 0
    for e1, e2 in zip(self.links_, x.links_):
      if e1 != e2: return 0
    if self.has_per_doc_data_ != x.has_per_doc_data_: return 0
    if self.has_per_doc_data_ and self.per_doc_data_ != x.per_doc_data_: return 0
    if self.has_label_data_ != x.has_label_data_: return 0
    if self.has_label_data_ and self.label_data_ != x.label_data_: return 0
    if self.has_rank_boost_doc_attachment_ != x.has_rank_boost_doc_attachment_: return 0
    if self.has_rank_boost_doc_attachment_ and self.rank_boost_doc_attachment_ != x.rank_boost_doc_attachment_: return 0
    if self.has_is_no_index_ != x.has_is_no_index_: return 0
    if self.has_is_no_index_ and self.is_no_index_ != x.is_no_index_: return 0
    if self.has_ipaddress_ != x.has_ipaddress_: return 0
    if self.has_ipaddress_ and self.ipaddress_ != x.ipaddress_: return 0
    if self.has_src_anchor_ != x.has_src_anchor_: return 0
    if self.has_src_anchor_ and self.src_anchor_ != x.src_anchor_: return 0
    if self.has_pipelinesignals_ != x.has_pipelinesignals_: return 0
    if self.has_pipelinesignals_ and self.pipelinesignals_ != x.pipelinesignals_: return 0
    if self.has_page_image_link_info_ != x.has_page_image_link_info_: return 0
    if self.has_page_image_link_info_ and self.page_image_link_info_ != x.page_image_link_info_: return 0
    if self.has_is_redirect_ != x.has_is_redirect_: return 0
    if self.has_is_redirect_ and self.is_redirect_ != x.is_redirect_: return 0
    if self.has_delete_linkgraph_node_ != x.has_delete_linkgraph_node_: return 0
    if self.has_delete_linkgraph_node_ and self.delete_linkgraph_node_ != x.delete_linkgraph_node_: return 0
    if self.has_faked_from_microrepmap_ != x.has_faked_from_microrepmap_: return 0
    if self.has_faked_from_microrepmap_ and self.faked_from_microrepmap_ != x.faked_from_microrepmap_: return 0
    if self.has_faked_from_prnode_ != x.has_faked_from_prnode_: return 0
    if self.has_faked_from_prnode_ and self.faked_from_prnode_ != x.faked_from_prnode_: return 0
    if self.has_outlinkdegree_ != x.has_outlinkdegree_: return 0
    if self.has_outlinkdegree_ and self.outlinkdegree_ != x.outlinkdegree_: return 0
    if self.has_faked_from_linkextractor_ != x.has_faked_from_linkextractor_: return 0
    if self.has_faked_from_linkextractor_ and self.faked_from_linkextractor_ != x.faked_from_linkextractor_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_url_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: url not set.')
    if (self.has_page_webmirror_info_ and not self.page_webmirror_info_.IsInitialized(debug_strs)): initialized = 0
    if (not self.has_timestamp_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: timestamp not set.')
    for i in xrange(len(self.links_)):
      if (not self.links_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_per_doc_data_ and not self.per_doc_data_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_label_data_ and not self.label_data_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_rank_boost_doc_attachment_ and not self.rank_boost_doc_attachment_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_src_anchor_ and not self.src_anchor_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_pipelinesignals_ and not self.pipelinesignals_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_page_image_link_info_ and not self.page_image_link_info_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.url_))
    if (self.has_page_webmirror_info_): n += 1 + self.lengthString(self.page_webmirror_info_.ByteSize())
    n += self.lengthVarInt64(self.timestamp_)
    n += 1 * len(self.links_)
    for i in xrange(len(self.links_)): n += self.lengthString(self.links_[i].ByteSize())
    if (self.has_per_doc_data_): n += 1 + self.lengthString(self.per_doc_data_.ByteSize())
    if (self.has_label_data_): n += 1 + self.lengthString(self.label_data_.ByteSize())
    if (self.has_rank_boost_doc_attachment_): n += 1 + self.lengthString(self.rank_boost_doc_attachment_.ByteSize())
    if (self.has_is_no_index_): n += 2
    if (self.has_ipaddress_): n += 1 + self.lengthVarInt64(self.ipaddress_)
    if (self.has_src_anchor_): n += 1 + self.lengthString(self.src_anchor_.ByteSize())
    if (self.has_pipelinesignals_): n += 4 + self.pipelinesignals_.ByteSize()
    if (self.has_page_image_link_info_): n += 1 + self.lengthString(self.page_image_link_info_.ByteSize())
    if (self.has_is_redirect_): n += 3
    if (self.has_delete_linkgraph_node_): n += 3
    if (self.has_faked_from_microrepmap_): n += 3
    if (self.has_faked_from_prnode_): n += 3
    if (self.has_outlinkdegree_): n += 2 + self.lengthVarInt64(self.outlinkdegree_)
    if (self.has_faked_from_linkextractor_): n += 3
    return n + 2

  def Clear(self):
    self.clear_url()
    self.clear_page_webmirror_info()
    self.clear_timestamp()
    self.clear_links()
    self.clear_per_doc_data()
    self.clear_label_data()
    self.clear_rank_boost_doc_attachment()
    self.clear_is_no_index()
    self.clear_ipaddress()
    self.clear_src_anchor()
    self.clear_pipelinesignals()
    self.clear_page_image_link_info()
    self.clear_is_redirect()
    self.clear_delete_linkgraph_node()
    self.clear_faked_from_microrepmap()
    self.clear_faked_from_prnode()
    self.clear_outlinkdegree()
    self.clear_faked_from_linkextractor()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.url_)
    if (self.has_page_webmirror_info_):
      out.putVarInt32(18)
      out.putVarInt32(self.page_webmirror_info_.ByteSize())
      self.page_webmirror_info_.OutputUnchecked(out)
    out.putVarInt32(24)
    out.putVarInt32(self.timestamp_)
    for i in xrange(len(self.links_)):
      out.putVarInt32(34)
      out.putVarInt32(self.links_[i].ByteSize())
      self.links_[i].OutputUnchecked(out)
    if (self.has_per_doc_data_):
      out.putVarInt32(42)
      out.putVarInt32(self.per_doc_data_.ByteSize())
      self.per_doc_data_.OutputUnchecked(out)
    if (self.has_label_data_):
      out.putVarInt32(50)
      out.putVarInt32(self.label_data_.ByteSize())
      self.label_data_.OutputUnchecked(out)
    if (self.has_ipaddress_):
      out.putVarInt32(56)
      out.putVarInt64(self.ipaddress_)
    if (self.has_is_no_index_):
      out.putVarInt32(64)
      out.putBoolean(self.is_no_index_)
    if (self.has_rank_boost_doc_attachment_):
      out.putVarInt32(74)
      out.putVarInt32(self.rank_boost_doc_attachment_.ByteSize())
      self.rank_boost_doc_attachment_.OutputUnchecked(out)
    if (self.has_src_anchor_):
      out.putVarInt32(82)
      out.putVarInt32(self.src_anchor_.ByteSize())
      self.src_anchor_.OutputUnchecked(out)
    if (self.has_page_image_link_info_):
      out.putVarInt32(90)
      out.putVarInt32(self.page_image_link_info_.ByteSize())
      self.page_image_link_info_.OutputUnchecked(out)
    if (self.has_is_redirect_):
      out.putVarInt32(160)
      out.putBoolean(self.is_redirect_)
    if (self.has_delete_linkgraph_node_):
      out.putVarInt32(168)
      out.putBoolean(self.delete_linkgraph_node_)
    if (self.has_faked_from_microrepmap_):
      out.putVarInt32(176)
      out.putBoolean(self.faked_from_microrepmap_)
    if (self.has_pipelinesignals_):
      out.putVarInt32(187)
      self.pipelinesignals_.OutputUnchecked(out)
      out.putVarInt32(188)
    if (self.has_faked_from_prnode_):
      out.putVarInt32(224)
      out.putBoolean(self.faked_from_prnode_)
    if (self.has_outlinkdegree_):
      out.putVarInt32(232)
      out.putVarInt32(self.outlinkdegree_)
    if (self.has_faked_from_linkextractor_):
      out.putVarInt32(248)
      out.putBoolean(self.faked_from_linkextractor_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_url(d.getPrefixedString())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_page_webmirror_info().TryMerge(tmp)
        continue
      if tt == 24:
        self.set_timestamp(d.getVarInt32())
        continue
      if tt == 34:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_links().TryMerge(tmp)
        continue
      if tt == 42:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_per_doc_data().TryMerge(tmp)
        continue
      if tt == 50:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_label_data().TryMerge(tmp)
        continue
      if tt == 56:
        self.set_ipaddress(d.getVarInt64())
        continue
      if tt == 64:
        self.set_is_no_index(d.getBoolean())
        continue
      if tt == 74:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_rank_boost_doc_attachment().TryMerge(tmp)
        continue
      if tt == 82:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_src_anchor().TryMerge(tmp)
        continue
      if tt == 90:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_page_image_link_info().TryMerge(tmp)
        continue
      if tt == 160:
        self.set_is_redirect(d.getBoolean())
        continue
      if tt == 168:
        self.set_delete_linkgraph_node(d.getBoolean())
        continue
      if tt == 176:
        self.set_faked_from_microrepmap(d.getBoolean())
        continue
      if tt == 187:
        self.mutable_pipelinesignals().TryMerge(d)
        continue
      if tt == 224:
        self.set_faked_from_prnode(d.getBoolean())
        continue
      if tt == 232:
        self.set_outlinkdegree(d.getVarInt32())
        continue
      if tt == 248:
        self.set_faked_from_linkextractor(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_url_: res+=prefix+("url: %s\n" % self.DebugFormatString(self.url_))
    if self.has_page_webmirror_info_:
      res+=prefix+"page_webmirror_info <\n"
      res+=self.page_webmirror_info_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_timestamp_: res+=prefix+("timestamp: %s\n" % self.DebugFormatInt32(self.timestamp_))
    cnt=0
    for e in self.links_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("links%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_per_doc_data_:
      res+=prefix+"per_doc_data <\n"
      res+=self.per_doc_data_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_label_data_:
      res+=prefix+"label_data <\n"
      res+=self.label_data_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_rank_boost_doc_attachment_:
      res+=prefix+"rank_boost_doc_attachment <\n"
      res+=self.rank_boost_doc_attachment_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_is_no_index_: res+=prefix+("is_no_index: %s\n" % self.DebugFormatBool(self.is_no_index_))
    if self.has_ipaddress_: res+=prefix+("ipaddress: %s\n" % self.DebugFormatInt64(self.ipaddress_))
    if self.has_src_anchor_:
      res+=prefix+"src_anchor <\n"
      res+=self.src_anchor_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_pipelinesignals_:
      res+=prefix+"PipelineSignals {\n"
      res+=self.pipelinesignals_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_page_image_link_info_:
      res+=prefix+"page_image_link_info <\n"
      res+=self.page_image_link_info_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_is_redirect_: res+=prefix+("is_redirect: %s\n" % self.DebugFormatBool(self.is_redirect_))
    if self.has_delete_linkgraph_node_: res+=prefix+("delete_linkgraph_node: %s\n" % self.DebugFormatBool(self.delete_linkgraph_node_))
    if self.has_faked_from_microrepmap_: res+=prefix+("faked_from_microrepmap: %s\n" % self.DebugFormatBool(self.faked_from_microrepmap_))
    if self.has_faked_from_prnode_: res+=prefix+("faked_from_prnode: %s\n" % self.DebugFormatBool(self.faked_from_prnode_))
    if self.has_outlinkdegree_: res+=prefix+("outlinkdegree: %s\n" % self.DebugFormatInt32(self.outlinkdegree_))
    if self.has_faked_from_linkextractor_: res+=prefix+("faked_from_linkextractor: %s\n" % self.DebugFormatBool(self.faked_from_linkextractor_))
    return res

  kurl = 1
  kpage_webmirror_info = 2
  ktimestamp = 3
  klinks = 4
  kper_doc_data = 5
  klabel_data = 6
  krank_boost_doc_attachment = 9
  kis_no_index = 8
  kipaddress = 7
  ksrc_anchor = 10
  kPipelineSignalsGroup = 23
  kPipelineSignalspagerank = 24
  kPipelineSignalspagerank_ns = 27
  kPipelineSignalsskip_during_indexing = 25
  kPipelineSignalsskip_during_collapse = 26
  kPipelineSignalsis_sitemove_penalized_source = 30
  kpage_image_link_info = 11
  kis_redirect = 20
  kdelete_linkgraph_node = 21
  kfaked_from_microrepmap = 22
  kfaked_from_prnode = 28
  koutlinkdegree = 29
  kfaked_from_linkextractor = 31

  _TEXT = (
   "ErrorCode",  #   0
   "url",  #   1
   "page_webmirror_info",  #   2
   "timestamp",  #   3
   "links",  #   4
   "per_doc_data",  #   5
   "label_data",  #   6
   "ipaddress",  #   7
   "is_no_index",  #   8
   "rank_boost_doc_attachment",  #   9
   "src_anchor",  #  10
   "page_image_link_info",  #  11
   None,  #  12
   None,  #  13
   None,  #  14
   None,  #  15
   None,  #  16
   None,  #  17
   None,  #  18
   None,  #  19
   "is_redirect",  #  20
   "delete_linkgraph_node",  #  21
   "faked_from_microrepmap",  #  22
   "PipelineSignals",  #  23
   "pagerank",  #  24
   "skip_during_indexing",  #  25
   "skip_during_collapse",  #  26
   "pagerank_ns",  #  27
   "faked_from_prnode",  #  28
   "outlinkdegree",  #  29
   "is_sitemove_penalized_source",  #  30
   "faked_from_linkextractor",  #  31
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.STRING,  #  10

   ProtocolBuffer.Encoder.STRING,  #  11

   ProtocolBuffer.Encoder.MAX_TYPE,  #  12

   ProtocolBuffer.Encoder.MAX_TYPE,  #  13

   ProtocolBuffer.Encoder.MAX_TYPE,  #  14

   ProtocolBuffer.Encoder.MAX_TYPE,  #  15

   ProtocolBuffer.Encoder.MAX_TYPE,  #  16

   ProtocolBuffer.Encoder.MAX_TYPE,  #  17

   ProtocolBuffer.Encoder.MAX_TYPE,  #  18

   ProtocolBuffer.Encoder.MAX_TYPE,  #  19

   ProtocolBuffer.Encoder.NUMERIC,  #  20

   ProtocolBuffer.Encoder.NUMERIC,  #  21

   ProtocolBuffer.Encoder.NUMERIC,  #  22

   ProtocolBuffer.Encoder.STARTGROUP,  #  23

   ProtocolBuffer.Encoder.NUMERIC,  #  24

   ProtocolBuffer.Encoder.NUMERIC,  #  25

   ProtocolBuffer.Encoder.NUMERIC,  #  26

   ProtocolBuffer.Encoder.NUMERIC,  #  27

   ProtocolBuffer.Encoder.NUMERIC,  #  28

   ProtocolBuffer.Encoder.NUMERIC,  #  29

   ProtocolBuffer.Encoder.NUMERIC,  #  30

   ProtocolBuffer.Encoder.NUMERIC,  #  31

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x29,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x63,
    0x6f,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x72,
    0x65,
    0x63,
    0x6f,
    0x72,
    0x64,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1c,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x63,
    0x6f,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x52,
    0x65,
    0x63,
    0x6f,
    0x72,
    0x64,
    0x13,
    0x1a,
    0x03,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x77,
    0x65,
    0x62,
    0x6d,
    0x69,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x5f,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x1f,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x63,
    0x6f,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x57,
    0x65,
    0x62,
    0x6d,
    0x69,
    0x72,
    0x72,
    0x6f,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x74,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x73,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x16,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x63,
    0x6f,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x70,
    0x65,
    0x72,
    0x5f,
    0x64,
    0x6f,
    0x63,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0a,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x6c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x1e,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x5f,
    0x6c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x73,
    0x2e,
    0x47,
    0x6f,
    0x6f,
    0x67,
    0x6c,
    0x65,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x44,
    0x61,
    0x74,
    0x61,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x5f,
    0x62,
    0x6f,
    0x6f,
    0x73,
    0x74,
    0x5f,
    0x64,
    0x6f,
    0x63,
    0x5f,
    0x61,
    0x74,
    0x74,
    0x61,
    0x63,
    0x68,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x16,
    0x52,
    0x61,
    0x6e,
    0x6b,
    0x42,
    0x6f,
    0x6f,
    0x73,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x41,
    0x74,
    0x74,
    0x61,
    0x63,
    0x68,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x69,
    0x73,
    0x5f,
    0x6e,
    0x6f,
    0x5f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x69,
    0x70,
    0x61,
    0x64,
    0x64,
    0x72,
    0x65,
    0x73,
    0x73,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x73,
    0x72,
    0x63,
    0x5f,
    0x61,
    0x6e,
    0x63,
    0x68,
    0x6f,
    0x72,
    0x20,
    0x0a,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x07,
    0x41,
    0x6e,
    0x63,
    0x68,
    0x6f,
    0x72,
    0x73,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x50,
    0x69,
    0x70,
    0x65,
    0x6c,
    0x69,
    0x6e,
    0x65,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x73,
    0x20,
    0x17,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x50,
    0x69,
    0x70,
    0x65,
    0x6c,
    0x69,
    0x6e,
    0x65,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x73,
    0x2e,
    0x70,
    0x61,
    0x67,
    0x65,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x18,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x50,
    0x69,
    0x70,
    0x65,
    0x6c,
    0x69,
    0x6e,
    0x65,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x73,
    0x2e,
    0x70,
    0x61,
    0x67,
    0x65,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x5f,
    0x6e,
    0x73,
    0x20,
    0x1b,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x24,
    0x50,
    0x69,
    0x70,
    0x65,
    0x6c,
    0x69,
    0x6e,
    0x65,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x73,
    0x2e,
    0x73,
    0x6b,
    0x69,
    0x70,
    0x5f,
    0x64,
    0x75,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x5f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x19,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x0a,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x24,
    0x50,
    0x69,
    0x70,
    0x65,
    0x6c,
    0x69,
    0x6e,
    0x65,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x73,
    0x2e,
    0x73,
    0x6b,
    0x69,
    0x70,
    0x5f,
    0x64,
    0x75,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x5f,
    0x63,
    0x6f,
    0x6c,
    0x6c,
    0x61,
    0x70,
    0x73,
    0x65,
    0x20,
    0x1a,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x0a,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x2c,
    0x50,
    0x69,
    0x70,
    0x65,
    0x6c,
    0x69,
    0x6e,
    0x65,
    0x53,
    0x69,
    0x67,
    0x6e,
    0x61,
    0x6c,
    0x73,
    0x2e,
    0x69,
    0x73,
    0x5f,
    0x73,
    0x69,
    0x74,
    0x65,
    0x6d,
    0x6f,
    0x76,
    0x65,
    0x5f,
    0x70,
    0x65,
    0x6e,
    0x61,
    0x6c,
    0x69,
    0x7a,
    0x65,
    0x64,
    0x5f,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x20,
    0x1e,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x0a,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x69,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x5f,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x0b,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x1f,
    0x69,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x6d,
    0x75,
    0x73,
    0x74,
    0x61,
    0x6e,
    0x67,
    0x2e,
    0x50,
    0x61,
    0x67,
    0x65,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x69,
    0x73,
    0x5f,
    0x72,
    0x65,
    0x64,
    0x69,
    0x72,
    0x65,
    0x63,
    0x74,
    0x20,
    0x14,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x64,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x5f,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x67,
    0x72,
    0x61,
    0x70,
    0x68,
    0x5f,
    0x6e,
    0x6f,
    0x64,
    0x65,
    0x20,
    0x15,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x66,
    0x61,
    0x6b,
    0x65,
    0x64,
    0x5f,
    0x66,
    0x72,
    0x6f,
    0x6d,
    0x5f,
    0x6d,
    0x69,
    0x63,
    0x72,
    0x6f,
    0x72,
    0x65,
    0x70,
    0x6d,
    0x61,
    0x70,
    0x20,
    0x16,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x66,
    0x61,
    0x6b,
    0x65,
    0x64,
    0x5f,
    0x66,
    0x72,
    0x6f,
    0x6d,
    0x5f,
    0x70,
    0x72,
    0x6e,
    0x6f,
    0x64,
    0x65,
    0x20,
    0x1c,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x6f,
    0x75,
    0x74,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x64,
    0x65,
    0x67,
    0x72,
    0x65,
    0x65,
    0x20,
    0x1d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x66,
    0x61,
    0x6b,
    0x65,
    0x64,
    0x5f,
    0x66,
    0x72,
    0x6f,
    0x6d,
    0x5f,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x65,
    0x78,
    0x74,
    0x72,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x20,
    0x1f,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class CandidateUrlClientInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.is_no_follow_ = 0
    self.has_is_no_follow_ = 0
    if contents is not None: self.MergeFromString(contents)

  def is_no_follow(self): return self.is_no_follow_

  def set_is_no_follow(self, x):
    self.has_is_no_follow_ = 1
    self.is_no_follow_ = x

  def clear_is_no_follow(self):
    self.has_is_no_follow_ = 0
    self.is_no_follow_ = 0

  def has_is_no_follow(self): return self.has_is_no_follow_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_is_no_follow()): self.set_is_no_follow(x.is_no_follow())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'content_converter.CandidateUrlClientInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'content_converter.CandidateUrlClientInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'content_converter.CandidateUrlClientInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'content_converter.CandidateUrlClientInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'content_converter.CandidateUrlClientInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_is_no_follow_ != x.has_is_no_follow_: return 0
    if self.has_is_no_follow_ and self.is_no_follow_ != x.is_no_follow_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_is_no_follow_): n += 2
    return n + 0

  def Clear(self):
    self.clear_is_no_follow()

  def OutputUnchecked(self, out):
    if (self.has_is_no_follow_):
      out.putVarInt32(8)
      out.putBoolean(self.is_no_follow_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_is_no_follow(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_is_no_follow_: res+=prefix+("is_no_follow: %s\n" % self.DebugFormatBool(self.is_no_follow_))
    return res

  kis_no_follow = 1

  _TEXT = (
   "ErrorCode",  #   0
   "is_no_follow",  #   1
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x29,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x63,
    0x6f,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x74,
    0x65,
    0x72,
    0x2f,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x72,
    0x65,
    0x63,
    0x6f,
    0x72,
    0x64,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x28,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x63,
    0x6f,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x43,
    0x61,
    0x6e,
    0x64,
    0x69,
    0x64,
    0x61,
    0x74,
    0x65,
    0x55,
    0x72,
    0x6c,
    0x43,
    0x6c,
    0x69,
    0x65,
    0x6e,
    0x74,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x13,
    0x1a,
    0x0c,
    0x69,
    0x73,
    0x5f,
    0x6e,
    0x6f,
    0x5f,
    0x66,
    0x6f,
    0x6c,
    0x6c,
    0x6f,
    0x77,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['WebmirrorInfo','Link','LinkRecord','LinkRecord_PipelineSignals','CandidateUrlClientInfo']
