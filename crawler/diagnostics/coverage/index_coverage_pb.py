# This file automatically generated by protocol-compiler from crawler/diagnostics/coverage/index_coverage.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

class IndexCoverage(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 4238691 

  _TypeId_NAMES = {
    4238691: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.shown_ = 0
    self.chances_ = 0
    self.clicks_good_ = 0
    self.clicks_bad_ = 0
    self.clicks_unclassified_ = 0
    self.ctr_weighted_impressions_ = 0.0
    self.clicks_long_ = 0
    self.has_shown_ = 0
    self.has_chances_ = 0
    self.has_clicks_good_ = 0
    self.has_clicks_bad_ = 0
    self.has_clicks_unclassified_ = 0
    self.has_ctr_weighted_impressions_ = 0
    self.has_clicks_long_ = 0
    if contents is not None: self.MergeFromString(contents)

  def shown(self): return self.shown_

  def set_shown(self, x):
    self.has_shown_ = 1
    self.shown_ = x

  def clear_shown(self):
    self.has_shown_ = 0
    self.shown_ = 0

  def has_shown(self): return self.has_shown_

  def chances(self): return self.chances_

  def set_chances(self, x):
    self.has_chances_ = 1
    self.chances_ = x

  def clear_chances(self):
    self.has_chances_ = 0
    self.chances_ = 0

  def has_chances(self): return self.has_chances_

  def clicks_good(self): return self.clicks_good_

  def set_clicks_good(self, x):
    self.has_clicks_good_ = 1
    self.clicks_good_ = x

  def clear_clicks_good(self):
    self.has_clicks_good_ = 0
    self.clicks_good_ = 0

  def has_clicks_good(self): return self.has_clicks_good_

  def clicks_bad(self): return self.clicks_bad_

  def set_clicks_bad(self, x):
    self.has_clicks_bad_ = 1
    self.clicks_bad_ = x

  def clear_clicks_bad(self):
    self.has_clicks_bad_ = 0
    self.clicks_bad_ = 0

  def has_clicks_bad(self): return self.has_clicks_bad_

  def clicks_unclassified(self): return self.clicks_unclassified_

  def set_clicks_unclassified(self, x):
    self.has_clicks_unclassified_ = 1
    self.clicks_unclassified_ = x

  def clear_clicks_unclassified(self):
    self.has_clicks_unclassified_ = 0
    self.clicks_unclassified_ = 0

  def has_clicks_unclassified(self): return self.has_clicks_unclassified_

  def ctr_weighted_impressions(self): return self.ctr_weighted_impressions_

  def set_ctr_weighted_impressions(self, x):
    self.has_ctr_weighted_impressions_ = 1
    self.ctr_weighted_impressions_ = x

  def clear_ctr_weighted_impressions(self):
    self.has_ctr_weighted_impressions_ = 0
    self.ctr_weighted_impressions_ = 0.0

  def has_ctr_weighted_impressions(self): return self.has_ctr_weighted_impressions_

  def clicks_long(self): return self.clicks_long_

  def set_clicks_long(self, x):
    self.has_clicks_long_ = 1
    self.clicks_long_ = x

  def clear_clicks_long(self):
    self.has_clicks_long_ = 0
    self.clicks_long_ = 0

  def has_clicks_long(self): return self.has_clicks_long_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_shown()): self.set_shown(x.shown())
    if (x.has_chances()): self.set_chances(x.chances())
    if (x.has_clicks_good()): self.set_clicks_good(x.clicks_good())
    if (x.has_clicks_bad()): self.set_clicks_bad(x.clicks_bad())
    if (x.has_clicks_unclassified()): self.set_clicks_unclassified(x.clicks_unclassified())
    if (x.has_ctr_weighted_impressions()): self.set_ctr_weighted_impressions(x.ctr_weighted_impressions())
    if (x.has_clicks_long()): self.set_clicks_long(x.clicks_long())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.IndexCoverage', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.IndexCoverage')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.IndexCoverage', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.IndexCoverage', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.IndexCoverage', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_shown_ != x.has_shown_: return 0
    if self.has_shown_ and self.shown_ != x.shown_: return 0
    if self.has_chances_ != x.has_chances_: return 0
    if self.has_chances_ and self.chances_ != x.chances_: return 0
    if self.has_clicks_good_ != x.has_clicks_good_: return 0
    if self.has_clicks_good_ and self.clicks_good_ != x.clicks_good_: return 0
    if self.has_clicks_bad_ != x.has_clicks_bad_: return 0
    if self.has_clicks_bad_ and self.clicks_bad_ != x.clicks_bad_: return 0
    if self.has_clicks_unclassified_ != x.has_clicks_unclassified_: return 0
    if self.has_clicks_unclassified_ and self.clicks_unclassified_ != x.clicks_unclassified_: return 0
    if self.has_ctr_weighted_impressions_ != x.has_ctr_weighted_impressions_: return 0
    if self.has_ctr_weighted_impressions_ and self.ctr_weighted_impressions_ != x.ctr_weighted_impressions_: return 0
    if self.has_clicks_long_ != x.has_clicks_long_: return 0
    if self.has_clicks_long_ and self.clicks_long_ != x.clicks_long_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_shown_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: shown not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.shown_)
    if (self.has_chances_): n += 1 + self.lengthVarInt64(self.chances_)
    if (self.has_clicks_good_): n += 1 + self.lengthVarInt64(self.clicks_good_)
    if (self.has_clicks_bad_): n += 1 + self.lengthVarInt64(self.clicks_bad_)
    if (self.has_clicks_unclassified_): n += 1 + self.lengthVarInt64(self.clicks_unclassified_)
    if (self.has_ctr_weighted_impressions_): n += 5
    if (self.has_clicks_long_): n += 1 + self.lengthVarInt64(self.clicks_long_)
    return n + 1

  def Clear(self):
    self.clear_shown()
    self.clear_chances()
    self.clear_clicks_good()
    self.clear_clicks_bad()
    self.clear_clicks_unclassified()
    self.clear_ctr_weighted_impressions()
    self.clear_clicks_long()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt64(self.shown_)
    if (self.has_chances_):
      out.putVarInt32(16)
      out.putVarInt64(self.chances_)
    if (self.has_clicks_good_):
      out.putVarInt32(24)
      out.putVarInt64(self.clicks_good_)
    if (self.has_clicks_bad_):
      out.putVarInt32(32)
      out.putVarInt64(self.clicks_bad_)
    if (self.has_clicks_unclassified_):
      out.putVarInt32(40)
      out.putVarInt64(self.clicks_unclassified_)
    if (self.has_ctr_weighted_impressions_):
      out.putVarInt32(53)
      out.putFloat(self.ctr_weighted_impressions_)
    if (self.has_clicks_long_):
      out.putVarInt32(56)
      out.putVarInt64(self.clicks_long_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_shown(d.getVarInt64())
        continue
      if tt == 16:
        self.set_chances(d.getVarInt64())
        continue
      if tt == 24:
        self.set_clicks_good(d.getVarInt64())
        continue
      if tt == 32:
        self.set_clicks_bad(d.getVarInt64())
        continue
      if tt == 40:
        self.set_clicks_unclassified(d.getVarInt64())
        continue
      if tt == 53:
        self.set_ctr_weighted_impressions(d.getFloat())
        continue
      if tt == 56:
        self.set_clicks_long(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_shown_: res+=prefix+("shown: %s\n" % self.DebugFormatInt64(self.shown_))
    if self.has_chances_: res+=prefix+("chances: %s\n" % self.DebugFormatInt64(self.chances_))
    if self.has_clicks_good_: res+=prefix+("clicks_good: %s\n" % self.DebugFormatInt64(self.clicks_good_))
    if self.has_clicks_bad_: res+=prefix+("clicks_bad: %s\n" % self.DebugFormatInt64(self.clicks_bad_))
    if self.has_clicks_unclassified_: res+=prefix+("clicks_unclassified: %s\n" % self.DebugFormatInt64(self.clicks_unclassified_))
    if self.has_ctr_weighted_impressions_: res+=prefix+("ctr_weighted_impressions: %s\n" % self.DebugFormatFloat(self.ctr_weighted_impressions_))
    if self.has_clicks_long_: res+=prefix+("clicks_long: %s\n" % self.DebugFormatInt64(self.clicks_long_))
    return res

  kshown = 1
  kchances = 2
  kclicks_good = 3
  kclicks_bad = 4
  kclicks_unclassified = 5
  kctr_weighted_impressions = 6
  kclicks_long = 7

  _TEXT = (
   "ErrorCode",  #   0
   "shown",  #   1
   "chances",  #   2
   "clicks_good",  #   3
   "clicks_bad",  #   4
   "clicks_unclassified",  #   5
   "ctr_weighted_impressions",  #   6
   "clicks_long",  #   7
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.FLOAT,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x31,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x64,
    0x69,
    0x61,
    0x67,
    0x6e,
    0x6f,
    0x73,
    0x74,
    0x69,
    0x63,
    0x73,
    0x2f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x5f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x15,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x13,
    0x1a,
    0x05,
    0x73,
    0x68,
    0x6f,
    0x77,
    0x6e,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x63,
    0x68,
    0x61,
    0x6e,
    0x63,
    0x65,
    0x73,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x63,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x73,
    0x5f,
    0x67,
    0x6f,
    0x6f,
    0x64,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x63,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x73,
    0x5f,
    0x62,
    0x61,
    0x64,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x63,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x73,
    0x5f,
    0x75,
    0x6e,
    0x63,
    0x6c,
    0x61,
    0x73,
    0x73,
    0x69,
    0x66,
    0x69,
    0x65,
    0x64,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x63,
    0x74,
    0x72,
    0x5f,
    0x77,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x65,
    0x64,
    0x5f,
    0x69,
    0x6d,
    0x70,
    0x72,
    0x65,
    0x73,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x06,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x63,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x73,
    0x5f,
    0x6c,
    0x6f,
    0x6e,
    0x67,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xe3,
    0xda,
    0x82,
    0x02,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class Conditions(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.datacenter_ = ""
    self.sources_ = []
    self.has_datacenter_ = 0
    if contents is not None: self.MergeFromString(contents)

  def datacenter(self): return self.datacenter_

  def set_datacenter(self, x):
    self.has_datacenter_ = 1
    self.datacenter_ = x

  def clear_datacenter(self):
    self.has_datacenter_ = 0
    self.datacenter_ = ""

  def has_datacenter(self): return self.has_datacenter_

  def sources_size(self): return len(self.sources_)
  def sources_list(self): return self.sources_

  def sources(self, i):
    return self.sources_[i]

  def set_sources(self, i, x):
    self.sources_[i] = x

  def add_sources(self, x):
    self.sources_.append(x)

  def clear_sources(self):
    self.sources_ = []


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_datacenter()): self.set_datacenter(x.datacenter())
    for i in xrange(x.sources_size()): self.add_sources(x.sources(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.Conditions', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.Conditions')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.Conditions', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.Conditions', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.Conditions', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_datacenter_ != x.has_datacenter_: return 0
    if self.has_datacenter_ and self.datacenter_ != x.datacenter_: return 0
    if len(self.sources_) != len(x.sources_): return 0
    for e1, e2 in zip(self.sources_, x.sources_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_datacenter_): n += 1 + self.lengthString(len(self.datacenter_))
    n += 1 * len(self.sources_)
    for i in xrange(len(self.sources_)): n += self.lengthVarInt64(self.sources_[i])
    return n + 0

  def Clear(self):
    self.clear_datacenter()
    self.clear_sources()

  def OutputUnchecked(self, out):
    if (self.has_datacenter_):
      out.putVarInt32(10)
      out.putPrefixedString(self.datacenter_)
    for i in xrange(len(self.sources_)):
      out.putVarInt32(16)
      out.putVarInt32(self.sources_[i])

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_datacenter(d.getPrefixedString())
        continue
      if tt == 16:
        self.add_sources(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_datacenter_: res+=prefix+("datacenter: %s\n" % self.DebugFormatString(self.datacenter_))
    cnt=0
    for e in self.sources_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("sources%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    return res

  kdatacenter = 1
  ksources = 2

  _TEXT = (
   "ErrorCode",  #   0
   "datacenter",  #   1
   "sources",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x31,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x64,
    0x69,
    0x61,
    0x67,
    0x6e,
    0x6f,
    0x73,
    0x74,
    0x69,
    0x63,
    0x73,
    0x2f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x5f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x12,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x43,
    0x6f,
    0x6e,
    0x64,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x13,
    0x1a,
    0x0a,
    0x64,
    0x61,
    0x74,
    0x61,
    0x63,
    0x65,
    0x6e,
    0x74,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x73,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class IndexCoverageSet_Events(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.conditions_ = Conditions()
    self.counts_ = IndexCoverage()
    self.has_conditions_ = 0
    self.has_counts_ = 0
    if contents is not None: self.MergeFromString(contents)

  def conditions(self): return self.conditions_

  def mutable_conditions(self): self.has_conditions_ = 1; return self.conditions_

  def clear_conditions(self):self.has_conditions_ = 0; self.conditions_.Clear()

  def has_conditions(self): return self.has_conditions_

  def counts(self): return self.counts_

  def mutable_counts(self): self.has_counts_ = 1; return self.counts_

  def clear_counts(self):self.has_counts_ = 0; self.counts_.Clear()

  def has_counts(self): return self.has_counts_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_conditions()): self.mutable_conditions().MergeFrom(x.conditions())
    if (x.has_counts()): self.mutable_counts().MergeFrom(x.counts())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.IndexCoverageSet', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.IndexCoverageSet')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.IndexCoverageSet', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.IndexCoverageSet', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.IndexCoverageSet', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_conditions_ != x.has_conditions_: return 0
    if self.has_conditions_ and self.conditions_ != x.conditions_: return 0
    if self.has_counts_ != x.has_counts_: return 0
    if self.has_counts_ and self.counts_ != x.counts_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_conditions_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: conditions not set.')
    elif not self.conditions_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_counts_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: counts not set.')
    elif not self.counts_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.conditions_.ByteSize())
    n += self.lengthString(self.counts_.ByteSize())
    return n + 2

  def Clear(self):
    self.clear_conditions()
    self.clear_counts()

  def OutputUnchecked(self, out):
    out.putVarInt32(18)
    out.putVarInt32(self.conditions_.ByteSize())
    self.conditions_.OutputUnchecked(out)
    out.putVarInt32(26)
    out.putVarInt32(self.counts_.ByteSize())
    self.counts_.OutputUnchecked(out)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_conditions().TryMerge(tmp)
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_counts().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_conditions_:
      res+=prefix+"conditions <\n"
      res+=self.conditions_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_counts_:
      res+=prefix+"counts <\n"
      res+=self.counts_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

class IndexCoverageSet(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.events_ = []
    if contents is not None: self.MergeFromString(contents)

  def events_size(self): return len(self.events_)
  def events_list(self): return self.events_

  def events(self, i):
    return self.events_[i]

  def mutable_events(self, i):
    return self.events_[i]

  def add_events(self):
    x = IndexCoverageSet_Events()
    self.events_.append(x)
    return x

  def clear_events(self):
    self.events_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.events_size()): self.add_events().CopyFrom(x.events(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.IndexCoverageSet', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.IndexCoverageSet')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.IndexCoverageSet', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.IndexCoverageSet', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.IndexCoverageSet', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.events_) != len(x.events_): return 0
    for e1, e2 in zip(self.events_, x.events_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.events_)):
      if (not self.events_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.events_)
    for i in xrange(len(self.events_)): n += self.events_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_events()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.events_)):
      out.putVarInt32(11)
      self.events_[i].OutputUnchecked(out)
      out.putVarInt32(12)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_events().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.events_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Events%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kEventsGroup = 1
  kEventsconditions = 2
  kEventscounts = 3

  _TEXT = (
   "ErrorCode",  #   0
   "Events",  #   1
   "conditions",  #   2
   "counts",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x31,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x64,
    0x69,
    0x61,
    0x67,
    0x6e,
    0x6f,
    0x73,
    0x74,
    0x69,
    0x63,
    0x73,
    0x2f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x5f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x18,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x53,
    0x65,
    0x74,
    0x13,
    0x1a,
    0x06,
    0x45,
    0x76,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x45,
    0x76,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x63,
    0x6f,
    0x6e,
    0x64,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x12,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x43,
    0x6f,
    0x6e,
    0x64,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x45,
    0x76,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x63,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x15,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x60,
    0x00,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class IndexCoverageAggregate(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.size_ = 0
    self.shown_ = 0
    self.clicks_good_ = 0
    self.clicks_bad_ = 0
    self.clicks_unclassified_ = 0
    self.domain_ = 0
    self.distinct_shown_ = 0
    self.ctr_weighted_impressions_ = 0.0
    self.clicks_long_ = 0
    self.has_size_ = 0
    self.has_shown_ = 0
    self.has_clicks_good_ = 0
    self.has_clicks_bad_ = 0
    self.has_clicks_unclassified_ = 0
    self.has_domain_ = 0
    self.has_distinct_shown_ = 0
    self.has_ctr_weighted_impressions_ = 0
    self.has_clicks_long_ = 0
    if contents is not None: self.MergeFromString(contents)

  def size(self): return self.size_

  def set_size(self, x):
    self.has_size_ = 1
    self.size_ = x

  def clear_size(self):
    self.has_size_ = 0
    self.size_ = 0

  def has_size(self): return self.has_size_

  def shown(self): return self.shown_

  def set_shown(self, x):
    self.has_shown_ = 1
    self.shown_ = x

  def clear_shown(self):
    self.has_shown_ = 0
    self.shown_ = 0

  def has_shown(self): return self.has_shown_

  def clicks_good(self): return self.clicks_good_

  def set_clicks_good(self, x):
    self.has_clicks_good_ = 1
    self.clicks_good_ = x

  def clear_clicks_good(self):
    self.has_clicks_good_ = 0
    self.clicks_good_ = 0

  def has_clicks_good(self): return self.has_clicks_good_

  def clicks_bad(self): return self.clicks_bad_

  def set_clicks_bad(self, x):
    self.has_clicks_bad_ = 1
    self.clicks_bad_ = x

  def clear_clicks_bad(self):
    self.has_clicks_bad_ = 0
    self.clicks_bad_ = 0

  def has_clicks_bad(self): return self.has_clicks_bad_

  def clicks_unclassified(self): return self.clicks_unclassified_

  def set_clicks_unclassified(self, x):
    self.has_clicks_unclassified_ = 1
    self.clicks_unclassified_ = x

  def clear_clicks_unclassified(self):
    self.has_clicks_unclassified_ = 0
    self.clicks_unclassified_ = 0

  def has_clicks_unclassified(self): return self.has_clicks_unclassified_

  def domain(self): return self.domain_

  def set_domain(self, x):
    self.has_domain_ = 1
    self.domain_ = x

  def clear_domain(self):
    self.has_domain_ = 0
    self.domain_ = 0

  def has_domain(self): return self.has_domain_

  def distinct_shown(self): return self.distinct_shown_

  def set_distinct_shown(self, x):
    self.has_distinct_shown_ = 1
    self.distinct_shown_ = x

  def clear_distinct_shown(self):
    self.has_distinct_shown_ = 0
    self.distinct_shown_ = 0

  def has_distinct_shown(self): return self.has_distinct_shown_

  def ctr_weighted_impressions(self): return self.ctr_weighted_impressions_

  def set_ctr_weighted_impressions(self, x):
    self.has_ctr_weighted_impressions_ = 1
    self.ctr_weighted_impressions_ = x

  def clear_ctr_weighted_impressions(self):
    self.has_ctr_weighted_impressions_ = 0
    self.ctr_weighted_impressions_ = 0.0

  def has_ctr_weighted_impressions(self): return self.has_ctr_weighted_impressions_

  def clicks_long(self): return self.clicks_long_

  def set_clicks_long(self, x):
    self.has_clicks_long_ = 1
    self.clicks_long_ = x

  def clear_clicks_long(self):
    self.has_clicks_long_ = 0
    self.clicks_long_ = 0

  def has_clicks_long(self): return self.has_clicks_long_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_size()): self.set_size(x.size())
    if (x.has_shown()): self.set_shown(x.shown())
    if (x.has_clicks_good()): self.set_clicks_good(x.clicks_good())
    if (x.has_clicks_bad()): self.set_clicks_bad(x.clicks_bad())
    if (x.has_clicks_unclassified()): self.set_clicks_unclassified(x.clicks_unclassified())
    if (x.has_domain()): self.set_domain(x.domain())
    if (x.has_distinct_shown()): self.set_distinct_shown(x.distinct_shown())
    if (x.has_ctr_weighted_impressions()): self.set_ctr_weighted_impressions(x.ctr_weighted_impressions())
    if (x.has_clicks_long()): self.set_clicks_long(x.clicks_long())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.IndexCoverageAggregate', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.IndexCoverageAggregate')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.IndexCoverageAggregate', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.IndexCoverageAggregate', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.IndexCoverageAggregate', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_size_ != x.has_size_: return 0
    if self.has_size_ and self.size_ != x.size_: return 0
    if self.has_shown_ != x.has_shown_: return 0
    if self.has_shown_ and self.shown_ != x.shown_: return 0
    if self.has_clicks_good_ != x.has_clicks_good_: return 0
    if self.has_clicks_good_ and self.clicks_good_ != x.clicks_good_: return 0
    if self.has_clicks_bad_ != x.has_clicks_bad_: return 0
    if self.has_clicks_bad_ and self.clicks_bad_ != x.clicks_bad_: return 0
    if self.has_clicks_unclassified_ != x.has_clicks_unclassified_: return 0
    if self.has_clicks_unclassified_ and self.clicks_unclassified_ != x.clicks_unclassified_: return 0
    if self.has_domain_ != x.has_domain_: return 0
    if self.has_domain_ and self.domain_ != x.domain_: return 0
    if self.has_distinct_shown_ != x.has_distinct_shown_: return 0
    if self.has_distinct_shown_ and self.distinct_shown_ != x.distinct_shown_: return 0
    if self.has_ctr_weighted_impressions_ != x.has_ctr_weighted_impressions_: return 0
    if self.has_ctr_weighted_impressions_ and self.ctr_weighted_impressions_ != x.ctr_weighted_impressions_: return 0
    if self.has_clicks_long_ != x.has_clicks_long_: return 0
    if self.has_clicks_long_ and self.clicks_long_ != x.clicks_long_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_size_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: size not set.')
    if (not self.has_shown_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: shown not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.size_)
    n += self.lengthVarInt64(self.shown_)
    if (self.has_clicks_good_): n += 1 + self.lengthVarInt64(self.clicks_good_)
    if (self.has_clicks_bad_): n += 1 + self.lengthVarInt64(self.clicks_bad_)
    if (self.has_clicks_unclassified_): n += 1 + self.lengthVarInt64(self.clicks_unclassified_)
    if (self.has_domain_): n += 2
    if (self.has_distinct_shown_): n += 1 + self.lengthVarInt64(self.distinct_shown_)
    if (self.has_ctr_weighted_impressions_): n += 5
    if (self.has_clicks_long_): n += 1 + self.lengthVarInt64(self.clicks_long_)
    return n + 2

  def Clear(self):
    self.clear_size()
    self.clear_shown()
    self.clear_clicks_good()
    self.clear_clicks_bad()
    self.clear_clicks_unclassified()
    self.clear_domain()
    self.clear_distinct_shown()
    self.clear_ctr_weighted_impressions()
    self.clear_clicks_long()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt64(self.size_)
    out.putVarInt32(16)
    out.putVarInt64(self.shown_)
    if (self.has_clicks_good_):
      out.putVarInt32(32)
      out.putVarInt64(self.clicks_good_)
    if (self.has_clicks_bad_):
      out.putVarInt32(40)
      out.putVarInt64(self.clicks_bad_)
    if (self.has_clicks_unclassified_):
      out.putVarInt32(48)
      out.putVarInt64(self.clicks_unclassified_)
    if (self.has_domain_):
      out.putVarInt32(56)
      out.putBoolean(self.domain_)
    if (self.has_distinct_shown_):
      out.putVarInt32(64)
      out.putVarInt64(self.distinct_shown_)
    if (self.has_ctr_weighted_impressions_):
      out.putVarInt32(77)
      out.putFloat(self.ctr_weighted_impressions_)
    if (self.has_clicks_long_):
      out.putVarInt32(80)
      out.putVarInt64(self.clicks_long_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_size(d.getVarInt64())
        continue
      if tt == 16:
        self.set_shown(d.getVarInt64())
        continue
      if tt == 32:
        self.set_clicks_good(d.getVarInt64())
        continue
      if tt == 40:
        self.set_clicks_bad(d.getVarInt64())
        continue
      if tt == 48:
        self.set_clicks_unclassified(d.getVarInt64())
        continue
      if tt == 56:
        self.set_domain(d.getBoolean())
        continue
      if tt == 64:
        self.set_distinct_shown(d.getVarInt64())
        continue
      if tt == 77:
        self.set_ctr_weighted_impressions(d.getFloat())
        continue
      if tt == 80:
        self.set_clicks_long(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_size_: res+=prefix+("size: %s\n" % self.DebugFormatInt64(self.size_))
    if self.has_shown_: res+=prefix+("shown: %s\n" % self.DebugFormatInt64(self.shown_))
    if self.has_clicks_good_: res+=prefix+("clicks_good: %s\n" % self.DebugFormatInt64(self.clicks_good_))
    if self.has_clicks_bad_: res+=prefix+("clicks_bad: %s\n" % self.DebugFormatInt64(self.clicks_bad_))
    if self.has_clicks_unclassified_: res+=prefix+("clicks_unclassified: %s\n" % self.DebugFormatInt64(self.clicks_unclassified_))
    if self.has_domain_: res+=prefix+("domain: %s\n" % self.DebugFormatBool(self.domain_))
    if self.has_distinct_shown_: res+=prefix+("distinct_shown: %s\n" % self.DebugFormatInt64(self.distinct_shown_))
    if self.has_ctr_weighted_impressions_: res+=prefix+("ctr_weighted_impressions: %s\n" % self.DebugFormatFloat(self.ctr_weighted_impressions_))
    if self.has_clicks_long_: res+=prefix+("clicks_long: %s\n" % self.DebugFormatInt64(self.clicks_long_))
    return res

  ksize = 1
  kshown = 2
  kclicks_good = 4
  kclicks_bad = 5
  kclicks_unclassified = 6
  kdomain = 7
  kdistinct_shown = 8
  kctr_weighted_impressions = 9
  kclicks_long = 10

  _TEXT = (
   "ErrorCode",  #   0
   "size",  #   1
   "shown",  #   2
   None,  #   3
   "clicks_good",  #   4
   "clicks_bad",  #   5
   "clicks_unclassified",  #   6
   "domain",  #   7
   "distinct_shown",  #   8
   "ctr_weighted_impressions",  #   9
   "clicks_long",  #  10
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.MAX_TYPE,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.FLOAT,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x31,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x64,
    0x69,
    0x61,
    0x67,
    0x6e,
    0x6f,
    0x73,
    0x74,
    0x69,
    0x63,
    0x73,
    0x2f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x5f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1e,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x41,
    0x67,
    0x67,
    0x72,
    0x65,
    0x67,
    0x61,
    0x74,
    0x65,
    0x13,
    0x1a,
    0x04,
    0x73,
    0x69,
    0x7a,
    0x65,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x73,
    0x68,
    0x6f,
    0x77,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x63,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x73,
    0x5f,
    0x67,
    0x6f,
    0x6f,
    0x64,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x63,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x73,
    0x5f,
    0x62,
    0x61,
    0x64,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x63,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x73,
    0x5f,
    0x75,
    0x6e,
    0x63,
    0x6c,
    0x61,
    0x73,
    0x73,
    0x69,
    0x66,
    0x69,
    0x65,
    0x64,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x64,
    0x6f,
    0x6d,
    0x61,
    0x69,
    0x6e,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x64,
    0x69,
    0x73,
    0x74,
    0x69,
    0x6e,
    0x63,
    0x74,
    0x5f,
    0x73,
    0x68,
    0x6f,
    0x77,
    0x6e,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x63,
    0x74,
    0x72,
    0x5f,
    0x77,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x65,
    0x64,
    0x5f,
    0x69,
    0x6d,
    0x70,
    0x72,
    0x65,
    0x73,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x09,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x63,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x73,
    0x5f,
    0x6c,
    0x6f,
    0x6e,
    0x67,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class IndexCoverageHistogram_Bin(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.legacy_score_ = 0.0
    self.seti_score_ = 0.0
    self.visibility_ = 0.0
    self.urls_ = 0
    self.tokens_ = 0
    self.log2_tokens_ = 0.0
    self.urls_shown_ = 0
    self.impressions_ = 0
    self.urls_long_clicked_ = 0
    self.long_clicks_ = 0
    self.ctr_weighted_impressions_ = 0.0
    self.click_probability_ = 0.0
    self.has_legacy_score_ = 0
    self.has_seti_score_ = 0
    self.has_visibility_ = 0
    self.has_urls_ = 0
    self.has_tokens_ = 0
    self.has_log2_tokens_ = 0
    self.has_urls_shown_ = 0
    self.has_impressions_ = 0
    self.has_urls_long_clicked_ = 0
    self.has_long_clicks_ = 0
    self.has_ctr_weighted_impressions_ = 0
    self.has_click_probability_ = 0
    if contents is not None: self.MergeFromString(contents)

  def legacy_score(self): return self.legacy_score_

  def set_legacy_score(self, x):
    self.has_legacy_score_ = 1
    self.legacy_score_ = x

  def clear_legacy_score(self):
    self.has_legacy_score_ = 0
    self.legacy_score_ = 0.0

  def has_legacy_score(self): return self.has_legacy_score_

  def seti_score(self): return self.seti_score_

  def set_seti_score(self, x):
    self.has_seti_score_ = 1
    self.seti_score_ = x

  def clear_seti_score(self):
    self.has_seti_score_ = 0
    self.seti_score_ = 0.0

  def has_seti_score(self): return self.has_seti_score_

  def visibility(self): return self.visibility_

  def set_visibility(self, x):
    self.has_visibility_ = 1
    self.visibility_ = x

  def clear_visibility(self):
    self.has_visibility_ = 0
    self.visibility_ = 0.0

  def has_visibility(self): return self.has_visibility_

  def urls(self): return self.urls_

  def set_urls(self, x):
    self.has_urls_ = 1
    self.urls_ = x

  def clear_urls(self):
    self.has_urls_ = 0
    self.urls_ = 0

  def has_urls(self): return self.has_urls_

  def tokens(self): return self.tokens_

  def set_tokens(self, x):
    self.has_tokens_ = 1
    self.tokens_ = x

  def clear_tokens(self):
    self.has_tokens_ = 0
    self.tokens_ = 0

  def has_tokens(self): return self.has_tokens_

  def log2_tokens(self): return self.log2_tokens_

  def set_log2_tokens(self, x):
    self.has_log2_tokens_ = 1
    self.log2_tokens_ = x

  def clear_log2_tokens(self):
    self.has_log2_tokens_ = 0
    self.log2_tokens_ = 0.0

  def has_log2_tokens(self): return self.has_log2_tokens_

  def urls_shown(self): return self.urls_shown_

  def set_urls_shown(self, x):
    self.has_urls_shown_ = 1
    self.urls_shown_ = x

  def clear_urls_shown(self):
    self.has_urls_shown_ = 0
    self.urls_shown_ = 0

  def has_urls_shown(self): return self.has_urls_shown_

  def impressions(self): return self.impressions_

  def set_impressions(self, x):
    self.has_impressions_ = 1
    self.impressions_ = x

  def clear_impressions(self):
    self.has_impressions_ = 0
    self.impressions_ = 0

  def has_impressions(self): return self.has_impressions_

  def urls_long_clicked(self): return self.urls_long_clicked_

  def set_urls_long_clicked(self, x):
    self.has_urls_long_clicked_ = 1
    self.urls_long_clicked_ = x

  def clear_urls_long_clicked(self):
    self.has_urls_long_clicked_ = 0
    self.urls_long_clicked_ = 0

  def has_urls_long_clicked(self): return self.has_urls_long_clicked_

  def long_clicks(self): return self.long_clicks_

  def set_long_clicks(self, x):
    self.has_long_clicks_ = 1
    self.long_clicks_ = x

  def clear_long_clicks(self):
    self.has_long_clicks_ = 0
    self.long_clicks_ = 0

  def has_long_clicks(self): return self.has_long_clicks_

  def ctr_weighted_impressions(self): return self.ctr_weighted_impressions_

  def set_ctr_weighted_impressions(self, x):
    self.has_ctr_weighted_impressions_ = 1
    self.ctr_weighted_impressions_ = x

  def clear_ctr_weighted_impressions(self):
    self.has_ctr_weighted_impressions_ = 0
    self.ctr_weighted_impressions_ = 0.0

  def has_ctr_weighted_impressions(self): return self.has_ctr_weighted_impressions_

  def click_probability(self): return self.click_probability_

  def set_click_probability(self, x):
    self.has_click_probability_ = 1
    self.click_probability_ = x

  def clear_click_probability(self):
    self.has_click_probability_ = 0
    self.click_probability_ = 0.0

  def has_click_probability(self): return self.has_click_probability_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_legacy_score()): self.set_legacy_score(x.legacy_score())
    if (x.has_seti_score()): self.set_seti_score(x.seti_score())
    if (x.has_visibility()): self.set_visibility(x.visibility())
    if (x.has_urls()): self.set_urls(x.urls())
    if (x.has_tokens()): self.set_tokens(x.tokens())
    if (x.has_log2_tokens()): self.set_log2_tokens(x.log2_tokens())
    if (x.has_urls_shown()): self.set_urls_shown(x.urls_shown())
    if (x.has_impressions()): self.set_impressions(x.impressions())
    if (x.has_urls_long_clicked()): self.set_urls_long_clicked(x.urls_long_clicked())
    if (x.has_long_clicks()): self.set_long_clicks(x.long_clicks())
    if (x.has_ctr_weighted_impressions()): self.set_ctr_weighted_impressions(x.ctr_weighted_impressions())
    if (x.has_click_probability()): self.set_click_probability(x.click_probability())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.IndexCoverageHistogram', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.IndexCoverageHistogram')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.IndexCoverageHistogram', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.IndexCoverageHistogram', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.IndexCoverageHistogram', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_legacy_score_ != x.has_legacy_score_: return 0
    if self.has_legacy_score_ and self.legacy_score_ != x.legacy_score_: return 0
    if self.has_seti_score_ != x.has_seti_score_: return 0
    if self.has_seti_score_ and self.seti_score_ != x.seti_score_: return 0
    if self.has_visibility_ != x.has_visibility_: return 0
    if self.has_visibility_ and self.visibility_ != x.visibility_: return 0
    if self.has_urls_ != x.has_urls_: return 0
    if self.has_urls_ and self.urls_ != x.urls_: return 0
    if self.has_tokens_ != x.has_tokens_: return 0
    if self.has_tokens_ and self.tokens_ != x.tokens_: return 0
    if self.has_log2_tokens_ != x.has_log2_tokens_: return 0
    if self.has_log2_tokens_ and self.log2_tokens_ != x.log2_tokens_: return 0
    if self.has_urls_shown_ != x.has_urls_shown_: return 0
    if self.has_urls_shown_ and self.urls_shown_ != x.urls_shown_: return 0
    if self.has_impressions_ != x.has_impressions_: return 0
    if self.has_impressions_ and self.impressions_ != x.impressions_: return 0
    if self.has_urls_long_clicked_ != x.has_urls_long_clicked_: return 0
    if self.has_urls_long_clicked_ and self.urls_long_clicked_ != x.urls_long_clicked_: return 0
    if self.has_long_clicks_ != x.has_long_clicks_: return 0
    if self.has_long_clicks_ and self.long_clicks_ != x.long_clicks_: return 0
    if self.has_ctr_weighted_impressions_ != x.has_ctr_weighted_impressions_: return 0
    if self.has_ctr_weighted_impressions_ and self.ctr_weighted_impressions_ != x.ctr_weighted_impressions_: return 0
    if self.has_click_probability_ != x.has_click_probability_: return 0
    if self.has_click_probability_ and self.click_probability_ != x.click_probability_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_legacy_score_): n += 5
    if (self.has_seti_score_): n += 5
    if (self.has_visibility_): n += 5
    if (self.has_urls_): n += 1 + self.lengthVarInt64(self.urls_)
    if (self.has_tokens_): n += 1 + self.lengthVarInt64(self.tokens_)
    if (self.has_log2_tokens_): n += 5
    if (self.has_urls_shown_): n += 1 + self.lengthVarInt64(self.urls_shown_)
    if (self.has_impressions_): n += 1 + self.lengthVarInt64(self.impressions_)
    if (self.has_urls_long_clicked_): n += 1 + self.lengthVarInt64(self.urls_long_clicked_)
    if (self.has_long_clicks_): n += 1 + self.lengthVarInt64(self.long_clicks_)
    if (self.has_ctr_weighted_impressions_): n += 9
    if (self.has_click_probability_): n += 9
    return n + 0

  def Clear(self):
    self.clear_legacy_score()
    self.clear_seti_score()
    self.clear_visibility()
    self.clear_urls()
    self.clear_tokens()
    self.clear_log2_tokens()
    self.clear_urls_shown()
    self.clear_impressions()
    self.clear_urls_long_clicked()
    self.clear_long_clicks()
    self.clear_ctr_weighted_impressions()
    self.clear_click_probability()

  def OutputUnchecked(self, out):
    if (self.has_legacy_score_):
      out.putVarInt32(29)
      out.putFloat(self.legacy_score_)
    if (self.has_urls_):
      out.putVarInt32(32)
      out.putVarInt64(self.urls_)
    if (self.has_tokens_):
      out.putVarInt32(40)
      out.putVarInt64(self.tokens_)
    if (self.has_urls_shown_):
      out.putVarInt32(48)
      out.putVarInt64(self.urls_shown_)
    if (self.has_impressions_):
      out.putVarInt32(56)
      out.putVarInt64(self.impressions_)
    if (self.has_urls_long_clicked_):
      out.putVarInt32(64)
      out.putVarInt64(self.urls_long_clicked_)
    if (self.has_long_clicks_):
      out.putVarInt32(72)
      out.putVarInt64(self.long_clicks_)
    if (self.has_ctr_weighted_impressions_):
      out.putVarInt32(81)
      out.putDouble(self.ctr_weighted_impressions_)
    if (self.has_click_probability_):
      out.putVarInt32(89)
      out.putDouble(self.click_probability_)
    if (self.has_seti_score_):
      out.putVarInt32(101)
      out.putFloat(self.seti_score_)
    if (self.has_log2_tokens_):
      out.putVarInt32(109)
      out.putFloat(self.log2_tokens_)
    if (self.has_visibility_):
      out.putVarInt32(117)
      out.putFloat(self.visibility_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 29:
        self.set_legacy_score(d.getFloat())
        continue
      if tt == 32:
        self.set_urls(d.getVarInt64())
        continue
      if tt == 40:
        self.set_tokens(d.getVarInt64())
        continue
      if tt == 48:
        self.set_urls_shown(d.getVarInt64())
        continue
      if tt == 56:
        self.set_impressions(d.getVarInt64())
        continue
      if tt == 64:
        self.set_urls_long_clicked(d.getVarInt64())
        continue
      if tt == 72:
        self.set_long_clicks(d.getVarInt64())
        continue
      if tt == 81:
        self.set_ctr_weighted_impressions(d.getDouble())
        continue
      if tt == 89:
        self.set_click_probability(d.getDouble())
        continue
      if tt == 101:
        self.set_seti_score(d.getFloat())
        continue
      if tt == 109:
        self.set_log2_tokens(d.getFloat())
        continue
      if tt == 117:
        self.set_visibility(d.getFloat())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_legacy_score_: res+=prefix+("legacy_score: %s\n" % self.DebugFormatFloat(self.legacy_score_))
    if self.has_seti_score_: res+=prefix+("seti_score: %s\n" % self.DebugFormatFloat(self.seti_score_))
    if self.has_visibility_: res+=prefix+("visibility: %s\n" % self.DebugFormatFloat(self.visibility_))
    if self.has_urls_: res+=prefix+("urls: %s\n" % self.DebugFormatInt64(self.urls_))
    if self.has_tokens_: res+=prefix+("tokens: %s\n" % self.DebugFormatInt64(self.tokens_))
    if self.has_log2_tokens_: res+=prefix+("log2_tokens: %s\n" % self.DebugFormatFloat(self.log2_tokens_))
    if self.has_urls_shown_: res+=prefix+("urls_shown: %s\n" % self.DebugFormatInt64(self.urls_shown_))
    if self.has_impressions_: res+=prefix+("impressions: %s\n" % self.DebugFormatInt64(self.impressions_))
    if self.has_urls_long_clicked_: res+=prefix+("urls_long_clicked: %s\n" % self.DebugFormatInt64(self.urls_long_clicked_))
    if self.has_long_clicks_: res+=prefix+("long_clicks: %s\n" % self.DebugFormatInt64(self.long_clicks_))
    if self.has_ctr_weighted_impressions_: res+=prefix+("ctr_weighted_impressions: %s\n" % self.DebugFormat(self.ctr_weighted_impressions_))
    if self.has_click_probability_: res+=prefix+("click_probability: %s\n" % self.DebugFormat(self.click_probability_))
    return res

class IndexCoverageHistogram(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.bin_width_ = 0.0
    self.bin_ = []
    self.has_bin_width_ = 0
    if contents is not None: self.MergeFromString(contents)

  def bin_width(self): return self.bin_width_

  def set_bin_width(self, x):
    self.has_bin_width_ = 1
    self.bin_width_ = x

  def clear_bin_width(self):
    self.has_bin_width_ = 0
    self.bin_width_ = 0.0

  def has_bin_width(self): return self.has_bin_width_

  def bin_size(self): return len(self.bin_)
  def bin_list(self): return self.bin_

  def bin(self, i):
    return self.bin_[i]

  def mutable_bin(self, i):
    return self.bin_[i]

  def add_bin(self):
    x = IndexCoverageHistogram_Bin()
    self.bin_.append(x)
    return x

  def clear_bin(self):
    self.bin_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_bin_width()): self.set_bin_width(x.bin_width())
    for i in xrange(x.bin_size()): self.add_bin().CopyFrom(x.bin(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.IndexCoverageHistogram', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.IndexCoverageHistogram')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.IndexCoverageHistogram', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.IndexCoverageHistogram', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.IndexCoverageHistogram', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_bin_width_ != x.has_bin_width_: return 0
    if self.has_bin_width_ and self.bin_width_ != x.bin_width_: return 0
    if len(self.bin_) != len(x.bin_): return 0
    for e1, e2 in zip(self.bin_, x.bin_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.bin_)):
      if (not self.bin_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_bin_width_): n += 5
    n += 2 * len(self.bin_)
    for i in xrange(len(self.bin_)): n += self.bin_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_bin_width()
    self.clear_bin()

  def OutputUnchecked(self, out):
    if (self.has_bin_width_):
      out.putVarInt32(13)
      out.putFloat(self.bin_width_)
    for i in xrange(len(self.bin_)):
      out.putVarInt32(19)
      self.bin_[i].OutputUnchecked(out)
      out.putVarInt32(20)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 13:
        self.set_bin_width(d.getFloat())
        continue
      if tt == 19:
        self.add_bin().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_bin_width_: res+=prefix+("bin_width: %s\n" % self.DebugFormatFloat(self.bin_width_))
    cnt=0
    for e in self.bin_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Bin%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kbin_width = 1
  kBinGroup = 2
  kBinlegacy_score = 3
  kBinseti_score = 12
  kBinvisibility = 14
  kBinurls = 4
  kBintokens = 5
  kBinlog2_tokens = 13
  kBinurls_shown = 6
  kBinimpressions = 7
  kBinurls_long_clicked = 8
  kBinlong_clicks = 9
  kBinctr_weighted_impressions = 10
  kBinclick_probability = 11

  _TEXT = (
   "ErrorCode",  #   0
   "bin_width",  #   1
   "Bin",  #   2
   "legacy_score",  #   3
   "urls",  #   4
   "tokens",  #   5
   "urls_shown",  #   6
   "impressions",  #   7
   "urls_long_clicked",  #   8
   "long_clicks",  #   9
   "ctr_weighted_impressions",  #  10
   "click_probability",  #  11
   "seti_score",  #  12
   "log2_tokens",  #  13
   "visibility",  #  14
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.FLOAT,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.FLOAT,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.NUMERIC,  #   9

   ProtocolBuffer.Encoder.DOUBLE,  #  10

   ProtocolBuffer.Encoder.DOUBLE,  #  11

   ProtocolBuffer.Encoder.FLOAT,  #  12

   ProtocolBuffer.Encoder.FLOAT,  #  13

   ProtocolBuffer.Encoder.FLOAT,  #  14

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x31,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x64,
    0x69,
    0x61,
    0x67,
    0x6e,
    0x6f,
    0x73,
    0x74,
    0x69,
    0x63,
    0x73,
    0x2f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x5f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1e,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x48,
    0x69,
    0x73,
    0x74,
    0x6f,
    0x67,
    0x72,
    0x61,
    0x6d,
    0x13,
    0x1a,
    0x09,
    0x62,
    0x69,
    0x6e,
    0x5f,
    0x77,
    0x69,
    0x64,
    0x74,
    0x68,
    0x20,
    0x01,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x03,
    0x42,
    0x69,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x42,
    0x69,
    0x6e,
    0x2e,
    0x6c,
    0x65,
    0x67,
    0x61,
    0x63,
    0x79,
    0x5f,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x03,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x42,
    0x69,
    0x6e,
    0x2e,
    0x73,
    0x65,
    0x74,
    0x69,
    0x5f,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x0c,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x42,
    0x69,
    0x6e,
    0x2e,
    0x76,
    0x69,
    0x73,
    0x69,
    0x62,
    0x69,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x20,
    0x0e,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x42,
    0x69,
    0x6e,
    0x2e,
    0x75,
    0x72,
    0x6c,
    0x73,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x42,
    0x69,
    0x6e,
    0x2e,
    0x74,
    0x6f,
    0x6b,
    0x65,
    0x6e,
    0x73,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x42,
    0x69,
    0x6e,
    0x2e,
    0x6c,
    0x6f,
    0x67,
    0x32,
    0x5f,
    0x74,
    0x6f,
    0x6b,
    0x65,
    0x6e,
    0x73,
    0x20,
    0x0d,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x42,
    0x69,
    0x6e,
    0x2e,
    0x75,
    0x72,
    0x6c,
    0x73,
    0x5f,
    0x73,
    0x68,
    0x6f,
    0x77,
    0x6e,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x42,
    0x69,
    0x6e,
    0x2e,
    0x69,
    0x6d,
    0x70,
    0x72,
    0x65,
    0x73,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x42,
    0x69,
    0x6e,
    0x2e,
    0x75,
    0x72,
    0x6c,
    0x73,
    0x5f,
    0x6c,
    0x6f,
    0x6e,
    0x67,
    0x5f,
    0x63,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x65,
    0x64,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x42,
    0x69,
    0x6e,
    0x2e,
    0x6c,
    0x6f,
    0x6e,
    0x67,
    0x5f,
    0x63,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x73,
    0x20,
    0x09,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x42,
    0x69,
    0x6e,
    0x2e,
    0x63,
    0x74,
    0x72,
    0x5f,
    0x77,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x65,
    0x64,
    0x5f,
    0x69,
    0x6d,
    0x70,
    0x72,
    0x65,
    0x73,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x0a,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x42,
    0x69,
    0x6e,
    0x2e,
    0x63,
    0x6c,
    0x69,
    0x63,
    0x6b,
    0x5f,
    0x70,
    0x72,
    0x6f,
    0x62,
    0x61,
    0x62,
    0x69,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x20,
    0x0b,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class IndexCoverageStatistics_Stats(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.histogram_ = IndexCoverageHistogram()
    self.has_name_ = 0
    self.has_histogram_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def histogram(self): return self.histogram_

  def mutable_histogram(self): self.has_histogram_ = 1; return self.histogram_

  def clear_histogram(self):self.has_histogram_ = 0; self.histogram_.Clear()

  def has_histogram(self): return self.has_histogram_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_histogram()): self.mutable_histogram().MergeFrom(x.histogram())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.IndexCoverageStatistics', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.IndexCoverageStatistics')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.IndexCoverageStatistics', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.IndexCoverageStatistics', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.IndexCoverageStatistics', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_histogram_ != x.has_histogram_: return 0
    if self.has_histogram_ and self.histogram_ != x.histogram_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    if (not self.has_histogram_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: histogram not set.')
    elif not self.histogram_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    n += self.lengthString(self.histogram_.ByteSize())
    return n + 2

  def Clear(self):
    self.clear_name()
    self.clear_histogram()

  def OutputUnchecked(self, out):
    out.putVarInt32(18)
    out.putPrefixedString(self.name_)
    out.putVarInt32(26)
    out.putVarInt32(self.histogram_.ByteSize())
    self.histogram_.OutputUnchecked(out)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_histogram().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_histogram_:
      res+=prefix+"histogram <\n"
      res+=self.histogram_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

class IndexCoverageStatistics(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.stats_ = []
    if contents is not None: self.MergeFromString(contents)

  def stats_size(self): return len(self.stats_)
  def stats_list(self): return self.stats_

  def stats(self, i):
    return self.stats_[i]

  def mutable_stats(self, i):
    return self.stats_[i]

  def add_stats(self):
    x = IndexCoverageStatistics_Stats()
    self.stats_.append(x)
    return x

  def clear_stats(self):
    self.stats_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.stats_size()): self.add_stats().CopyFrom(x.stats(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.IndexCoverageStatistics', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.IndexCoverageStatistics')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.IndexCoverageStatistics', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.IndexCoverageStatistics', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.IndexCoverageStatistics', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.stats_) != len(x.stats_): return 0
    for e1, e2 in zip(self.stats_, x.stats_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.stats_)):
      if (not self.stats_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.stats_)
    for i in xrange(len(self.stats_)): n += self.stats_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_stats()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.stats_)):
      out.putVarInt32(11)
      self.stats_[i].OutputUnchecked(out)
      out.putVarInt32(12)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_stats().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.stats_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Stats%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kStatsGroup = 1
  kStatsname = 2
  kStatshistogram = 3

  _TEXT = (
   "ErrorCode",  #   0
   "Stats",  #   1
   "name",  #   2
   "histogram",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x31,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x64,
    0x69,
    0x61,
    0x67,
    0x6e,
    0x6f,
    0x73,
    0x74,
    0x69,
    0x63,
    0x73,
    0x2f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x5f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1f,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x53,
    0x74,
    0x61,
    0x74,
    0x69,
    0x73,
    0x74,
    0x69,
    0x63,
    0x73,
    0x13,
    0x1a,
    0x05,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x53,
    0x74,
    0x61,
    0x74,
    0x73,
    0x2e,
    0x68,
    0x69,
    0x73,
    0x74,
    0x6f,
    0x67,
    0x72,
    0x61,
    0x6d,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x1e,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x48,
    0x69,
    0x73,
    0x74,
    0x6f,
    0x67,
    0x72,
    0x61,
    0x6d,
    0x60,
    0x00,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class CumulativeIndexCoverage(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.indexed_ = 0
    self.used_ = 0
    self.impressions_ = 0
    self.has_indexed_ = 0
    self.has_used_ = 0
    self.has_impressions_ = 0
    if contents is not None: self.MergeFromString(contents)

  def indexed(self): return self.indexed_

  def set_indexed(self, x):
    self.has_indexed_ = 1
    self.indexed_ = x

  def clear_indexed(self):
    self.has_indexed_ = 0
    self.indexed_ = 0

  def has_indexed(self): return self.has_indexed_

  def used(self): return self.used_

  def set_used(self, x):
    self.has_used_ = 1
    self.used_ = x

  def clear_used(self):
    self.has_used_ = 0
    self.used_ = 0

  def has_used(self): return self.has_used_

  def impressions(self): return self.impressions_

  def set_impressions(self, x):
    self.has_impressions_ = 1
    self.impressions_ = x

  def clear_impressions(self):
    self.has_impressions_ = 0
    self.impressions_ = 0

  def has_impressions(self): return self.has_impressions_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_indexed()): self.set_indexed(x.indexed())
    if (x.has_used()): self.set_used(x.used())
    if (x.has_impressions()): self.set_impressions(x.impressions())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.CumulativeIndexCoverage', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.CumulativeIndexCoverage')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.CumulativeIndexCoverage', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.CumulativeIndexCoverage', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.CumulativeIndexCoverage', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_indexed_ != x.has_indexed_: return 0
    if self.has_indexed_ and self.indexed_ != x.indexed_: return 0
    if self.has_used_ != x.has_used_: return 0
    if self.has_used_ and self.used_ != x.used_: return 0
    if self.has_impressions_ != x.has_impressions_: return 0
    if self.has_impressions_ and self.impressions_ != x.impressions_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_indexed_): n += 1 + self.lengthVarInt64(self.indexed_)
    if (self.has_used_): n += 1 + self.lengthVarInt64(self.used_)
    if (self.has_impressions_): n += 1 + self.lengthVarInt64(self.impressions_)
    return n + 0

  def Clear(self):
    self.clear_indexed()
    self.clear_used()
    self.clear_impressions()

  def OutputUnchecked(self, out):
    if (self.has_indexed_):
      out.putVarInt32(8)
      out.putVarInt64(self.indexed_)
    if (self.has_used_):
      out.putVarInt32(16)
      out.putVarInt64(self.used_)
    if (self.has_impressions_):
      out.putVarInt32(24)
      out.putVarInt64(self.impressions_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_indexed(d.getVarInt64())
        continue
      if tt == 16:
        self.set_used(d.getVarInt64())
        continue
      if tt == 24:
        self.set_impressions(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_indexed_: res+=prefix+("indexed: %s\n" % self.DebugFormatInt64(self.indexed_))
    if self.has_used_: res+=prefix+("used: %s\n" % self.DebugFormatInt64(self.used_))
    if self.has_impressions_: res+=prefix+("impressions: %s\n" % self.DebugFormatInt64(self.impressions_))
    return res

  kindexed = 1
  kused = 2
  kimpressions = 3

  _TEXT = (
   "ErrorCode",  #   0
   "indexed",  #   1
   "used",  #   2
   "impressions",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x31,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x64,
    0x69,
    0x61,
    0x67,
    0x6e,
    0x6f,
    0x73,
    0x74,
    0x69,
    0x63,
    0x73,
    0x2f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x5f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1f,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x43,
    0x75,
    0x6d,
    0x75,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x76,
    0x65,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x13,
    0x1a,
    0x07,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x65,
    0x64,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x75,
    0x73,
    0x65,
    0x64,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x69,
    0x6d,
    0x70,
    0x72,
    0x65,
    0x73,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class RegionalCoverage_RegionCounts(ProtocolBuffer.ProtocolMessage):

  GLOBAL       =    0 
  AMERICA      =    1 
  EMEA         =    2 
  ASIA         =    3 
  MOBILE_GLOBAL =    4 
  BASEREGIONAL =    5 

  _REGION_ID_NAMES = {
    0: "GLOBAL",
    1: "AMERICA",
    2: "EMEA",
    3: "ASIA",
    4: "MOBILE_GLOBAL",
    5: "BASEREGIONAL",
  }

  def REGION_ID_Name(cls, x): return cls._REGION_ID_NAMES.get(x, "")
  REGION_ID_Name = classmethod(REGION_ID_Name)

  def __init__(self, contents=None):
    self.scorer_id_deprecated_ = 0
    self.region_id_ = 0
    self.source_corpus_id_ = 0
    self.cycle_id_ = 0
    self.coverage_ = IndexCoverage()
    self.has_scorer_id_deprecated_ = 0
    self.has_region_id_ = 0
    self.has_source_corpus_id_ = 0
    self.has_cycle_id_ = 0
    self.has_coverage_ = 0
    if contents is not None: self.MergeFromString(contents)

  def scorer_id_deprecated(self): return self.scorer_id_deprecated_

  def set_scorer_id_deprecated(self, x):
    self.has_scorer_id_deprecated_ = 1
    self.scorer_id_deprecated_ = x

  def clear_scorer_id_deprecated(self):
    self.has_scorer_id_deprecated_ = 0
    self.scorer_id_deprecated_ = 0

  def has_scorer_id_deprecated(self): return self.has_scorer_id_deprecated_

  def region_id(self): return self.region_id_

  def set_region_id(self, x):
    self.has_region_id_ = 1
    self.region_id_ = x

  def clear_region_id(self):
    self.has_region_id_ = 0
    self.region_id_ = 0

  def has_region_id(self): return self.has_region_id_

  def source_corpus_id(self): return self.source_corpus_id_

  def set_source_corpus_id(self, x):
    self.has_source_corpus_id_ = 1
    self.source_corpus_id_ = x

  def clear_source_corpus_id(self):
    self.has_source_corpus_id_ = 0
    self.source_corpus_id_ = 0

  def has_source_corpus_id(self): return self.has_source_corpus_id_

  def cycle_id(self): return self.cycle_id_

  def set_cycle_id(self, x):
    self.has_cycle_id_ = 1
    self.cycle_id_ = x

  def clear_cycle_id(self):
    self.has_cycle_id_ = 0
    self.cycle_id_ = 0

  def has_cycle_id(self): return self.has_cycle_id_

  def coverage(self): return self.coverage_

  def mutable_coverage(self): self.has_coverage_ = 1; return self.coverage_

  def clear_coverage(self):self.has_coverage_ = 0; self.coverage_.Clear()

  def has_coverage(self): return self.has_coverage_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_scorer_id_deprecated()): self.set_scorer_id_deprecated(x.scorer_id_deprecated())
    if (x.has_region_id()): self.set_region_id(x.region_id())
    if (x.has_source_corpus_id()): self.set_source_corpus_id(x.source_corpus_id())
    if (x.has_cycle_id()): self.set_cycle_id(x.cycle_id())
    if (x.has_coverage()): self.mutable_coverage().MergeFrom(x.coverage())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.RegionalCoverage', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.RegionalCoverage')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.RegionalCoverage', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.RegionalCoverage', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.RegionalCoverage', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_scorer_id_deprecated_ != x.has_scorer_id_deprecated_: return 0
    if self.has_scorer_id_deprecated_ and self.scorer_id_deprecated_ != x.scorer_id_deprecated_: return 0
    if self.has_region_id_ != x.has_region_id_: return 0
    if self.has_region_id_ and self.region_id_ != x.region_id_: return 0
    if self.has_source_corpus_id_ != x.has_source_corpus_id_: return 0
    if self.has_source_corpus_id_ and self.source_corpus_id_ != x.source_corpus_id_: return 0
    if self.has_cycle_id_ != x.has_cycle_id_: return 0
    if self.has_cycle_id_ and self.cycle_id_ != x.cycle_id_: return 0
    if self.has_coverage_ != x.has_coverage_: return 0
    if self.has_coverage_ and self.coverage_ != x.coverage_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_scorer_id_deprecated_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: scorer_id_deprecated not set.')
    if (not self.has_coverage_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: coverage not set.')
    elif not self.coverage_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.scorer_id_deprecated_)
    if (self.has_region_id_): n += 1 + self.lengthVarInt64(self.region_id_)
    if (self.has_source_corpus_id_): n += 1 + self.lengthVarInt64(self.source_corpus_id_)
    if (self.has_cycle_id_): n += 1 + self.lengthVarInt64(self.cycle_id_)
    n += self.lengthString(self.coverage_.ByteSize())
    return n + 2

  def Clear(self):
    self.clear_scorer_id_deprecated()
    self.clear_region_id()
    self.clear_source_corpus_id()
    self.clear_cycle_id()
    self.clear_coverage()

  def OutputUnchecked(self, out):
    out.putVarInt32(16)
    out.putVarInt32(self.scorer_id_deprecated_)
    out.putVarInt32(26)
    out.putVarInt32(self.coverage_.ByteSize())
    self.coverage_.OutputUnchecked(out)
    if (self.has_region_id_):
      out.putVarInt32(32)
      out.putVarInt32(self.region_id_)
    if (self.has_source_corpus_id_):
      out.putVarInt32(40)
      out.putVarInt32(self.source_corpus_id_)
    if (self.has_cycle_id_):
      out.putVarInt32(48)
      out.putVarInt32(self.cycle_id_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 16:
        self.set_scorer_id_deprecated(d.getVarInt32())
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_coverage().TryMerge(tmp)
        continue
      if tt == 32:
        self.set_region_id(d.getVarInt32())
        continue
      if tt == 40:
        self.set_source_corpus_id(d.getVarInt32())
        continue
      if tt == 48:
        self.set_cycle_id(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_scorer_id_deprecated_: res+=prefix+("scorer_id_DEPRECATED: %s\n" % self.DebugFormatInt32(self.scorer_id_deprecated_))
    if self.has_region_id_: res+=prefix+("region_id: %s\n" % self.DebugFormatInt32(self.region_id_))
    if self.has_source_corpus_id_: res+=prefix+("source_corpus_id: %s\n" % self.DebugFormatInt32(self.source_corpus_id_))
    if self.has_cycle_id_: res+=prefix+("cycle_id: %s\n" % self.DebugFormatInt32(self.cycle_id_))
    if self.has_coverage_:
      res+=prefix+"coverage <\n"
      res+=self.coverage_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

class RegionalCoverage(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 5367844 

  _TypeId_NAMES = {
    5367844: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.regioncounts_ = []
    if contents is not None: self.MergeFromString(contents)

  def regioncounts_size(self): return len(self.regioncounts_)
  def regioncounts_list(self): return self.regioncounts_

  def regioncounts(self, i):
    return self.regioncounts_[i]

  def mutable_regioncounts(self, i):
    return self.regioncounts_[i]

  def add_regioncounts(self):
    x = RegionalCoverage_RegionCounts()
    self.regioncounts_.append(x)
    return x

  def clear_regioncounts(self):
    self.regioncounts_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.regioncounts_size()): self.add_regioncounts().CopyFrom(x.regioncounts(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.RegionalCoverage', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.RegionalCoverage')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.RegionalCoverage', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.RegionalCoverage', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.RegionalCoverage', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.regioncounts_) != len(x.regioncounts_): return 0
    for e1, e2 in zip(self.regioncounts_, x.regioncounts_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.regioncounts_)):
      if (not self.regioncounts_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.regioncounts_)
    for i in xrange(len(self.regioncounts_)): n += self.regioncounts_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_regioncounts()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.regioncounts_)):
      out.putVarInt32(11)
      self.regioncounts_[i].OutputUnchecked(out)
      out.putVarInt32(12)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_regioncounts().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.regioncounts_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("RegionCounts%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kRegionCountsGroup = 1
  kRegionCountsscorer_id_DEPRECATED = 2
  kRegionCountsregion_id = 4
  kRegionCountssource_corpus_id = 5
  kRegionCountscycle_id = 6
  kRegionCountscoverage = 3

  _TEXT = (
   "ErrorCode",  #   0
   "RegionCounts",  #   1
   "scorer_id_DEPRECATED",  #   2
   "coverage",  #   3
   "region_id",  #   4
   "source_corpus_id",  #   5
   "cycle_id",  #   6
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x31,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x64,
    0x69,
    0x61,
    0x67,
    0x6e,
    0x6f,
    0x73,
    0x74,
    0x69,
    0x63,
    0x73,
    0x2f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x5f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x18,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x6c,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x13,
    0x1a,
    0x0c,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x21,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x72,
    0x5f,
    0x69,
    0x64,
    0x5f,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x72,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x69,
    0x64,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x68,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1d,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x63,
    0x6f,
    0x72,
    0x70,
    0x75,
    0x73,
    0x5f,
    0x69,
    0x64,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x63,
    0x79,
    0x63,
    0x6c,
    0x65,
    0x5f,
    0x69,
    0x64,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0x60,
    0x00,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x73,
    0x2e,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x15,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x60,
    0x00,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xa4,
    0xd0,
    0xc7,
    0x02,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x09,
    0x52,
    0x45,
    0x47,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x49,
    0x44,
    0x80,
    0x01,
    0x00,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x06,
    0x47,
    0x4c,
    0x4f,
    0x42,
    0x41,
    0x4c,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x41,
    0x4d,
    0x45,
    0x52,
    0x49,
    0x43,
    0x41,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x04,
    0x45,
    0x4d,
    0x45,
    0x41,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x04,
    0x41,
    0x53,
    0x49,
    0x41,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x4d,
    0x4f,
    0x42,
    0x49,
    0x4c,
    0x45,
    0x5f,
    0x47,
    0x4c,
    0x4f,
    0x42,
    0x41,
    0x4c,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x42,
    0x41,
    0x53,
    0x45,
    0x52,
    0x45,
    0x47,
    0x49,
    0x4f,
    0x4e,
    0x41,
    0x4c,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class SelectedMapperInfo_ServingRegions(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.region_id_ = 0
    self.has_region_id_ = 0
    if contents is not None: self.MergeFromString(contents)

  def region_id(self): return self.region_id_

  def set_region_id(self, x):
    self.has_region_id_ = 1
    self.region_id_ = x

  def clear_region_id(self):
    self.has_region_id_ = 0
    self.region_id_ = 0

  def has_region_id(self): return self.has_region_id_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_region_id()): self.set_region_id(x.region_id())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.SelectedMapperInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.SelectedMapperInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.SelectedMapperInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.SelectedMapperInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.SelectedMapperInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_region_id_ != x.has_region_id_: return 0
    if self.has_region_id_ and self.region_id_ != x.region_id_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_region_id_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: region_id not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.region_id_)
    return n + 1

  def Clear(self):
    self.clear_region_id()

  def OutputUnchecked(self, out):
    out.putVarInt32(24)
    out.putVarInt32(self.region_id_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 24:
        self.set_region_id(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_region_id_: res+=prefix+("region_id: %s\n" % self.DebugFormatInt32(self.region_id_))
    return res

class SelectedMapperInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.segment_name_ = ""
    self.servingregions_ = []
    self.has_segment_name_ = 0
    if contents is not None: self.MergeFromString(contents)

  def segment_name(self): return self.segment_name_

  def set_segment_name(self, x):
    self.has_segment_name_ = 1
    self.segment_name_ = x

  def clear_segment_name(self):
    self.has_segment_name_ = 0
    self.segment_name_ = ""

  def has_segment_name(self): return self.has_segment_name_

  def servingregions_size(self): return len(self.servingregions_)
  def servingregions_list(self): return self.servingregions_

  def servingregions(self, i):
    return self.servingregions_[i]

  def mutable_servingregions(self, i):
    return self.servingregions_[i]

  def add_servingregions(self):
    x = SelectedMapperInfo_ServingRegions()
    self.servingregions_.append(x)
    return x

  def clear_servingregions(self):
    self.servingregions_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_segment_name()): self.set_segment_name(x.segment_name())
    for i in xrange(x.servingregions_size()): self.add_servingregions().CopyFrom(x.servingregions(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.SelectedMapperInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.SelectedMapperInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.SelectedMapperInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.SelectedMapperInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.SelectedMapperInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_segment_name_ != x.has_segment_name_: return 0
    if self.has_segment_name_ and self.segment_name_ != x.segment_name_: return 0
    if len(self.servingregions_) != len(x.servingregions_): return 0
    for e1, e2 in zip(self.servingregions_, x.servingregions_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.servingregions_)):
      if (not self.servingregions_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_segment_name_): n += 1 + self.lengthString(len(self.segment_name_))
    n += 2 * len(self.servingregions_)
    for i in xrange(len(self.servingregions_)): n += self.servingregions_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_segment_name()
    self.clear_servingregions()

  def OutputUnchecked(self, out):
    if (self.has_segment_name_):
      out.putVarInt32(10)
      out.putPrefixedString(self.segment_name_)
    for i in xrange(len(self.servingregions_)):
      out.putVarInt32(19)
      self.servingregions_[i].OutputUnchecked(out)
      out.putVarInt32(20)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_segment_name(d.getPrefixedString())
        continue
      if tt == 19:
        self.add_servingregions().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_segment_name_: res+=prefix+("segment_name: %s\n" % self.DebugFormatString(self.segment_name_))
    cnt=0
    for e in self.servingregions_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("ServingRegions%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  ksegment_name = 1
  kServingRegionsGroup = 2
  kServingRegionsregion_id = 3

  _TEXT = (
   "ErrorCode",  #   0
   "segment_name",  #   1
   "ServingRegions",  #   2
   "region_id",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x31,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x64,
    0x69,
    0x61,
    0x67,
    0x6e,
    0x6f,
    0x73,
    0x74,
    0x69,
    0x63,
    0x73,
    0x2f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x5f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1a,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x53,
    0x65,
    0x6c,
    0x65,
    0x63,
    0x74,
    0x65,
    0x64,
    0x4d,
    0x61,
    0x70,
    0x70,
    0x65,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x13,
    0x1a,
    0x0c,
    0x73,
    0x65,
    0x67,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x53,
    0x65,
    0x72,
    0x76,
    0x69,
    0x6e,
    0x67,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x53,
    0x65,
    0x72,
    0x76,
    0x69,
    0x6e,
    0x67,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x72,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x69,
    0x64,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class RegionalCoverageReducerInfo_ChancesPerRegion(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.region_id_ = 0
    self.chances_ = 0
    self.has_region_id_ = 0
    self.has_chances_ = 0
    if contents is not None: self.MergeFromString(contents)

  def region_id(self): return self.region_id_

  def set_region_id(self, x):
    self.has_region_id_ = 1
    self.region_id_ = x

  def clear_region_id(self):
    self.has_region_id_ = 0
    self.region_id_ = 0

  def has_region_id(self): return self.has_region_id_

  def chances(self): return self.chances_

  def set_chances(self, x):
    self.has_chances_ = 1
    self.chances_ = x

  def clear_chances(self):
    self.has_chances_ = 0
    self.chances_ = 0

  def has_chances(self): return self.has_chances_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_region_id()): self.set_region_id(x.region_id())
    if (x.has_chances()): self.set_chances(x.chances())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.RegionalCoverageReducerInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.RegionalCoverageReducerInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.RegionalCoverageReducerInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.RegionalCoverageReducerInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.RegionalCoverageReducerInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_region_id_ != x.has_region_id_: return 0
    if self.has_region_id_ and self.region_id_ != x.region_id_: return 0
    if self.has_chances_ != x.has_chances_: return 0
    if self.has_chances_ and self.chances_ != x.chances_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_region_id_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: region_id not set.')
    if (not self.has_chances_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: chances not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.region_id_)
    n += self.lengthVarInt64(self.chances_)
    return n + 2

  def Clear(self):
    self.clear_region_id()
    self.clear_chances()

  def OutputUnchecked(self, out):
    out.putVarInt32(32)
    out.putVarInt32(self.region_id_)
    out.putVarInt32(40)
    out.putVarInt64(self.chances_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 28: break
      if tt == 32:
        self.set_region_id(d.getVarInt32())
        continue
      if tt == 40:
        self.set_chances(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_region_id_: res+=prefix+("region_id: %s\n" % self.DebugFormatInt32(self.region_id_))
    if self.has_chances_: res+=prefix+("chances: %s\n" % self.DebugFormatInt64(self.chances_))
    return res

class RegionalCoverageReducerInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.segment_id_ = 0
    self.num_segments_ = 0
    self.chancesperregion_ = []
    self.mobile_prime_log_days_ = 0
    self.mobile_backfill_log_days_ = 0
    self.has_segment_id_ = 0
    self.has_num_segments_ = 0
    self.has_mobile_prime_log_days_ = 0
    self.has_mobile_backfill_log_days_ = 0
    if contents is not None: self.MergeFromString(contents)

  def segment_id(self): return self.segment_id_

  def set_segment_id(self, x):
    self.has_segment_id_ = 1
    self.segment_id_ = x

  def clear_segment_id(self):
    self.has_segment_id_ = 0
    self.segment_id_ = 0

  def has_segment_id(self): return self.has_segment_id_

  def num_segments(self): return self.num_segments_

  def set_num_segments(self, x):
    self.has_num_segments_ = 1
    self.num_segments_ = x

  def clear_num_segments(self):
    self.has_num_segments_ = 0
    self.num_segments_ = 0

  def has_num_segments(self): return self.has_num_segments_

  def chancesperregion_size(self): return len(self.chancesperregion_)
  def chancesperregion_list(self): return self.chancesperregion_

  def chancesperregion(self, i):
    return self.chancesperregion_[i]

  def mutable_chancesperregion(self, i):
    return self.chancesperregion_[i]

  def add_chancesperregion(self):
    x = RegionalCoverageReducerInfo_ChancesPerRegion()
    self.chancesperregion_.append(x)
    return x

  def clear_chancesperregion(self):
    self.chancesperregion_ = []
  def mobile_prime_log_days(self): return self.mobile_prime_log_days_

  def set_mobile_prime_log_days(self, x):
    self.has_mobile_prime_log_days_ = 1
    self.mobile_prime_log_days_ = x

  def clear_mobile_prime_log_days(self):
    self.has_mobile_prime_log_days_ = 0
    self.mobile_prime_log_days_ = 0

  def has_mobile_prime_log_days(self): return self.has_mobile_prime_log_days_

  def mobile_backfill_log_days(self): return self.mobile_backfill_log_days_

  def set_mobile_backfill_log_days(self, x):
    self.has_mobile_backfill_log_days_ = 1
    self.mobile_backfill_log_days_ = x

  def clear_mobile_backfill_log_days(self):
    self.has_mobile_backfill_log_days_ = 0
    self.mobile_backfill_log_days_ = 0

  def has_mobile_backfill_log_days(self): return self.has_mobile_backfill_log_days_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_segment_id()): self.set_segment_id(x.segment_id())
    if (x.has_num_segments()): self.set_num_segments(x.num_segments())
    for i in xrange(x.chancesperregion_size()): self.add_chancesperregion().CopyFrom(x.chancesperregion(i))
    if (x.has_mobile_prime_log_days()): self.set_mobile_prime_log_days(x.mobile_prime_log_days())
    if (x.has_mobile_backfill_log_days()): self.set_mobile_backfill_log_days(x.mobile_backfill_log_days())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'crawler.RegionalCoverageReducerInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'crawler.RegionalCoverageReducerInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'crawler.RegionalCoverageReducerInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'crawler.RegionalCoverageReducerInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'crawler.RegionalCoverageReducerInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_segment_id_ != x.has_segment_id_: return 0
    if self.has_segment_id_ and self.segment_id_ != x.segment_id_: return 0
    if self.has_num_segments_ != x.has_num_segments_: return 0
    if self.has_num_segments_ and self.num_segments_ != x.num_segments_: return 0
    if len(self.chancesperregion_) != len(x.chancesperregion_): return 0
    for e1, e2 in zip(self.chancesperregion_, x.chancesperregion_):
      if e1 != e2: return 0
    if self.has_mobile_prime_log_days_ != x.has_mobile_prime_log_days_: return 0
    if self.has_mobile_prime_log_days_ and self.mobile_prime_log_days_ != x.mobile_prime_log_days_: return 0
    if self.has_mobile_backfill_log_days_ != x.has_mobile_backfill_log_days_: return 0
    if self.has_mobile_backfill_log_days_ and self.mobile_backfill_log_days_ != x.mobile_backfill_log_days_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_segment_id_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: segment_id not set.')
    if (not self.has_num_segments_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: num_segments not set.')
    for i in xrange(len(self.chancesperregion_)):
      if (not self.chancesperregion_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.segment_id_)
    n += self.lengthVarInt64(self.num_segments_)
    n += 2 * len(self.chancesperregion_)
    for i in xrange(len(self.chancesperregion_)): n += self.chancesperregion_[i].ByteSize()
    if (self.has_mobile_prime_log_days_): n += 1 + self.lengthVarInt64(self.mobile_prime_log_days_)
    if (self.has_mobile_backfill_log_days_): n += 1 + self.lengthVarInt64(self.mobile_backfill_log_days_)
    return n + 2

  def Clear(self):
    self.clear_segment_id()
    self.clear_num_segments()
    self.clear_chancesperregion()
    self.clear_mobile_prime_log_days()
    self.clear_mobile_backfill_log_days()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.segment_id_)
    out.putVarInt32(16)
    out.putVarInt32(self.num_segments_)
    for i in xrange(len(self.chancesperregion_)):
      out.putVarInt32(27)
      self.chancesperregion_[i].OutputUnchecked(out)
      out.putVarInt32(28)
    if (self.has_mobile_prime_log_days_):
      out.putVarInt32(48)
      out.putVarInt32(self.mobile_prime_log_days_)
    if (self.has_mobile_backfill_log_days_):
      out.putVarInt32(56)
      out.putVarInt32(self.mobile_backfill_log_days_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_segment_id(d.getVarInt32())
        continue
      if tt == 16:
        self.set_num_segments(d.getVarInt32())
        continue
      if tt == 27:
        self.add_chancesperregion().TryMerge(d)
        continue
      if tt == 48:
        self.set_mobile_prime_log_days(d.getVarInt32())
        continue
      if tt == 56:
        self.set_mobile_backfill_log_days(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_segment_id_: res+=prefix+("segment_id: %s\n" % self.DebugFormatInt32(self.segment_id_))
    if self.has_num_segments_: res+=prefix+("num_segments: %s\n" % self.DebugFormatInt32(self.num_segments_))
    cnt=0
    for e in self.chancesperregion_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("ChancesPerRegion%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_mobile_prime_log_days_: res+=prefix+("mobile_prime_log_days: %s\n" % self.DebugFormatInt32(self.mobile_prime_log_days_))
    if self.has_mobile_backfill_log_days_: res+=prefix+("mobile_backfill_log_days: %s\n" % self.DebugFormatInt32(self.mobile_backfill_log_days_))
    return res

  ksegment_id = 1
  knum_segments = 2
  kChancesPerRegionGroup = 3
  kChancesPerRegionregion_id = 4
  kChancesPerRegionchances = 5
  kmobile_prime_log_days = 6
  kmobile_backfill_log_days = 7

  _TEXT = (
   "ErrorCode",  #   0
   "segment_id",  #   1
   "num_segments",  #   2
   "ChancesPerRegion",  #   3
   "region_id",  #   4
   "chances",  #   5
   "mobile_prime_log_days",  #   6
   "mobile_backfill_log_days",  #   7
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STARTGROUP,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x31,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2f,
    0x64,
    0x69,
    0x61,
    0x67,
    0x6e,
    0x6f,
    0x73,
    0x74,
    0x69,
    0x63,
    0x73,
    0x2f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x5f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x23,
    0x63,
    0x72,
    0x61,
    0x77,
    0x6c,
    0x65,
    0x72,
    0x2e,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x6c,
    0x43,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x61,
    0x67,
    0x65,
    0x52,
    0x65,
    0x64,
    0x75,
    0x63,
    0x65,
    0x72,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x13,
    0x1a,
    0x0a,
    0x73,
    0x65,
    0x67,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x69,
    0x64,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x6e,
    0x75,
    0x6d,
    0x5f,
    0x73,
    0x65,
    0x67,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x43,
    0x68,
    0x61,
    0x6e,
    0x63,
    0x65,
    0x73,
    0x50,
    0x65,
    0x72,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x03,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x43,
    0x68,
    0x61,
    0x6e,
    0x63,
    0x65,
    0x73,
    0x50,
    0x65,
    0x72,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x72,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x69,
    0x64,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x43,
    0x68,
    0x61,
    0x6e,
    0x63,
    0x65,
    0x73,
    0x50,
    0x65,
    0x72,
    0x52,
    0x65,
    0x67,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x63,
    0x68,
    0x61,
    0x6e,
    0x63,
    0x65,
    0x73,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x6d,
    0x6f,
    0x62,
    0x69,
    0x6c,
    0x65,
    0x5f,
    0x70,
    0x72,
    0x69,
    0x6d,
    0x65,
    0x5f,
    0x6c,
    0x6f,
    0x67,
    0x5f,
    0x64,
    0x61,
    0x79,
    0x73,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x6d,
    0x6f,
    0x62,
    0x69,
    0x6c,
    0x65,
    0x5f,
    0x62,
    0x61,
    0x63,
    0x6b,
    0x66,
    0x69,
    0x6c,
    0x6c,
    0x5f,
    0x6c,
    0x6f,
    0x67,
    0x5f,
    0x64,
    0x61,
    0x79,
    0x73,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['IndexCoverage','Conditions','IndexCoverageSet','IndexCoverageSet_Events','IndexCoverageAggregate','IndexCoverageHistogram','IndexCoverageHistogram_Bin','IndexCoverageStatistics','IndexCoverageStatistics_Stats','CumulativeIndexCoverage','RegionalCoverage','RegionalCoverage_RegionCounts','SelectedMapperInfo','SelectedMapperInfo_ServingRegions','RegionalCoverageReducerInfo','RegionalCoverageReducerInfo_ChancesPerRegion']
