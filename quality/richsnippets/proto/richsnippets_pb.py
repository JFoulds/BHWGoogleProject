# This file automatically generated by protocol-compiler from quality/richsnippets/proto/richsnippets.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

from google3.weboftrust.prose.rpc.base_prose_server_pb import ProseOneboxProviderReply
class DataObject_Attribute(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.value_ = ""
    self.cdata_ = ""
    self.has_name_ = 0
    self.has_value_ = 0
    self.has_cdata_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_

  def cdata(self): return self.cdata_

  def set_cdata(self, x):
    self.has_cdata_ = 1
    self.cdata_ = x

  def clear_cdata(self):
    self.has_cdata_ = 0
    self.cdata_ = ""

  def has_cdata(self): return self.has_cdata_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_value()): self.set_value(x.value())
    if (x.has_cdata()): self.set_cdata(x.cdata())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'richsnippets.DataObject', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'richsnippets.DataObject')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'richsnippets.DataObject', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'richsnippets.DataObject', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'richsnippets.DataObject', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    if self.has_cdata_ != x.has_cdata_: return 0
    if self.has_cdata_ and self.cdata_ != x.cdata_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    if (self.has_value_): n += 1 + self.lengthString(len(self.value_))
    if (self.has_cdata_): n += 1 + self.lengthString(len(self.cdata_))
    return n + 1

  def Clear(self):
    self.clear_name()
    self.clear_value()
    self.clear_cdata()

  def OutputUnchecked(self, out):
    out.putVarInt32(26)
    out.putPrefixedString(self.name_)
    if (self.has_value_):
      out.putVarInt32(34)
      out.putPrefixedString(self.value_)
    if (self.has_cdata_):
      out.putVarInt32(42)
      out.putPrefixedString(self.cdata_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 26:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 34:
        self.set_value(d.getPrefixedString())
        continue
      if tt == 42:
        self.set_cdata(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_value_: res+=prefix+("value: %s\n" % self.DebugFormatString(self.value_))
    if self.has_cdata_: res+=prefix+("cdata: %s\n" % self.DebugFormatString(self.cdata_))
    return res

class DataObject(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = ""
    self.attribute_ = []
    self.has_type_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = ""

  def has_type(self): return self.has_type_

  def attribute_size(self): return len(self.attribute_)
  def attribute_list(self): return self.attribute_

  def attribute(self, i):
    return self.attribute_[i]

  def mutable_attribute(self, i):
    return self.attribute_[i]

  def add_attribute(self):
    x = DataObject_Attribute()
    self.attribute_.append(x)
    return x

  def clear_attribute(self):
    self.attribute_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    for i in xrange(x.attribute_size()): self.add_attribute().CopyFrom(x.attribute(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'richsnippets.DataObject', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'richsnippets.DataObject')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'richsnippets.DataObject', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'richsnippets.DataObject', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'richsnippets.DataObject', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if len(self.attribute_) != len(x.attribute_): return 0
    for e1, e2 in zip(self.attribute_, x.attribute_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.attribute_)):
      if (not self.attribute_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_type_): n += 1 + self.lengthString(len(self.type_))
    n += 2 * len(self.attribute_)
    for i in xrange(len(self.attribute_)): n += self.attribute_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_type()
    self.clear_attribute()

  def OutputUnchecked(self, out):
    if (self.has_type_):
      out.putVarInt32(10)
      out.putPrefixedString(self.type_)
    for i in xrange(len(self.attribute_)):
      out.putVarInt32(19)
      self.attribute_[i].OutputUnchecked(out)
      out.putVarInt32(20)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_type(d.getPrefixedString())
        continue
      if tt == 19:
        self.add_attribute().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("type: %s\n" % self.DebugFormatString(self.type_))
    cnt=0
    for e in self.attribute_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Attribute%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  ktype = 1
  kAttributeGroup = 2
  kAttributename = 3
  kAttributevalue = 4
  kAttributecdata = 5

  _TEXT = (
   "ErrorCode",  #   0
   "type",  #   1
   "Attribute",  #   2
   "name",  #   3
   "value",  #   4
   "cdata",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2d,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x72,
    0x69,
    0x63,
    0x68,
    0x73,
    0x6e,
    0x69,
    0x70,
    0x70,
    0x65,
    0x74,
    0x73,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x72,
    0x69,
    0x63,
    0x68,
    0x73,
    0x6e,
    0x69,
    0x70,
    0x70,
    0x65,
    0x74,
    0x73,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x17,
    0x72,
    0x69,
    0x63,
    0x68,
    0x73,
    0x6e,
    0x69,
    0x70,
    0x70,
    0x65,
    0x74,
    0x73,
    0x2e,
    0x44,
    0x61,
    0x74,
    0x61,
    0x4f,
    0x62,
    0x6a,
    0x65,
    0x63,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x2e,
    0x63,
    0x64,
    0x61,
    0x74,
    0x61,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class PageMap_TemplateType(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.src_ = ""
    self.has_src_ = 0
    if contents is not None: self.MergeFromString(contents)

  def src(self): return self.src_

  def set_src(self, x):
    self.has_src_ = 1
    self.src_ = x

  def clear_src(self):
    self.has_src_ = 0
    self.src_ = ""

  def has_src(self): return self.has_src_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_src()): self.set_src(x.src())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'richsnippets.PageMap', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'richsnippets.PageMap')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'richsnippets.PageMap', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'richsnippets.PageMap', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'richsnippets.PageMap', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_src_ != x.has_src_: return 0
    if self.has_src_ and self.src_ != x.src_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_src_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: src not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.src_))
    return n + 1

  def Clear(self):
    self.clear_src()

  def OutputUnchecked(self, out):
    out.putVarInt32(18)
    out.putPrefixedString(self.src_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        self.set_src(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_src_: res+=prefix+("src: %s\n" % self.DebugFormatString(self.src_))
    return res

class PageMap(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 7292182 

  _TypeId_NAMES = {
    7292182: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.templatetype_ = []
    self.dataobject_ = []
    self.richsnippet_as_onebox_ = None
    self.has_richsnippet_as_onebox_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def templatetype_size(self): return len(self.templatetype_)
  def templatetype_list(self): return self.templatetype_

  def templatetype(self, i):
    return self.templatetype_[i]

  def mutable_templatetype(self, i):
    return self.templatetype_[i]

  def add_templatetype(self):
    x = PageMap_TemplateType()
    self.templatetype_.append(x)
    return x

  def clear_templatetype(self):
    self.templatetype_ = []
  def dataobject_size(self): return len(self.dataobject_)
  def dataobject_list(self): return self.dataobject_

  def dataobject(self, i):
    return self.dataobject_[i]

  def mutable_dataobject(self, i):
    return self.dataobject_[i]

  def add_dataobject(self):
    x = DataObject()
    self.dataobject_.append(x)
    return x

  def clear_dataobject(self):
    self.dataobject_ = []
  def richsnippet_as_onebox(self):
    if self.richsnippet_as_onebox_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.richsnippet_as_onebox_ is None: self.richsnippet_as_onebox_ = ProseOneboxProviderReply()
      finally:
        self.lazy_init_lock_.release()
    return self.richsnippet_as_onebox_

  def mutable_richsnippet_as_onebox(self): self.has_richsnippet_as_onebox_ = 1; return self.richsnippet_as_onebox()

  def clear_richsnippet_as_onebox(self):
    #Warning: this method does not acquire the lock.
    self.has_richsnippet_as_onebox_ = 0;
    if self.richsnippet_as_onebox_ is not None: self.richsnippet_as_onebox_.Clear()

  def has_richsnippet_as_onebox(self): return self.has_richsnippet_as_onebox_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.templatetype_size()): self.add_templatetype().CopyFrom(x.templatetype(i))
    for i in xrange(x.dataobject_size()): self.add_dataobject().CopyFrom(x.dataobject(i))
    if (x.has_richsnippet_as_onebox()): self.mutable_richsnippet_as_onebox().MergeFrom(x.richsnippet_as_onebox())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'richsnippets.PageMap', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'richsnippets.PageMap')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'richsnippets.PageMap', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'richsnippets.PageMap', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'richsnippets.PageMap', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.templatetype_) != len(x.templatetype_): return 0
    for e1, e2 in zip(self.templatetype_, x.templatetype_):
      if e1 != e2: return 0
    if len(self.dataobject_) != len(x.dataobject_): return 0
    for e1, e2 in zip(self.dataobject_, x.dataobject_):
      if e1 != e2: return 0
    if self.has_richsnippet_as_onebox_ != x.has_richsnippet_as_onebox_: return 0
    if self.has_richsnippet_as_onebox_ and self.richsnippet_as_onebox_ != x.richsnippet_as_onebox_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.templatetype_)):
      if (not self.templatetype_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.dataobject_)):
      if (not self.dataobject_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_richsnippet_as_onebox_ and not self.richsnippet_as_onebox_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.templatetype_)
    for i in xrange(len(self.templatetype_)): n += self.templatetype_[i].ByteSize()
    n += 1 * len(self.dataobject_)
    for i in xrange(len(self.dataobject_)): n += self.lengthString(self.dataobject_[i].ByteSize())
    if (self.has_richsnippet_as_onebox_): n += 2 + self.lengthString(self.richsnippet_as_onebox_.ByteSize())
    return n + 0

  def Clear(self):
    self.clear_templatetype()
    self.clear_dataobject()
    self.clear_richsnippet_as_onebox()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.templatetype_)):
      out.putVarInt32(11)
      self.templatetype_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    for i in xrange(len(self.dataobject_)):
      out.putVarInt32(26)
      out.putVarInt32(self.dataobject_[i].ByteSize())
      self.dataobject_[i].OutputUnchecked(out)
    if (self.has_richsnippet_as_onebox_):
      out.putVarInt32(850)
      out.putVarInt32(self.richsnippet_as_onebox_.ByteSize())
      self.richsnippet_as_onebox_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_templatetype().TryMerge(d)
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_dataobject().TryMerge(tmp)
        continue
      if tt == 850:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_richsnippet_as_onebox().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.templatetype_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("TemplateType%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.dataobject_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DataObject%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_richsnippet_as_onebox_:
      res+=prefix+"richsnippet_as_onebox <\n"
      res+=self.richsnippet_as_onebox_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

  kTemplateTypeGroup = 1
  kTemplateTypesrc = 2
  kDataObject = 3
  krichsnippet_as_onebox = 106

  _TEXT = (
   "ErrorCode",  #   0
   "TemplateType",  #   1
   "src",  #   2
   "DataObject",  #   3
   None,  #   4
   None,  #   5
   None,  #   6
   None,  #   7
   None,  #   8
   None,  #   9
   None,  #  10
   None,  #  11
   None,  #  12
   None,  #  13
   None,  #  14
   None,  #  15
   None,  #  16
   None,  #  17
   None,  #  18
   None,  #  19
   None,  #  20
   None,  #  21
   None,  #  22
   None,  #  23
   None,  #  24
   None,  #  25
   None,  #  26
   None,  #  27
   None,  #  28
   None,  #  29
   None,  #  30
   None,  #  31
   None,  #  32
   None,  #  33
   None,  #  34
   None,  #  35
   None,  #  36
   None,  #  37
   None,  #  38
   None,  #  39
   None,  #  40
   None,  #  41
   None,  #  42
   None,  #  43
   None,  #  44
   None,  #  45
   None,  #  46
   None,  #  47
   None,  #  48
   None,  #  49
   None,  #  50
   None,  #  51
   None,  #  52
   None,  #  53
   None,  #  54
   None,  #  55
   None,  #  56
   None,  #  57
   None,  #  58
   None,  #  59
   None,  #  60
   None,  #  61
   None,  #  62
   None,  #  63
   None,  #  64
   None,  #  65
   None,  #  66
   None,  #  67
   None,  #  68
   None,  #  69
   None,  #  70
   None,  #  71
   None,  #  72
   None,  #  73
   None,  #  74
   None,  #  75
   None,  #  76
   None,  #  77
   None,  #  78
   None,  #  79
   None,  #  80
   None,  #  81
   None,  #  82
   None,  #  83
   None,  #  84
   None,  #  85
   None,  #  86
   None,  #  87
   None,  #  88
   None,  #  89
   None,  #  90
   None,  #  91
   None,  #  92
   None,  #  93
   None,  #  94
   None,  #  95
   None,  #  96
   None,  #  97
   None,  #  98
   None,  #  99
   None,  # 100
   None,  # 101
   None,  # 102
   None,  # 103
   None,  # 104
   None,  # 105
   "richsnippet_as_onebox",  # 106
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.MAX_TYPE,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.MAX_TYPE,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.MAX_TYPE,  #   8

   ProtocolBuffer.Encoder.MAX_TYPE,  #   9

   ProtocolBuffer.Encoder.MAX_TYPE,  #  10

   ProtocolBuffer.Encoder.MAX_TYPE,  #  11

   ProtocolBuffer.Encoder.MAX_TYPE,  #  12

   ProtocolBuffer.Encoder.MAX_TYPE,  #  13

   ProtocolBuffer.Encoder.MAX_TYPE,  #  14

   ProtocolBuffer.Encoder.MAX_TYPE,  #  15

   ProtocolBuffer.Encoder.MAX_TYPE,  #  16

   ProtocolBuffer.Encoder.MAX_TYPE,  #  17

   ProtocolBuffer.Encoder.MAX_TYPE,  #  18

   ProtocolBuffer.Encoder.MAX_TYPE,  #  19

   ProtocolBuffer.Encoder.MAX_TYPE,  #  20

   ProtocolBuffer.Encoder.MAX_TYPE,  #  21

   ProtocolBuffer.Encoder.MAX_TYPE,  #  22

   ProtocolBuffer.Encoder.MAX_TYPE,  #  23

   ProtocolBuffer.Encoder.MAX_TYPE,  #  24

   ProtocolBuffer.Encoder.MAX_TYPE,  #  25

   ProtocolBuffer.Encoder.MAX_TYPE,  #  26

   ProtocolBuffer.Encoder.MAX_TYPE,  #  27

   ProtocolBuffer.Encoder.MAX_TYPE,  #  28

   ProtocolBuffer.Encoder.MAX_TYPE,  #  29

   ProtocolBuffer.Encoder.MAX_TYPE,  #  30

   ProtocolBuffer.Encoder.MAX_TYPE,  #  31

   ProtocolBuffer.Encoder.MAX_TYPE,  #  32

   ProtocolBuffer.Encoder.MAX_TYPE,  #  33

   ProtocolBuffer.Encoder.MAX_TYPE,  #  34

   ProtocolBuffer.Encoder.MAX_TYPE,  #  35

   ProtocolBuffer.Encoder.MAX_TYPE,  #  36

   ProtocolBuffer.Encoder.MAX_TYPE,  #  37

   ProtocolBuffer.Encoder.MAX_TYPE,  #  38

   ProtocolBuffer.Encoder.MAX_TYPE,  #  39

   ProtocolBuffer.Encoder.MAX_TYPE,  #  40

   ProtocolBuffer.Encoder.MAX_TYPE,  #  41

   ProtocolBuffer.Encoder.MAX_TYPE,  #  42

   ProtocolBuffer.Encoder.MAX_TYPE,  #  43

   ProtocolBuffer.Encoder.MAX_TYPE,  #  44

   ProtocolBuffer.Encoder.MAX_TYPE,  #  45

   ProtocolBuffer.Encoder.MAX_TYPE,  #  46

   ProtocolBuffer.Encoder.MAX_TYPE,  #  47

   ProtocolBuffer.Encoder.MAX_TYPE,  #  48

   ProtocolBuffer.Encoder.MAX_TYPE,  #  49

   ProtocolBuffer.Encoder.MAX_TYPE,  #  50

   ProtocolBuffer.Encoder.MAX_TYPE,  #  51

   ProtocolBuffer.Encoder.MAX_TYPE,  #  52

   ProtocolBuffer.Encoder.MAX_TYPE,  #  53

   ProtocolBuffer.Encoder.MAX_TYPE,  #  54

   ProtocolBuffer.Encoder.MAX_TYPE,  #  55

   ProtocolBuffer.Encoder.MAX_TYPE,  #  56

   ProtocolBuffer.Encoder.MAX_TYPE,  #  57

   ProtocolBuffer.Encoder.MAX_TYPE,  #  58

   ProtocolBuffer.Encoder.MAX_TYPE,  #  59

   ProtocolBuffer.Encoder.MAX_TYPE,  #  60

   ProtocolBuffer.Encoder.MAX_TYPE,  #  61

   ProtocolBuffer.Encoder.MAX_TYPE,  #  62

   ProtocolBuffer.Encoder.MAX_TYPE,  #  63

   ProtocolBuffer.Encoder.MAX_TYPE,  #  64

   ProtocolBuffer.Encoder.MAX_TYPE,  #  65

   ProtocolBuffer.Encoder.MAX_TYPE,  #  66

   ProtocolBuffer.Encoder.MAX_TYPE,  #  67

   ProtocolBuffer.Encoder.MAX_TYPE,  #  68

   ProtocolBuffer.Encoder.MAX_TYPE,  #  69

   ProtocolBuffer.Encoder.MAX_TYPE,  #  70

   ProtocolBuffer.Encoder.MAX_TYPE,  #  71

   ProtocolBuffer.Encoder.MAX_TYPE,  #  72

   ProtocolBuffer.Encoder.MAX_TYPE,  #  73

   ProtocolBuffer.Encoder.MAX_TYPE,  #  74

   ProtocolBuffer.Encoder.MAX_TYPE,  #  75

   ProtocolBuffer.Encoder.MAX_TYPE,  #  76

   ProtocolBuffer.Encoder.MAX_TYPE,  #  77

   ProtocolBuffer.Encoder.MAX_TYPE,  #  78

   ProtocolBuffer.Encoder.MAX_TYPE,  #  79

   ProtocolBuffer.Encoder.MAX_TYPE,  #  80

   ProtocolBuffer.Encoder.MAX_TYPE,  #  81

   ProtocolBuffer.Encoder.MAX_TYPE,  #  82

   ProtocolBuffer.Encoder.MAX_TYPE,  #  83

   ProtocolBuffer.Encoder.MAX_TYPE,  #  84

   ProtocolBuffer.Encoder.MAX_TYPE,  #  85

   ProtocolBuffer.Encoder.MAX_TYPE,  #  86

   ProtocolBuffer.Encoder.MAX_TYPE,  #  87

   ProtocolBuffer.Encoder.MAX_TYPE,  #  88

   ProtocolBuffer.Encoder.MAX_TYPE,  #  89

   ProtocolBuffer.Encoder.MAX_TYPE,  #  90

   ProtocolBuffer.Encoder.MAX_TYPE,  #  91

   ProtocolBuffer.Encoder.MAX_TYPE,  #  92

   ProtocolBuffer.Encoder.MAX_TYPE,  #  93

   ProtocolBuffer.Encoder.MAX_TYPE,  #  94

   ProtocolBuffer.Encoder.MAX_TYPE,  #  95

   ProtocolBuffer.Encoder.MAX_TYPE,  #  96

   ProtocolBuffer.Encoder.MAX_TYPE,  #  97

   ProtocolBuffer.Encoder.MAX_TYPE,  #  98

   ProtocolBuffer.Encoder.MAX_TYPE,  #  99

   ProtocolBuffer.Encoder.MAX_TYPE,  # 100

   ProtocolBuffer.Encoder.MAX_TYPE,  # 101

   ProtocolBuffer.Encoder.MAX_TYPE,  # 102

   ProtocolBuffer.Encoder.MAX_TYPE,  # 103

   ProtocolBuffer.Encoder.MAX_TYPE,  # 104

   ProtocolBuffer.Encoder.MAX_TYPE,  # 105

   ProtocolBuffer.Encoder.STRING,  # 106

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2d,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x72,
    0x69,
    0x63,
    0x68,
    0x73,
    0x6e,
    0x69,
    0x70,
    0x70,
    0x65,
    0x74,
    0x73,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x72,
    0x69,
    0x63,
    0x68,
    0x73,
    0x6e,
    0x69,
    0x70,
    0x70,
    0x65,
    0x74,
    0x73,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x14,
    0x72,
    0x69,
    0x63,
    0x68,
    0x73,
    0x6e,
    0x69,
    0x70,
    0x70,
    0x65,
    0x74,
    0x73,
    0x2e,
    0x50,
    0x61,
    0x67,
    0x65,
    0x4d,
    0x61,
    0x70,
    0x13,
    0x1a,
    0x0c,
    0x54,
    0x65,
    0x6d,
    0x70,
    0x6c,
    0x61,
    0x74,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x54,
    0x65,
    0x6d,
    0x70,
    0x6c,
    0x61,
    0x74,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x2e,
    0x73,
    0x72,
    0x63,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x44,
    0x61,
    0x74,
    0x61,
    0x4f,
    0x62,
    0x6a,
    0x65,
    0x63,
    0x74,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x17,
    0x72,
    0x69,
    0x63,
    0x68,
    0x73,
    0x6e,
    0x69,
    0x70,
    0x70,
    0x65,
    0x74,
    0x73,
    0x2e,
    0x44,
    0x61,
    0x74,
    0x61,
    0x4f,
    0x62,
    0x6a,
    0x65,
    0x63,
    0x74,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x72,
    0x69,
    0x63,
    0x68,
    0x73,
    0x6e,
    0x69,
    0x70,
    0x70,
    0x65,
    0x74,
    0x5f,
    0x61,
    0x73,
    0x5f,
    0x6f,
    0x6e,
    0x65,
    0x62,
    0x6f,
    0x78,
    0x20,
    0x6a,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x23,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x50,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x4f,
    0x6e,
    0x65,
    0x62,
    0x6f,
    0x78,
    0x50,
    0x72,
    0x6f,
    0x76,
    0x69,
    0x64,
    0x65,
    0x72,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0x96,
    0x8a,
    0xbd,
    0x03,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['DataObject','DataObject_Attribute','PageMap','PageMap_TemplateType']
