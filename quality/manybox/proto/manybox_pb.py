# This file automatically generated by protocol-compiler from quality/manybox/proto/manybox.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

from google3.net.proto.message_set import MessageSet
from google3.location.country.postaladdress_pb import PostalAddress
from google3.location.country.telephonenumber_pb import TelephoneNumber
from google3.repository.base.repository_pb import GDocumentBase
from google3.googlebase.mustang.protos.googlebase_web_attributes_pb import GoogleBaseWebAttributes
class ManyboxData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 2338328 

  _TypeId_NAMES = {
    2338328: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)


  INLINKS      =    0 
  DAFFIE       =    1 
  RELATED      =    2 
  SNIPPET      =    3 
  IMAGE        =    4 
  LOCAL        =    5 
  SCHOLAR      =    6 
  FINANCE      =    7 
  GOOGLEBASE   =    8 
  FLASHSKIPINTRO =    9 
  SITESEARCH   =   10 

  _DataTypes_NAMES = {
    0: "INLINKS",
    1: "DAFFIE",
    2: "RELATED",
    3: "SNIPPET",
    4: "IMAGE",
    5: "LOCAL",
    6: "SCHOLAR",
    7: "FINANCE",
    8: "GOOGLEBASE",
    9: "FLASHSKIPINTRO",
    10: "SITESEARCH",
  }

  def DataTypes_Name(cls, x): return cls._DataTypes_NAMES.get(x, "")
  DataTypes_Name = classmethod(DataTypes_Name)

  def __init__(self, contents=None):
    self.components_ = None
    self.data_summary_ = 0
    self.debug_ = ""
    self.has_components_ = 0
    self.has_data_summary_ = 0
    self.has_debug_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def components(self):
    if self.components_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.components_ is None: self.components_ = MessageSet()
      finally:
        self.lazy_init_lock_.release()
    return self.components_

  def mutable_components(self): self.has_components_ = 1; return self.components()

  def clear_components(self):
    #Warning: this method does not acquire the lock.
    self.has_components_ = 0;
    if self.components_ is not None: self.components_.Clear()

  def has_components(self): return self.has_components_

  def data_summary(self): return self.data_summary_

  def set_data_summary(self, x):
    self.has_data_summary_ = 1
    self.data_summary_ = x

  def clear_data_summary(self):
    self.has_data_summary_ = 0
    self.data_summary_ = 0

  def has_data_summary(self): return self.has_data_summary_

  def debug(self): return self.debug_

  def set_debug(self, x):
    self.has_debug_ = 1
    self.debug_ = x

  def clear_debug(self):
    self.has_debug_ = 0
    self.debug_ = ""

  def has_debug(self): return self.has_debug_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_components()): self.mutable_components().MergeFrom(x.components())
    if (x.has_data_summary()): self.set_data_summary(x.data_summary())
    if (x.has_debug()): self.set_debug(x.debug())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ManyboxData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ManyboxData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ManyboxData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ManyboxData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ManyboxData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_components_ != x.has_components_: return 0
    if self.has_components_ and self.components_ != x.components_: return 0
    if self.has_data_summary_ != x.has_data_summary_: return 0
    if self.has_data_summary_ and self.data_summary_ != x.data_summary_: return 0
    if self.has_debug_ != x.has_debug_: return 0
    if self.has_debug_ and self.debug_ != x.debug_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (self.has_components_ and not self.components_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_components_): n += 1 + self.lengthString(self.components_.ByteSize())
    if (self.has_data_summary_): n += 1 + self.lengthVarInt64(self.data_summary_)
    if (self.has_debug_): n += 2 + self.lengthString(len(self.debug_))
    return n + 0

  def Clear(self):
    self.clear_components()
    self.clear_data_summary()
    self.clear_debug()

  def OutputUnchecked(self, out):
    if (self.has_components_):
      out.putVarInt32(10)
      out.putVarInt32(self.components_.ByteSize())
      self.components_.OutputUnchecked(out)
    if (self.has_data_summary_):
      out.putVarInt32(24)
      out.putVarInt32(self.data_summary_)
    if (self.has_debug_):
      out.putVarInt32(802)
      out.putPrefixedString(self.debug_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_components().TryMerge(tmp)
        continue
      if tt == 24:
        self.set_data_summary(d.getVarInt32())
        continue
      if tt == 802:
        self.set_debug(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_components_:
      res+=prefix+"components <\n"
      res+=self.components_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_data_summary_: res+=prefix+("data_summary: %s\n" % self.DebugFormatInt32(self.data_summary_))
    if self.has_debug_: res+=prefix+("debug: %s\n" % self.DebugFormatString(self.debug_))
    return res

  kcomponents = 1
  kdata_summary = 3
  kdebug = 100

  _TEXT = (
   "ErrorCode",  #   0
   "components",  #   1
   None,  #   2
   "data_summary",  #   3
   None,  #   4
   None,  #   5
   None,  #   6
   None,  #   7
   None,  #   8
   None,  #   9
   None,  #  10
   None,  #  11
   None,  #  12
   None,  #  13
   None,  #  14
   None,  #  15
   None,  #  16
   None,  #  17
   None,  #  18
   None,  #  19
   None,  #  20
   None,  #  21
   None,  #  22
   None,  #  23
   None,  #  24
   None,  #  25
   None,  #  26
   None,  #  27
   None,  #  28
   None,  #  29
   None,  #  30
   None,  #  31
   None,  #  32
   None,  #  33
   None,  #  34
   None,  #  35
   None,  #  36
   None,  #  37
   None,  #  38
   None,  #  39
   None,  #  40
   None,  #  41
   None,  #  42
   None,  #  43
   None,  #  44
   None,  #  45
   None,  #  46
   None,  #  47
   None,  #  48
   None,  #  49
   None,  #  50
   None,  #  51
   None,  #  52
   None,  #  53
   None,  #  54
   None,  #  55
   None,  #  56
   None,  #  57
   None,  #  58
   None,  #  59
   None,  #  60
   None,  #  61
   None,  #  62
   None,  #  63
   None,  #  64
   None,  #  65
   None,  #  66
   None,  #  67
   None,  #  68
   None,  #  69
   None,  #  70
   None,  #  71
   None,  #  72
   None,  #  73
   None,  #  74
   None,  #  75
   None,  #  76
   None,  #  77
   None,  #  78
   None,  #  79
   None,  #  80
   None,  #  81
   None,  #  82
   None,  #  83
   None,  #  84
   None,  #  85
   None,  #  86
   None,  #  87
   None,  #  88
   None,  #  89
   None,  #  90
   None,  #  91
   None,  #  92
   None,  #  93
   None,  #  94
   None,  #  95
   None,  #  96
   None,  #  97
   None,  #  98
   None,  #  99
   "debug",  # 100
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.MAX_TYPE,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.MAX_TYPE,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.MAX_TYPE,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.MAX_TYPE,  #   8

   ProtocolBuffer.Encoder.MAX_TYPE,  #   9

   ProtocolBuffer.Encoder.MAX_TYPE,  #  10

   ProtocolBuffer.Encoder.MAX_TYPE,  #  11

   ProtocolBuffer.Encoder.MAX_TYPE,  #  12

   ProtocolBuffer.Encoder.MAX_TYPE,  #  13

   ProtocolBuffer.Encoder.MAX_TYPE,  #  14

   ProtocolBuffer.Encoder.MAX_TYPE,  #  15

   ProtocolBuffer.Encoder.MAX_TYPE,  #  16

   ProtocolBuffer.Encoder.MAX_TYPE,  #  17

   ProtocolBuffer.Encoder.MAX_TYPE,  #  18

   ProtocolBuffer.Encoder.MAX_TYPE,  #  19

   ProtocolBuffer.Encoder.MAX_TYPE,  #  20

   ProtocolBuffer.Encoder.MAX_TYPE,  #  21

   ProtocolBuffer.Encoder.MAX_TYPE,  #  22

   ProtocolBuffer.Encoder.MAX_TYPE,  #  23

   ProtocolBuffer.Encoder.MAX_TYPE,  #  24

   ProtocolBuffer.Encoder.MAX_TYPE,  #  25

   ProtocolBuffer.Encoder.MAX_TYPE,  #  26

   ProtocolBuffer.Encoder.MAX_TYPE,  #  27

   ProtocolBuffer.Encoder.MAX_TYPE,  #  28

   ProtocolBuffer.Encoder.MAX_TYPE,  #  29

   ProtocolBuffer.Encoder.MAX_TYPE,  #  30

   ProtocolBuffer.Encoder.MAX_TYPE,  #  31

   ProtocolBuffer.Encoder.MAX_TYPE,  #  32

   ProtocolBuffer.Encoder.MAX_TYPE,  #  33

   ProtocolBuffer.Encoder.MAX_TYPE,  #  34

   ProtocolBuffer.Encoder.MAX_TYPE,  #  35

   ProtocolBuffer.Encoder.MAX_TYPE,  #  36

   ProtocolBuffer.Encoder.MAX_TYPE,  #  37

   ProtocolBuffer.Encoder.MAX_TYPE,  #  38

   ProtocolBuffer.Encoder.MAX_TYPE,  #  39

   ProtocolBuffer.Encoder.MAX_TYPE,  #  40

   ProtocolBuffer.Encoder.MAX_TYPE,  #  41

   ProtocolBuffer.Encoder.MAX_TYPE,  #  42

   ProtocolBuffer.Encoder.MAX_TYPE,  #  43

   ProtocolBuffer.Encoder.MAX_TYPE,  #  44

   ProtocolBuffer.Encoder.MAX_TYPE,  #  45

   ProtocolBuffer.Encoder.MAX_TYPE,  #  46

   ProtocolBuffer.Encoder.MAX_TYPE,  #  47

   ProtocolBuffer.Encoder.MAX_TYPE,  #  48

   ProtocolBuffer.Encoder.MAX_TYPE,  #  49

   ProtocolBuffer.Encoder.MAX_TYPE,  #  50

   ProtocolBuffer.Encoder.MAX_TYPE,  #  51

   ProtocolBuffer.Encoder.MAX_TYPE,  #  52

   ProtocolBuffer.Encoder.MAX_TYPE,  #  53

   ProtocolBuffer.Encoder.MAX_TYPE,  #  54

   ProtocolBuffer.Encoder.MAX_TYPE,  #  55

   ProtocolBuffer.Encoder.MAX_TYPE,  #  56

   ProtocolBuffer.Encoder.MAX_TYPE,  #  57

   ProtocolBuffer.Encoder.MAX_TYPE,  #  58

   ProtocolBuffer.Encoder.MAX_TYPE,  #  59

   ProtocolBuffer.Encoder.MAX_TYPE,  #  60

   ProtocolBuffer.Encoder.MAX_TYPE,  #  61

   ProtocolBuffer.Encoder.MAX_TYPE,  #  62

   ProtocolBuffer.Encoder.MAX_TYPE,  #  63

   ProtocolBuffer.Encoder.MAX_TYPE,  #  64

   ProtocolBuffer.Encoder.MAX_TYPE,  #  65

   ProtocolBuffer.Encoder.MAX_TYPE,  #  66

   ProtocolBuffer.Encoder.MAX_TYPE,  #  67

   ProtocolBuffer.Encoder.MAX_TYPE,  #  68

   ProtocolBuffer.Encoder.MAX_TYPE,  #  69

   ProtocolBuffer.Encoder.MAX_TYPE,  #  70

   ProtocolBuffer.Encoder.MAX_TYPE,  #  71

   ProtocolBuffer.Encoder.MAX_TYPE,  #  72

   ProtocolBuffer.Encoder.MAX_TYPE,  #  73

   ProtocolBuffer.Encoder.MAX_TYPE,  #  74

   ProtocolBuffer.Encoder.MAX_TYPE,  #  75

   ProtocolBuffer.Encoder.MAX_TYPE,  #  76

   ProtocolBuffer.Encoder.MAX_TYPE,  #  77

   ProtocolBuffer.Encoder.MAX_TYPE,  #  78

   ProtocolBuffer.Encoder.MAX_TYPE,  #  79

   ProtocolBuffer.Encoder.MAX_TYPE,  #  80

   ProtocolBuffer.Encoder.MAX_TYPE,  #  81

   ProtocolBuffer.Encoder.MAX_TYPE,  #  82

   ProtocolBuffer.Encoder.MAX_TYPE,  #  83

   ProtocolBuffer.Encoder.MAX_TYPE,  #  84

   ProtocolBuffer.Encoder.MAX_TYPE,  #  85

   ProtocolBuffer.Encoder.MAX_TYPE,  #  86

   ProtocolBuffer.Encoder.MAX_TYPE,  #  87

   ProtocolBuffer.Encoder.MAX_TYPE,  #  88

   ProtocolBuffer.Encoder.MAX_TYPE,  #  89

   ProtocolBuffer.Encoder.MAX_TYPE,  #  90

   ProtocolBuffer.Encoder.MAX_TYPE,  #  91

   ProtocolBuffer.Encoder.MAX_TYPE,  #  92

   ProtocolBuffer.Encoder.MAX_TYPE,  #  93

   ProtocolBuffer.Encoder.MAX_TYPE,  #  94

   ProtocolBuffer.Encoder.MAX_TYPE,  #  95

   ProtocolBuffer.Encoder.MAX_TYPE,  #  96

   ProtocolBuffer.Encoder.MAX_TYPE,  #  97

   ProtocolBuffer.Encoder.MAX_TYPE,  #  98

   ProtocolBuffer.Encoder.MAX_TYPE,  #  99

   ProtocolBuffer.Encoder.STRING,  # 100

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0b,
    0x4d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x0a,
    0x63,
    0x6f,
    0x6d,
    0x70,
    0x6f,
    0x6e,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0a,
    0x4d,
    0x65,
    0x73,
    0x73,
    0x61,
    0x67,
    0x65,
    0x53,
    0x65,
    0x74,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x64,
    0x61,
    0x74,
    0x61,
    0x5f,
    0x73,
    0x75,
    0x6d,
    0x6d,
    0x61,
    0x72,
    0x79,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x64,
    0x65,
    0x62,
    0x75,
    0x67,
    0x20,
    0x64,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0x98,
    0xdc,
    0x8e,
    0x01,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x09,
    0x44,
    0x61,
    0x74,
    0x61,
    0x54,
    0x79,
    0x70,
    0x65,
    0x73,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x49,
    0x4e,
    0x4c,
    0x49,
    0x4e,
    0x4b,
    0x53,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x06,
    0x44,
    0x41,
    0x46,
    0x46,
    0x49,
    0x45,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x52,
    0x45,
    0x4c,
    0x41,
    0x54,
    0x45,
    0x44,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x53,
    0x4e,
    0x49,
    0x50,
    0x50,
    0x45,
    0x54,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x05,
    0x49,
    0x4d,
    0x41,
    0x47,
    0x45,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x05,
    0x4c,
    0x4f,
    0x43,
    0x41,
    0x4c,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x53,
    0x43,
    0x48,
    0x4f,
    0x4c,
    0x41,
    0x52,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x46,
    0x49,
    0x4e,
    0x41,
    0x4e,
    0x43,
    0x45,
    0x98,
    0x01,
    0x07,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x47,
    0x4f,
    0x4f,
    0x47,
    0x4c,
    0x45,
    0x42,
    0x41,
    0x53,
    0x45,
    0x98,
    0x01,
    0x08,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x46,
    0x4c,
    0x41,
    0x53,
    0x48,
    0x53,
    0x4b,
    0x49,
    0x50,
    0x49,
    0x4e,
    0x54,
    0x52,
    0x4f,
    0x98,
    0x01,
    0x09,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x53,
    0x49,
    0x54,
    0x45,
    0x53,
    0x45,
    0x41,
    0x52,
    0x43,
    0x48,
    0x98,
    0x01,
    0x0a,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class RelatedLinkData_Link(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.title_ = ""
    self.url_ = ""
    self.score_ = 0.0
    self.has_title_ = 0
    self.has_url_ = 0
    self.has_score_ = 0
    if contents is not None: self.MergeFromString(contents)

  def title(self): return self.title_

  def set_title(self, x):
    self.has_title_ = 1
    self.title_ = x

  def clear_title(self):
    self.has_title_ = 0
    self.title_ = ""

  def has_title(self): return self.has_title_

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def score(self): return self.score_

  def set_score(self, x):
    self.has_score_ = 1
    self.score_ = x

  def clear_score(self):
    self.has_score_ = 0
    self.score_ = 0.0

  def has_score(self): return self.has_score_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_title()): self.set_title(x.title())
    if (x.has_url()): self.set_url(x.url())
    if (x.has_score()): self.set_score(x.score())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'RelatedLinkData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'RelatedLinkData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'RelatedLinkData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'RelatedLinkData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'RelatedLinkData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_title_ != x.has_title_: return 0
    if self.has_title_ and self.title_ != x.title_: return 0
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if self.has_score_ != x.has_score_: return 0
    if self.has_score_ and self.score_ != x.score_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_title_): n += 1 + self.lengthString(len(self.title_))
    if (self.has_url_): n += 1 + self.lengthString(len(self.url_))
    if (self.has_score_): n += 5
    return n + 0

  def Clear(self):
    self.clear_title()
    self.clear_url()
    self.clear_score()

  def OutputUnchecked(self, out):
    if (self.has_title_):
      out.putVarInt32(18)
      out.putPrefixedString(self.title_)
    if (self.has_url_):
      out.putVarInt32(26)
      out.putPrefixedString(self.url_)
    if (self.has_score_):
      out.putVarInt32(37)
      out.putFloat(self.score_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        self.set_title(d.getPrefixedString())
        continue
      if tt == 26:
        self.set_url(d.getPrefixedString())
        continue
      if tt == 37:
        self.set_score(d.getFloat())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_title_: res+=prefix+("title: %s\n" % self.DebugFormatString(self.title_))
    if self.has_url_: res+=prefix+("url: %s\n" % self.DebugFormatString(self.url_))
    if self.has_score_: res+=prefix+("score: %s\n" % self.DebugFormatFloat(self.score_))
    return res

class RelatedLinkData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 2285125 

  _TypeId_NAMES = {
    2285125: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.link_ = []
    self.target_url_ = ""
    self.has_target_url_ = 0
    if contents is not None: self.MergeFromString(contents)

  def link_size(self): return len(self.link_)
  def link_list(self): return self.link_

  def link(self, i):
    return self.link_[i]

  def mutable_link(self, i):
    return self.link_[i]

  def add_link(self):
    x = RelatedLinkData_Link()
    self.link_.append(x)
    return x

  def clear_link(self):
    self.link_ = []
  def target_url(self): return self.target_url_

  def set_target_url(self, x):
    self.has_target_url_ = 1
    self.target_url_ = x

  def clear_target_url(self):
    self.has_target_url_ = 0
    self.target_url_ = ""

  def has_target_url(self): return self.has_target_url_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.link_size()): self.add_link().CopyFrom(x.link(i))
    if (x.has_target_url()): self.set_target_url(x.target_url())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'RelatedLinkData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'RelatedLinkData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'RelatedLinkData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'RelatedLinkData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'RelatedLinkData', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.link_) != len(x.link_): return 0
    for e1, e2 in zip(self.link_, x.link_):
      if e1 != e2: return 0
    if self.has_target_url_ != x.has_target_url_: return 0
    if self.has_target_url_ and self.target_url_ != x.target_url_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.link_)):
      if (not self.link_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.link_)
    for i in xrange(len(self.link_)): n += self.link_[i].ByteSize()
    if (self.has_target_url_): n += 1 + self.lengthString(len(self.target_url_))
    return n + 0

  def Clear(self):
    self.clear_link()
    self.clear_target_url()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.link_)):
      out.putVarInt32(11)
      self.link_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    if (self.has_target_url_):
      out.putVarInt32(42)
      out.putPrefixedString(self.target_url_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_link().TryMerge(d)
        continue
      if tt == 42:
        self.set_target_url(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.link_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Link%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_target_url_: res+=prefix+("target_url: %s\n" % self.DebugFormatString(self.target_url_))
    return res

  kLinkGroup = 1
  kLinktitle = 2
  kLinkurl = 3
  kLinkscore = 4
  ktarget_url = 5

  _TEXT = (
   "ErrorCode",  #   0
   "Link",  #   1
   "title",  #   2
   "url",  #   3
   "score",  #   4
   "target_url",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.FLOAT,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0f,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x65,
    0x64,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x04,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x2e,
    0x74,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x2e,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x2e,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x04,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x74,
    0x61,
    0x72,
    0x67,
    0x65,
    0x74,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xc5,
    0xbc,
    0x8b,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class InlinkData_Source(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.doc_ = None
    self.snippet_ = ""
    self.source_title_ = ""
    self.source_url_ = ""
    self.source_main_title_ = ""
    self.source_main_url_ = ""
    self.feed_url_ = ""
    self.anchor_text_ = ""
    self.created_date_ = 0
    self.score_ = 0
    self.source_doclength_ = 0
    self.link_offset_ = 0
    self.link_index_ = 0
    self.source_outdegree_ = 0
    self.source_outsites_ = 0
    self.anchor_pagerank_ = []
    self.has_doc_ = 0
    self.has_snippet_ = 0
    self.has_source_title_ = 0
    self.has_source_url_ = 0
    self.has_source_main_title_ = 0
    self.has_source_main_url_ = 0
    self.has_feed_url_ = 0
    self.has_anchor_text_ = 0
    self.has_created_date_ = 0
    self.has_score_ = 0
    self.has_source_doclength_ = 0
    self.has_link_offset_ = 0
    self.has_link_index_ = 0
    self.has_source_outdegree_ = 0
    self.has_source_outsites_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def doc(self):
    if self.doc_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.doc_ is None: self.doc_ = GDocumentBase()
      finally:
        self.lazy_init_lock_.release()
    return self.doc_

  def mutable_doc(self): self.has_doc_ = 1; return self.doc()

  def clear_doc(self):
    #Warning: this method does not acquire the lock.
    self.has_doc_ = 0;
    if self.doc_ is not None: self.doc_.Clear()

  def has_doc(self): return self.has_doc_

  def snippet(self): return self.snippet_

  def set_snippet(self, x):
    self.has_snippet_ = 1
    self.snippet_ = x

  def clear_snippet(self):
    self.has_snippet_ = 0
    self.snippet_ = ""

  def has_snippet(self): return self.has_snippet_

  def source_title(self): return self.source_title_

  def set_source_title(self, x):
    self.has_source_title_ = 1
    self.source_title_ = x

  def clear_source_title(self):
    self.has_source_title_ = 0
    self.source_title_ = ""

  def has_source_title(self): return self.has_source_title_

  def source_url(self): return self.source_url_

  def set_source_url(self, x):
    self.has_source_url_ = 1
    self.source_url_ = x

  def clear_source_url(self):
    self.has_source_url_ = 0
    self.source_url_ = ""

  def has_source_url(self): return self.has_source_url_

  def source_main_title(self): return self.source_main_title_

  def set_source_main_title(self, x):
    self.has_source_main_title_ = 1
    self.source_main_title_ = x

  def clear_source_main_title(self):
    self.has_source_main_title_ = 0
    self.source_main_title_ = ""

  def has_source_main_title(self): return self.has_source_main_title_

  def source_main_url(self): return self.source_main_url_

  def set_source_main_url(self, x):
    self.has_source_main_url_ = 1
    self.source_main_url_ = x

  def clear_source_main_url(self):
    self.has_source_main_url_ = 0
    self.source_main_url_ = ""

  def has_source_main_url(self): return self.has_source_main_url_

  def feed_url(self): return self.feed_url_

  def set_feed_url(self, x):
    self.has_feed_url_ = 1
    self.feed_url_ = x

  def clear_feed_url(self):
    self.has_feed_url_ = 0
    self.feed_url_ = ""

  def has_feed_url(self): return self.has_feed_url_

  def anchor_text(self): return self.anchor_text_

  def set_anchor_text(self, x):
    self.has_anchor_text_ = 1
    self.anchor_text_ = x

  def clear_anchor_text(self):
    self.has_anchor_text_ = 0
    self.anchor_text_ = ""

  def has_anchor_text(self): return self.has_anchor_text_

  def created_date(self): return self.created_date_

  def set_created_date(self, x):
    self.has_created_date_ = 1
    self.created_date_ = x

  def clear_created_date(self):
    self.has_created_date_ = 0
    self.created_date_ = 0

  def has_created_date(self): return self.has_created_date_

  def score(self): return self.score_

  def set_score(self, x):
    self.has_score_ = 1
    self.score_ = x

  def clear_score(self):
    self.has_score_ = 0
    self.score_ = 0

  def has_score(self): return self.has_score_

  def source_doclength(self): return self.source_doclength_

  def set_source_doclength(self, x):
    self.has_source_doclength_ = 1
    self.source_doclength_ = x

  def clear_source_doclength(self):
    self.has_source_doclength_ = 0
    self.source_doclength_ = 0

  def has_source_doclength(self): return self.has_source_doclength_

  def link_offset(self): return self.link_offset_

  def set_link_offset(self, x):
    self.has_link_offset_ = 1
    self.link_offset_ = x

  def clear_link_offset(self):
    self.has_link_offset_ = 0
    self.link_offset_ = 0

  def has_link_offset(self): return self.has_link_offset_

  def link_index(self): return self.link_index_

  def set_link_index(self, x):
    self.has_link_index_ = 1
    self.link_index_ = x

  def clear_link_index(self):
    self.has_link_index_ = 0
    self.link_index_ = 0

  def has_link_index(self): return self.has_link_index_

  def source_outdegree(self): return self.source_outdegree_

  def set_source_outdegree(self, x):
    self.has_source_outdegree_ = 1
    self.source_outdegree_ = x

  def clear_source_outdegree(self):
    self.has_source_outdegree_ = 0
    self.source_outdegree_ = 0

  def has_source_outdegree(self): return self.has_source_outdegree_

  def source_outsites(self): return self.source_outsites_

  def set_source_outsites(self, x):
    self.has_source_outsites_ = 1
    self.source_outsites_ = x

  def clear_source_outsites(self):
    self.has_source_outsites_ = 0
    self.source_outsites_ = 0

  def has_source_outsites(self): return self.has_source_outsites_

  def anchor_pagerank_size(self): return len(self.anchor_pagerank_)
  def anchor_pagerank_list(self): return self.anchor_pagerank_

  def anchor_pagerank(self, i):
    return self.anchor_pagerank_[i]

  def set_anchor_pagerank(self, i, x):
    self.anchor_pagerank_[i] = x

  def add_anchor_pagerank(self, x):
    self.anchor_pagerank_.append(x)

  def clear_anchor_pagerank(self):
    self.anchor_pagerank_ = []


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_doc()): self.mutable_doc().MergeFrom(x.doc())
    if (x.has_snippet()): self.set_snippet(x.snippet())
    if (x.has_source_title()): self.set_source_title(x.source_title())
    if (x.has_source_url()): self.set_source_url(x.source_url())
    if (x.has_source_main_title()): self.set_source_main_title(x.source_main_title())
    if (x.has_source_main_url()): self.set_source_main_url(x.source_main_url())
    if (x.has_feed_url()): self.set_feed_url(x.feed_url())
    if (x.has_anchor_text()): self.set_anchor_text(x.anchor_text())
    if (x.has_created_date()): self.set_created_date(x.created_date())
    if (x.has_score()): self.set_score(x.score())
    if (x.has_source_doclength()): self.set_source_doclength(x.source_doclength())
    if (x.has_link_offset()): self.set_link_offset(x.link_offset())
    if (x.has_link_index()): self.set_link_index(x.link_index())
    if (x.has_source_outdegree()): self.set_source_outdegree(x.source_outdegree())
    if (x.has_source_outsites()): self.set_source_outsites(x.source_outsites())
    for i in xrange(x.anchor_pagerank_size()): self.add_anchor_pagerank(x.anchor_pagerank(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'InlinkData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'InlinkData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'InlinkData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'InlinkData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'InlinkData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_doc_ != x.has_doc_: return 0
    if self.has_doc_ and self.doc_ != x.doc_: return 0
    if self.has_snippet_ != x.has_snippet_: return 0
    if self.has_snippet_ and self.snippet_ != x.snippet_: return 0
    if self.has_source_title_ != x.has_source_title_: return 0
    if self.has_source_title_ and self.source_title_ != x.source_title_: return 0
    if self.has_source_url_ != x.has_source_url_: return 0
    if self.has_source_url_ and self.source_url_ != x.source_url_: return 0
    if self.has_source_main_title_ != x.has_source_main_title_: return 0
    if self.has_source_main_title_ and self.source_main_title_ != x.source_main_title_: return 0
    if self.has_source_main_url_ != x.has_source_main_url_: return 0
    if self.has_source_main_url_ and self.source_main_url_ != x.source_main_url_: return 0
    if self.has_feed_url_ != x.has_feed_url_: return 0
    if self.has_feed_url_ and self.feed_url_ != x.feed_url_: return 0
    if self.has_anchor_text_ != x.has_anchor_text_: return 0
    if self.has_anchor_text_ and self.anchor_text_ != x.anchor_text_: return 0
    if self.has_created_date_ != x.has_created_date_: return 0
    if self.has_created_date_ and self.created_date_ != x.created_date_: return 0
    if self.has_score_ != x.has_score_: return 0
    if self.has_score_ and self.score_ != x.score_: return 0
    if self.has_source_doclength_ != x.has_source_doclength_: return 0
    if self.has_source_doclength_ and self.source_doclength_ != x.source_doclength_: return 0
    if self.has_link_offset_ != x.has_link_offset_: return 0
    if self.has_link_offset_ and self.link_offset_ != x.link_offset_: return 0
    if self.has_link_index_ != x.has_link_index_: return 0
    if self.has_link_index_ and self.link_index_ != x.link_index_: return 0
    if self.has_source_outdegree_ != x.has_source_outdegree_: return 0
    if self.has_source_outdegree_ and self.source_outdegree_ != x.source_outdegree_: return 0
    if self.has_source_outsites_ != x.has_source_outsites_: return 0
    if self.has_source_outsites_ and self.source_outsites_ != x.source_outsites_: return 0
    if len(self.anchor_pagerank_) != len(x.anchor_pagerank_): return 0
    for e1, e2 in zip(self.anchor_pagerank_, x.anchor_pagerank_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (self.has_doc_ and not self.doc_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_doc_): n += 2 + self.lengthString(self.doc_.ByteSize())
    if (self.has_snippet_): n += 2 + self.lengthString(len(self.snippet_))
    if (self.has_source_title_): n += 1 + self.lengthString(len(self.source_title_))
    if (self.has_source_url_): n += 1 + self.lengthString(len(self.source_url_))
    if (self.has_source_main_title_): n += 1 + self.lengthString(len(self.source_main_title_))
    if (self.has_source_main_url_): n += 1 + self.lengthString(len(self.source_main_url_))
    if (self.has_feed_url_): n += 2 + self.lengthString(len(self.feed_url_))
    if (self.has_anchor_text_): n += 1 + self.lengthString(len(self.anchor_text_))
    if (self.has_created_date_): n += 1 + self.lengthVarInt64(self.created_date_)
    if (self.has_score_): n += 1 + self.lengthVarInt64(self.score_)
    if (self.has_source_doclength_): n += 1 + self.lengthVarInt64(self.source_doclength_)
    if (self.has_link_offset_): n += 1 + self.lengthVarInt64(self.link_offset_)
    if (self.has_link_index_): n += 1 + self.lengthVarInt64(self.link_index_)
    if (self.has_source_outdegree_): n += 1 + self.lengthVarInt64(self.source_outdegree_)
    if (self.has_source_outsites_): n += 1 + self.lengthVarInt64(self.source_outsites_)
    n += 1 * len(self.anchor_pagerank_)
    for i in xrange(len(self.anchor_pagerank_)): n += self.lengthVarInt64(self.anchor_pagerank_[i])
    return n + 0

  def Clear(self):
    self.clear_doc()
    self.clear_snippet()
    self.clear_source_title()
    self.clear_source_url()
    self.clear_source_main_title()
    self.clear_source_main_url()
    self.clear_feed_url()
    self.clear_anchor_text()
    self.clear_created_date()
    self.clear_score()
    self.clear_source_doclength()
    self.clear_link_offset()
    self.clear_link_index()
    self.clear_source_outdegree()
    self.clear_source_outsites()
    self.clear_anchor_pagerank()

  def OutputUnchecked(self, out):
    if (self.has_source_title_):
      out.putVarInt32(18)
      out.putPrefixedString(self.source_title_)
    if (self.has_source_url_):
      out.putVarInt32(26)
      out.putPrefixedString(self.source_url_)
    if (self.has_source_main_title_):
      out.putVarInt32(34)
      out.putPrefixedString(self.source_main_title_)
    if (self.has_source_main_url_):
      out.putVarInt32(42)
      out.putPrefixedString(self.source_main_url_)
    if (self.has_anchor_text_):
      out.putVarInt32(50)
      out.putPrefixedString(self.anchor_text_)
    if (self.has_score_):
      out.putVarInt32(56)
      out.putVarInt32(self.score_)
    if (self.has_created_date_):
      out.putVarInt32(64)
      out.putVarUint64(self.created_date_)
    if (self.has_source_doclength_):
      out.putVarInt32(80)
      out.putVarInt32(self.source_doclength_)
    if (self.has_link_offset_):
      out.putVarInt32(88)
      out.putVarInt32(self.link_offset_)
    if (self.has_source_outdegree_):
      out.putVarInt32(96)
      out.putVarInt32(self.source_outdegree_)
    if (self.has_source_outsites_):
      out.putVarInt32(104)
      out.putVarInt32(self.source_outsites_)
    for i in xrange(len(self.anchor_pagerank_)):
      out.putVarInt32(112)
      out.putVarInt32(self.anchor_pagerank_[i])
    if (self.has_link_index_):
      out.putVarInt32(120)
      out.putVarInt32(self.link_index_)
    if (self.has_feed_url_):
      out.putVarInt32(130)
      out.putPrefixedString(self.feed_url_)
    if (self.has_doc_):
      out.putVarInt32(138)
      out.putVarInt32(self.doc_.ByteSize())
      self.doc_.OutputUnchecked(out)
    if (self.has_snippet_):
      out.putVarInt32(146)
      out.putPrefixedString(self.snippet_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        self.set_source_title(d.getPrefixedString())
        continue
      if tt == 26:
        self.set_source_url(d.getPrefixedString())
        continue
      if tt == 34:
        self.set_source_main_title(d.getPrefixedString())
        continue
      if tt == 42:
        self.set_source_main_url(d.getPrefixedString())
        continue
      if tt == 50:
        self.set_anchor_text(d.getPrefixedString())
        continue
      if tt == 56:
        self.set_score(d.getVarInt32())
        continue
      if tt == 64:
        self.set_created_date(d.getVarUint64())
        continue
      if tt == 80:
        self.set_source_doclength(d.getVarInt32())
        continue
      if tt == 88:
        self.set_link_offset(d.getVarInt32())
        continue
      if tt == 96:
        self.set_source_outdegree(d.getVarInt32())
        continue
      if tt == 104:
        self.set_source_outsites(d.getVarInt32())
        continue
      if tt == 112:
        self.add_anchor_pagerank(d.getVarInt32())
        continue
      if tt == 120:
        self.set_link_index(d.getVarInt32())
        continue
      if tt == 130:
        self.set_feed_url(d.getPrefixedString())
        continue
      if tt == 138:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_doc().TryMerge(tmp)
        continue
      if tt == 146:
        self.set_snippet(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_doc_:
      res+=prefix+"doc <\n"
      res+=self.doc_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_snippet_: res+=prefix+("snippet: %s\n" % self.DebugFormatString(self.snippet_))
    if self.has_source_title_: res+=prefix+("source_title: %s\n" % self.DebugFormatString(self.source_title_))
    if self.has_source_url_: res+=prefix+("source_url: %s\n" % self.DebugFormatString(self.source_url_))
    if self.has_source_main_title_: res+=prefix+("source_main_title: %s\n" % self.DebugFormatString(self.source_main_title_))
    if self.has_source_main_url_: res+=prefix+("source_main_url: %s\n" % self.DebugFormatString(self.source_main_url_))
    if self.has_feed_url_: res+=prefix+("feed_url: %s\n" % self.DebugFormatString(self.feed_url_))
    if self.has_anchor_text_: res+=prefix+("anchor_text: %s\n" % self.DebugFormatString(self.anchor_text_))
    if self.has_created_date_: res+=prefix+("created_date: %s\n" % self.DebugFormatInt64(self.created_date_))
    if self.has_score_: res+=prefix+("score: %s\n" % self.DebugFormatInt32(self.score_))
    if self.has_source_doclength_: res+=prefix+("source_doclength: %s\n" % self.DebugFormatInt32(self.source_doclength_))
    if self.has_link_offset_: res+=prefix+("link_offset: %s\n" % self.DebugFormatInt32(self.link_offset_))
    if self.has_link_index_: res+=prefix+("link_index: %s\n" % self.DebugFormatInt32(self.link_index_))
    if self.has_source_outdegree_: res+=prefix+("source_outdegree: %s\n" % self.DebugFormatInt32(self.source_outdegree_))
    if self.has_source_outsites_: res+=prefix+("source_outsites: %s\n" % self.DebugFormatInt32(self.source_outsites_))
    cnt=0
    for e in self.anchor_pagerank_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("anchor_pagerank%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    return res

class InlinkData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 1903243 

  _TypeId_NAMES = {
    1903243: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.source_ = []
    self.target_url_ = ""
    self.has_target_url_ = 0
    if contents is not None: self.MergeFromString(contents)

  def source_size(self): return len(self.source_)
  def source_list(self): return self.source_

  def source(self, i):
    return self.source_[i]

  def mutable_source(self, i):
    return self.source_[i]

  def add_source(self):
    x = InlinkData_Source()
    self.source_.append(x)
    return x

  def clear_source(self):
    self.source_ = []
  def target_url(self): return self.target_url_

  def set_target_url(self, x):
    self.has_target_url_ = 1
    self.target_url_ = x

  def clear_target_url(self):
    self.has_target_url_ = 0
    self.target_url_ = ""

  def has_target_url(self): return self.has_target_url_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.source_size()): self.add_source().CopyFrom(x.source(i))
    if (x.has_target_url()): self.set_target_url(x.target_url())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'InlinkData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'InlinkData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'InlinkData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'InlinkData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'InlinkData', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.source_) != len(x.source_): return 0
    for e1, e2 in zip(self.source_, x.source_):
      if e1 != e2: return 0
    if self.has_target_url_ != x.has_target_url_: return 0
    if self.has_target_url_ and self.target_url_ != x.target_url_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.source_)):
      if (not self.source_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.source_)
    for i in xrange(len(self.source_)): n += self.source_[i].ByteSize()
    if (self.has_target_url_): n += 1 + self.lengthString(len(self.target_url_))
    return n + 0

  def Clear(self):
    self.clear_source()
    self.clear_target_url()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.source_)):
      out.putVarInt32(11)
      self.source_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    if (self.has_target_url_):
      out.putVarInt32(74)
      out.putPrefixedString(self.target_url_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_source().TryMerge(d)
        continue
      if tt == 74:
        self.set_target_url(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.source_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Source%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_target_url_: res+=prefix+("target_url: %s\n" % self.DebugFormatString(self.target_url_))
    return res

  kSourceGroup = 1
  kSourcedoc = 17
  kSourcesnippet = 18
  kSourcesource_title = 2
  kSourcesource_url = 3
  kSourcesource_main_title = 4
  kSourcesource_main_url = 5
  kSourcefeed_url = 16
  kSourceanchor_text = 6
  kSourcecreated_date = 8
  kSourcescore = 7
  kSourcesource_doclength = 10
  kSourcelink_offset = 11
  kSourcelink_index = 15
  kSourcesource_outdegree = 12
  kSourcesource_outsites = 13
  kSourceanchor_pagerank = 14
  ktarget_url = 9

  _TEXT = (
   "ErrorCode",  #   0
   "Source",  #   1
   "source_title",  #   2
   "source_url",  #   3
   "source_main_title",  #   4
   "source_main_url",  #   5
   "anchor_text",  #   6
   "score",  #   7
   "created_date",  #   8
   "target_url",  #   9
   "source_doclength",  #  10
   "link_offset",  #  11
   "source_outdegree",  #  12
   "source_outsites",  #  13
   "anchor_pagerank",  #  14
   "link_index",  #  15
   "feed_url",  #  16
   "doc",  #  17
   "snippet",  #  18
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

   ProtocolBuffer.Encoder.NUMERIC,  #  12

   ProtocolBuffer.Encoder.NUMERIC,  #  13

   ProtocolBuffer.Encoder.NUMERIC,  #  14

   ProtocolBuffer.Encoder.NUMERIC,  #  15

   ProtocolBuffer.Encoder.STRING,  #  16

   ProtocolBuffer.Encoder.STRING,  #  17

   ProtocolBuffer.Encoder.STRING,  #  18

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0a,
    0x49,
    0x6e,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x64,
    0x6f,
    0x63,
    0x20,
    0x11,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0d,
    0x47,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x42,
    0x61,
    0x73,
    0x65,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x73,
    0x6e,
    0x69,
    0x70,
    0x70,
    0x65,
    0x74,
    0x20,
    0x12,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x74,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x6d,
    0x61,
    0x69,
    0x6e,
    0x5f,
    0x74,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x6d,
    0x61,
    0x69,
    0x6e,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x66,
    0x65,
    0x65,
    0x64,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x10,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x61,
    0x6e,
    0x63,
    0x68,
    0x6f,
    0x72,
    0x5f,
    0x74,
    0x65,
    0x78,
    0x74,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x63,
    0x72,
    0x65,
    0x61,
    0x74,
    0x65,
    0x64,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x65,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x73,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x64,
    0x6f,
    0x63,
    0x6c,
    0x65,
    0x6e,
    0x67,
    0x74,
    0x68,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x5f,
    0x6f,
    0x66,
    0x66,
    0x73,
    0x65,
    0x74,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x5f,
    0x69,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x0f,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x6f,
    0x75,
    0x74,
    0x64,
    0x65,
    0x67,
    0x72,
    0x65,
    0x65,
    0x20,
    0x0c,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x6f,
    0x75,
    0x74,
    0x73,
    0x69,
    0x74,
    0x65,
    0x73,
    0x20,
    0x0d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x2e,
    0x61,
    0x6e,
    0x63,
    0x68,
    0x6f,
    0x72,
    0x5f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x0e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x74,
    0x61,
    0x72,
    0x67,
    0x65,
    0x74,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0x8b,
    0x95,
    0x74,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class GoogleBaseData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 3520667 

  _TypeId_NAMES = {
    3520667: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.attributes_ = GoogleBaseWebAttributes()
    self.target_url_ = ""
    self.has_attributes_ = 0
    self.has_target_url_ = 0
    if contents is not None: self.MergeFromString(contents)

  def attributes(self): return self.attributes_

  def mutable_attributes(self): self.has_attributes_ = 1; return self.attributes_

  def clear_attributes(self):self.has_attributes_ = 0; self.attributes_.Clear()

  def has_attributes(self): return self.has_attributes_

  def target_url(self): return self.target_url_

  def set_target_url(self, x):
    self.has_target_url_ = 1
    self.target_url_ = x

  def clear_target_url(self):
    self.has_target_url_ = 0
    self.target_url_ = ""

  def has_target_url(self): return self.has_target_url_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_attributes()): self.mutable_attributes().MergeFrom(x.attributes())
    if (x.has_target_url()): self.set_target_url(x.target_url())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'GoogleBaseData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'GoogleBaseData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'GoogleBaseData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'GoogleBaseData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'GoogleBaseData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_attributes_ != x.has_attributes_: return 0
    if self.has_attributes_ and self.attributes_ != x.attributes_: return 0
    if self.has_target_url_ != x.has_target_url_: return 0
    if self.has_target_url_ and self.target_url_ != x.target_url_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_attributes_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: attributes not set.')
    elif not self.attributes_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.attributes_.ByteSize())
    if (self.has_target_url_): n += 1 + self.lengthString(len(self.target_url_))
    return n + 1

  def Clear(self):
    self.clear_attributes()
    self.clear_target_url()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.attributes_.ByteSize())
    self.attributes_.OutputUnchecked(out)
    if (self.has_target_url_):
      out.putVarInt32(66)
      out.putPrefixedString(self.target_url_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_attributes().TryMerge(tmp)
        continue
      if tt == 66:
        self.set_target_url(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_attributes_:
      res+=prefix+"attributes <\n"
      res+=self.attributes_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_target_url_: res+=prefix+("target_url: %s\n" % self.DebugFormatString(self.target_url_))
    return res

  kattributes = 1
  ktarget_url = 8

  _TEXT = (
   "ErrorCode",  #   0
   "attributes",  #   1
   None,  #   2
   None,  #   3
   None,  #   4
   None,  #   5
   None,  #   6
   None,  #   7
   "target_url",  #   8
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.MAX_TYPE,  #   2

   ProtocolBuffer.Encoder.MAX_TYPE,  #   3

   ProtocolBuffer.Encoder.MAX_TYPE,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.MAX_TYPE,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0e,
    0x47,
    0x6f,
    0x6f,
    0x67,
    0x6c,
    0x65,
    0x42,
    0x61,
    0x73,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x0a,
    0x61,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x73,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x22,
    0x67,
    0x6f,
    0x6f,
    0x67,
    0x6c,
    0x65,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2e,
    0x47,
    0x6f,
    0x6f,
    0x67,
    0x6c,
    0x65,
    0x42,
    0x61,
    0x73,
    0x65,
    0x57,
    0x65,
    0x62,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x73,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x74,
    0x61,
    0x72,
    0x67,
    0x65,
    0x74,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0x9b,
    0xf1,
    0xd6,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class CompactDaffieObject_Fact(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.attribute_ = ""
    self.value_ = ""
    self.confidence_ = 0.0
    self.importance_ = 0.0
    self.has_attribute_ = 0
    self.has_value_ = 0
    self.has_confidence_ = 0
    self.has_importance_ = 0
    if contents is not None: self.MergeFromString(contents)

  def attribute(self): return self.attribute_

  def set_attribute(self, x):
    self.has_attribute_ = 1
    self.attribute_ = x

  def clear_attribute(self):
    self.has_attribute_ = 0
    self.attribute_ = ""

  def has_attribute(self): return self.has_attribute_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_

  def confidence(self): return self.confidence_

  def set_confidence(self, x):
    self.has_confidence_ = 1
    self.confidence_ = x

  def clear_confidence(self):
    self.has_confidence_ = 0
    self.confidence_ = 0.0

  def has_confidence(self): return self.has_confidence_

  def importance(self): return self.importance_

  def set_importance(self, x):
    self.has_importance_ = 1
    self.importance_ = x

  def clear_importance(self):
    self.has_importance_ = 0
    self.importance_ = 0.0

  def has_importance(self): return self.has_importance_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_attribute()): self.set_attribute(x.attribute())
    if (x.has_value()): self.set_value(x.value())
    if (x.has_confidence()): self.set_confidence(x.confidence())
    if (x.has_importance()): self.set_importance(x.importance())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'CompactDaffieObject', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'CompactDaffieObject')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'CompactDaffieObject', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'CompactDaffieObject', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'CompactDaffieObject', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_attribute_ != x.has_attribute_: return 0
    if self.has_attribute_ and self.attribute_ != x.attribute_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    if self.has_confidence_ != x.has_confidence_: return 0
    if self.has_confidence_ and self.confidence_ != x.confidence_: return 0
    if self.has_importance_ != x.has_importance_: return 0
    if self.has_importance_ and self.importance_ != x.importance_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_attribute_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: attribute not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    if (not self.has_confidence_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: confidence not set.')
    if (not self.has_importance_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: importance not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.attribute_))
    n += self.lengthString(len(self.value_))
    return n + 12

  def Clear(self):
    self.clear_attribute()
    self.clear_value()
    self.clear_confidence()
    self.clear_importance()

  def OutputUnchecked(self, out):
    out.putVarInt32(26)
    out.putPrefixedString(self.attribute_)
    out.putVarInt32(34)
    out.putPrefixedString(self.value_)
    out.putVarInt32(53)
    out.putFloat(self.confidence_)
    out.putVarInt32(61)
    out.putFloat(self.importance_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 26:
        self.set_attribute(d.getPrefixedString())
        continue
      if tt == 34:
        self.set_value(d.getPrefixedString())
        continue
      if tt == 53:
        self.set_confidence(d.getFloat())
        continue
      if tt == 61:
        self.set_importance(d.getFloat())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_attribute_: res+=prefix+("attribute: %s\n" % self.DebugFormatString(self.attribute_))
    if self.has_value_: res+=prefix+("value: %s\n" % self.DebugFormatString(self.value_))
    if self.has_confidence_: res+=prefix+("confidence: %s\n" % self.DebugFormatFloat(self.confidence_))
    if self.has_importance_: res+=prefix+("importance: %s\n" % self.DebugFormatFloat(self.importance_))
    return res

class CompactDaffieObject(ProtocolBuffer.ProtocolMessage):

  DEFAULT      =    0 
  COMPANY      =    1 

  _ObjectType_NAMES = {
    0: "DEFAULT",
    1: "COMPANY",
  }

  def ObjectType_Name(cls, x): return cls._ObjectType_NAMES.get(x, "")
  ObjectType_Name = classmethod(ObjectType_Name)

  def __init__(self, contents=None):
    self.name_ = ""
    self.fact_ = []
    self.source_ = ""
    self.target_url_ = ""
    self.type_ = 0
    self.has_name_ = 0
    self.has_source_ = 0
    self.has_target_url_ = 0
    self.has_type_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def fact_size(self): return len(self.fact_)
  def fact_list(self): return self.fact_

  def fact(self, i):
    return self.fact_[i]

  def mutable_fact(self, i):
    return self.fact_[i]

  def add_fact(self):
    x = CompactDaffieObject_Fact()
    self.fact_.append(x)
    return x

  def clear_fact(self):
    self.fact_ = []
  def source(self): return self.source_

  def set_source(self, x):
    self.has_source_ = 1
    self.source_ = x

  def clear_source(self):
    self.has_source_ = 0
    self.source_ = ""

  def has_source(self): return self.has_source_

  def target_url(self): return self.target_url_

  def set_target_url(self, x):
    self.has_target_url_ = 1
    self.target_url_ = x

  def clear_target_url(self):
    self.has_target_url_ = 0
    self.target_url_ = ""

  def has_target_url(self): return self.has_target_url_

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = 0

  def has_type(self): return self.has_type_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    for i in xrange(x.fact_size()): self.add_fact().CopyFrom(x.fact(i))
    if (x.has_source()): self.set_source(x.source())
    if (x.has_target_url()): self.set_target_url(x.target_url())
    if (x.has_type()): self.set_type(x.type())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'CompactDaffieObject', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'CompactDaffieObject')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'CompactDaffieObject', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'CompactDaffieObject', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'CompactDaffieObject', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if len(self.fact_) != len(x.fact_): return 0
    for e1, e2 in zip(self.fact_, x.fact_):
      if e1 != e2: return 0
    if self.has_source_ != x.has_source_: return 0
    if self.has_source_ and self.source_ != x.source_: return 0
    if self.has_target_url_ != x.has_target_url_: return 0
    if self.has_target_url_ and self.target_url_ != x.target_url_: return 0
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    for i in xrange(len(self.fact_)):
      if (not self.fact_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    n += 2 * len(self.fact_)
    for i in xrange(len(self.fact_)): n += self.fact_[i].ByteSize()
    if (self.has_source_): n += 1 + self.lengthString(len(self.source_))
    if (self.has_target_url_): n += 1 + self.lengthString(len(self.target_url_))
    if (self.has_type_): n += 1 + self.lengthVarInt64(self.type_)
    return n + 1

  def Clear(self):
    self.clear_name()
    self.clear_fact()
    self.clear_source()
    self.clear_target_url()
    self.clear_type()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.name_)
    for i in xrange(len(self.fact_)):
      out.putVarInt32(19)
      self.fact_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    if (self.has_source_):
      out.putVarInt32(42)
      out.putPrefixedString(self.source_)
    if (self.has_target_url_):
      out.putVarInt32(66)
      out.putPrefixedString(self.target_url_)
    if (self.has_type_):
      out.putVarInt32(72)
      out.putVarInt32(self.type_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 19:
        self.add_fact().TryMerge(d)
        continue
      if tt == 42:
        self.set_source(d.getPrefixedString())
        continue
      if tt == 66:
        self.set_target_url(d.getPrefixedString())
        continue
      if tt == 72:
        self.set_type(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    cnt=0
    for e in self.fact_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Fact%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_source_: res+=prefix+("source: %s\n" % self.DebugFormatString(self.source_))
    if self.has_target_url_: res+=prefix+("target_url: %s\n" % self.DebugFormatString(self.target_url_))
    if self.has_type_: res+=prefix+("type: %s\n" % self.DebugFormatInt32(self.type_))
    return res

  kname = 1
  kFactGroup = 2
  kFactattribute = 3
  kFactvalue = 4
  kFactconfidence = 6
  kFactimportance = 7
  ksource = 5
  ktarget_url = 8
  ktype = 9

  _TEXT = (
   "ErrorCode",  #   0
   "name",  #   1
   "Fact",  #   2
   "attribute",  #   3
   "value",  #   4
   "source",  #   5
   "confidence",  #   6
   "importance",  #   7
   "target_url",  #   8
   "type",  #   9
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.FLOAT,  #   6

   ProtocolBuffer.Encoder.FLOAT,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.NUMERIC,  #   9

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x13,
    0x43,
    0x6f,
    0x6d,
    0x70,
    0x61,
    0x63,
    0x74,
    0x44,
    0x61,
    0x66,
    0x66,
    0x69,
    0x65,
    0x4f,
    0x62,
    0x6a,
    0x65,
    0x63,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x46,
    0x61,
    0x63,
    0x74,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x46,
    0x61,
    0x63,
    0x74,
    0x2e,
    0x61,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x46,
    0x61,
    0x63,
    0x74,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x46,
    0x61,
    0x63,
    0x74,
    0x2e,
    0x63,
    0x6f,
    0x6e,
    0x66,
    0x69,
    0x64,
    0x65,
    0x6e,
    0x63,
    0x65,
    0x20,
    0x06,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x46,
    0x61,
    0x63,
    0x74,
    0x2e,
    0x69,
    0x6d,
    0x70,
    0x6f,
    0x72,
    0x74,
    0x61,
    0x6e,
    0x63,
    0x65,
    0x20,
    0x07,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x74,
    0x61,
    0x72,
    0x67,
    0x65,
    0x74,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x04,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x09,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x68,
    0x00,
    0x14,
    0x73,
    0x7a,
    0x0a,
    0x4f,
    0x62,
    0x6a,
    0x65,
    0x63,
    0x74,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x44,
    0x45,
    0x46,
    0x41,
    0x55,
    0x4c,
    0x54,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x43,
    0x4f,
    0x4d,
    0x50,
    0x41,
    0x4e,
    0x59,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class DaffieObjectsData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 1608505 

  _TypeId_NAMES = {
    1608505: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.objects_ = []
    if contents is not None: self.MergeFromString(contents)

  def objects_size(self): return len(self.objects_)
  def objects_list(self): return self.objects_

  def objects(self, i):
    return self.objects_[i]

  def mutable_objects(self, i):
    return self.objects_[i]

  def add_objects(self):
    x = CompactDaffieObject()
    self.objects_.append(x)
    return x

  def clear_objects(self):
    self.objects_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.objects_size()): self.add_objects().CopyFrom(x.objects(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'DaffieObjectsData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'DaffieObjectsData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'DaffieObjectsData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'DaffieObjectsData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'DaffieObjectsData', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.objects_) != len(x.objects_): return 0
    for e1, e2 in zip(self.objects_, x.objects_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.objects_)):
      if (not self.objects_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.objects_)
    for i in xrange(len(self.objects_)): n += self.lengthString(self.objects_[i].ByteSize())
    return n + 0

  def Clear(self):
    self.clear_objects()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.objects_)):
      out.putVarInt32(10)
      out.putVarInt32(self.objects_[i].ByteSize())
      self.objects_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_objects().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.objects_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("objects%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

  kobjects = 1

  _TEXT = (
   "ErrorCode",  #   0
   "objects",  #   1
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x11,
    0x44,
    0x61,
    0x66,
    0x66,
    0x69,
    0x65,
    0x4f,
    0x62,
    0x6a,
    0x65,
    0x63,
    0x74,
    0x73,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x07,
    0x6f,
    0x62,
    0x6a,
    0x65,
    0x63,
    0x74,
    0x73,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x13,
    0x43,
    0x6f,
    0x6d,
    0x70,
    0x61,
    0x63,
    0x74,
    0x44,
    0x61,
    0x66,
    0x66,
    0x69,
    0x65,
    0x4f,
    0x62,
    0x6a,
    0x65,
    0x63,
    0x74,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xb9,
    0x96,
    0x62,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class DisplayableImage(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 2355693 

  _TypeId_NAMES = {
    2355693: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.docid_ = 0
    self.url_ = ""
    self.thumb_width_ = 0
    self.thumb_height_ = 0
    self.image_width_ = 0
    self.image_height_ = 0
    self.image_size_ = 0
    self.has_docid_ = 0
    self.has_url_ = 0
    self.has_thumb_width_ = 0
    self.has_thumb_height_ = 0
    self.has_image_width_ = 0
    self.has_image_height_ = 0
    self.has_image_size_ = 0
    if contents is not None: self.MergeFromString(contents)

  def docid(self): return self.docid_

  def set_docid(self, x):
    self.has_docid_ = 1
    self.docid_ = x

  def clear_docid(self):
    self.has_docid_ = 0
    self.docid_ = 0

  def has_docid(self): return self.has_docid_

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def thumb_width(self): return self.thumb_width_

  def set_thumb_width(self, x):
    self.has_thumb_width_ = 1
    self.thumb_width_ = x

  def clear_thumb_width(self):
    self.has_thumb_width_ = 0
    self.thumb_width_ = 0

  def has_thumb_width(self): return self.has_thumb_width_

  def thumb_height(self): return self.thumb_height_

  def set_thumb_height(self, x):
    self.has_thumb_height_ = 1
    self.thumb_height_ = x

  def clear_thumb_height(self):
    self.has_thumb_height_ = 0
    self.thumb_height_ = 0

  def has_thumb_height(self): return self.has_thumb_height_

  def image_width(self): return self.image_width_

  def set_image_width(self, x):
    self.has_image_width_ = 1
    self.image_width_ = x

  def clear_image_width(self):
    self.has_image_width_ = 0
    self.image_width_ = 0

  def has_image_width(self): return self.has_image_width_

  def image_height(self): return self.image_height_

  def set_image_height(self, x):
    self.has_image_height_ = 1
    self.image_height_ = x

  def clear_image_height(self):
    self.has_image_height_ = 0
    self.image_height_ = 0

  def has_image_height(self): return self.has_image_height_

  def image_size(self): return self.image_size_

  def set_image_size(self, x):
    self.has_image_size_ = 1
    self.image_size_ = x

  def clear_image_size(self):
    self.has_image_size_ = 0
    self.image_size_ = 0

  def has_image_size(self): return self.has_image_size_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_docid()): self.set_docid(x.docid())
    if (x.has_url()): self.set_url(x.url())
    if (x.has_thumb_width()): self.set_thumb_width(x.thumb_width())
    if (x.has_thumb_height()): self.set_thumb_height(x.thumb_height())
    if (x.has_image_width()): self.set_image_width(x.image_width())
    if (x.has_image_height()): self.set_image_height(x.image_height())
    if (x.has_image_size()): self.set_image_size(x.image_size())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'DisplayableImage', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'DisplayableImage')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'DisplayableImage', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'DisplayableImage', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'DisplayableImage', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_docid_ != x.has_docid_: return 0
    if self.has_docid_ and self.docid_ != x.docid_: return 0
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if self.has_thumb_width_ != x.has_thumb_width_: return 0
    if self.has_thumb_width_ and self.thumb_width_ != x.thumb_width_: return 0
    if self.has_thumb_height_ != x.has_thumb_height_: return 0
    if self.has_thumb_height_ and self.thumb_height_ != x.thumb_height_: return 0
    if self.has_image_width_ != x.has_image_width_: return 0
    if self.has_image_width_ and self.image_width_ != x.image_width_: return 0
    if self.has_image_height_ != x.has_image_height_: return 0
    if self.has_image_height_ and self.image_height_ != x.image_height_: return 0
    if self.has_image_size_ != x.has_image_size_: return 0
    if self.has_image_size_ and self.image_size_ != x.image_size_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_docid_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: docid not set.')
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_url_): n += 1 + self.lengthString(len(self.url_))
    if (self.has_thumb_width_): n += 1 + self.lengthVarInt64(self.thumb_width_)
    if (self.has_thumb_height_): n += 1 + self.lengthVarInt64(self.thumb_height_)
    if (self.has_image_width_): n += 1 + self.lengthVarInt64(self.image_width_)
    if (self.has_image_height_): n += 1 + self.lengthVarInt64(self.image_height_)
    if (self.has_image_size_): n += 1 + self.lengthVarInt64(self.image_size_)
    return n + 9

  def Clear(self):
    self.clear_docid()
    self.clear_url()
    self.clear_thumb_width()
    self.clear_thumb_height()
    self.clear_image_width()
    self.clear_image_height()
    self.clear_image_size()

  def OutputUnchecked(self, out):
    out.putVarInt32(9)
    out.put64(self.docid_)
    if (self.has_url_):
      out.putVarInt32(18)
      out.putPrefixedString(self.url_)
    if (self.has_thumb_width_):
      out.putVarInt32(24)
      out.putVarInt32(self.thumb_width_)
    if (self.has_thumb_height_):
      out.putVarInt32(32)
      out.putVarInt32(self.thumb_height_)
    if (self.has_image_width_):
      out.putVarInt32(40)
      out.putVarInt32(self.image_width_)
    if (self.has_image_height_):
      out.putVarInt32(48)
      out.putVarInt32(self.image_height_)
    if (self.has_image_size_):
      out.putVarInt32(56)
      out.putVarInt32(self.image_size_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 9:
        self.set_docid(d.get64())
        continue
      if tt == 18:
        self.set_url(d.getPrefixedString())
        continue
      if tt == 24:
        self.set_thumb_width(d.getVarInt32())
        continue
      if tt == 32:
        self.set_thumb_height(d.getVarInt32())
        continue
      if tt == 40:
        self.set_image_width(d.getVarInt32())
        continue
      if tt == 48:
        self.set_image_height(d.getVarInt32())
        continue
      if tt == 56:
        self.set_image_size(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_docid_: res+=prefix+("docid: %s\n" % self.DebugFormatFixed64(self.docid_))
    if self.has_url_: res+=prefix+("url: %s\n" % self.DebugFormatString(self.url_))
    if self.has_thumb_width_: res+=prefix+("thumb_width: %s\n" % self.DebugFormatInt32(self.thumb_width_))
    if self.has_thumb_height_: res+=prefix+("thumb_height: %s\n" % self.DebugFormatInt32(self.thumb_height_))
    if self.has_image_width_: res+=prefix+("image_width: %s\n" % self.DebugFormatInt32(self.image_width_))
    if self.has_image_height_: res+=prefix+("image_height: %s\n" % self.DebugFormatInt32(self.image_height_))
    if self.has_image_size_: res+=prefix+("image_size: %s\n" % self.DebugFormatInt32(self.image_size_))
    return res

  kdocid = 1
  kurl = 2
  kthumb_width = 3
  kthumb_height = 4
  kimage_width = 5
  kimage_height = 6
  kimage_size = 7

  _TEXT = (
   "ErrorCode",  #   0
   "docid",  #   1
   "url",  #   2
   "thumb_width",  #   3
   "thumb_height",  #   4
   "image_width",  #   5
   "image_height",  #   6
   "image_size",  #   7
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.DOUBLE,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x10,
    0x44,
    0x69,
    0x73,
    0x70,
    0x6c,
    0x61,
    0x79,
    0x61,
    0x62,
    0x6c,
    0x65,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x13,
    0x1a,
    0x05,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x64,
    0x20,
    0x01,
    0x28,
    0x01,
    0x30,
    0x06,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x03,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x74,
    0x68,
    0x75,
    0x6d,
    0x62,
    0x5f,
    0x77,
    0x69,
    0x64,
    0x74,
    0x68,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x74,
    0x68,
    0x75,
    0x6d,
    0x62,
    0x5f,
    0x68,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x69,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x77,
    0x69,
    0x64,
    0x74,
    0x68,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x69,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x68,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x69,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x73,
    0x69,
    0x7a,
    0x65,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xed,
    0xe3,
    0x8f,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class LocalInfoData_LocalInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.latitude_e6_ = 0
    self.longitude_e6_ = 0
    self.address_text_ = None
    self.phone_number_ = None
    self.scraped_type_ = 0
    self.separated_address_ = 0
    self.preceded_by_tag_ = 0
    self.quality_ = 0
    self.is_approximate_geocode_ = 0
    self.has_latitude_e6_ = 0
    self.has_longitude_e6_ = 0
    self.has_address_text_ = 0
    self.has_phone_number_ = 0
    self.has_scraped_type_ = 0
    self.has_separated_address_ = 0
    self.has_preceded_by_tag_ = 0
    self.has_quality_ = 0
    self.has_is_approximate_geocode_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def latitude_e6(self): return self.latitude_e6_

  def set_latitude_e6(self, x):
    self.has_latitude_e6_ = 1
    self.latitude_e6_ = x

  def clear_latitude_e6(self):
    self.has_latitude_e6_ = 0
    self.latitude_e6_ = 0

  def has_latitude_e6(self): return self.has_latitude_e6_

  def longitude_e6(self): return self.longitude_e6_

  def set_longitude_e6(self, x):
    self.has_longitude_e6_ = 1
    self.longitude_e6_ = x

  def clear_longitude_e6(self):
    self.has_longitude_e6_ = 0
    self.longitude_e6_ = 0

  def has_longitude_e6(self): return self.has_longitude_e6_

  def address_text(self):
    if self.address_text_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.address_text_ is None: self.address_text_ = PostalAddress()
      finally:
        self.lazy_init_lock_.release()
    return self.address_text_

  def mutable_address_text(self): self.has_address_text_ = 1; return self.address_text()

  def clear_address_text(self):
    #Warning: this method does not acquire the lock.
    self.has_address_text_ = 0;
    if self.address_text_ is not None: self.address_text_.Clear()

  def has_address_text(self): return self.has_address_text_

  def phone_number(self):
    if self.phone_number_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.phone_number_ is None: self.phone_number_ = TelephoneNumber()
      finally:
        self.lazy_init_lock_.release()
    return self.phone_number_

  def mutable_phone_number(self): self.has_phone_number_ = 1; return self.phone_number()

  def clear_phone_number(self):
    #Warning: this method does not acquire the lock.
    self.has_phone_number_ = 0;
    if self.phone_number_ is not None: self.phone_number_.Clear()

  def has_phone_number(self): return self.has_phone_number_

  def scraped_type(self): return self.scraped_type_

  def set_scraped_type(self, x):
    self.has_scraped_type_ = 1
    self.scraped_type_ = x

  def clear_scraped_type(self):
    self.has_scraped_type_ = 0
    self.scraped_type_ = 0

  def has_scraped_type(self): return self.has_scraped_type_

  def separated_address(self): return self.separated_address_

  def set_separated_address(self, x):
    self.has_separated_address_ = 1
    self.separated_address_ = x

  def clear_separated_address(self):
    self.has_separated_address_ = 0
    self.separated_address_ = 0

  def has_separated_address(self): return self.has_separated_address_

  def preceded_by_tag(self): return self.preceded_by_tag_

  def set_preceded_by_tag(self, x):
    self.has_preceded_by_tag_ = 1
    self.preceded_by_tag_ = x

  def clear_preceded_by_tag(self):
    self.has_preceded_by_tag_ = 0
    self.preceded_by_tag_ = 0

  def has_preceded_by_tag(self): return self.has_preceded_by_tag_

  def quality(self): return self.quality_

  def set_quality(self, x):
    self.has_quality_ = 1
    self.quality_ = x

  def clear_quality(self):
    self.has_quality_ = 0
    self.quality_ = 0

  def has_quality(self): return self.has_quality_

  def is_approximate_geocode(self): return self.is_approximate_geocode_

  def set_is_approximate_geocode(self, x):
    self.has_is_approximate_geocode_ = 1
    self.is_approximate_geocode_ = x

  def clear_is_approximate_geocode(self):
    self.has_is_approximate_geocode_ = 0
    self.is_approximate_geocode_ = 0

  def has_is_approximate_geocode(self): return self.has_is_approximate_geocode_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_latitude_e6()): self.set_latitude_e6(x.latitude_e6())
    if (x.has_longitude_e6()): self.set_longitude_e6(x.longitude_e6())
    if (x.has_address_text()): self.mutable_address_text().MergeFrom(x.address_text())
    if (x.has_phone_number()): self.mutable_phone_number().MergeFrom(x.phone_number())
    if (x.has_scraped_type()): self.set_scraped_type(x.scraped_type())
    if (x.has_separated_address()): self.set_separated_address(x.separated_address())
    if (x.has_preceded_by_tag()): self.set_preceded_by_tag(x.preceded_by_tag())
    if (x.has_quality()): self.set_quality(x.quality())
    if (x.has_is_approximate_geocode()): self.set_is_approximate_geocode(x.is_approximate_geocode())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'LocalInfoData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'LocalInfoData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'LocalInfoData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'LocalInfoData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'LocalInfoData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_latitude_e6_ != x.has_latitude_e6_: return 0
    if self.has_latitude_e6_ and self.latitude_e6_ != x.latitude_e6_: return 0
    if self.has_longitude_e6_ != x.has_longitude_e6_: return 0
    if self.has_longitude_e6_ and self.longitude_e6_ != x.longitude_e6_: return 0
    if self.has_address_text_ != x.has_address_text_: return 0
    if self.has_address_text_ and self.address_text_ != x.address_text_: return 0
    if self.has_phone_number_ != x.has_phone_number_: return 0
    if self.has_phone_number_ and self.phone_number_ != x.phone_number_: return 0
    if self.has_scraped_type_ != x.has_scraped_type_: return 0
    if self.has_scraped_type_ and self.scraped_type_ != x.scraped_type_: return 0
    if self.has_separated_address_ != x.has_separated_address_: return 0
    if self.has_separated_address_ and self.separated_address_ != x.separated_address_: return 0
    if self.has_preceded_by_tag_ != x.has_preceded_by_tag_: return 0
    if self.has_preceded_by_tag_ and self.preceded_by_tag_ != x.preceded_by_tag_: return 0
    if self.has_quality_ != x.has_quality_: return 0
    if self.has_quality_ and self.quality_ != x.quality_: return 0
    if self.has_is_approximate_geocode_ != x.has_is_approximate_geocode_: return 0
    if self.has_is_approximate_geocode_ and self.is_approximate_geocode_ != x.is_approximate_geocode_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_latitude_e6_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: latitude_e6 not set.')
    if (not self.has_longitude_e6_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: longitude_e6 not set.')
    if (self.has_address_text_ and not self.address_text_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_phone_number_ and not self.phone_number_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.latitude_e6_)
    n += self.lengthVarInt64(self.longitude_e6_)
    if (self.has_address_text_): n += 1 + self.lengthString(self.address_text_.ByteSize())
    if (self.has_phone_number_): n += 1 + self.lengthString(self.phone_number_.ByteSize())
    if (self.has_scraped_type_): n += 1 + self.lengthVarInt64(self.scraped_type_)
    if (self.has_separated_address_): n += 2
    if (self.has_preceded_by_tag_): n += 2
    if (self.has_quality_): n += 1 + self.lengthVarInt64(self.quality_)
    if (self.has_is_approximate_geocode_): n += 2
    return n + 2

  def Clear(self):
    self.clear_latitude_e6()
    self.clear_longitude_e6()
    self.clear_address_text()
    self.clear_phone_number()
    self.clear_scraped_type()
    self.clear_separated_address()
    self.clear_preceded_by_tag()
    self.clear_quality()
    self.clear_is_approximate_geocode()

  def OutputUnchecked(self, out):
    out.putVarInt32(16)
    out.putVarInt32(self.latitude_e6_)
    out.putVarInt32(24)
    out.putVarInt32(self.longitude_e6_)
    if (self.has_address_text_):
      out.putVarInt32(34)
      out.putVarInt32(self.address_text_.ByteSize())
      self.address_text_.OutputUnchecked(out)
    if (self.has_phone_number_):
      out.putVarInt32(42)
      out.putVarInt32(self.phone_number_.ByteSize())
      self.phone_number_.OutputUnchecked(out)
    if (self.has_scraped_type_):
      out.putVarInt32(64)
      out.putVarInt32(self.scraped_type_)
    if (self.has_separated_address_):
      out.putVarInt32(72)
      out.putBoolean(self.separated_address_)
    if (self.has_quality_):
      out.putVarInt32(80)
      out.putVarInt32(self.quality_)
    if (self.has_preceded_by_tag_):
      out.putVarInt32(88)
      out.putBoolean(self.preceded_by_tag_)
    if (self.has_is_approximate_geocode_):
      out.putVarInt32(96)
      out.putBoolean(self.is_approximate_geocode_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 16:
        self.set_latitude_e6(d.getVarInt32())
        continue
      if tt == 24:
        self.set_longitude_e6(d.getVarInt32())
        continue
      if tt == 34:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_address_text().TryMerge(tmp)
        continue
      if tt == 42:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_phone_number().TryMerge(tmp)
        continue
      if tt == 64:
        self.set_scraped_type(d.getVarInt32())
        continue
      if tt == 72:
        self.set_separated_address(d.getBoolean())
        continue
      if tt == 80:
        self.set_quality(d.getVarInt32())
        continue
      if tt == 88:
        self.set_preceded_by_tag(d.getBoolean())
        continue
      if tt == 96:
        self.set_is_approximate_geocode(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_latitude_e6_: res+=prefix+("latitude_e6: %s\n" % self.DebugFormatInt32(self.latitude_e6_))
    if self.has_longitude_e6_: res+=prefix+("longitude_e6: %s\n" % self.DebugFormatInt32(self.longitude_e6_))
    if self.has_address_text_:
      res+=prefix+"address_text <\n"
      res+=self.address_text_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_phone_number_:
      res+=prefix+"phone_number <\n"
      res+=self.phone_number_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_scraped_type_: res+=prefix+("scraped_type: %s\n" % self.DebugFormatInt32(self.scraped_type_))
    if self.has_separated_address_: res+=prefix+("separated_address: %s\n" % self.DebugFormatBool(self.separated_address_))
    if self.has_preceded_by_tag_: res+=prefix+("preceded_by_tag: %s\n" % self.DebugFormatBool(self.preceded_by_tag_))
    if self.has_quality_: res+=prefix+("quality: %s\n" % self.DebugFormatInt32(self.quality_))
    if self.has_is_approximate_geocode_: res+=prefix+("is_approximate_geocode: %s\n" % self.DebugFormatBool(self.is_approximate_geocode_))
    return res

class LocalInfoData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 2512640 

  _TypeId_NAMES = {
    2512640: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)


  UNIQUE       =    1 
  OCCASIONAL   =    2 
  PREVALENT    =    4 
  SMALL_SITE   =    8 
  FORUM_URL    =   16 
  SOLO         =   32 
  SEPARATE     =   64 
  INLINE       =  128 

  _ScrapedType_NAMES = {
    1: "UNIQUE",
    2: "OCCASIONAL",
    4: "PREVALENT",
    8: "SMALL_SITE",
    16: "FORUM_URL",
    32: "SOLO",
    64: "SEPARATE",
    128: "INLINE",
  }

  def ScrapedType_Name(cls, x): return cls._ScrapedType_NAMES.get(x, "")
  ScrapedType_Name = classmethod(ScrapedType_Name)

  def __init__(self, contents=None):
    self.localinfo_ = []
    self.target_url_ = ""
    self.docid_ = 0
    self.has_target_url_ = 0
    self.has_docid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def localinfo_size(self): return len(self.localinfo_)
  def localinfo_list(self): return self.localinfo_

  def localinfo(self, i):
    return self.localinfo_[i]

  def mutable_localinfo(self, i):
    return self.localinfo_[i]

  def add_localinfo(self):
    x = LocalInfoData_LocalInfo()
    self.localinfo_.append(x)
    return x

  def clear_localinfo(self):
    self.localinfo_ = []
  def target_url(self): return self.target_url_

  def set_target_url(self, x):
    self.has_target_url_ = 1
    self.target_url_ = x

  def clear_target_url(self):
    self.has_target_url_ = 0
    self.target_url_ = ""

  def has_target_url(self): return self.has_target_url_

  def docid(self): return self.docid_

  def set_docid(self, x):
    self.has_docid_ = 1
    self.docid_ = x

  def clear_docid(self):
    self.has_docid_ = 0
    self.docid_ = 0

  def has_docid(self): return self.has_docid_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.localinfo_size()): self.add_localinfo().CopyFrom(x.localinfo(i))
    if (x.has_target_url()): self.set_target_url(x.target_url())
    if (x.has_docid()): self.set_docid(x.docid())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'LocalInfoData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'LocalInfoData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'LocalInfoData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'LocalInfoData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'LocalInfoData', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.localinfo_) != len(x.localinfo_): return 0
    for e1, e2 in zip(self.localinfo_, x.localinfo_):
      if e1 != e2: return 0
    if self.has_target_url_ != x.has_target_url_: return 0
    if self.has_target_url_ and self.target_url_ != x.target_url_: return 0
    if self.has_docid_ != x.has_docid_: return 0
    if self.has_docid_ and self.docid_ != x.docid_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.localinfo_)):
      if (not self.localinfo_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.localinfo_)
    for i in xrange(len(self.localinfo_)): n += self.localinfo_[i].ByteSize()
    if (self.has_target_url_): n += 1 + self.lengthString(len(self.target_url_))
    if (self.has_docid_): n += 9
    return n + 0

  def Clear(self):
    self.clear_localinfo()
    self.clear_target_url()
    self.clear_docid()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.localinfo_)):
      out.putVarInt32(11)
      self.localinfo_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    if (self.has_target_url_):
      out.putVarInt32(50)
      out.putPrefixedString(self.target_url_)
    if (self.has_docid_):
      out.putVarInt32(57)
      out.put64(self.docid_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_localinfo().TryMerge(d)
        continue
      if tt == 50:
        self.set_target_url(d.getPrefixedString())
        continue
      if tt == 57:
        self.set_docid(d.get64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.localinfo_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("LocalInfo%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_target_url_: res+=prefix+("target_url: %s\n" % self.DebugFormatString(self.target_url_))
    if self.has_docid_: res+=prefix+("docid: %s\n" % self.DebugFormatFixed64(self.docid_))
    return res

  kLocalInfoGroup = 1
  kLocalInfolatitude_e6 = 2
  kLocalInfolongitude_e6 = 3
  kLocalInfoaddress_text = 4
  kLocalInfophone_number = 5
  kLocalInfoscraped_type = 8
  kLocalInfoseparated_address = 9
  kLocalInfopreceded_by_tag = 11
  kLocalInfoquality = 10
  kLocalInfois_approximate_geocode = 12
  ktarget_url = 6
  kdocid = 7

  _TEXT = (
   "ErrorCode",  #   0
   "LocalInfo",  #   1
   "latitude_e6",  #   2
   "longitude_e6",  #   3
   "address_text",  #   4
   "phone_number",  #   5
   "target_url",  #   6
   "docid",  #   7
   "scraped_type",  #   8
   "separated_address",  #   9
   "quality",  #  10
   "preceded_by_tag",  #  11
   "is_approximate_geocode",  #  12
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.DOUBLE,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.NUMERIC,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

   ProtocolBuffer.Encoder.NUMERIC,  #  12

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0d,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x09,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x74,
    0x75,
    0x64,
    0x65,
    0x5f,
    0x65,
    0x36,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x6c,
    0x6f,
    0x6e,
    0x67,
    0x69,
    0x74,
    0x75,
    0x64,
    0x65,
    0x5f,
    0x65,
    0x36,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x61,
    0x64,
    0x64,
    0x72,
    0x65,
    0x73,
    0x73,
    0x5f,
    0x74,
    0x65,
    0x78,
    0x74,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0d,
    0x50,
    0x6f,
    0x73,
    0x74,
    0x61,
    0x6c,
    0x41,
    0x64,
    0x64,
    0x72,
    0x65,
    0x73,
    0x73,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x68,
    0x6f,
    0x6e,
    0x65,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0f,
    0x54,
    0x65,
    0x6c,
    0x65,
    0x70,
    0x68,
    0x6f,
    0x6e,
    0x65,
    0x4e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x73,
    0x63,
    0x72,
    0x61,
    0x70,
    0x65,
    0x64,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x68,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x73,
    0x65,
    0x70,
    0x61,
    0x72,
    0x61,
    0x74,
    0x65,
    0x64,
    0x5f,
    0x61,
    0x64,
    0x64,
    0x72,
    0x65,
    0x73,
    0x73,
    0x20,
    0x09,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x72,
    0x65,
    0x63,
    0x65,
    0x64,
    0x65,
    0x64,
    0x5f,
    0x62,
    0x79,
    0x5f,
    0x74,
    0x61,
    0x67,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x20,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x6c,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x69,
    0x73,
    0x5f,
    0x61,
    0x70,
    0x70,
    0x72,
    0x6f,
    0x78,
    0x69,
    0x6d,
    0x61,
    0x74,
    0x65,
    0x5f,
    0x67,
    0x65,
    0x6f,
    0x63,
    0x6f,
    0x64,
    0x65,
    0x20,
    0x0c,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x00,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x74,
    0x61,
    0x72,
    0x67,
    0x65,
    0x74,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x64,
    0x20,
    0x07,
    0x28,
    0x01,
    0x30,
    0x06,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0x80,
    0xae,
    0x99,
    0x01,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x0b,
    0x53,
    0x63,
    0x72,
    0x61,
    0x70,
    0x65,
    0x64,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x06,
    0x55,
    0x4e,
    0x49,
    0x51,
    0x55,
    0x45,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x4f,
    0x43,
    0x43,
    0x41,
    0x53,
    0x49,
    0x4f,
    0x4e,
    0x41,
    0x4c,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x50,
    0x52,
    0x45,
    0x56,
    0x41,
    0x4c,
    0x45,
    0x4e,
    0x54,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x53,
    0x4d,
    0x41,
    0x4c,
    0x4c,
    0x5f,
    0x53,
    0x49,
    0x54,
    0x45,
    0x98,
    0x01,
    0x08,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x46,
    0x4f,
    0x52,
    0x55,
    0x4d,
    0x5f,
    0x55,
    0x52,
    0x4c,
    0x98,
    0x01,
    0x10,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x04,
    0x53,
    0x4f,
    0x4c,
    0x4f,
    0x98,
    0x01,
    0x20,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x53,
    0x45,
    0x50,
    0x41,
    0x52,
    0x41,
    0x54,
    0x45,
    0x98,
    0x01,
    0x40,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x06,
    0x49,
    0x4e,
    0x4c,
    0x49,
    0x4e,
    0x45,
    0x98,
    0x01,
    0x80,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ScholarData_DocInfoAuthor(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.last_name_ = ""
    self.other_names_ = ""
    self.department_ = ""
    self.institution_ = ""
    self.email_ = ""
    self.has_last_name_ = 0
    self.has_other_names_ = 0
    self.has_department_ = 0
    self.has_institution_ = 0
    self.has_email_ = 0
    if contents is not None: self.MergeFromString(contents)

  def last_name(self): return self.last_name_

  def set_last_name(self, x):
    self.has_last_name_ = 1
    self.last_name_ = x

  def clear_last_name(self):
    self.has_last_name_ = 0
    self.last_name_ = ""

  def has_last_name(self): return self.has_last_name_

  def other_names(self): return self.other_names_

  def set_other_names(self, x):
    self.has_other_names_ = 1
    self.other_names_ = x

  def clear_other_names(self):
    self.has_other_names_ = 0
    self.other_names_ = ""

  def has_other_names(self): return self.has_other_names_

  def department(self): return self.department_

  def set_department(self, x):
    self.has_department_ = 1
    self.department_ = x

  def clear_department(self):
    self.has_department_ = 0
    self.department_ = ""

  def has_department(self): return self.has_department_

  def institution(self): return self.institution_

  def set_institution(self, x):
    self.has_institution_ = 1
    self.institution_ = x

  def clear_institution(self):
    self.has_institution_ = 0
    self.institution_ = ""

  def has_institution(self): return self.has_institution_

  def email(self): return self.email_

  def set_email(self, x):
    self.has_email_ = 1
    self.email_ = x

  def clear_email(self):
    self.has_email_ = 0
    self.email_ = ""

  def has_email(self): return self.has_email_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_last_name()): self.set_last_name(x.last_name())
    if (x.has_other_names()): self.set_other_names(x.other_names())
    if (x.has_department()): self.set_department(x.department())
    if (x.has_institution()): self.set_institution(x.institution())
    if (x.has_email()): self.set_email(x.email())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ScholarData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ScholarData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ScholarData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ScholarData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ScholarData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_last_name_ != x.has_last_name_: return 0
    if self.has_last_name_ and self.last_name_ != x.last_name_: return 0
    if self.has_other_names_ != x.has_other_names_: return 0
    if self.has_other_names_ and self.other_names_ != x.other_names_: return 0
    if self.has_department_ != x.has_department_: return 0
    if self.has_department_ and self.department_ != x.department_: return 0
    if self.has_institution_ != x.has_institution_: return 0
    if self.has_institution_ and self.institution_ != x.institution_: return 0
    if self.has_email_ != x.has_email_: return 0
    if self.has_email_ and self.email_ != x.email_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_last_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: last_name not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.last_name_))
    if (self.has_other_names_): n += 2 + self.lengthString(len(self.other_names_))
    if (self.has_department_): n += 2 + self.lengthString(len(self.department_))
    if (self.has_institution_): n += 2 + self.lengthString(len(self.institution_))
    if (self.has_email_): n += 2 + self.lengthString(len(self.email_))
    return n + 2

  def Clear(self):
    self.clear_last_name()
    self.clear_other_names()
    self.clear_department()
    self.clear_institution()
    self.clear_email()

  def OutputUnchecked(self, out):
    out.putVarInt32(250)
    out.putPrefixedString(self.last_name_)
    if (self.has_other_names_):
      out.putVarInt32(258)
      out.putPrefixedString(self.other_names_)
    if (self.has_department_):
      out.putVarInt32(266)
      out.putPrefixedString(self.department_)
    if (self.has_institution_):
      out.putVarInt32(274)
      out.putPrefixedString(self.institution_)
    if (self.has_email_):
      out.putVarInt32(282)
      out.putPrefixedString(self.email_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 36: break
      if tt == 250:
        self.set_last_name(d.getPrefixedString())
        continue
      if tt == 258:
        self.set_other_names(d.getPrefixedString())
        continue
      if tt == 266:
        self.set_department(d.getPrefixedString())
        continue
      if tt == 274:
        self.set_institution(d.getPrefixedString())
        continue
      if tt == 282:
        self.set_email(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_last_name_: res+=prefix+("last_name: %s\n" % self.DebugFormatString(self.last_name_))
    if self.has_other_names_: res+=prefix+("other_names: %s\n" % self.DebugFormatString(self.other_names_))
    if self.has_department_: res+=prefix+("department: %s\n" % self.DebugFormatString(self.department_))
    if self.has_institution_: res+=prefix+("institution: %s\n" % self.DebugFormatString(self.institution_))
    if self.has_email_: res+=prefix+("email: %s\n" % self.DebugFormatString(self.email_))
    return res

class ScholarData_DocInfoExcerpt(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.content_ = ""
    self.label_ = ""
    self.has_content_ = 0
    self.has_label_ = 0
    if contents is not None: self.MergeFromString(contents)

  def content(self): return self.content_

  def set_content(self, x):
    self.has_content_ = 1
    self.content_ = x

  def clear_content(self):
    self.has_content_ = 0
    self.content_ = ""

  def has_content(self): return self.has_content_

  def label(self): return self.label_

  def set_label(self, x):
    self.has_label_ = 1
    self.label_ = x

  def clear_label(self):
    self.has_label_ = 0
    self.label_ = ""

  def has_label(self): return self.has_label_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_content()): self.set_content(x.content())
    if (x.has_label()): self.set_label(x.label())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ScholarData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ScholarData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ScholarData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ScholarData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ScholarData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_content_ != x.has_content_: return 0
    if self.has_content_ and self.content_ != x.content_: return 0
    if self.has_label_ != x.has_label_: return 0
    if self.has_label_ and self.label_ != x.label_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_content_): n += 2 + self.lengthString(len(self.content_))
    if (self.has_label_): n += 2 + self.lengthString(len(self.label_))
    return n + 0

  def Clear(self):
    self.clear_content()
    self.clear_label()

  def OutputUnchecked(self, out):
    if (self.has_content_):
      out.putVarInt32(570)
      out.putPrefixedString(self.content_)
    if (self.has_label_):
      out.putVarInt32(578)
      out.putPrefixedString(self.label_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 564: break
      if tt == 570:
        self.set_content(d.getPrefixedString())
        continue
      if tt == 578:
        self.set_label(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_content_: res+=prefix+("content: %s\n" % self.DebugFormatString(self.content_))
    if self.has_label_: res+=prefix+("label: %s\n" % self.DebugFormatString(self.label_))
    return res

class ScholarData_DocInfo(ProtocolBuffer.ProtocolMessage):

  SCHOLAR      =    0 
  COMPOSITE_DOC =    1 

  _Source_NAMES = {
    0: "SCHOLAR",
    1: "COMPOSITE_DOC",
  }

  def Source_Name(cls, x): return cls._Source_NAMES.get(x, "")
  Source_Name = classmethod(Source_Name)

  def __init__(self, contents=None):
    self.title_ = ""
    self.author_ = []
    self.publication_day_ = 0
    self.publication_month_ = 0
    self.publication_year_ = 0
    self.publication_venue_ = ""
    self.pages_ = ""
    self.volume_ = 0
    self.number_ = ""
    self.page_count_ = 0
    self.abstract_ = ""
    self.excerpt_ = []
    self.source_ = 0
    self.scholar_id_ = 0
    self.pagerank_ = 0
    self.has_title_ = 0
    self.has_publication_day_ = 0
    self.has_publication_month_ = 0
    self.has_publication_year_ = 0
    self.has_publication_venue_ = 0
    self.has_pages_ = 0
    self.has_volume_ = 0
    self.has_number_ = 0
    self.has_page_count_ = 0
    self.has_abstract_ = 0
    self.has_source_ = 0
    self.has_scholar_id_ = 0
    self.has_pagerank_ = 0
    if contents is not None: self.MergeFromString(contents)

  def title(self): return self.title_

  def set_title(self, x):
    self.has_title_ = 1
    self.title_ = x

  def clear_title(self):
    self.has_title_ = 0
    self.title_ = ""

  def has_title(self): return self.has_title_

  def author_size(self): return len(self.author_)
  def author_list(self): return self.author_

  def author(self, i):
    return self.author_[i]

  def mutable_author(self, i):
    return self.author_[i]

  def add_author(self):
    x = ScholarData_DocInfoAuthor()
    self.author_.append(x)
    return x

  def clear_author(self):
    self.author_ = []
  def publication_day(self): return self.publication_day_

  def set_publication_day(self, x):
    self.has_publication_day_ = 1
    self.publication_day_ = x

  def clear_publication_day(self):
    self.has_publication_day_ = 0
    self.publication_day_ = 0

  def has_publication_day(self): return self.has_publication_day_

  def publication_month(self): return self.publication_month_

  def set_publication_month(self, x):
    self.has_publication_month_ = 1
    self.publication_month_ = x

  def clear_publication_month(self):
    self.has_publication_month_ = 0
    self.publication_month_ = 0

  def has_publication_month(self): return self.has_publication_month_

  def publication_year(self): return self.publication_year_

  def set_publication_year(self, x):
    self.has_publication_year_ = 1
    self.publication_year_ = x

  def clear_publication_year(self):
    self.has_publication_year_ = 0
    self.publication_year_ = 0

  def has_publication_year(self): return self.has_publication_year_

  def publication_venue(self): return self.publication_venue_

  def set_publication_venue(self, x):
    self.has_publication_venue_ = 1
    self.publication_venue_ = x

  def clear_publication_venue(self):
    self.has_publication_venue_ = 0
    self.publication_venue_ = ""

  def has_publication_venue(self): return self.has_publication_venue_

  def pages(self): return self.pages_

  def set_pages(self, x):
    self.has_pages_ = 1
    self.pages_ = x

  def clear_pages(self):
    self.has_pages_ = 0
    self.pages_ = ""

  def has_pages(self): return self.has_pages_

  def volume(self): return self.volume_

  def set_volume(self, x):
    self.has_volume_ = 1
    self.volume_ = x

  def clear_volume(self):
    self.has_volume_ = 0
    self.volume_ = 0

  def has_volume(self): return self.has_volume_

  def number(self): return self.number_

  def set_number(self, x):
    self.has_number_ = 1
    self.number_ = x

  def clear_number(self):
    self.has_number_ = 0
    self.number_ = ""

  def has_number(self): return self.has_number_

  def page_count(self): return self.page_count_

  def set_page_count(self, x):
    self.has_page_count_ = 1
    self.page_count_ = x

  def clear_page_count(self):
    self.has_page_count_ = 0
    self.page_count_ = 0

  def has_page_count(self): return self.has_page_count_

  def abstract(self): return self.abstract_

  def set_abstract(self, x):
    self.has_abstract_ = 1
    self.abstract_ = x

  def clear_abstract(self):
    self.has_abstract_ = 0
    self.abstract_ = ""

  def has_abstract(self): return self.has_abstract_

  def excerpt_size(self): return len(self.excerpt_)
  def excerpt_list(self): return self.excerpt_

  def excerpt(self, i):
    return self.excerpt_[i]

  def mutable_excerpt(self, i):
    return self.excerpt_[i]

  def add_excerpt(self):
    x = ScholarData_DocInfoExcerpt()
    self.excerpt_.append(x)
    return x

  def clear_excerpt(self):
    self.excerpt_ = []
  def source(self): return self.source_

  def set_source(self, x):
    self.has_source_ = 1
    self.source_ = x

  def clear_source(self):
    self.has_source_ = 0
    self.source_ = 0

  def has_source(self): return self.has_source_

  def scholar_id(self): return self.scholar_id_

  def set_scholar_id(self, x):
    self.has_scholar_id_ = 1
    self.scholar_id_ = x

  def clear_scholar_id(self):
    self.has_scholar_id_ = 0
    self.scholar_id_ = 0

  def has_scholar_id(self): return self.has_scholar_id_

  def pagerank(self): return self.pagerank_

  def set_pagerank(self, x):
    self.has_pagerank_ = 1
    self.pagerank_ = x

  def clear_pagerank(self):
    self.has_pagerank_ = 0
    self.pagerank_ = 0

  def has_pagerank(self): return self.has_pagerank_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_title()): self.set_title(x.title())
    for i in xrange(x.author_size()): self.add_author().CopyFrom(x.author(i))
    if (x.has_publication_day()): self.set_publication_day(x.publication_day())
    if (x.has_publication_month()): self.set_publication_month(x.publication_month())
    if (x.has_publication_year()): self.set_publication_year(x.publication_year())
    if (x.has_publication_venue()): self.set_publication_venue(x.publication_venue())
    if (x.has_pages()): self.set_pages(x.pages())
    if (x.has_volume()): self.set_volume(x.volume())
    if (x.has_number()): self.set_number(x.number())
    if (x.has_page_count()): self.set_page_count(x.page_count())
    if (x.has_abstract()): self.set_abstract(x.abstract())
    for i in xrange(x.excerpt_size()): self.add_excerpt().CopyFrom(x.excerpt(i))
    if (x.has_source()): self.set_source(x.source())
    if (x.has_scholar_id()): self.set_scholar_id(x.scholar_id())
    if (x.has_pagerank()): self.set_pagerank(x.pagerank())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ScholarData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ScholarData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ScholarData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ScholarData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ScholarData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_title_ != x.has_title_: return 0
    if self.has_title_ and self.title_ != x.title_: return 0
    if len(self.author_) != len(x.author_): return 0
    for e1, e2 in zip(self.author_, x.author_):
      if e1 != e2: return 0
    if self.has_publication_day_ != x.has_publication_day_: return 0
    if self.has_publication_day_ and self.publication_day_ != x.publication_day_: return 0
    if self.has_publication_month_ != x.has_publication_month_: return 0
    if self.has_publication_month_ and self.publication_month_ != x.publication_month_: return 0
    if self.has_publication_year_ != x.has_publication_year_: return 0
    if self.has_publication_year_ and self.publication_year_ != x.publication_year_: return 0
    if self.has_publication_venue_ != x.has_publication_venue_: return 0
    if self.has_publication_venue_ and self.publication_venue_ != x.publication_venue_: return 0
    if self.has_pages_ != x.has_pages_: return 0
    if self.has_pages_ and self.pages_ != x.pages_: return 0
    if self.has_volume_ != x.has_volume_: return 0
    if self.has_volume_ and self.volume_ != x.volume_: return 0
    if self.has_number_ != x.has_number_: return 0
    if self.has_number_ and self.number_ != x.number_: return 0
    if self.has_page_count_ != x.has_page_count_: return 0
    if self.has_page_count_ and self.page_count_ != x.page_count_: return 0
    if self.has_abstract_ != x.has_abstract_: return 0
    if self.has_abstract_ and self.abstract_ != x.abstract_: return 0
    if len(self.excerpt_) != len(x.excerpt_): return 0
    for e1, e2 in zip(self.excerpt_, x.excerpt_):
      if e1 != e2: return 0
    if self.has_source_ != x.has_source_: return 0
    if self.has_source_ and self.source_ != x.source_: return 0
    if self.has_scholar_id_ != x.has_scholar_id_: return 0
    if self.has_scholar_id_ and self.scholar_id_ != x.scholar_id_: return 0
    if self.has_pagerank_ != x.has_pagerank_: return 0
    if self.has_pagerank_ and self.pagerank_ != x.pagerank_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.author_)):
      if (not self.author_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.excerpt_)):
      if (not self.excerpt_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_title_): n += 1 + self.lengthString(len(self.title_))
    n += 2 * len(self.author_)
    for i in xrange(len(self.author_)): n += self.author_[i].ByteSize()
    if (self.has_publication_day_): n += 2 + self.lengthVarInt64(self.publication_day_)
    if (self.has_publication_month_): n += 2 + self.lengthVarInt64(self.publication_month_)
    if (self.has_publication_year_): n += 2 + self.lengthVarInt64(self.publication_year_)
    if (self.has_publication_venue_): n += 2 + self.lengthString(len(self.publication_venue_))
    if (self.has_pages_): n += 2 + self.lengthString(len(self.pages_))
    if (self.has_volume_): n += 2 + self.lengthVarInt64(self.volume_)
    if (self.has_number_): n += 2 + self.lengthString(len(self.number_))
    if (self.has_page_count_): n += 2 + self.lengthVarInt64(self.page_count_)
    if (self.has_abstract_): n += 2 + self.lengthString(len(self.abstract_))
    n += 4 * len(self.excerpt_)
    for i in xrange(len(self.excerpt_)): n += self.excerpt_[i].ByteSize()
    if (self.has_source_): n += 2 + self.lengthVarInt64(self.source_)
    if (self.has_scholar_id_): n += 10
    if (self.has_pagerank_): n += 2 + self.lengthVarInt64(self.pagerank_)
    return n + 0

  def Clear(self):
    self.clear_title()
    self.clear_author()
    self.clear_publication_day()
    self.clear_publication_month()
    self.clear_publication_year()
    self.clear_publication_venue()
    self.clear_pages()
    self.clear_volume()
    self.clear_number()
    self.clear_page_count()
    self.clear_abstract()
    self.clear_excerpt()
    self.clear_source()
    self.clear_scholar_id()
    self.clear_pagerank()

  def OutputUnchecked(self, out):
    if (self.has_title_):
      out.putVarInt32(26)
      out.putPrefixedString(self.title_)
    for i in xrange(len(self.author_)):
      out.putVarInt32(35)
      self.author_[i].OutputUnchecked(out)
      out.putVarInt32(36)
    if (self.has_publication_day_):
      out.putVarInt32(328)
      out.putVarInt32(self.publication_day_)
    if (self.has_publication_month_):
      out.putVarInt32(336)
      out.putVarInt32(self.publication_month_)
    if (self.has_publication_year_):
      out.putVarInt32(344)
      out.putVarInt32(self.publication_year_)
    if (self.has_publication_venue_):
      out.putVarInt32(354)
      out.putPrefixedString(self.publication_venue_)
    if (self.has_pages_):
      out.putVarInt32(410)
      out.putPrefixedString(self.pages_)
    if (self.has_volume_):
      out.putVarInt32(416)
      out.putVarInt32(self.volume_)
    if (self.has_number_):
      out.putVarInt32(426)
      out.putPrefixedString(self.number_)
    if (self.has_page_count_):
      out.putVarInt32(432)
      out.putVarInt32(self.page_count_)
    if (self.has_abstract_):
      out.putVarInt32(490)
      out.putPrefixedString(self.abstract_)
    if (self.has_source_):
      out.putVarInt32(504)
      out.putVarInt32(self.source_)
    if (self.has_scholar_id_):
      out.putVarInt32(521)
      out.put64(self.scholar_id_)
    if (self.has_pagerank_):
      out.putVarInt32(528)
      out.putVarInt32(self.pagerank_)
    for i in xrange(len(self.excerpt_)):
      out.putVarInt32(563)
      self.excerpt_[i].OutputUnchecked(out)
      out.putVarInt32(564)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 26:
        self.set_title(d.getPrefixedString())
        continue
      if tt == 35:
        self.add_author().TryMerge(d)
        continue
      if tt == 328:
        self.set_publication_day(d.getVarInt32())
        continue
      if tt == 336:
        self.set_publication_month(d.getVarInt32())
        continue
      if tt == 344:
        self.set_publication_year(d.getVarInt32())
        continue
      if tt == 354:
        self.set_publication_venue(d.getPrefixedString())
        continue
      if tt == 410:
        self.set_pages(d.getPrefixedString())
        continue
      if tt == 416:
        self.set_volume(d.getVarInt32())
        continue
      if tt == 426:
        self.set_number(d.getPrefixedString())
        continue
      if tt == 432:
        self.set_page_count(d.getVarInt32())
        continue
      if tt == 490:
        self.set_abstract(d.getPrefixedString())
        continue
      if tt == 504:
        self.set_source(d.getVarInt32())
        continue
      if tt == 521:
        self.set_scholar_id(d.get64())
        continue
      if tt == 528:
        self.set_pagerank(d.getVarInt32())
        continue
      if tt == 563:
        self.add_excerpt().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_title_: res+=prefix+("title: %s\n" % self.DebugFormatString(self.title_))
    cnt=0
    for e in self.author_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Author%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_publication_day_: res+=prefix+("publication_day: %s\n" % self.DebugFormatInt32(self.publication_day_))
    if self.has_publication_month_: res+=prefix+("publication_month: %s\n" % self.DebugFormatInt32(self.publication_month_))
    if self.has_publication_year_: res+=prefix+("publication_year: %s\n" % self.DebugFormatInt32(self.publication_year_))
    if self.has_publication_venue_: res+=prefix+("publication_venue: %s\n" % self.DebugFormatString(self.publication_venue_))
    if self.has_pages_: res+=prefix+("pages: %s\n" % self.DebugFormatString(self.pages_))
    if self.has_volume_: res+=prefix+("volume: %s\n" % self.DebugFormatInt32(self.volume_))
    if self.has_number_: res+=prefix+("number: %s\n" % self.DebugFormatString(self.number_))
    if self.has_page_count_: res+=prefix+("page_count: %s\n" % self.DebugFormatInt32(self.page_count_))
    if self.has_abstract_: res+=prefix+("abstract: %s\n" % self.DebugFormatString(self.abstract_))
    cnt=0
    for e in self.excerpt_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Excerpt%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_source_: res+=prefix+("source: %s\n" % self.DebugFormatInt32(self.source_))
    if self.has_scholar_id_: res+=prefix+("scholar_id: %s\n" % self.DebugFormatFixed64(self.scholar_id_))
    if self.has_pagerank_: res+=prefix+("pagerank: %s\n" % self.DebugFormatInt32(self.pagerank_))
    return res

class ScholarData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 2741539 

  _TypeId_NAMES = {
    2741539: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.docinfo_ = []
    self.target_url_ = ""
    self.target_docid_ = 0
    self.has_target_url_ = 0
    self.has_target_docid_ = 0
    if contents is not None: self.MergeFromString(contents)

  def docinfo_size(self): return len(self.docinfo_)
  def docinfo_list(self): return self.docinfo_

  def docinfo(self, i):
    return self.docinfo_[i]

  def mutable_docinfo(self, i):
    return self.docinfo_[i]

  def add_docinfo(self):
    x = ScholarData_DocInfo()
    self.docinfo_.append(x)
    return x

  def clear_docinfo(self):
    self.docinfo_ = []
  def target_url(self): return self.target_url_

  def set_target_url(self, x):
    self.has_target_url_ = 1
    self.target_url_ = x

  def clear_target_url(self):
    self.has_target_url_ = 0
    self.target_url_ = ""

  def has_target_url(self): return self.has_target_url_

  def target_docid(self): return self.target_docid_

  def set_target_docid(self, x):
    self.has_target_docid_ = 1
    self.target_docid_ = x

  def clear_target_docid(self):
    self.has_target_docid_ = 0
    self.target_docid_ = 0

  def has_target_docid(self): return self.has_target_docid_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.docinfo_size()): self.add_docinfo().CopyFrom(x.docinfo(i))
    if (x.has_target_url()): self.set_target_url(x.target_url())
    if (x.has_target_docid()): self.set_target_docid(x.target_docid())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'ScholarData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'ScholarData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'ScholarData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'ScholarData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'ScholarData', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.docinfo_) != len(x.docinfo_): return 0
    for e1, e2 in zip(self.docinfo_, x.docinfo_):
      if e1 != e2: return 0
    if self.has_target_url_ != x.has_target_url_: return 0
    if self.has_target_url_ and self.target_url_ != x.target_url_: return 0
    if self.has_target_docid_ != x.has_target_docid_: return 0
    if self.has_target_docid_ and self.target_docid_ != x.target_docid_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.docinfo_)):
      if (not self.docinfo_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.docinfo_)
    for i in xrange(len(self.docinfo_)): n += self.docinfo_[i].ByteSize()
    if (self.has_target_url_): n += 1 + self.lengthString(len(self.target_url_))
    if (self.has_target_docid_): n += 9
    return n + 0

  def Clear(self):
    self.clear_docinfo()
    self.clear_target_url()
    self.clear_target_docid()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.docinfo_)):
      out.putVarInt32(11)
      self.docinfo_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    if (self.has_target_url_):
      out.putVarInt32(18)
      out.putPrefixedString(self.target_url_)
    if (self.has_target_docid_):
      out.putVarInt32(41)
      out.put64(self.target_docid_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_docinfo().TryMerge(d)
        continue
      if tt == 18:
        self.set_target_url(d.getPrefixedString())
        continue
      if tt == 41:
        self.set_target_docid(d.get64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.docinfo_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DocInfo%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_target_url_: res+=prefix+("target_url: %s\n" % self.DebugFormatString(self.target_url_))
    if self.has_target_docid_: res+=prefix+("target_docid: %s\n" % self.DebugFormatFixed64(self.target_docid_))
    return res

  kDocInfoGroup = 1
  kDocInfotitle = 3
  kDocInfoAuthorGroup = 4
  kDocInfoAuthorlast_name = 31
  kDocInfoAuthorother_names = 32
  kDocInfoAuthordepartment = 33
  kDocInfoAuthorinstitution = 34
  kDocInfoAuthoremail = 35
  kDocInfopublication_day = 41
  kDocInfopublication_month = 42
  kDocInfopublication_year = 43
  kDocInfopublication_venue = 44
  kDocInfopages = 51
  kDocInfovolume = 52
  kDocInfonumber = 53
  kDocInfopage_count = 54
  kDocInfoabstract = 61
  kDocInfoExcerptGroup = 70
  kDocInfoExcerptcontent = 71
  kDocInfoExcerptlabel = 72
  kDocInfosource = 63
  kDocInfoscholar_id = 65
  kDocInfopagerank = 66
  ktarget_url = 2
  ktarget_docid = 5

  _TEXT = (
   "ErrorCode",  #   0
   "DocInfo",  #   1
   "target_url",  #   2
   "title",  #   3
   "Author",  #   4
   "target_docid",  #   5
   None,  #   6
   None,  #   7
   None,  #   8
   None,  #   9
   None,  #  10
   None,  #  11
   None,  #  12
   None,  #  13
   None,  #  14
   None,  #  15
   None,  #  16
   None,  #  17
   None,  #  18
   None,  #  19
   None,  #  20
   None,  #  21
   None,  #  22
   None,  #  23
   None,  #  24
   None,  #  25
   None,  #  26
   None,  #  27
   None,  #  28
   None,  #  29
   None,  #  30
   "last_name",  #  31
   "other_names",  #  32
   "department",  #  33
   "institution",  #  34
   "email",  #  35
   None,  #  36
   None,  #  37
   None,  #  38
   None,  #  39
   None,  #  40
   "publication_day",  #  41
   "publication_month",  #  42
   "publication_year",  #  43
   "publication_venue",  #  44
   None,  #  45
   None,  #  46
   None,  #  47
   None,  #  48
   None,  #  49
   None,  #  50
   "pages",  #  51
   "volume",  #  52
   "number",  #  53
   "page_count",  #  54
   None,  #  55
   None,  #  56
   None,  #  57
   None,  #  58
   None,  #  59
   None,  #  60
   "abstract",  #  61
   None,  #  62
   "source",  #  63
   None,  #  64
   "scholar_id",  #  65
   "pagerank",  #  66
   None,  #  67
   None,  #  68
   None,  #  69
   "Excerpt",  #  70
   "content",  #  71
   "label",  #  72
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STARTGROUP,  #   4

   ProtocolBuffer.Encoder.DOUBLE,  #   5

   ProtocolBuffer.Encoder.MAX_TYPE,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.MAX_TYPE,  #   8

   ProtocolBuffer.Encoder.MAX_TYPE,  #   9

   ProtocolBuffer.Encoder.MAX_TYPE,  #  10

   ProtocolBuffer.Encoder.MAX_TYPE,  #  11

   ProtocolBuffer.Encoder.MAX_TYPE,  #  12

   ProtocolBuffer.Encoder.MAX_TYPE,  #  13

   ProtocolBuffer.Encoder.MAX_TYPE,  #  14

   ProtocolBuffer.Encoder.MAX_TYPE,  #  15

   ProtocolBuffer.Encoder.MAX_TYPE,  #  16

   ProtocolBuffer.Encoder.MAX_TYPE,  #  17

   ProtocolBuffer.Encoder.MAX_TYPE,  #  18

   ProtocolBuffer.Encoder.MAX_TYPE,  #  19

   ProtocolBuffer.Encoder.MAX_TYPE,  #  20

   ProtocolBuffer.Encoder.MAX_TYPE,  #  21

   ProtocolBuffer.Encoder.MAX_TYPE,  #  22

   ProtocolBuffer.Encoder.MAX_TYPE,  #  23

   ProtocolBuffer.Encoder.MAX_TYPE,  #  24

   ProtocolBuffer.Encoder.MAX_TYPE,  #  25

   ProtocolBuffer.Encoder.MAX_TYPE,  #  26

   ProtocolBuffer.Encoder.MAX_TYPE,  #  27

   ProtocolBuffer.Encoder.MAX_TYPE,  #  28

   ProtocolBuffer.Encoder.MAX_TYPE,  #  29

   ProtocolBuffer.Encoder.MAX_TYPE,  #  30

   ProtocolBuffer.Encoder.STRING,  #  31

   ProtocolBuffer.Encoder.STRING,  #  32

   ProtocolBuffer.Encoder.STRING,  #  33

   ProtocolBuffer.Encoder.STRING,  #  34

   ProtocolBuffer.Encoder.STRING,  #  35

   ProtocolBuffer.Encoder.MAX_TYPE,  #  36

   ProtocolBuffer.Encoder.MAX_TYPE,  #  37

   ProtocolBuffer.Encoder.MAX_TYPE,  #  38

   ProtocolBuffer.Encoder.MAX_TYPE,  #  39

   ProtocolBuffer.Encoder.MAX_TYPE,  #  40

   ProtocolBuffer.Encoder.NUMERIC,  #  41

   ProtocolBuffer.Encoder.NUMERIC,  #  42

   ProtocolBuffer.Encoder.NUMERIC,  #  43

   ProtocolBuffer.Encoder.STRING,  #  44

   ProtocolBuffer.Encoder.MAX_TYPE,  #  45

   ProtocolBuffer.Encoder.MAX_TYPE,  #  46

   ProtocolBuffer.Encoder.MAX_TYPE,  #  47

   ProtocolBuffer.Encoder.MAX_TYPE,  #  48

   ProtocolBuffer.Encoder.MAX_TYPE,  #  49

   ProtocolBuffer.Encoder.MAX_TYPE,  #  50

   ProtocolBuffer.Encoder.STRING,  #  51

   ProtocolBuffer.Encoder.NUMERIC,  #  52

   ProtocolBuffer.Encoder.STRING,  #  53

   ProtocolBuffer.Encoder.NUMERIC,  #  54

   ProtocolBuffer.Encoder.MAX_TYPE,  #  55

   ProtocolBuffer.Encoder.MAX_TYPE,  #  56

   ProtocolBuffer.Encoder.MAX_TYPE,  #  57

   ProtocolBuffer.Encoder.MAX_TYPE,  #  58

   ProtocolBuffer.Encoder.MAX_TYPE,  #  59

   ProtocolBuffer.Encoder.MAX_TYPE,  #  60

   ProtocolBuffer.Encoder.STRING,  #  61

   ProtocolBuffer.Encoder.MAX_TYPE,  #  62

   ProtocolBuffer.Encoder.NUMERIC,  #  63

   ProtocolBuffer.Encoder.MAX_TYPE,  #  64

   ProtocolBuffer.Encoder.DOUBLE,  #  65

   ProtocolBuffer.Encoder.NUMERIC,  #  66

   ProtocolBuffer.Encoder.MAX_TYPE,  #  67

   ProtocolBuffer.Encoder.MAX_TYPE,  #  68

   ProtocolBuffer.Encoder.MAX_TYPE,  #  69

   ProtocolBuffer.Encoder.STARTGROUP,  #  70

   ProtocolBuffer.Encoder.STRING,  #  71

   ProtocolBuffer.Encoder.STRING,  #  72

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0b,
    0x53,
    0x63,
    0x68,
    0x6f,
    0x6c,
    0x61,
    0x72,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x07,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x74,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x41,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x20,
    0x04,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x41,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x2e,
    0x6c,
    0x61,
    0x73,
    0x74,
    0x5f,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x1f,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x41,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x2e,
    0x6f,
    0x74,
    0x68,
    0x65,
    0x72,
    0x5f,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x73,
    0x20,
    0x20,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x41,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x2e,
    0x64,
    0x65,
    0x70,
    0x61,
    0x72,
    0x74,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x21,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x41,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x2e,
    0x69,
    0x6e,
    0x73,
    0x74,
    0x69,
    0x74,
    0x75,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x22,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x41,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x2e,
    0x65,
    0x6d,
    0x61,
    0x69,
    0x6c,
    0x20,
    0x23,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x64,
    0x61,
    0x79,
    0x20,
    0x29,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x6d,
    0x6f,
    0x6e,
    0x74,
    0x68,
    0x20,
    0x2a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x79,
    0x65,
    0x61,
    0x72,
    0x20,
    0x2b,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x76,
    0x65,
    0x6e,
    0x75,
    0x65,
    0x20,
    0x2c,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x33,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x76,
    0x6f,
    0x6c,
    0x75,
    0x6d,
    0x65,
    0x20,
    0x34,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x35,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x63,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x36,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x61,
    0x62,
    0x73,
    0x74,
    0x72,
    0x61,
    0x63,
    0x74,
    0x20,
    0x3d,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x45,
    0x78,
    0x63,
    0x65,
    0x72,
    0x70,
    0x74,
    0x20,
    0x46,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x45,
    0x78,
    0x63,
    0x65,
    0x72,
    0x70,
    0x74,
    0x2e,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x47,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x11,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x45,
    0x78,
    0x63,
    0x65,
    0x72,
    0x70,
    0x74,
    0x2e,
    0x6c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x48,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x11,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x20,
    0x3f,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x73,
    0x63,
    0x68,
    0x6f,
    0x6c,
    0x61,
    0x72,
    0x5f,
    0x69,
    0x64,
    0x20,
    0x41,
    0x28,
    0x01,
    0x30,
    0x06,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x61,
    0x67,
    0x65,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x42,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x74,
    0x61,
    0x72,
    0x67,
    0x65,
    0x74,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x74,
    0x61,
    0x72,
    0x67,
    0x65,
    0x74,
    0x5f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x64,
    0x20,
    0x05,
    0x28,
    0x01,
    0x30,
    0x06,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xa3,
    0xaa,
    0xa7,
    0x01,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x06,
    0x53,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x80,
    0x01,
    0x00,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x53,
    0x43,
    0x48,
    0x4f,
    0x4c,
    0x41,
    0x52,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x43,
    0x4f,
    0x4d,
    0x50,
    0x4f,
    0x53,
    0x49,
    0x54,
    0x45,
    0x5f,
    0x44,
    0x4f,
    0x43,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FinanceData_Company(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.ticker_ = ""
    self.description_ = ""
    self.exchange_ = ""
    self.country_ = ""
    self.has_ticker_ = 0
    self.has_description_ = 0
    self.has_exchange_ = 0
    self.has_country_ = 0
    if contents is not None: self.MergeFromString(contents)

  def ticker(self): return self.ticker_

  def set_ticker(self, x):
    self.has_ticker_ = 1
    self.ticker_ = x

  def clear_ticker(self):
    self.has_ticker_ = 0
    self.ticker_ = ""

  def has_ticker(self): return self.has_ticker_

  def description(self): return self.description_

  def set_description(self, x):
    self.has_description_ = 1
    self.description_ = x

  def clear_description(self):
    self.has_description_ = 0
    self.description_ = ""

  def has_description(self): return self.has_description_

  def exchange(self): return self.exchange_

  def set_exchange(self, x):
    self.has_exchange_ = 1
    self.exchange_ = x

  def clear_exchange(self):
    self.has_exchange_ = 0
    self.exchange_ = ""

  def has_exchange(self): return self.has_exchange_

  def country(self): return self.country_

  def set_country(self, x):
    self.has_country_ = 1
    self.country_ = x

  def clear_country(self):
    self.has_country_ = 0
    self.country_ = ""

  def has_country(self): return self.has_country_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_ticker()): self.set_ticker(x.ticker())
    if (x.has_description()): self.set_description(x.description())
    if (x.has_exchange()): self.set_exchange(x.exchange())
    if (x.has_country()): self.set_country(x.country())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'FinanceData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'FinanceData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'FinanceData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'FinanceData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'FinanceData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_ticker_ != x.has_ticker_: return 0
    if self.has_ticker_ and self.ticker_ != x.ticker_: return 0
    if self.has_description_ != x.has_description_: return 0
    if self.has_description_ and self.description_ != x.description_: return 0
    if self.has_exchange_ != x.has_exchange_: return 0
    if self.has_exchange_ and self.exchange_ != x.exchange_: return 0
    if self.has_country_ != x.has_country_: return 0
    if self.has_country_ and self.country_ != x.country_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_ticker_): n += 1 + self.lengthString(len(self.ticker_))
    if (self.has_description_): n += 1 + self.lengthString(len(self.description_))
    if (self.has_exchange_): n += 1 + self.lengthString(len(self.exchange_))
    if (self.has_country_): n += 1 + self.lengthString(len(self.country_))
    return n + 0

  def Clear(self):
    self.clear_ticker()
    self.clear_description()
    self.clear_exchange()
    self.clear_country()

  def OutputUnchecked(self, out):
    if (self.has_ticker_):
      out.putVarInt32(26)
      out.putPrefixedString(self.ticker_)
    if (self.has_description_):
      out.putVarInt32(34)
      out.putPrefixedString(self.description_)
    if (self.has_exchange_):
      out.putVarInt32(42)
      out.putPrefixedString(self.exchange_)
    if (self.has_country_):
      out.putVarInt32(50)
      out.putPrefixedString(self.country_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 26:
        self.set_ticker(d.getPrefixedString())
        continue
      if tt == 34:
        self.set_description(d.getPrefixedString())
        continue
      if tt == 42:
        self.set_exchange(d.getPrefixedString())
        continue
      if tt == 50:
        self.set_country(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_ticker_: res+=prefix+("ticker: %s\n" % self.DebugFormatString(self.ticker_))
    if self.has_description_: res+=prefix+("description: %s\n" % self.DebugFormatString(self.description_))
    if self.has_exchange_: res+=prefix+("exchange: %s\n" % self.DebugFormatString(self.exchange_))
    if self.has_country_: res+=prefix+("country: %s\n" % self.DebugFormatString(self.country_))
    return res

class FinanceData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 2759123 

  _TypeId_NAMES = {
    2759123: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.company_ = []
    self.description_ = ""
    self.target_url_ = ""
    self.has_description_ = 0
    self.has_target_url_ = 0
    if contents is not None: self.MergeFromString(contents)

  def company_size(self): return len(self.company_)
  def company_list(self): return self.company_

  def company(self, i):
    return self.company_[i]

  def mutable_company(self, i):
    return self.company_[i]

  def add_company(self):
    x = FinanceData_Company()
    self.company_.append(x)
    return x

  def clear_company(self):
    self.company_ = []
  def description(self): return self.description_

  def set_description(self, x):
    self.has_description_ = 1
    self.description_ = x

  def clear_description(self):
    self.has_description_ = 0
    self.description_ = ""

  def has_description(self): return self.has_description_

  def target_url(self): return self.target_url_

  def set_target_url(self, x):
    self.has_target_url_ = 1
    self.target_url_ = x

  def clear_target_url(self):
    self.has_target_url_ = 0
    self.target_url_ = ""

  def has_target_url(self): return self.has_target_url_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.company_size()): self.add_company().CopyFrom(x.company(i))
    if (x.has_description()): self.set_description(x.description())
    if (x.has_target_url()): self.set_target_url(x.target_url())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'FinanceData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'FinanceData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'FinanceData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'FinanceData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'FinanceData', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.company_) != len(x.company_): return 0
    for e1, e2 in zip(self.company_, x.company_):
      if e1 != e2: return 0
    if self.has_description_ != x.has_description_: return 0
    if self.has_description_ and self.description_ != x.description_: return 0
    if self.has_target_url_ != x.has_target_url_: return 0
    if self.has_target_url_ and self.target_url_ != x.target_url_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.company_)):
      if (not self.company_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.company_)
    for i in xrange(len(self.company_)): n += self.company_[i].ByteSize()
    if (self.has_description_): n += 1 + self.lengthString(len(self.description_))
    if (self.has_target_url_): n += 1 + self.lengthString(len(self.target_url_))
    return n + 0

  def Clear(self):
    self.clear_company()
    self.clear_description()
    self.clear_target_url()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.company_)):
      out.putVarInt32(11)
      self.company_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    if (self.has_target_url_):
      out.putVarInt32(18)
      out.putPrefixedString(self.target_url_)
    if (self.has_description_):
      out.putVarInt32(74)
      out.putPrefixedString(self.description_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_company().TryMerge(d)
        continue
      if tt == 18:
        self.set_target_url(d.getPrefixedString())
        continue
      if tt == 74:
        self.set_description(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.company_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Company%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_description_: res+=prefix+("description: %s\n" % self.DebugFormatString(self.description_))
    if self.has_target_url_: res+=prefix+("target_url: %s\n" % self.DebugFormatString(self.target_url_))
    return res

  kCompanyGroup = 1
  kCompanyticker = 3
  kCompanydescription = 4
  kCompanyexchange = 5
  kCompanycountry = 6
  kdescription = 9
  ktarget_url = 2

  _TEXT = (
   "ErrorCode",  #   0
   "Company",  #   1
   "target_url",  #   2
   "ticker",  #   3
   "description",  #   4
   "exchange",  #   5
   "country",  #   6
   None,  #   7
   None,  #   8
   "description",  #   9
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.MAX_TYPE,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0b,
    0x46,
    0x69,
    0x6e,
    0x61,
    0x6e,
    0x63,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x07,
    0x43,
    0x6f,
    0x6d,
    0x70,
    0x61,
    0x6e,
    0x79,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x43,
    0x6f,
    0x6d,
    0x70,
    0x61,
    0x6e,
    0x79,
    0x2e,
    0x74,
    0x69,
    0x63,
    0x6b,
    0x65,
    0x72,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x43,
    0x6f,
    0x6d,
    0x70,
    0x61,
    0x6e,
    0x79,
    0x2e,
    0x64,
    0x65,
    0x73,
    0x63,
    0x72,
    0x69,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x43,
    0x6f,
    0x6d,
    0x70,
    0x61,
    0x6e,
    0x79,
    0x2e,
    0x65,
    0x78,
    0x63,
    0x68,
    0x61,
    0x6e,
    0x67,
    0x65,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x43,
    0x6f,
    0x6d,
    0x70,
    0x61,
    0x6e,
    0x79,
    0x2e,
    0x63,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x72,
    0x79,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x64,
    0x65,
    0x73,
    0x63,
    0x72,
    0x69,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x74,
    0x61,
    0x72,
    0x67,
    0x65,
    0x74,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xd3,
    0xb3,
    0xa8,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FlashSkipIntroData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 5768904 

  _TypeId_NAMES = {
    5768904: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.skip_intro_url_ = ""
    self.has_skip_intro_url_ = 0
    if contents is not None: self.MergeFromString(contents)

  def skip_intro_url(self): return self.skip_intro_url_

  def set_skip_intro_url(self, x):
    self.has_skip_intro_url_ = 1
    self.skip_intro_url_ = x

  def clear_skip_intro_url(self):
    self.has_skip_intro_url_ = 0
    self.skip_intro_url_ = ""

  def has_skip_intro_url(self): return self.has_skip_intro_url_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_skip_intro_url()): self.set_skip_intro_url(x.skip_intro_url())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'FlashSkipIntroData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'FlashSkipIntroData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'FlashSkipIntroData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'FlashSkipIntroData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'FlashSkipIntroData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_skip_intro_url_ != x.has_skip_intro_url_: return 0
    if self.has_skip_intro_url_ and self.skip_intro_url_ != x.skip_intro_url_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_skip_intro_url_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: skip_intro_url not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.skip_intro_url_))
    return n + 1

  def Clear(self):
    self.clear_skip_intro_url()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.skip_intro_url_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_skip_intro_url(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_skip_intro_url_: res+=prefix+("skip_intro_url: %s\n" % self.DebugFormatString(self.skip_intro_url_))
    return res

  kskip_intro_url = 1

  _TEXT = (
   "ErrorCode",  #   0
   "skip_intro_url",  #   1
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x12,
    0x46,
    0x6c,
    0x61,
    0x73,
    0x68,
    0x53,
    0x6b,
    0x69,
    0x70,
    0x49,
    0x6e,
    0x74,
    0x72,
    0x6f,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x0e,
    0x73,
    0x6b,
    0x69,
    0x70,
    0x5f,
    0x69,
    0x6e,
    0x74,
    0x72,
    0x6f,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xc8,
    0x8d,
    0xe0,
    0x02,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class SiteSearchBoxData(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 6228996 

  _TypeId_NAMES = {
    6228996: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.site_restrict_ = ""
    self.target_url_ = ""
    self.has_site_restrict_ = 0
    self.has_target_url_ = 0
    if contents is not None: self.MergeFromString(contents)

  def site_restrict(self): return self.site_restrict_

  def set_site_restrict(self, x):
    self.has_site_restrict_ = 1
    self.site_restrict_ = x

  def clear_site_restrict(self):
    self.has_site_restrict_ = 0
    self.site_restrict_ = ""

  def has_site_restrict(self): return self.has_site_restrict_

  def target_url(self): return self.target_url_

  def set_target_url(self, x):
    self.has_target_url_ = 1
    self.target_url_ = x

  def clear_target_url(self):
    self.has_target_url_ = 0
    self.target_url_ = ""

  def has_target_url(self): return self.has_target_url_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_site_restrict()): self.set_site_restrict(x.site_restrict())
    if (x.has_target_url()): self.set_target_url(x.target_url())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'SiteSearchBoxData', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'SiteSearchBoxData')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'SiteSearchBoxData', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'SiteSearchBoxData', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'SiteSearchBoxData', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_site_restrict_ != x.has_site_restrict_: return 0
    if self.has_site_restrict_ and self.site_restrict_ != x.site_restrict_: return 0
    if self.has_target_url_ != x.has_target_url_: return 0
    if self.has_target_url_ and self.target_url_ != x.target_url_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_site_restrict_): n += 1 + self.lengthString(len(self.site_restrict_))
    if (self.has_target_url_): n += 1 + self.lengthString(len(self.target_url_))
    return n + 0

  def Clear(self):
    self.clear_site_restrict()
    self.clear_target_url()

  def OutputUnchecked(self, out):
    if (self.has_site_restrict_):
      out.putVarInt32(10)
      out.putPrefixedString(self.site_restrict_)
    if (self.has_target_url_):
      out.putVarInt32(18)
      out.putPrefixedString(self.target_url_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_site_restrict(d.getPrefixedString())
        continue
      if tt == 18:
        self.set_target_url(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_site_restrict_: res+=prefix+("site_restrict: %s\n" % self.DebugFormatString(self.site_restrict_))
    if self.has_target_url_: res+=prefix+("target_url: %s\n" % self.DebugFormatString(self.target_url_))
    return res

  ksite_restrict = 1
  ktarget_url = 2

  _TEXT = (
   "ErrorCode",  #   0
   "site_restrict",  #   1
   "target_url",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x23,
    0x71,
    0x75,
    0x61,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x2f,
    0x6d,
    0x61,
    0x6e,
    0x79,
    0x62,
    0x6f,
    0x78,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x11,
    0x53,
    0x69,
    0x74,
    0x65,
    0x53,
    0x65,
    0x61,
    0x72,
    0x63,
    0x68,
    0x42,
    0x6f,
    0x78,
    0x44,
    0x61,
    0x74,
    0x61,
    0x13,
    0x1a,
    0x0d,
    0x73,
    0x69,
    0x74,
    0x65,
    0x5f,
    0x72,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x74,
    0x61,
    0x72,
    0x67,
    0x65,
    0x74,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0x84,
    0x98,
    0xfc,
    0x02,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['ManyboxData','RelatedLinkData','RelatedLinkData_Link','InlinkData','InlinkData_Source','GoogleBaseData','CompactDaffieObject','CompactDaffieObject_Fact','DaffieObjectsData','DisplayableImage','LocalInfoData','LocalInfoData_LocalInfo','ScholarData','ScholarData_DocInfoAuthor','ScholarData_DocInfoExcerpt','ScholarData_DocInfo','FinanceData','FinanceData_Company','FlashSkipIntroData','SiteSearchBoxData']
