# This file automatically generated by protocol-compiler from weboftrust/prose/rpc/data.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

from google3.net.proto.message_set import MessageSet
from google3.kansas.rpc.client_pb import UserKeyProto
class WotReplyStatus(ProtocolBuffer.ProtocolMessage):

  OK           =    0 
  INVALID_USER =    1 
  INVALID_APPLICATION =    2 
  USER_NOT_PREPARED =    3 
  INVALID_TRUST_LEVEL =    4 
  UNKNOWN_DATATYPE =    5 
  KANSAS_ERROR =    6 
  RPC_ERROR    =    7 
  ERROR        =    9 
  INVALID_REQUEST =   10 

  _ReplyStatus_NAMES = {
    0: "OK",
    1: "INVALID_USER",
    2: "INVALID_APPLICATION",
    3: "USER_NOT_PREPARED",
    4: "INVALID_TRUST_LEVEL",
    5: "UNKNOWN_DATATYPE",
    6: "KANSAS_ERROR",
    7: "RPC_ERROR",
    9: "ERROR",
    10: "INVALID_REQUEST",
  }

  def ReplyStatus_Name(cls, x): return cls._ReplyStatus_NAMES.get(x, "")
  ReplyStatus_Name = classmethod(ReplyStatus_Name)

  def __init__(self, contents=None):
    pass
    if contents is not None: self.MergeFromString(contents)


  def MergeFrom(self, x):
    assert x is not self

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.WotReplyStatus', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.WotReplyStatus')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.WotReplyStatus', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.WotReplyStatus', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.WotReplyStatus', s)


  def Equals(self, x):
    if x is self: return 1
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    return n + 0

  def Clear(self):
    pass

  def OutputUnchecked(self, out):
    pass

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    return res


  _TEXT = (
   "ErrorCode",  #   0
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x1f,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x19,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x57,
    0x6f,
    0x74,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x73,
    0x7a,
    0x0b,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x02,
    0x4f,
    0x4b,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x49,
    0x4e,
    0x56,
    0x41,
    0x4c,
    0x49,
    0x44,
    0x5f,
    0x55,
    0x53,
    0x45,
    0x52,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x13,
    0x49,
    0x4e,
    0x56,
    0x41,
    0x4c,
    0x49,
    0x44,
    0x5f,
    0x41,
    0x50,
    0x50,
    0x4c,
    0x49,
    0x43,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x55,
    0x53,
    0x45,
    0x52,
    0x5f,
    0x4e,
    0x4f,
    0x54,
    0x5f,
    0x50,
    0x52,
    0x45,
    0x50,
    0x41,
    0x52,
    0x45,
    0x44,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x13,
    0x49,
    0x4e,
    0x56,
    0x41,
    0x4c,
    0x49,
    0x44,
    0x5f,
    0x54,
    0x52,
    0x55,
    0x53,
    0x54,
    0x5f,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x55,
    0x4e,
    0x4b,
    0x4e,
    0x4f,
    0x57,
    0x4e,
    0x5f,
    0x44,
    0x41,
    0x54,
    0x41,
    0x54,
    0x59,
    0x50,
    0x45,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x4b,
    0x41,
    0x4e,
    0x53,
    0x41,
    0x53,
    0x5f,
    0x45,
    0x52,
    0x52,
    0x4f,
    0x52,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x52,
    0x50,
    0x43,
    0x5f,
    0x45,
    0x52,
    0x52,
    0x4f,
    0x52,
    0x98,
    0x01,
    0x07,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x05,
    0x45,
    0x52,
    0x52,
    0x4f,
    0x52,
    0x98,
    0x01,
    0x09,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x49,
    0x4e,
    0x56,
    0x41,
    0x4c,
    0x49,
    0x44,
    0x5f,
    0x52,
    0x45,
    0x51,
    0x55,
    0x45,
    0x53,
    0x54,
    0x98,
    0x01,
    0x0a,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class AttributeValue(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.attribute_ = ""
    self.value_ = ""
    self.has_attribute_ = 0
    self.has_value_ = 0
    if contents is not None: self.MergeFromString(contents)

  def attribute(self): return self.attribute_

  def set_attribute(self, x):
    self.has_attribute_ = 1
    self.attribute_ = x

  def clear_attribute(self):
    self.has_attribute_ = 0
    self.attribute_ = ""

  def has_attribute(self): return self.has_attribute_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_attribute()): self.set_attribute(x.attribute())
    if (x.has_value()): self.set_value(x.value())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.AttributeValue', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.AttributeValue')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.AttributeValue', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.AttributeValue', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.AttributeValue', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_attribute_ != x.has_attribute_: return 0
    if self.has_attribute_ and self.attribute_ != x.attribute_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_attribute_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: attribute not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.attribute_))
    n += self.lengthString(len(self.value_))
    return n + 2

  def Clear(self):
    self.clear_attribute()
    self.clear_value()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.attribute_)
    out.putVarInt32(18)
    out.putPrefixedString(self.value_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_attribute(d.getPrefixedString())
        continue
      if tt == 18:
        self.set_value(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_attribute_: res+=prefix+("Attribute: %s\n" % self.DebugFormatString(self.attribute_))
    if self.has_value_: res+=prefix+("Value: %s\n" % self.DebugFormatString(self.value_))
    return res

  kAttribute = 1
  kValue = 2

  _TEXT = (
   "ErrorCode",  #   0
   "Attribute",  #   1
   "Value",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x1f,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x19,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x13,
    0x1a,
    0x09,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class WotApplication(ProtocolBuffer.ProtocolMessage):

  UNITTEST     =    1 
  GROUPS       =    2 
  LABELS       =    3 
  SITEMAPS     =    4 
  ONEBOX       =    5 
  VIDEO        =    6 
  BASE         =    7 
  LABELS_CSE   =    8 

  _Application_NAMES = {
    1: "UNITTEST",
    2: "GROUPS",
    3: "LABELS",
    4: "SITEMAPS",
    5: "ONEBOX",
    6: "VIDEO",
    7: "BASE",
    8: "LABELS_CSE",
  }

  def Application_Name(cls, x): return cls._Application_NAMES.get(x, "")
  Application_Name = classmethod(Application_Name)

  def __init__(self, contents=None):
    pass
    if contents is not None: self.MergeFromString(contents)


  def MergeFrom(self, x):
    assert x is not self

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.WotApplication', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.WotApplication')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.WotApplication', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.WotApplication', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.WotApplication', s)


  def Equals(self, x):
    if x is self: return 1
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    return n + 0

  def Clear(self):
    pass

  def OutputUnchecked(self, out):
    pass

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    return res


  _TEXT = (
   "ErrorCode",  #   0
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x1f,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x19,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x57,
    0x6f,
    0x74,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x7a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x55,
    0x4e,
    0x49,
    0x54,
    0x54,
    0x45,
    0x53,
    0x54,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x06,
    0x47,
    0x52,
    0x4f,
    0x55,
    0x50,
    0x53,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x06,
    0x4c,
    0x41,
    0x42,
    0x45,
    0x4c,
    0x53,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x53,
    0x49,
    0x54,
    0x45,
    0x4d,
    0x41,
    0x50,
    0x53,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x06,
    0x4f,
    0x4e,
    0x45,
    0x42,
    0x4f,
    0x58,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x05,
    0x56,
    0x49,
    0x44,
    0x45,
    0x4f,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x04,
    0x42,
    0x41,
    0x53,
    0x45,
    0x98,
    0x01,
    0x07,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x4c,
    0x41,
    0x42,
    0x45,
    0x4c,
    0x53,
    0x5f,
    0x43,
    0x53,
    0x45,
    0x98,
    0x01,
    0x08,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class AnnotationProto(ProtocolBuffer.ProtocolMessage):

  OTHER        =    1 
  BOOKMARK     =    2 
  LABEL        =    3 
  DESCRIPTION  =    4 
  SEARCH_MOVE_TO_TOP =    5 
  INFERRED     =    6 
  ONEBOX_FEED  =    7 
  ONEBOX_FEED_STATUS =    8 
  CSE_FEED     =    9 

  _AnnotationType_NAMES = {
    1: "OTHER",
    2: "BOOKMARK",
    3: "LABEL",
    4: "DESCRIPTION",
    5: "SEARCH_MOVE_TO_TOP",
    6: "INFERRED",
    7: "ONEBOX_FEED",
    8: "ONEBOX_FEED_STATUS",
    9: "CSE_FEED",
  }

  def AnnotationType_Name(cls, x): return cls._AnnotationType_NAMES.get(x, "")
  AnnotationType_Name = classmethod(AnnotationType_Name)

  def __init__(self, contents=None):
    self.type_ = 0
    self.url_ = ""
    self.associatedurl_ = []
    self.rating_ = 0.0
    self.title_ = ""
    self.description_ = ""
    self.label_ = []
    self.application_ = 0
    self.exacturlmatch_ = 1
    self.query_ = []
    self.author_ = None
    self.provider_ = None
    self.attributevalues_ = []
    self.attributes_ = None
    self.timestamp_ = 0
    self.donotsetkansastimestamp_ = 0
    self.docid_ = 0
    self.annotationnamespace_ = ""
    self.remotehost_ = 0
    self.has_type_ = 0
    self.has_url_ = 0
    self.has_rating_ = 0
    self.has_title_ = 0
    self.has_description_ = 0
    self.has_application_ = 0
    self.has_exacturlmatch_ = 0
    self.has_author_ = 0
    self.has_provider_ = 0
    self.has_attributes_ = 0
    self.has_timestamp_ = 0
    self.has_donotsetkansastimestamp_ = 0
    self.has_docid_ = 0
    self.has_annotationnamespace_ = 0
    self.has_remotehost_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = 0

  def has_type(self): return self.has_type_

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def associatedurl_size(self): return len(self.associatedurl_)
  def associatedurl_list(self): return self.associatedurl_

  def associatedurl(self, i):
    return self.associatedurl_[i]

  def set_associatedurl(self, i, x):
    self.associatedurl_[i] = x

  def add_associatedurl(self, x):
    self.associatedurl_.append(x)

  def clear_associatedurl(self):
    self.associatedurl_ = []

  def rating(self): return self.rating_

  def set_rating(self, x):
    self.has_rating_ = 1
    self.rating_ = x

  def clear_rating(self):
    self.has_rating_ = 0
    self.rating_ = 0.0

  def has_rating(self): return self.has_rating_

  def title(self): return self.title_

  def set_title(self, x):
    self.has_title_ = 1
    self.title_ = x

  def clear_title(self):
    self.has_title_ = 0
    self.title_ = ""

  def has_title(self): return self.has_title_

  def description(self): return self.description_

  def set_description(self, x):
    self.has_description_ = 1
    self.description_ = x

  def clear_description(self):
    self.has_description_ = 0
    self.description_ = ""

  def has_description(self): return self.has_description_

  def label_size(self): return len(self.label_)
  def label_list(self): return self.label_

  def label(self, i):
    return self.label_[i]

  def set_label(self, i, x):
    self.label_[i] = x

  def add_label(self, x):
    self.label_.append(x)

  def clear_label(self):
    self.label_ = []

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def exacturlmatch(self): return self.exacturlmatch_

  def set_exacturlmatch(self, x):
    self.has_exacturlmatch_ = 1
    self.exacturlmatch_ = x

  def clear_exacturlmatch(self):
    self.has_exacturlmatch_ = 0
    self.exacturlmatch_ = 1

  def has_exacturlmatch(self): return self.has_exacturlmatch_

  def query_size(self): return len(self.query_)
  def query_list(self): return self.query_

  def query(self, i):
    return self.query_[i]

  def set_query(self, i, x):
    self.query_[i] = x

  def add_query(self, x):
    self.query_.append(x)

  def clear_query(self):
    self.query_ = []

  def author(self):
    if self.author_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.author_ is None: self.author_ = UserKeyProto()
      finally:
        self.lazy_init_lock_.release()
    return self.author_

  def mutable_author(self): self.has_author_ = 1; return self.author()

  def clear_author(self):
    #Warning: this method does not acquire the lock.
    self.has_author_ = 0;
    if self.author_ is not None: self.author_.Clear()

  def has_author(self): return self.has_author_

  def provider(self):
    if self.provider_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.provider_ is None: self.provider_ = UserKeyProto()
      finally:
        self.lazy_init_lock_.release()
    return self.provider_

  def mutable_provider(self): self.has_provider_ = 1; return self.provider()

  def clear_provider(self):
    #Warning: this method does not acquire the lock.
    self.has_provider_ = 0;
    if self.provider_ is not None: self.provider_.Clear()

  def has_provider(self): return self.has_provider_

  def attributevalues_size(self): return len(self.attributevalues_)
  def attributevalues_list(self): return self.attributevalues_

  def attributevalues(self, i):
    return self.attributevalues_[i]

  def mutable_attributevalues(self, i):
    return self.attributevalues_[i]

  def add_attributevalues(self):
    x = AttributeValue()
    self.attributevalues_.append(x)
    return x

  def clear_attributevalues(self):
    self.attributevalues_ = []
  def attributes(self):
    if self.attributes_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.attributes_ is None: self.attributes_ = MessageSet()
      finally:
        self.lazy_init_lock_.release()
    return self.attributes_

  def mutable_attributes(self): self.has_attributes_ = 1; return self.attributes()

  def clear_attributes(self):
    #Warning: this method does not acquire the lock.
    self.has_attributes_ = 0;
    if self.attributes_ is not None: self.attributes_.Clear()

  def has_attributes(self): return self.has_attributes_

  def timestamp(self): return self.timestamp_

  def set_timestamp(self, x):
    self.has_timestamp_ = 1
    self.timestamp_ = x

  def clear_timestamp(self):
    self.has_timestamp_ = 0
    self.timestamp_ = 0

  def has_timestamp(self): return self.has_timestamp_

  def donotsetkansastimestamp(self): return self.donotsetkansastimestamp_

  def set_donotsetkansastimestamp(self, x):
    self.has_donotsetkansastimestamp_ = 1
    self.donotsetkansastimestamp_ = x

  def clear_donotsetkansastimestamp(self):
    self.has_donotsetkansastimestamp_ = 0
    self.donotsetkansastimestamp_ = 0

  def has_donotsetkansastimestamp(self): return self.has_donotsetkansastimestamp_

  def docid(self): return self.docid_

  def set_docid(self, x):
    self.has_docid_ = 1
    self.docid_ = x

  def clear_docid(self):
    self.has_docid_ = 0
    self.docid_ = 0

  def has_docid(self): return self.has_docid_

  def annotationnamespace(self): return self.annotationnamespace_

  def set_annotationnamespace(self, x):
    self.has_annotationnamespace_ = 1
    self.annotationnamespace_ = x

  def clear_annotationnamespace(self):
    self.has_annotationnamespace_ = 0
    self.annotationnamespace_ = ""

  def has_annotationnamespace(self): return self.has_annotationnamespace_

  def remotehost(self): return self.remotehost_

  def set_remotehost(self, x):
    self.has_remotehost_ = 1
    self.remotehost_ = x

  def clear_remotehost(self):
    self.has_remotehost_ = 0
    self.remotehost_ = 0

  def has_remotehost(self): return self.has_remotehost_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_url()): self.set_url(x.url())
    for i in xrange(x.associatedurl_size()): self.add_associatedurl(x.associatedurl(i))
    if (x.has_rating()): self.set_rating(x.rating())
    if (x.has_title()): self.set_title(x.title())
    if (x.has_description()): self.set_description(x.description())
    for i in xrange(x.label_size()): self.add_label(x.label(i))
    if (x.has_application()): self.set_application(x.application())
    if (x.has_exacturlmatch()): self.set_exacturlmatch(x.exacturlmatch())
    for i in xrange(x.query_size()): self.add_query(x.query(i))
    if (x.has_author()): self.mutable_author().MergeFrom(x.author())
    if (x.has_provider()): self.mutable_provider().MergeFrom(x.provider())
    for i in xrange(x.attributevalues_size()): self.add_attributevalues().CopyFrom(x.attributevalues(i))
    if (x.has_attributes()): self.mutable_attributes().MergeFrom(x.attributes())
    if (x.has_timestamp()): self.set_timestamp(x.timestamp())
    if (x.has_donotsetkansastimestamp()): self.set_donotsetkansastimestamp(x.donotsetkansastimestamp())
    if (x.has_docid()): self.set_docid(x.docid())
    if (x.has_annotationnamespace()): self.set_annotationnamespace(x.annotationnamespace())
    if (x.has_remotehost()): self.set_remotehost(x.remotehost())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.AnnotationProto', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.AnnotationProto')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.AnnotationProto', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.AnnotationProto', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.AnnotationProto', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if len(self.associatedurl_) != len(x.associatedurl_): return 0
    for e1, e2 in zip(self.associatedurl_, x.associatedurl_):
      if e1 != e2: return 0
    if self.has_rating_ != x.has_rating_: return 0
    if self.has_rating_ and self.rating_ != x.rating_: return 0
    if self.has_title_ != x.has_title_: return 0
    if self.has_title_ and self.title_ != x.title_: return 0
    if self.has_description_ != x.has_description_: return 0
    if self.has_description_ and self.description_ != x.description_: return 0
    if len(self.label_) != len(x.label_): return 0
    for e1, e2 in zip(self.label_, x.label_):
      if e1 != e2: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_exacturlmatch_ != x.has_exacturlmatch_: return 0
    if self.has_exacturlmatch_ and self.exacturlmatch_ != x.exacturlmatch_: return 0
    if len(self.query_) != len(x.query_): return 0
    for e1, e2 in zip(self.query_, x.query_):
      if e1 != e2: return 0
    if self.has_author_ != x.has_author_: return 0
    if self.has_author_ and self.author_ != x.author_: return 0
    if self.has_provider_ != x.has_provider_: return 0
    if self.has_provider_ and self.provider_ != x.provider_: return 0
    if len(self.attributevalues_) != len(x.attributevalues_): return 0
    for e1, e2 in zip(self.attributevalues_, x.attributevalues_):
      if e1 != e2: return 0
    if self.has_attributes_ != x.has_attributes_: return 0
    if self.has_attributes_ and self.attributes_ != x.attributes_: return 0
    if self.has_timestamp_ != x.has_timestamp_: return 0
    if self.has_timestamp_ and self.timestamp_ != x.timestamp_: return 0
    if self.has_donotsetkansastimestamp_ != x.has_donotsetkansastimestamp_: return 0
    if self.has_donotsetkansastimestamp_ and self.donotsetkansastimestamp_ != x.donotsetkansastimestamp_: return 0
    if self.has_docid_ != x.has_docid_: return 0
    if self.has_docid_ and self.docid_ != x.docid_: return 0
    if self.has_annotationnamespace_ != x.has_annotationnamespace_: return 0
    if self.has_annotationnamespace_ and self.annotationnamespace_ != x.annotationnamespace_: return 0
    if self.has_remotehost_ != x.has_remotehost_: return 0
    if self.has_remotehost_ and self.remotehost_ != x.remotehost_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (not self.has_url_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: url not set.')
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    if (self.has_author_ and not self.author_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_provider_ and not self.provider_.IsInitialized(debug_strs)): initialized = 0
    for i in xrange(len(self.attributevalues_)):
      if (not self.attributevalues_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_attributes_ and not self.attributes_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.type_)
    n += self.lengthString(len(self.url_))
    n += 2 * len(self.associatedurl_)
    for i in xrange(len(self.associatedurl_)): n += self.lengthString(len(self.associatedurl_[i]))
    if (self.has_rating_): n += 5
    if (self.has_title_): n += 1 + self.lengthString(len(self.title_))
    if (self.has_description_): n += 1 + self.lengthString(len(self.description_))
    n += 1 * len(self.label_)
    for i in xrange(len(self.label_)): n += self.lengthString(len(self.label_[i]))
    n += self.lengthVarInt64(self.application_)
    if (self.has_exacturlmatch_): n += 2
    n += 1 * len(self.query_)
    for i in xrange(len(self.query_)): n += self.lengthString(len(self.query_[i]))
    if (self.has_author_): n += 1 + self.lengthString(self.author_.ByteSize())
    if (self.has_provider_): n += 1 + self.lengthString(self.provider_.ByteSize())
    n += 2 * len(self.attributevalues_)
    for i in xrange(len(self.attributevalues_)): n += self.lengthString(self.attributevalues_[i].ByteSize())
    if (self.has_attributes_): n += 2 + self.lengthString(self.attributes_.ByteSize())
    if (self.has_timestamp_): n += 2 + self.lengthVarInt64(self.timestamp_)
    if (self.has_donotsetkansastimestamp_): n += 2 + self.lengthVarInt64(self.donotsetkansastimestamp_)
    if (self.has_docid_): n += 2 + self.lengthVarInt64(self.docid_)
    if (self.has_annotationnamespace_): n += 2 + self.lengthString(len(self.annotationnamespace_))
    if (self.has_remotehost_): n += 2 + self.lengthVarInt64(self.remotehost_)
    return n + 3

  def Clear(self):
    self.clear_type()
    self.clear_url()
    self.clear_associatedurl()
    self.clear_rating()
    self.clear_title()
    self.clear_description()
    self.clear_label()
    self.clear_application()
    self.clear_exacturlmatch()
    self.clear_query()
    self.clear_author()
    self.clear_provider()
    self.clear_attributevalues()
    self.clear_attributes()
    self.clear_timestamp()
    self.clear_donotsetkansastimestamp()
    self.clear_docid()
    self.clear_annotationnamespace()
    self.clear_remotehost()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.type_)
    out.putVarInt32(18)
    out.putPrefixedString(self.url_)
    if (self.has_rating_):
      out.putVarInt32(29)
      out.putFloat(self.rating_)
    if (self.has_title_):
      out.putVarInt32(34)
      out.putPrefixedString(self.title_)
    if (self.has_description_):
      out.putVarInt32(42)
      out.putPrefixedString(self.description_)
    for i in xrange(len(self.label_)):
      out.putVarInt32(50)
      out.putPrefixedString(self.label_[i])
    out.putVarInt32(56)
    out.putVarInt32(self.application_)
    if (self.has_exacturlmatch_):
      out.putVarInt32(64)
      out.putBoolean(self.exacturlmatch_)
    for i in xrange(len(self.query_)):
      out.putVarInt32(74)
      out.putPrefixedString(self.query_[i])
    if (self.has_author_):
      out.putVarInt32(82)
      out.putVarInt32(self.author_.ByteSize())
      self.author_.OutputUnchecked(out)
    if (self.has_provider_):
      out.putVarInt32(90)
      out.putVarInt32(self.provider_.ByteSize())
      self.provider_.OutputUnchecked(out)
    if (self.has_timestamp_):
      out.putVarInt32(128)
      out.putVarInt64(self.timestamp_)
    for i in xrange(len(self.attributevalues_)):
      out.putVarInt32(138)
      out.putVarInt32(self.attributevalues_[i].ByteSize())
      self.attributevalues_[i].OutputUnchecked(out)
    if (self.has_docid_):
      out.putVarInt32(152)
      out.putVarInt64(self.docid_)
    for i in xrange(len(self.associatedurl_)):
      out.putVarInt32(162)
      out.putPrefixedString(self.associatedurl_[i])
    if (self.has_donotsetkansastimestamp_):
      out.putVarInt32(168)
      out.putVarInt64(self.donotsetkansastimestamp_)
    if (self.has_attributes_):
      out.putVarInt32(178)
      out.putVarInt32(self.attributes_.ByteSize())
      self.attributes_.OutputUnchecked(out)
    if (self.has_annotationnamespace_):
      out.putVarInt32(186)
      out.putPrefixedString(self.annotationnamespace_)
    if (self.has_remotehost_):
      out.putVarInt32(192)
      out.putVarInt32(self.remotehost_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_type(d.getVarInt32())
        continue
      if tt == 18:
        self.set_url(d.getPrefixedString())
        continue
      if tt == 29:
        self.set_rating(d.getFloat())
        continue
      if tt == 34:
        self.set_title(d.getPrefixedString())
        continue
      if tt == 42:
        self.set_description(d.getPrefixedString())
        continue
      if tt == 50:
        self.add_label(d.getPrefixedString())
        continue
      if tt == 56:
        self.set_application(d.getVarInt32())
        continue
      if tt == 64:
        self.set_exacturlmatch(d.getBoolean())
        continue
      if tt == 74:
        self.add_query(d.getPrefixedString())
        continue
      if tt == 82:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_author().TryMerge(tmp)
        continue
      if tt == 90:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_provider().TryMerge(tmp)
        continue
      if tt == 128:
        self.set_timestamp(d.getVarInt64())
        continue
      if tt == 138:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_attributevalues().TryMerge(tmp)
        continue
      if tt == 152:
        self.set_docid(d.getVarInt64())
        continue
      if tt == 162:
        self.add_associatedurl(d.getPrefixedString())
        continue
      if tt == 168:
        self.set_donotsetkansastimestamp(d.getVarInt64())
        continue
      if tt == 178:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_attributes().TryMerge(tmp)
        continue
      if tt == 186:
        self.set_annotationnamespace(d.getPrefixedString())
        continue
      if tt == 192:
        self.set_remotehost(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatInt32(self.type_))
    if self.has_url_: res+=prefix+("Url: %s\n" % self.DebugFormatString(self.url_))
    cnt=0
    for e in self.associatedurl_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("AssociatedUrl%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_rating_: res+=prefix+("Rating: %s\n" % self.DebugFormatFloat(self.rating_))
    if self.has_title_: res+=prefix+("Title: %s\n" % self.DebugFormatString(self.title_))
    if self.has_description_: res+=prefix+("Description: %s\n" % self.DebugFormatString(self.description_))
    cnt=0
    for e in self.label_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Label%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_exacturlmatch_: res+=prefix+("ExactUrlMatch: %s\n" % self.DebugFormatBool(self.exacturlmatch_))
    cnt=0
    for e in self.query_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Query%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_author_:
      res+=prefix+"Author <\n"
      res+=self.author_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_provider_:
      res+=prefix+"Provider <\n"
      res+=self.provider_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.attributevalues_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("AttributeValues%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_attributes_:
      res+=prefix+"Attributes <\n"
      res+=self.attributes_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_timestamp_: res+=prefix+("Timestamp: %s\n" % self.DebugFormatInt64(self.timestamp_))
    if self.has_donotsetkansastimestamp_: res+=prefix+("DoNotSetKansasTimestamp: %s\n" % self.DebugFormatInt64(self.donotsetkansastimestamp_))
    if self.has_docid_: res+=prefix+("Docid: %s\n" % self.DebugFormatInt64(self.docid_))
    if self.has_annotationnamespace_: res+=prefix+("AnnotationNamespace: %s\n" % self.DebugFormatString(self.annotationnamespace_))
    if self.has_remotehost_: res+=prefix+("RemoteHost: %s\n" % self.DebugFormatInt32(self.remotehost_))
    return res

  kType = 1
  kUrl = 2
  kAssociatedUrl = 20
  kRating = 3
  kTitle = 4
  kDescription = 5
  kLabel = 6
  kApplication = 7
  kExactUrlMatch = 8
  kQuery = 9
  kAuthor = 10
  kProvider = 11
  kAttributeValues = 17
  kAttributes = 22
  kTimestamp = 16
  kDoNotSetKansasTimestamp = 21
  kDocid = 19
  kAnnotationNamespace = 23
  kRemoteHost = 24

  _TEXT = (
   "ErrorCode",  #   0
   "Type",  #   1
   "Url",  #   2
   "Rating",  #   3
   "Title",  #   4
   "Description",  #   5
   "Label",  #   6
   "Application",  #   7
   "ExactUrlMatch",  #   8
   "Query",  #   9
   "Author",  #  10
   "Provider",  #  11
   None,  #  12
   None,  #  13
   None,  #  14
   None,  #  15
   "Timestamp",  #  16
   "AttributeValues",  #  17
   None,  #  18
   "Docid",  #  19
   "AssociatedUrl",  #  20
   "DoNotSetKansasTimestamp",  #  21
   "Attributes",  #  22
   "AnnotationNamespace",  #  23
   "RemoteHost",  #  24
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.FLOAT,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.STRING,  #  10

   ProtocolBuffer.Encoder.STRING,  #  11

   ProtocolBuffer.Encoder.MAX_TYPE,  #  12

   ProtocolBuffer.Encoder.MAX_TYPE,  #  13

   ProtocolBuffer.Encoder.MAX_TYPE,  #  14

   ProtocolBuffer.Encoder.MAX_TYPE,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

   ProtocolBuffer.Encoder.STRING,  #  17

   ProtocolBuffer.Encoder.MAX_TYPE,  #  18

   ProtocolBuffer.Encoder.NUMERIC,  #  19

   ProtocolBuffer.Encoder.STRING,  #  20

   ProtocolBuffer.Encoder.NUMERIC,  #  21

   ProtocolBuffer.Encoder.STRING,  #  22

   ProtocolBuffer.Encoder.STRING,  #  23

   ProtocolBuffer.Encoder.NUMERIC,  #  24

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x1f,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1a,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x13,
    0x1a,
    0x04,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x03,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x41,
    0x73,
    0x73,
    0x6f,
    0x63,
    0x69,
    0x61,
    0x74,
    0x65,
    0x64,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x14,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x52,
    0x61,
    0x74,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x03,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x54,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x44,
    0x65,
    0x73,
    0x63,
    0x72,
    0x69,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x45,
    0x78,
    0x61,
    0x63,
    0x74,
    0x55,
    0x72,
    0x6c,
    0x4d,
    0x61,
    0x74,
    0x63,
    0x68,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x51,
    0x75,
    0x65,
    0x72,
    0x79,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x41,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x20,
    0x0a,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x50,
    0x72,
    0x6f,
    0x76,
    0x69,
    0x64,
    0x65,
    0x72,
    0x20,
    0x0b,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x73,
    0x20,
    0x11,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x19,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x73,
    0x20,
    0x16,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0a,
    0x4d,
    0x65,
    0x73,
    0x73,
    0x61,
    0x67,
    0x65,
    0x53,
    0x65,
    0x74,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x44,
    0x6f,
    0x4e,
    0x6f,
    0x74,
    0x53,
    0x65,
    0x74,
    0x4b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x15,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x44,
    0x6f,
    0x63,
    0x69,
    0x64,
    0x20,
    0x13,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4e,
    0x61,
    0x6d,
    0x65,
    0x73,
    0x70,
    0x61,
    0x63,
    0x65,
    0x20,
    0x17,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x52,
    0x65,
    0x6d,
    0x6f,
    0x74,
    0x65,
    0x48,
    0x6f,
    0x73,
    0x74,
    0x20,
    0x18,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x0e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x05,
    0x4f,
    0x54,
    0x48,
    0x45,
    0x52,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x42,
    0x4f,
    0x4f,
    0x4b,
    0x4d,
    0x41,
    0x52,
    0x4b,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x05,
    0x4c,
    0x41,
    0x42,
    0x45,
    0x4c,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x44,
    0x45,
    0x53,
    0x43,
    0x52,
    0x49,
    0x50,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x53,
    0x45,
    0x41,
    0x52,
    0x43,
    0x48,
    0x5f,
    0x4d,
    0x4f,
    0x56,
    0x45,
    0x5f,
    0x54,
    0x4f,
    0x5f,
    0x54,
    0x4f,
    0x50,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x49,
    0x4e,
    0x46,
    0x45,
    0x52,
    0x52,
    0x45,
    0x44,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x4f,
    0x4e,
    0x45,
    0x42,
    0x4f,
    0x58,
    0x5f,
    0x46,
    0x45,
    0x45,
    0x44,
    0x98,
    0x01,
    0x07,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x4f,
    0x4e,
    0x45,
    0x42,
    0x4f,
    0x58,
    0x5f,
    0x46,
    0x45,
    0x45,
    0x44,
    0x5f,
    0x53,
    0x54,
    0x41,
    0x54,
    0x55,
    0x53,
    0x98,
    0x01,
    0x08,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x43,
    0x53,
    0x45,
    0x5f,
    0x46,
    0x45,
    0x45,
    0x44,
    0x98,
    0x01,
    0x09,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class TrustRelationProto(ProtocolBuffer.ProtocolMessage):

  OTHER        =    1 
  USER_STATED  =    2 
  GMAIL_CONTACT =    3 
  IM_CONTACT   =    4 
  ORKUT_FRIEND =    5 
  INFERRED     =    6 
  ENDORSED     =    7 
  CONTRIBUTOR  =    8 

  _TrustRelType_NAMES = {
    1: "OTHER",
    2: "USER_STATED",
    3: "GMAIL_CONTACT",
    4: "IM_CONTACT",
    5: "ORKUT_FRIEND",
    6: "INFERRED",
    7: "ENDORSED",
    8: "CONTRIBUTOR",
  }

  def TrustRelType_Name(cls, x): return cls._TrustRelType_NAMES.get(x, "")
  TrustRelType_Name = classmethod(TrustRelType_Name)

  def __init__(self, contents=None):
    self.type_ = 0
    self.trustee_ = UserKeyProto()
    self.truster_ = None
    self.userspecified_ = 1
    self.topic_ = ""
    self.label_ = ""
    self.strength_ = 0.0
    self.application_ = 0
    self.attributevalues_ = []
    self.attributes_ = None
    self.timestamp_ = 0
    self.donotsetkansastimestamp_ = 0
    self.has_type_ = 0
    self.has_trustee_ = 0
    self.has_truster_ = 0
    self.has_userspecified_ = 0
    self.has_topic_ = 0
    self.has_label_ = 0
    self.has_strength_ = 0
    self.has_application_ = 0
    self.has_attributes_ = 0
    self.has_timestamp_ = 0
    self.has_donotsetkansastimestamp_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = 0

  def has_type(self): return self.has_type_

  def trustee(self): return self.trustee_

  def mutable_trustee(self): self.has_trustee_ = 1; return self.trustee_

  def clear_trustee(self):self.has_trustee_ = 0; self.trustee_.Clear()

  def has_trustee(self): return self.has_trustee_

  def truster(self):
    if self.truster_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.truster_ is None: self.truster_ = UserKeyProto()
      finally:
        self.lazy_init_lock_.release()
    return self.truster_

  def mutable_truster(self): self.has_truster_ = 1; return self.truster()

  def clear_truster(self):
    #Warning: this method does not acquire the lock.
    self.has_truster_ = 0;
    if self.truster_ is not None: self.truster_.Clear()

  def has_truster(self): return self.has_truster_

  def userspecified(self): return self.userspecified_

  def set_userspecified(self, x):
    self.has_userspecified_ = 1
    self.userspecified_ = x

  def clear_userspecified(self):
    self.has_userspecified_ = 0
    self.userspecified_ = 1

  def has_userspecified(self): return self.has_userspecified_

  def topic(self): return self.topic_

  def set_topic(self, x):
    self.has_topic_ = 1
    self.topic_ = x

  def clear_topic(self):
    self.has_topic_ = 0
    self.topic_ = ""

  def has_topic(self): return self.has_topic_

  def label(self): return self.label_

  def set_label(self, x):
    self.has_label_ = 1
    self.label_ = x

  def clear_label(self):
    self.has_label_ = 0
    self.label_ = ""

  def has_label(self): return self.has_label_

  def strength(self): return self.strength_

  def set_strength(self, x):
    self.has_strength_ = 1
    self.strength_ = x

  def clear_strength(self):
    self.has_strength_ = 0
    self.strength_ = 0.0

  def has_strength(self): return self.has_strength_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def attributevalues_size(self): return len(self.attributevalues_)
  def attributevalues_list(self): return self.attributevalues_

  def attributevalues(self, i):
    return self.attributevalues_[i]

  def mutable_attributevalues(self, i):
    return self.attributevalues_[i]

  def add_attributevalues(self):
    x = AttributeValue()
    self.attributevalues_.append(x)
    return x

  def clear_attributevalues(self):
    self.attributevalues_ = []
  def attributes(self):
    if self.attributes_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.attributes_ is None: self.attributes_ = MessageSet()
      finally:
        self.lazy_init_lock_.release()
    return self.attributes_

  def mutable_attributes(self): self.has_attributes_ = 1; return self.attributes()

  def clear_attributes(self):
    #Warning: this method does not acquire the lock.
    self.has_attributes_ = 0;
    if self.attributes_ is not None: self.attributes_.Clear()

  def has_attributes(self): return self.has_attributes_

  def timestamp(self): return self.timestamp_

  def set_timestamp(self, x):
    self.has_timestamp_ = 1
    self.timestamp_ = x

  def clear_timestamp(self):
    self.has_timestamp_ = 0
    self.timestamp_ = 0

  def has_timestamp(self): return self.has_timestamp_

  def donotsetkansastimestamp(self): return self.donotsetkansastimestamp_

  def set_donotsetkansastimestamp(self, x):
    self.has_donotsetkansastimestamp_ = 1
    self.donotsetkansastimestamp_ = x

  def clear_donotsetkansastimestamp(self):
    self.has_donotsetkansastimestamp_ = 0
    self.donotsetkansastimestamp_ = 0

  def has_donotsetkansastimestamp(self): return self.has_donotsetkansastimestamp_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_trustee()): self.mutable_trustee().MergeFrom(x.trustee())
    if (x.has_truster()): self.mutable_truster().MergeFrom(x.truster())
    if (x.has_userspecified()): self.set_userspecified(x.userspecified())
    if (x.has_topic()): self.set_topic(x.topic())
    if (x.has_label()): self.set_label(x.label())
    if (x.has_strength()): self.set_strength(x.strength())
    if (x.has_application()): self.set_application(x.application())
    for i in xrange(x.attributevalues_size()): self.add_attributevalues().CopyFrom(x.attributevalues(i))
    if (x.has_attributes()): self.mutable_attributes().MergeFrom(x.attributes())
    if (x.has_timestamp()): self.set_timestamp(x.timestamp())
    if (x.has_donotsetkansastimestamp()): self.set_donotsetkansastimestamp(x.donotsetkansastimestamp())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.TrustRelationProto', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.TrustRelationProto')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.TrustRelationProto', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.TrustRelationProto', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.TrustRelationProto', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_trustee_ != x.has_trustee_: return 0
    if self.has_trustee_ and self.trustee_ != x.trustee_: return 0
    if self.has_truster_ != x.has_truster_: return 0
    if self.has_truster_ and self.truster_ != x.truster_: return 0
    if self.has_userspecified_ != x.has_userspecified_: return 0
    if self.has_userspecified_ and self.userspecified_ != x.userspecified_: return 0
    if self.has_topic_ != x.has_topic_: return 0
    if self.has_topic_ and self.topic_ != x.topic_: return 0
    if self.has_label_ != x.has_label_: return 0
    if self.has_label_ and self.label_ != x.label_: return 0
    if self.has_strength_ != x.has_strength_: return 0
    if self.has_strength_ and self.strength_ != x.strength_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if len(self.attributevalues_) != len(x.attributevalues_): return 0
    for e1, e2 in zip(self.attributevalues_, x.attributevalues_):
      if e1 != e2: return 0
    if self.has_attributes_ != x.has_attributes_: return 0
    if self.has_attributes_ and self.attributes_ != x.attributes_: return 0
    if self.has_timestamp_ != x.has_timestamp_: return 0
    if self.has_timestamp_ and self.timestamp_ != x.timestamp_: return 0
    if self.has_donotsetkansastimestamp_ != x.has_donotsetkansastimestamp_: return 0
    if self.has_donotsetkansastimestamp_ and self.donotsetkansastimestamp_ != x.donotsetkansastimestamp_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (not self.has_trustee_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: trustee not set.')
    elif not self.trustee_.IsInitialized(debug_strs): initialized = 0
    if (self.has_truster_ and not self.truster_.IsInitialized(debug_strs)): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    for i in xrange(len(self.attributevalues_)):
      if (not self.attributevalues_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_attributes_ and not self.attributes_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.type_)
    n += self.lengthString(self.trustee_.ByteSize())
    if (self.has_truster_): n += 1 + self.lengthString(self.truster_.ByteSize())
    if (self.has_userspecified_): n += 2
    if (self.has_topic_): n += 1 + self.lengthString(len(self.topic_))
    if (self.has_label_): n += 1 + self.lengthString(len(self.label_))
    if (self.has_strength_): n += 5
    n += self.lengthVarInt64(self.application_)
    n += 1 * len(self.attributevalues_)
    for i in xrange(len(self.attributevalues_)): n += self.lengthString(self.attributevalues_[i].ByteSize())
    if (self.has_attributes_): n += 2 + self.lengthString(self.attributes_.ByteSize())
    if (self.has_timestamp_): n += 2 + self.lengthVarInt64(self.timestamp_)
    if (self.has_donotsetkansastimestamp_): n += 2 + self.lengthVarInt64(self.donotsetkansastimestamp_)
    return n + 3

  def Clear(self):
    self.clear_type()
    self.clear_trustee()
    self.clear_truster()
    self.clear_userspecified()
    self.clear_topic()
    self.clear_label()
    self.clear_strength()
    self.clear_application()
    self.clear_attributevalues()
    self.clear_attributes()
    self.clear_timestamp()
    self.clear_donotsetkansastimestamp()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.type_)
    out.putVarInt32(18)
    out.putVarInt32(self.trustee_.ByteSize())
    self.trustee_.OutputUnchecked(out)
    if (self.has_truster_):
      out.putVarInt32(26)
      out.putVarInt32(self.truster_.ByteSize())
      self.truster_.OutputUnchecked(out)
    if (self.has_userspecified_):
      out.putVarInt32(32)
      out.putBoolean(self.userspecified_)
    if (self.has_topic_):
      out.putVarInt32(42)
      out.putPrefixedString(self.topic_)
    if (self.has_label_):
      out.putVarInt32(50)
      out.putPrefixedString(self.label_)
    if (self.has_strength_):
      out.putVarInt32(61)
      out.putFloat(self.strength_)
    out.putVarInt32(64)
    out.putVarInt32(self.application_)
    for i in xrange(len(self.attributevalues_)):
      out.putVarInt32(74)
      out.putVarInt32(self.attributevalues_[i].ByteSize())
      self.attributevalues_[i].OutputUnchecked(out)
    if (self.has_timestamp_):
      out.putVarInt32(128)
      out.putVarInt64(self.timestamp_)
    if (self.has_donotsetkansastimestamp_):
      out.putVarInt32(136)
      out.putVarInt64(self.donotsetkansastimestamp_)
    if (self.has_attributes_):
      out.putVarInt32(146)
      out.putVarInt32(self.attributes_.ByteSize())
      self.attributes_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_type(d.getVarInt32())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_trustee().TryMerge(tmp)
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_truster().TryMerge(tmp)
        continue
      if tt == 32:
        self.set_userspecified(d.getBoolean())
        continue
      if tt == 42:
        self.set_topic(d.getPrefixedString())
        continue
      if tt == 50:
        self.set_label(d.getPrefixedString())
        continue
      if tt == 61:
        self.set_strength(d.getFloat())
        continue
      if tt == 64:
        self.set_application(d.getVarInt32())
        continue
      if tt == 74:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_attributevalues().TryMerge(tmp)
        continue
      if tt == 128:
        self.set_timestamp(d.getVarInt64())
        continue
      if tt == 136:
        self.set_donotsetkansastimestamp(d.getVarInt64())
        continue
      if tt == 146:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_attributes().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatInt32(self.type_))
    if self.has_trustee_:
      res+=prefix+"Trustee <\n"
      res+=self.trustee_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_truster_:
      res+=prefix+"Truster <\n"
      res+=self.truster_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_userspecified_: res+=prefix+("UserSpecified: %s\n" % self.DebugFormatBool(self.userspecified_))
    if self.has_topic_: res+=prefix+("Topic: %s\n" % self.DebugFormatString(self.topic_))
    if self.has_label_: res+=prefix+("Label: %s\n" % self.DebugFormatString(self.label_))
    if self.has_strength_: res+=prefix+("Strength: %s\n" % self.DebugFormatFloat(self.strength_))
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    cnt=0
    for e in self.attributevalues_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("AttributeValues%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_attributes_:
      res+=prefix+"Attributes <\n"
      res+=self.attributes_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_timestamp_: res+=prefix+("Timestamp: %s\n" % self.DebugFormatInt64(self.timestamp_))
    if self.has_donotsetkansastimestamp_: res+=prefix+("DoNotSetKansasTimestamp: %s\n" % self.DebugFormatInt64(self.donotsetkansastimestamp_))
    return res

  kType = 1
  kTrustee = 2
  kTruster = 3
  kUserSpecified = 4
  kTopic = 5
  kLabel = 6
  kStrength = 7
  kApplication = 8
  kAttributeValues = 9
  kAttributes = 18
  kTimestamp = 16
  kDoNotSetKansasTimestamp = 17

  _TEXT = (
   "ErrorCode",  #   0
   "Type",  #   1
   "Trustee",  #   2
   "Truster",  #   3
   "UserSpecified",  #   4
   "Topic",  #   5
   "Label",  #   6
   "Strength",  #   7
   "Application",  #   8
   "AttributeValues",  #   9
   None,  #  10
   None,  #  11
   None,  #  12
   None,  #  13
   None,  #  14
   None,  #  15
   "Timestamp",  #  16
   "DoNotSetKansasTimestamp",  #  17
   "Attributes",  #  18
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.FLOAT,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.MAX_TYPE,  #  10

   ProtocolBuffer.Encoder.MAX_TYPE,  #  11

   ProtocolBuffer.Encoder.MAX_TYPE,  #  12

   ProtocolBuffer.Encoder.MAX_TYPE,  #  13

   ProtocolBuffer.Encoder.MAX_TYPE,  #  14

   ProtocolBuffer.Encoder.MAX_TYPE,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

   ProtocolBuffer.Encoder.NUMERIC,  #  17

   ProtocolBuffer.Encoder.STRING,  #  18

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x1f,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1d,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x13,
    0x1a,
    0x04,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x65,
    0x65,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x55,
    0x73,
    0x65,
    0x72,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x65,
    0x64,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x54,
    0x6f,
    0x70,
    0x69,
    0x63,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x42,
    0x00,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x22,
    0x22,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x42,
    0x00,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x22,
    0x22,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x53,
    0x74,
    0x72,
    0x65,
    0x6e,
    0x67,
    0x74,
    0x68,
    0x20,
    0x07,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x73,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x19,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x73,
    0x20,
    0x12,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0a,
    0x4d,
    0x65,
    0x73,
    0x73,
    0x61,
    0x67,
    0x65,
    0x53,
    0x65,
    0x74,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x44,
    0x6f,
    0x4e,
    0x6f,
    0x74,
    0x53,
    0x65,
    0x74,
    0x4b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x11,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x0c,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x05,
    0x4f,
    0x54,
    0x48,
    0x45,
    0x52,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x55,
    0x53,
    0x45,
    0x52,
    0x5f,
    0x53,
    0x54,
    0x41,
    0x54,
    0x45,
    0x44,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x47,
    0x4d,
    0x41,
    0x49,
    0x4c,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x54,
    0x41,
    0x43,
    0x54,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x49,
    0x4d,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x54,
    0x41,
    0x43,
    0x54,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0c,
    0x4f,
    0x52,
    0x4b,
    0x55,
    0x54,
    0x5f,
    0x46,
    0x52,
    0x49,
    0x45,
    0x4e,
    0x44,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x49,
    0x4e,
    0x46,
    0x45,
    0x52,
    0x52,
    0x45,
    0x44,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x45,
    0x4e,
    0x44,
    0x4f,
    0x52,
    0x53,
    0x45,
    0x44,
    0x98,
    0x01,
    0x07,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x43,
    0x4f,
    0x4e,
    0x54,
    0x52,
    0x49,
    0x42,
    0x55,
    0x54,
    0x4f,
    0x52,
    0x98,
    0x01,
    0x08,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['WotReplyStatus','AttributeValue','WotApplication','AnnotationProto','TrustRelationProto']
