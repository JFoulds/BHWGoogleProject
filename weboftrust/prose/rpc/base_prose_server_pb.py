# This file automatically generated by protocol-compiler from weboftrust/prose/rpc/base-prose-server.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

from google3.kansas.rpc.client_pb import UserKeyProto
from google3.weboftrust.prose.rpc.data_pb import AnnotationProto
from google3.weboftrust.prose.rpc.data_pb import TrustRelationProto
from google3.weboftrust.prose.rpc.data_pb import AttributeValue
class AddAnnotationRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.application_ = 0
    self.annotation_ = AnnotationProto()
    self.timestamp_ = 0
    self.writetokansas_ = 1
    self.has_user_ = 0
    self.has_application_ = 0
    self.has_annotation_ = 0
    self.has_timestamp_ = 0
    self.has_writetokansas_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def annotation(self): return self.annotation_

  def mutable_annotation(self): self.has_annotation_ = 1; return self.annotation_

  def clear_annotation(self):self.has_annotation_ = 0; self.annotation_.Clear()

  def has_annotation(self): return self.has_annotation_

  def timestamp(self): return self.timestamp_

  def set_timestamp(self, x):
    self.has_timestamp_ = 1
    self.timestamp_ = x

  def clear_timestamp(self):
    self.has_timestamp_ = 0
    self.timestamp_ = 0

  def has_timestamp(self): return self.has_timestamp_

  def writetokansas(self): return self.writetokansas_

  def set_writetokansas(self, x):
    self.has_writetokansas_ = 1
    self.writetokansas_ = x

  def clear_writetokansas(self):
    self.has_writetokansas_ = 0
    self.writetokansas_ = 1

  def has_writetokansas(self): return self.has_writetokansas_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_application()): self.set_application(x.application())
    if (x.has_annotation()): self.mutable_annotation().MergeFrom(x.annotation())
    if (x.has_timestamp()): self.set_timestamp(x.timestamp())
    if (x.has_writetokansas()): self.set_writetokansas(x.writetokansas())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.AddAnnotationRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.AddAnnotationRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.AddAnnotationRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.AddAnnotationRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.AddAnnotationRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_annotation_ != x.has_annotation_: return 0
    if self.has_annotation_ and self.annotation_ != x.annotation_: return 0
    if self.has_timestamp_ != x.has_timestamp_: return 0
    if self.has_timestamp_ and self.timestamp_ != x.timestamp_: return 0
    if self.has_writetokansas_ != x.has_writetokansas_: return 0
    if self.has_writetokansas_ and self.writetokansas_ != x.writetokansas_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    if (not self.has_annotation_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: annotation not set.')
    elif not self.annotation_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += self.lengthVarInt64(self.application_)
    n += self.lengthString(self.annotation_.ByteSize())
    if (self.has_timestamp_): n += 1 + self.lengthVarInt64(self.timestamp_)
    if (self.has_writetokansas_): n += 2
    return n + 3

  def Clear(self):
    self.clear_user()
    self.clear_application()
    self.clear_annotation()
    self.clear_timestamp()
    self.clear_writetokansas()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)
    out.putVarInt32(26)
    out.putVarInt32(self.annotation_.ByteSize())
    self.annotation_.OutputUnchecked(out)
    if (self.has_timestamp_):
      out.putVarInt32(32)
      out.putVarUint64(self.timestamp_)
    if (self.has_writetokansas_):
      out.putVarInt32(80)
      out.putBoolean(self.writetokansas_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_annotation().TryMerge(tmp)
        continue
      if tt == 32:
        self.set_timestamp(d.getVarUint64())
        continue
      if tt == 80:
        self.set_writetokansas(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_annotation_:
      res+=prefix+"Annotation <\n"
      res+=self.annotation_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_timestamp_: res+=prefix+("Timestamp: %s\n" % self.DebugFormatInt64(self.timestamp_))
    if self.has_writetokansas_: res+=prefix+("WriteToKansas: %s\n" % self.DebugFormatBool(self.writetokansas_))
    return res

  kUser = 1
  kApplication = 2
  kAnnotation = 3
  kTimestamp = 4
  kWriteToKansas = 10

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Application",  #   2
   "Annotation",  #   3
   "Timestamp",  #   4
   None,  #   5
   None,  #   6
   None,  #   7
   None,  #   8
   None,  #   9
   "WriteToKansas",  #  10
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.MAX_TYPE,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.MAX_TYPE,  #   8

   ProtocolBuffer.Encoder.MAX_TYPE,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1f,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x64,
    0x64,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x1a,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x57,
    0x72,
    0x69,
    0x74,
    0x65,
    0x54,
    0x6f,
    0x4b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class BatchAddAnnotationRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.application_ = 0
    self.annotations_ = []
    self.timestamp_ = 0
    self.writetokansas_ = 1
    self.has_user_ = 0
    self.has_application_ = 0
    self.has_timestamp_ = 0
    self.has_writetokansas_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def annotations_size(self): return len(self.annotations_)
  def annotations_list(self): return self.annotations_

  def annotations(self, i):
    return self.annotations_[i]

  def mutable_annotations(self, i):
    return self.annotations_[i]

  def add_annotations(self):
    x = AnnotationProto()
    self.annotations_.append(x)
    return x

  def clear_annotations(self):
    self.annotations_ = []
  def timestamp(self): return self.timestamp_

  def set_timestamp(self, x):
    self.has_timestamp_ = 1
    self.timestamp_ = x

  def clear_timestamp(self):
    self.has_timestamp_ = 0
    self.timestamp_ = 0

  def has_timestamp(self): return self.has_timestamp_

  def writetokansas(self): return self.writetokansas_

  def set_writetokansas(self, x):
    self.has_writetokansas_ = 1
    self.writetokansas_ = x

  def clear_writetokansas(self):
    self.has_writetokansas_ = 0
    self.writetokansas_ = 1

  def has_writetokansas(self): return self.has_writetokansas_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_application()): self.set_application(x.application())
    for i in xrange(x.annotations_size()): self.add_annotations().CopyFrom(x.annotations(i))
    if (x.has_timestamp()): self.set_timestamp(x.timestamp())
    if (x.has_writetokansas()): self.set_writetokansas(x.writetokansas())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.BatchAddAnnotationRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.BatchAddAnnotationRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.BatchAddAnnotationRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.BatchAddAnnotationRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.BatchAddAnnotationRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if len(self.annotations_) != len(x.annotations_): return 0
    for e1, e2 in zip(self.annotations_, x.annotations_):
      if e1 != e2: return 0
    if self.has_timestamp_ != x.has_timestamp_: return 0
    if self.has_timestamp_ and self.timestamp_ != x.timestamp_: return 0
    if self.has_writetokansas_ != x.has_writetokansas_: return 0
    if self.has_writetokansas_ and self.writetokansas_ != x.writetokansas_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    for i in xrange(len(self.annotations_)):
      if (not self.annotations_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += self.lengthVarInt64(self.application_)
    n += 1 * len(self.annotations_)
    for i in xrange(len(self.annotations_)): n += self.lengthString(self.annotations_[i].ByteSize())
    if (self.has_timestamp_): n += 1 + self.lengthVarInt64(self.timestamp_)
    if (self.has_writetokansas_): n += 2
    return n + 2

  def Clear(self):
    self.clear_user()
    self.clear_application()
    self.clear_annotations()
    self.clear_timestamp()
    self.clear_writetokansas()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)
    for i in xrange(len(self.annotations_)):
      out.putVarInt32(26)
      out.putVarInt32(self.annotations_[i].ByteSize())
      self.annotations_[i].OutputUnchecked(out)
    if (self.has_timestamp_):
      out.putVarInt32(32)
      out.putVarUint64(self.timestamp_)
    if (self.has_writetokansas_):
      out.putVarInt32(80)
      out.putBoolean(self.writetokansas_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_annotations().TryMerge(tmp)
        continue
      if tt == 32:
        self.set_timestamp(d.getVarUint64())
        continue
      if tt == 80:
        self.set_writetokansas(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    cnt=0
    for e in self.annotations_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Annotations%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_timestamp_: res+=prefix+("Timestamp: %s\n" % self.DebugFormatInt64(self.timestamp_))
    if self.has_writetokansas_: res+=prefix+("WriteToKansas: %s\n" % self.DebugFormatBool(self.writetokansas_))
    return res

  kUser = 1
  kApplication = 2
  kAnnotations = 3
  kTimestamp = 4
  kWriteToKansas = 10

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Application",  #   2
   "Annotations",  #   3
   "Timestamp",  #   4
   None,  #   5
   None,  #   6
   None,  #   7
   None,  #   8
   None,  #   9
   "WriteToKansas",  #  10
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.MAX_TYPE,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.MAX_TYPE,  #   8

   ProtocolBuffer.Encoder.MAX_TYPE,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x24,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x42,
    0x61,
    0x74,
    0x63,
    0x68,
    0x41,
    0x64,
    0x64,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x1a,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x57,
    0x72,
    0x69,
    0x74,
    0x65,
    0x54,
    0x6f,
    0x4b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class DeleteAnnotationsRequest_DeleteAnnotations(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.url_ = ""
    self.annotationtype_ = 0
    self.label_ = []
    self.query_ = []
    self.attributevaluepair_ = []
    self.mintimestamp_ = 0
    self.maxtimestamp_ = 0
    self.annotationnamespace_ = ""
    self.has_url_ = 0
    self.has_annotationtype_ = 0
    self.has_mintimestamp_ = 0
    self.has_maxtimestamp_ = 0
    self.has_annotationnamespace_ = 0
    if contents is not None: self.MergeFromString(contents)

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def annotationtype(self): return self.annotationtype_

  def set_annotationtype(self, x):
    self.has_annotationtype_ = 1
    self.annotationtype_ = x

  def clear_annotationtype(self):
    self.has_annotationtype_ = 0
    self.annotationtype_ = 0

  def has_annotationtype(self): return self.has_annotationtype_

  def label_size(self): return len(self.label_)
  def label_list(self): return self.label_

  def label(self, i):
    return self.label_[i]

  def set_label(self, i, x):
    self.label_[i] = x

  def add_label(self, x):
    self.label_.append(x)

  def clear_label(self):
    self.label_ = []

  def query_size(self): return len(self.query_)
  def query_list(self): return self.query_

  def query(self, i):
    return self.query_[i]

  def set_query(self, i, x):
    self.query_[i] = x

  def add_query(self, x):
    self.query_.append(x)

  def clear_query(self):
    self.query_ = []

  def attributevaluepair_size(self): return len(self.attributevaluepair_)
  def attributevaluepair_list(self): return self.attributevaluepair_

  def attributevaluepair(self, i):
    return self.attributevaluepair_[i]

  def mutable_attributevaluepair(self, i):
    return self.attributevaluepair_[i]

  def add_attributevaluepair(self):
    x = AttributeValue()
    self.attributevaluepair_.append(x)
    return x

  def clear_attributevaluepair(self):
    self.attributevaluepair_ = []
  def mintimestamp(self): return self.mintimestamp_

  def set_mintimestamp(self, x):
    self.has_mintimestamp_ = 1
    self.mintimestamp_ = x

  def clear_mintimestamp(self):
    self.has_mintimestamp_ = 0
    self.mintimestamp_ = 0

  def has_mintimestamp(self): return self.has_mintimestamp_

  def maxtimestamp(self): return self.maxtimestamp_

  def set_maxtimestamp(self, x):
    self.has_maxtimestamp_ = 1
    self.maxtimestamp_ = x

  def clear_maxtimestamp(self):
    self.has_maxtimestamp_ = 0
    self.maxtimestamp_ = 0

  def has_maxtimestamp(self): return self.has_maxtimestamp_

  def annotationnamespace(self): return self.annotationnamespace_

  def set_annotationnamespace(self, x):
    self.has_annotationnamespace_ = 1
    self.annotationnamespace_ = x

  def clear_annotationnamespace(self):
    self.has_annotationnamespace_ = 0
    self.annotationnamespace_ = ""

  def has_annotationnamespace(self): return self.has_annotationnamespace_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_url()): self.set_url(x.url())
    if (x.has_annotationtype()): self.set_annotationtype(x.annotationtype())
    for i in xrange(x.label_size()): self.add_label(x.label(i))
    for i in xrange(x.query_size()): self.add_query(x.query(i))
    for i in xrange(x.attributevaluepair_size()): self.add_attributevaluepair().CopyFrom(x.attributevaluepair(i))
    if (x.has_mintimestamp()): self.set_mintimestamp(x.mintimestamp())
    if (x.has_maxtimestamp()): self.set_maxtimestamp(x.maxtimestamp())
    if (x.has_annotationnamespace()): self.set_annotationnamespace(x.annotationnamespace())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.DeleteAnnotationsRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.DeleteAnnotationsRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.DeleteAnnotationsRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.DeleteAnnotationsRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.DeleteAnnotationsRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if self.has_annotationtype_ != x.has_annotationtype_: return 0
    if self.has_annotationtype_ and self.annotationtype_ != x.annotationtype_: return 0
    if len(self.label_) != len(x.label_): return 0
    for e1, e2 in zip(self.label_, x.label_):
      if e1 != e2: return 0
    if len(self.query_) != len(x.query_): return 0
    for e1, e2 in zip(self.query_, x.query_):
      if e1 != e2: return 0
    if len(self.attributevaluepair_) != len(x.attributevaluepair_): return 0
    for e1, e2 in zip(self.attributevaluepair_, x.attributevaluepair_):
      if e1 != e2: return 0
    if self.has_mintimestamp_ != x.has_mintimestamp_: return 0
    if self.has_mintimestamp_ and self.mintimestamp_ != x.mintimestamp_: return 0
    if self.has_maxtimestamp_ != x.has_maxtimestamp_: return 0
    if self.has_maxtimestamp_ and self.maxtimestamp_ != x.maxtimestamp_: return 0
    if self.has_annotationnamespace_ != x.has_annotationnamespace_: return 0
    if self.has_annotationnamespace_ and self.annotationnamespace_ != x.annotationnamespace_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.attributevaluepair_)):
      if (not self.attributevaluepair_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_url_): n += 1 + self.lengthString(len(self.url_))
    if (self.has_annotationtype_): n += 1 + self.lengthVarInt64(self.annotationtype_)
    n += 1 * len(self.label_)
    for i in xrange(len(self.label_)): n += self.lengthString(len(self.label_[i]))
    n += 1 * len(self.query_)
    for i in xrange(len(self.query_)): n += self.lengthString(len(self.query_[i]))
    n += 1 * len(self.attributevaluepair_)
    for i in xrange(len(self.attributevaluepair_)): n += self.lengthString(self.attributevaluepair_[i].ByteSize())
    if (self.has_mintimestamp_): n += 1 + self.lengthVarInt64(self.mintimestamp_)
    if (self.has_maxtimestamp_): n += 1 + self.lengthVarInt64(self.maxtimestamp_)
    if (self.has_annotationnamespace_): n += 1 + self.lengthString(len(self.annotationnamespace_))
    return n + 0

  def Clear(self):
    self.clear_url()
    self.clear_annotationtype()
    self.clear_label()
    self.clear_query()
    self.clear_attributevaluepair()
    self.clear_mintimestamp()
    self.clear_maxtimestamp()
    self.clear_annotationnamespace()

  def OutputUnchecked(self, out):
    if (self.has_url_):
      out.putVarInt32(42)
      out.putPrefixedString(self.url_)
    if (self.has_annotationtype_):
      out.putVarInt32(48)
      out.putVarInt32(self.annotationtype_)
    for i in xrange(len(self.label_)):
      out.putVarInt32(58)
      out.putPrefixedString(self.label_[i])
    for i in xrange(len(self.query_)):
      out.putVarInt32(66)
      out.putPrefixedString(self.query_[i])
    for i in xrange(len(self.attributevaluepair_)):
      out.putVarInt32(74)
      out.putVarInt32(self.attributevaluepair_[i].ByteSize())
      self.attributevaluepair_[i].OutputUnchecked(out)
    if (self.has_mintimestamp_):
      out.putVarInt32(88)
      out.putVarInt64(self.mintimestamp_)
    if (self.has_maxtimestamp_):
      out.putVarInt32(96)
      out.putVarInt64(self.maxtimestamp_)
    if (self.has_annotationnamespace_):
      out.putVarInt32(106)
      out.putPrefixedString(self.annotationnamespace_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 36: break
      if tt == 42:
        self.set_url(d.getPrefixedString())
        continue
      if tt == 48:
        self.set_annotationtype(d.getVarInt32())
        continue
      if tt == 58:
        self.add_label(d.getPrefixedString())
        continue
      if tt == 66:
        self.add_query(d.getPrefixedString())
        continue
      if tt == 74:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_attributevaluepair().TryMerge(tmp)
        continue
      if tt == 88:
        self.set_mintimestamp(d.getVarInt64())
        continue
      if tt == 96:
        self.set_maxtimestamp(d.getVarInt64())
        continue
      if tt == 106:
        self.set_annotationnamespace(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_url_: res+=prefix+("Url: %s\n" % self.DebugFormatString(self.url_))
    if self.has_annotationtype_: res+=prefix+("AnnotationType: %s\n" % self.DebugFormatInt32(self.annotationtype_))
    cnt=0
    for e in self.label_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Label%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    cnt=0
    for e in self.query_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Query%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    cnt=0
    for e in self.attributevaluepair_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("AttributeValuePair%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_mintimestamp_: res+=prefix+("MinTimestamp: %s\n" % self.DebugFormatInt64(self.mintimestamp_))
    if self.has_maxtimestamp_: res+=prefix+("MaxTimestamp: %s\n" % self.DebugFormatInt64(self.maxtimestamp_))
    if self.has_annotationnamespace_: res+=prefix+("AnnotationNamespace: %s\n" % self.DebugFormatString(self.annotationnamespace_))
    return res

class DeleteAnnotationsRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.application_ = 0
    self.deleteallannotations_ = 0
    self.deleteannotations_ = []
    self.shouldbroadcast_ = 0
    self.deleteinkansas_ = 1
    self.has_user_ = 0
    self.has_application_ = 0
    self.has_deleteallannotations_ = 0
    self.has_shouldbroadcast_ = 0
    self.has_deleteinkansas_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def deleteallannotations(self): return self.deleteallannotations_

  def set_deleteallannotations(self, x):
    self.has_deleteallannotations_ = 1
    self.deleteallannotations_ = x

  def clear_deleteallannotations(self):
    self.has_deleteallannotations_ = 0
    self.deleteallannotations_ = 0

  def has_deleteallannotations(self): return self.has_deleteallannotations_

  def deleteannotations_size(self): return len(self.deleteannotations_)
  def deleteannotations_list(self): return self.deleteannotations_

  def deleteannotations(self, i):
    return self.deleteannotations_[i]

  def mutable_deleteannotations(self, i):
    return self.deleteannotations_[i]

  def add_deleteannotations(self):
    x = DeleteAnnotationsRequest_DeleteAnnotations()
    self.deleteannotations_.append(x)
    return x

  def clear_deleteannotations(self):
    self.deleteannotations_ = []
  def shouldbroadcast(self): return self.shouldbroadcast_

  def set_shouldbroadcast(self, x):
    self.has_shouldbroadcast_ = 1
    self.shouldbroadcast_ = x

  def clear_shouldbroadcast(self):
    self.has_shouldbroadcast_ = 0
    self.shouldbroadcast_ = 0

  def has_shouldbroadcast(self): return self.has_shouldbroadcast_

  def deleteinkansas(self): return self.deleteinkansas_

  def set_deleteinkansas(self, x):
    self.has_deleteinkansas_ = 1
    self.deleteinkansas_ = x

  def clear_deleteinkansas(self):
    self.has_deleteinkansas_ = 0
    self.deleteinkansas_ = 1

  def has_deleteinkansas(self): return self.has_deleteinkansas_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_application()): self.set_application(x.application())
    if (x.has_deleteallannotations()): self.set_deleteallannotations(x.deleteallannotations())
    for i in xrange(x.deleteannotations_size()): self.add_deleteannotations().CopyFrom(x.deleteannotations(i))
    if (x.has_shouldbroadcast()): self.set_shouldbroadcast(x.shouldbroadcast())
    if (x.has_deleteinkansas()): self.set_deleteinkansas(x.deleteinkansas())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.DeleteAnnotationsRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.DeleteAnnotationsRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.DeleteAnnotationsRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.DeleteAnnotationsRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.DeleteAnnotationsRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_deleteallannotations_ != x.has_deleteallannotations_: return 0
    if self.has_deleteallannotations_ and self.deleteallannotations_ != x.deleteallannotations_: return 0
    if len(self.deleteannotations_) != len(x.deleteannotations_): return 0
    for e1, e2 in zip(self.deleteannotations_, x.deleteannotations_):
      if e1 != e2: return 0
    if self.has_shouldbroadcast_ != x.has_shouldbroadcast_: return 0
    if self.has_shouldbroadcast_ and self.shouldbroadcast_ != x.shouldbroadcast_: return 0
    if self.has_deleteinkansas_ != x.has_deleteinkansas_: return 0
    if self.has_deleteinkansas_ and self.deleteinkansas_ != x.deleteinkansas_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    for i in xrange(len(self.deleteannotations_)):
      if (not self.deleteannotations_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += self.lengthVarInt64(self.application_)
    if (self.has_deleteallannotations_): n += 2
    n += 2 * len(self.deleteannotations_)
    for i in xrange(len(self.deleteannotations_)): n += self.deleteannotations_[i].ByteSize()
    if (self.has_shouldbroadcast_): n += 2
    if (self.has_deleteinkansas_): n += 2
    return n + 2

  def Clear(self):
    self.clear_user()
    self.clear_application()
    self.clear_deleteallannotations()
    self.clear_deleteannotations()
    self.clear_shouldbroadcast()
    self.clear_deleteinkansas()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)
    if (self.has_deleteallannotations_):
      out.putVarInt32(24)
      out.putBoolean(self.deleteallannotations_)
    for i in xrange(len(self.deleteannotations_)):
      out.putVarInt32(35)
      self.deleteannotations_[i].OutputUnchecked(out)
      out.putVarInt32(36)
    if (self.has_shouldbroadcast_):
      out.putVarInt32(80)
      out.putBoolean(self.shouldbroadcast_)
    if (self.has_deleteinkansas_):
      out.putVarInt32(112)
      out.putBoolean(self.deleteinkansas_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      if tt == 24:
        self.set_deleteallannotations(d.getBoolean())
        continue
      if tt == 35:
        self.add_deleteannotations().TryMerge(d)
        continue
      if tt == 80:
        self.set_shouldbroadcast(d.getBoolean())
        continue
      if tt == 112:
        self.set_deleteinkansas(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_deleteallannotations_: res+=prefix+("DeleteAllAnnotations: %s\n" % self.DebugFormatBool(self.deleteallannotations_))
    cnt=0
    for e in self.deleteannotations_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DeleteAnnotations%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_shouldbroadcast_: res+=prefix+("ShouldBroadcast: %s\n" % self.DebugFormatBool(self.shouldbroadcast_))
    if self.has_deleteinkansas_: res+=prefix+("DeleteInKansas: %s\n" % self.DebugFormatBool(self.deleteinkansas_))
    return res

  kUser = 1
  kApplication = 2
  kDeleteAllAnnotations = 3
  kDeleteAnnotationsGroup = 4
  kDeleteAnnotationsUrl = 5
  kDeleteAnnotationsAnnotationType = 6
  kDeleteAnnotationsLabel = 7
  kDeleteAnnotationsQuery = 8
  kDeleteAnnotationsAttributeValuePair = 9
  kDeleteAnnotationsMinTimestamp = 11
  kDeleteAnnotationsMaxTimestamp = 12
  kDeleteAnnotationsAnnotationNamespace = 13
  kShouldBroadcast = 10
  kDeleteInKansas = 14

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Application",  #   2
   "DeleteAllAnnotations",  #   3
   "DeleteAnnotations",  #   4
   "Url",  #   5
   "AnnotationType",  #   6
   "Label",  #   7
   "Query",  #   8
   "AttributeValuePair",  #   9
   "ShouldBroadcast",  #  10
   "MinTimestamp",  #  11
   "MaxTimestamp",  #  12
   "AnnotationNamespace",  #  13
   "DeleteInKansas",  #  14
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.STARTGROUP,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.STRING,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

   ProtocolBuffer.Encoder.NUMERIC,  #  12

   ProtocolBuffer.Encoder.STRING,  #  13

   ProtocolBuffer.Encoder.NUMERIC,  #  14

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x23,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x41,
    0x6c,
    0x6c,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x04,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x20,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x07,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x51,
    0x75,
    0x65,
    0x72,
    0x79,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x24,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x50,
    0x61,
    0x69,
    0x72,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x19,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x4d,
    0x69,
    0x6e,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0x60,
    0x03,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x4d,
    0x61,
    0x78,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x0c,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x25,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4e,
    0x61,
    0x6d,
    0x65,
    0x73,
    0x70,
    0x61,
    0x63,
    0x65,
    0x20,
    0x0d,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x53,
    0x68,
    0x6f,
    0x75,
    0x6c,
    0x64,
    0x42,
    0x72,
    0x6f,
    0x61,
    0x64,
    0x63,
    0x61,
    0x73,
    0x74,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x49,
    0x6e,
    0x4b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x20,
    0x0e,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class RenameLabelsRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.application_ = 0
    self.oldlabel_ = ""
    self.newlabel_ = ""
    self.has_user_ = 0
    self.has_application_ = 0
    self.has_oldlabel_ = 0
    self.has_newlabel_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def oldlabel(self): return self.oldlabel_

  def set_oldlabel(self, x):
    self.has_oldlabel_ = 1
    self.oldlabel_ = x

  def clear_oldlabel(self):
    self.has_oldlabel_ = 0
    self.oldlabel_ = ""

  def has_oldlabel(self): return self.has_oldlabel_

  def newlabel(self): return self.newlabel_

  def set_newlabel(self, x):
    self.has_newlabel_ = 1
    self.newlabel_ = x

  def clear_newlabel(self):
    self.has_newlabel_ = 0
    self.newlabel_ = ""

  def has_newlabel(self): return self.has_newlabel_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_application()): self.set_application(x.application())
    if (x.has_oldlabel()): self.set_oldlabel(x.oldlabel())
    if (x.has_newlabel()): self.set_newlabel(x.newlabel())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.RenameLabelsRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.RenameLabelsRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.RenameLabelsRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.RenameLabelsRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.RenameLabelsRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_oldlabel_ != x.has_oldlabel_: return 0
    if self.has_oldlabel_ and self.oldlabel_ != x.oldlabel_: return 0
    if self.has_newlabel_ != x.has_newlabel_: return 0
    if self.has_newlabel_ and self.newlabel_ != x.newlabel_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    if (not self.has_oldlabel_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: oldlabel not set.')
    if (not self.has_newlabel_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: newlabel not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += self.lengthVarInt64(self.application_)
    n += self.lengthString(len(self.oldlabel_))
    n += self.lengthString(len(self.newlabel_))
    return n + 4

  def Clear(self):
    self.clear_user()
    self.clear_application()
    self.clear_oldlabel()
    self.clear_newlabel()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)
    out.putVarInt32(26)
    out.putPrefixedString(self.oldlabel_)
    out.putVarInt32(34)
    out.putPrefixedString(self.newlabel_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      if tt == 26:
        self.set_oldlabel(d.getPrefixedString())
        continue
      if tt == 34:
        self.set_newlabel(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_oldlabel_: res+=prefix+("OldLabel: %s\n" % self.DebugFormatString(self.oldlabel_))
    if self.has_newlabel_: res+=prefix+("NewLabel: %s\n" % self.DebugFormatString(self.newlabel_))
    return res

  kUser = 1
  kApplication = 2
  kOldLabel = 3
  kNewLabel = 4

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Application",  #   2
   "OldLabel",  #   3
   "NewLabel",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1e,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x52,
    0x65,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x73,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x4f,
    0x6c,
    0x64,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x4e,
    0x65,
    0x77,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class AddTrustRelationRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.application_ = 0
    self.trustrelation_ = TrustRelationProto()
    self.timestamp_ = 0
    self.writetokansas_ = 1
    self.has_user_ = 0
    self.has_application_ = 0
    self.has_trustrelation_ = 0
    self.has_timestamp_ = 0
    self.has_writetokansas_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def trustrelation(self): return self.trustrelation_

  def mutable_trustrelation(self): self.has_trustrelation_ = 1; return self.trustrelation_

  def clear_trustrelation(self):self.has_trustrelation_ = 0; self.trustrelation_.Clear()

  def has_trustrelation(self): return self.has_trustrelation_

  def timestamp(self): return self.timestamp_

  def set_timestamp(self, x):
    self.has_timestamp_ = 1
    self.timestamp_ = x

  def clear_timestamp(self):
    self.has_timestamp_ = 0
    self.timestamp_ = 0

  def has_timestamp(self): return self.has_timestamp_

  def writetokansas(self): return self.writetokansas_

  def set_writetokansas(self, x):
    self.has_writetokansas_ = 1
    self.writetokansas_ = x

  def clear_writetokansas(self):
    self.has_writetokansas_ = 0
    self.writetokansas_ = 1

  def has_writetokansas(self): return self.has_writetokansas_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_application()): self.set_application(x.application())
    if (x.has_trustrelation()): self.mutable_trustrelation().MergeFrom(x.trustrelation())
    if (x.has_timestamp()): self.set_timestamp(x.timestamp())
    if (x.has_writetokansas()): self.set_writetokansas(x.writetokansas())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.AddTrustRelationRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.AddTrustRelationRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.AddTrustRelationRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.AddTrustRelationRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.AddTrustRelationRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_trustrelation_ != x.has_trustrelation_: return 0
    if self.has_trustrelation_ and self.trustrelation_ != x.trustrelation_: return 0
    if self.has_timestamp_ != x.has_timestamp_: return 0
    if self.has_timestamp_ and self.timestamp_ != x.timestamp_: return 0
    if self.has_writetokansas_ != x.has_writetokansas_: return 0
    if self.has_writetokansas_ and self.writetokansas_ != x.writetokansas_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    if (not self.has_trustrelation_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: trustrelation not set.')
    elif not self.trustrelation_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += self.lengthVarInt64(self.application_)
    n += self.lengthString(self.trustrelation_.ByteSize())
    if (self.has_timestamp_): n += 1 + self.lengthVarInt64(self.timestamp_)
    if (self.has_writetokansas_): n += 2
    return n + 3

  def Clear(self):
    self.clear_user()
    self.clear_application()
    self.clear_trustrelation()
    self.clear_timestamp()
    self.clear_writetokansas()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)
    out.putVarInt32(26)
    out.putVarInt32(self.trustrelation_.ByteSize())
    self.trustrelation_.OutputUnchecked(out)
    if (self.has_timestamp_):
      out.putVarInt32(32)
      out.putVarUint64(self.timestamp_)
    if (self.has_writetokansas_):
      out.putVarInt32(80)
      out.putBoolean(self.writetokansas_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_trustrelation().TryMerge(tmp)
        continue
      if tt == 32:
        self.set_timestamp(d.getVarUint64())
        continue
      if tt == 80:
        self.set_writetokansas(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_trustrelation_:
      res+=prefix+"TrustRelation <\n"
      res+=self.trustrelation_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_timestamp_: res+=prefix+("Timestamp: %s\n" % self.DebugFormatInt64(self.timestamp_))
    if self.has_writetokansas_: res+=prefix+("WriteToKansas: %s\n" % self.DebugFormatBool(self.writetokansas_))
    return res

  kUser = 1
  kApplication = 2
  kTrustRelation = 3
  kTimestamp = 4
  kWriteToKansas = 10

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Application",  #   2
   "TrustRelation",  #   3
   "Timestamp",  #   4
   None,  #   5
   None,  #   6
   None,  #   7
   None,  #   8
   None,  #   9
   "WriteToKansas",  #  10
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.MAX_TYPE,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.MAX_TYPE,  #   8

   ProtocolBuffer.Encoder.MAX_TYPE,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x22,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x64,
    0x64,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x1d,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x57,
    0x72,
    0x69,
    0x74,
    0x65,
    0x54,
    0x6f,
    0x4b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class DeleteTrustRelationsRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.trustee_ = []
    self.application_ = 0
    self.shouldbroadcast_ = 0
    self.deleteinkansas_ = 1
    self.has_user_ = 0
    self.has_application_ = 0
    self.has_shouldbroadcast_ = 0
    self.has_deleteinkansas_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def trustee_size(self): return len(self.trustee_)
  def trustee_list(self): return self.trustee_

  def trustee(self, i):
    return self.trustee_[i]

  def mutable_trustee(self, i):
    return self.trustee_[i]

  def add_trustee(self):
    x = UserKeyProto()
    self.trustee_.append(x)
    return x

  def clear_trustee(self):
    self.trustee_ = []
  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def shouldbroadcast(self): return self.shouldbroadcast_

  def set_shouldbroadcast(self, x):
    self.has_shouldbroadcast_ = 1
    self.shouldbroadcast_ = x

  def clear_shouldbroadcast(self):
    self.has_shouldbroadcast_ = 0
    self.shouldbroadcast_ = 0

  def has_shouldbroadcast(self): return self.has_shouldbroadcast_

  def deleteinkansas(self): return self.deleteinkansas_

  def set_deleteinkansas(self, x):
    self.has_deleteinkansas_ = 1
    self.deleteinkansas_ = x

  def clear_deleteinkansas(self):
    self.has_deleteinkansas_ = 0
    self.deleteinkansas_ = 1

  def has_deleteinkansas(self): return self.has_deleteinkansas_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    for i in xrange(x.trustee_size()): self.add_trustee().CopyFrom(x.trustee(i))
    if (x.has_application()): self.set_application(x.application())
    if (x.has_shouldbroadcast()): self.set_shouldbroadcast(x.shouldbroadcast())
    if (x.has_deleteinkansas()): self.set_deleteinkansas(x.deleteinkansas())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.DeleteTrustRelationsRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.DeleteTrustRelationsRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.DeleteTrustRelationsRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.DeleteTrustRelationsRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.DeleteTrustRelationsRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if len(self.trustee_) != len(x.trustee_): return 0
    for e1, e2 in zip(self.trustee_, x.trustee_):
      if e1 != e2: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_shouldbroadcast_ != x.has_shouldbroadcast_: return 0
    if self.has_shouldbroadcast_ and self.shouldbroadcast_ != x.shouldbroadcast_: return 0
    if self.has_deleteinkansas_ != x.has_deleteinkansas_: return 0
    if self.has_deleteinkansas_ and self.deleteinkansas_ != x.deleteinkansas_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    for i in xrange(len(self.trustee_)):
      if (not self.trustee_[i].IsInitialized(debug_strs)): initialized=0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += 1 * len(self.trustee_)
    for i in xrange(len(self.trustee_)): n += self.lengthString(self.trustee_[i].ByteSize())
    n += self.lengthVarInt64(self.application_)
    if (self.has_shouldbroadcast_): n += 2
    if (self.has_deleteinkansas_): n += 2
    return n + 2

  def Clear(self):
    self.clear_user()
    self.clear_trustee()
    self.clear_application()
    self.clear_shouldbroadcast()
    self.clear_deleteinkansas()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    for i in xrange(len(self.trustee_)):
      out.putVarInt32(18)
      out.putVarInt32(self.trustee_[i].ByteSize())
      self.trustee_[i].OutputUnchecked(out)
    out.putVarInt32(24)
    out.putVarInt32(self.application_)
    if (self.has_shouldbroadcast_):
      out.putVarInt32(32)
      out.putBoolean(self.shouldbroadcast_)
    if (self.has_deleteinkansas_):
      out.putVarInt32(40)
      out.putBoolean(self.deleteinkansas_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_trustee().TryMerge(tmp)
        continue
      if tt == 24:
        self.set_application(d.getVarInt32())
        continue
      if tt == 32:
        self.set_shouldbroadcast(d.getBoolean())
        continue
      if tt == 40:
        self.set_deleteinkansas(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.trustee_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Trustee%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_shouldbroadcast_: res+=prefix+("ShouldBroadcast: %s\n" % self.DebugFormatBool(self.shouldbroadcast_))
    if self.has_deleteinkansas_: res+=prefix+("DeleteInKansas: %s\n" % self.DebugFormatBool(self.deleteinkansas_))
    return res

  kUser = 1
  kTrustee = 2
  kApplication = 3
  kShouldBroadcast = 4
  kDeleteInKansas = 5

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Trustee",  #   2
   "Application",  #   3
   "ShouldBroadcast",  #   4
   "DeleteInKansas",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x26,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x65,
    0x65,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x53,
    0x68,
    0x6f,
    0x75,
    0x6c,
    0x64,
    0x42,
    0x72,
    0x6f,
    0x61,
    0x64,
    0x63,
    0x61,
    0x73,
    0x74,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x49,
    0x6e,
    0x4b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ProseAnnotationTrustUpdateReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.has_status_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.ProseAnnotationTrustUpdateReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.ProseAnnotationTrustUpdateReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.ProseAnnotationTrustUpdateReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.ProseAnnotationTrustUpdateReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.ProseAnnotationTrustUpdateReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    return n + 1

  def Clear(self):
    self.clear_status()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    return res

  kStatus = 1

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x2a,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x50,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x55,
    0x70,
    0x64,
    0x61,
    0x74,
    0x65,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class DocumentProto(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.url_ = ""
    self.provider_ = None
    self.docid_ = 0
    self.weight_ = 0.0
    self.globalweight_ = 0.0
    self.numglobalraters_ = 0
    self.annotations_ = []
    self.label_ = []
    self.has_url_ = 0
    self.has_provider_ = 0
    self.has_docid_ = 0
    self.has_weight_ = 0
    self.has_globalweight_ = 0
    self.has_numglobalraters_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def provider(self):
    if self.provider_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.provider_ is None: self.provider_ = UserKeyProto()
      finally:
        self.lazy_init_lock_.release()
    return self.provider_

  def mutable_provider(self): self.has_provider_ = 1; return self.provider()

  def clear_provider(self):
    #Warning: this method does not acquire the lock.
    self.has_provider_ = 0;
    if self.provider_ is not None: self.provider_.Clear()

  def has_provider(self): return self.has_provider_

  def docid(self): return self.docid_

  def set_docid(self, x):
    self.has_docid_ = 1
    self.docid_ = x

  def clear_docid(self):
    self.has_docid_ = 0
    self.docid_ = 0

  def has_docid(self): return self.has_docid_

  def weight(self): return self.weight_

  def set_weight(self, x):
    self.has_weight_ = 1
    self.weight_ = x

  def clear_weight(self):
    self.has_weight_ = 0
    self.weight_ = 0.0

  def has_weight(self): return self.has_weight_

  def globalweight(self): return self.globalweight_

  def set_globalweight(self, x):
    self.has_globalweight_ = 1
    self.globalweight_ = x

  def clear_globalweight(self):
    self.has_globalweight_ = 0
    self.globalweight_ = 0.0

  def has_globalweight(self): return self.has_globalweight_

  def numglobalraters(self): return self.numglobalraters_

  def set_numglobalraters(self, x):
    self.has_numglobalraters_ = 1
    self.numglobalraters_ = x

  def clear_numglobalraters(self):
    self.has_numglobalraters_ = 0
    self.numglobalraters_ = 0

  def has_numglobalraters(self): return self.has_numglobalraters_

  def annotations_size(self): return len(self.annotations_)
  def annotations_list(self): return self.annotations_

  def annotations(self, i):
    return self.annotations_[i]

  def mutable_annotations(self, i):
    return self.annotations_[i]

  def add_annotations(self):
    x = AnnotationProto()
    self.annotations_.append(x)
    return x

  def clear_annotations(self):
    self.annotations_ = []
  def label_size(self): return len(self.label_)
  def label_list(self): return self.label_

  def label(self, i):
    return self.label_[i]

  def set_label(self, i, x):
    self.label_[i] = x

  def add_label(self, x):
    self.label_.append(x)

  def clear_label(self):
    self.label_ = []


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_url()): self.set_url(x.url())
    if (x.has_provider()): self.mutable_provider().MergeFrom(x.provider())
    if (x.has_docid()): self.set_docid(x.docid())
    if (x.has_weight()): self.set_weight(x.weight())
    if (x.has_globalweight()): self.set_globalweight(x.globalweight())
    if (x.has_numglobalraters()): self.set_numglobalraters(x.numglobalraters())
    for i in xrange(x.annotations_size()): self.add_annotations().CopyFrom(x.annotations(i))
    for i in xrange(x.label_size()): self.add_label(x.label(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.DocumentProto', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.DocumentProto')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.DocumentProto', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.DocumentProto', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.DocumentProto', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if self.has_provider_ != x.has_provider_: return 0
    if self.has_provider_ and self.provider_ != x.provider_: return 0
    if self.has_docid_ != x.has_docid_: return 0
    if self.has_docid_ and self.docid_ != x.docid_: return 0
    if self.has_weight_ != x.has_weight_: return 0
    if self.has_weight_ and self.weight_ != x.weight_: return 0
    if self.has_globalweight_ != x.has_globalweight_: return 0
    if self.has_globalweight_ and self.globalweight_ != x.globalweight_: return 0
    if self.has_numglobalraters_ != x.has_numglobalraters_: return 0
    if self.has_numglobalraters_ and self.numglobalraters_ != x.numglobalraters_: return 0
    if len(self.annotations_) != len(x.annotations_): return 0
    for e1, e2 in zip(self.annotations_, x.annotations_):
      if e1 != e2: return 0
    if len(self.label_) != len(x.label_): return 0
    for e1, e2 in zip(self.label_, x.label_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (self.has_provider_ and not self.provider_.IsInitialized(debug_strs)): initialized = 0
    for i in xrange(len(self.annotations_)):
      if (not self.annotations_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_url_): n += 1 + self.lengthString(len(self.url_))
    if (self.has_provider_): n += 1 + self.lengthString(self.provider_.ByteSize())
    if (self.has_docid_): n += 1 + self.lengthVarInt64(self.docid_)
    if (self.has_weight_): n += 5
    if (self.has_globalweight_): n += 5
    if (self.has_numglobalraters_): n += 5
    n += 1 * len(self.annotations_)
    for i in xrange(len(self.annotations_)): n += self.lengthString(self.annotations_[i].ByteSize())
    n += 1 * len(self.label_)
    for i in xrange(len(self.label_)): n += self.lengthString(len(self.label_[i]))
    return n + 0

  def Clear(self):
    self.clear_url()
    self.clear_provider()
    self.clear_docid()
    self.clear_weight()
    self.clear_globalweight()
    self.clear_numglobalraters()
    self.clear_annotations()
    self.clear_label()

  def OutputUnchecked(self, out):
    if (self.has_url_):
      out.putVarInt32(10)
      out.putPrefixedString(self.url_)
    if (self.has_provider_):
      out.putVarInt32(18)
      out.putVarInt32(self.provider_.ByteSize())
      self.provider_.OutputUnchecked(out)
    if (self.has_docid_):
      out.putVarInt32(24)
      out.putVarUint64(self.docid_)
    if (self.has_weight_):
      out.putVarInt32(37)
      out.putFloat(self.weight_)
    if (self.has_globalweight_):
      out.putVarInt32(45)
      out.putFloat(self.globalweight_)
    if (self.has_numglobalraters_):
      out.putVarInt32(53)
      out.put32(self.numglobalraters_)
    for i in xrange(len(self.annotations_)):
      out.putVarInt32(58)
      out.putVarInt32(self.annotations_[i].ByteSize())
      self.annotations_[i].OutputUnchecked(out)
    for i in xrange(len(self.label_)):
      out.putVarInt32(66)
      out.putPrefixedString(self.label_[i])

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_url(d.getPrefixedString())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_provider().TryMerge(tmp)
        continue
      if tt == 24:
        self.set_docid(d.getVarUint64())
        continue
      if tt == 37:
        self.set_weight(d.getFloat())
        continue
      if tt == 45:
        self.set_globalweight(d.getFloat())
        continue
      if tt == 53:
        self.set_numglobalraters(d.get32())
        continue
      if tt == 58:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_annotations().TryMerge(tmp)
        continue
      if tt == 66:
        self.add_label(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_url_: res+=prefix+("Url: %s\n" % self.DebugFormatString(self.url_))
    if self.has_provider_:
      res+=prefix+"Provider <\n"
      res+=self.provider_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_docid_: res+=prefix+("DocID: %s\n" % self.DebugFormatInt64(self.docid_))
    if self.has_weight_: res+=prefix+("Weight: %s\n" % self.DebugFormatFloat(self.weight_))
    if self.has_globalweight_: res+=prefix+("GlobalWeight: %s\n" % self.DebugFormatFloat(self.globalweight_))
    if self.has_numglobalraters_: res+=prefix+("NumGlobalRaters: %s\n" % self.DebugFormatFixed32(self.numglobalraters_))
    cnt=0
    for e in self.annotations_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Annotations%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.label_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Label%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    return res

  kUrl = 1
  kProvider = 2
  kDocID = 3
  kWeight = 4
  kGlobalWeight = 5
  kNumGlobalRaters = 6
  kAnnotations = 7
  kLabel = 8

  _TEXT = (
   "ErrorCode",  #   0
   "Url",  #   1
   "Provider",  #   2
   "DocID",  #   3
   "Weight",  #   4
   "GlobalWeight",  #   5
   "NumGlobalRaters",  #   6
   "Annotations",  #   7
   "Label",  #   8
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.FLOAT,  #   4

   ProtocolBuffer.Encoder.FLOAT,  #   5

   ProtocolBuffer.Encoder.FLOAT,  #   6

   ProtocolBuffer.Encoder.STRING,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x18,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x13,
    0x1a,
    0x03,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x50,
    0x72,
    0x6f,
    0x76,
    0x69,
    0x64,
    0x65,
    0x72,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x44,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x57,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x04,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x47,
    0x6c,
    0x6f,
    0x62,
    0x61,
    0x6c,
    0x57,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x05,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x4e,
    0x75,
    0x6d,
    0x47,
    0x6c,
    0x6f,
    0x62,
    0x61,
    0x6c,
    0x52,
    0x61,
    0x74,
    0x65,
    0x72,
    0x73,
    0x20,
    0x06,
    0x28,
    0x05,
    0x30,
    0x07,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x07,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x1a,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class DocumentScoreRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.documents_ = []
    self.application_ = 0
    self.trustlevel_ = 2
    self.has_user_ = 0
    self.has_application_ = 0
    self.has_trustlevel_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def documents_size(self): return len(self.documents_)
  def documents_list(self): return self.documents_

  def documents(self, i):
    return self.documents_[i]

  def mutable_documents(self, i):
    return self.documents_[i]

  def add_documents(self):
    x = DocumentProto()
    self.documents_.append(x)
    return x

  def clear_documents(self):
    self.documents_ = []
  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def trustlevel(self): return self.trustlevel_

  def set_trustlevel(self, x):
    self.has_trustlevel_ = 1
    self.trustlevel_ = x

  def clear_trustlevel(self):
    self.has_trustlevel_ = 0
    self.trustlevel_ = 2

  def has_trustlevel(self): return self.has_trustlevel_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    for i in xrange(x.documents_size()): self.add_documents().CopyFrom(x.documents(i))
    if (x.has_application()): self.set_application(x.application())
    if (x.has_trustlevel()): self.set_trustlevel(x.trustlevel())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.DocumentScoreRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.DocumentScoreRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.DocumentScoreRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.DocumentScoreRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.DocumentScoreRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if len(self.documents_) != len(x.documents_): return 0
    for e1, e2 in zip(self.documents_, x.documents_):
      if e1 != e2: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_trustlevel_ != x.has_trustlevel_: return 0
    if self.has_trustlevel_ and self.trustlevel_ != x.trustlevel_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    for i in xrange(len(self.documents_)):
      if (not self.documents_[i].IsInitialized(debug_strs)): initialized=0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += 1 * len(self.documents_)
    for i in xrange(len(self.documents_)): n += self.lengthString(self.documents_[i].ByteSize())
    n += self.lengthVarInt64(self.application_)
    if (self.has_trustlevel_): n += 1 + self.lengthVarInt64(self.trustlevel_)
    return n + 2

  def Clear(self):
    self.clear_user()
    self.clear_documents()
    self.clear_application()
    self.clear_trustlevel()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    for i in xrange(len(self.documents_)):
      out.putVarInt32(18)
      out.putVarInt32(self.documents_[i].ByteSize())
      self.documents_[i].OutputUnchecked(out)
    out.putVarInt32(24)
    out.putVarInt32(self.application_)
    if (self.has_trustlevel_):
      out.putVarInt32(32)
      out.putVarInt32(self.trustlevel_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_documents().TryMerge(tmp)
        continue
      if tt == 24:
        self.set_application(d.getVarInt32())
        continue
      if tt == 32:
        self.set_trustlevel(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.documents_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Documents%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_trustlevel_: res+=prefix+("TrustLevel: %s\n" % self.DebugFormatInt32(self.trustlevel_))
    return res

  kUser = 1
  kDocuments = 2
  kApplication = 3
  kTrustLevel = 4

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Documents",  #   2
   "Application",  #   3
   "TrustLevel",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1f,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x18,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x32,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x32,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class DocumentScoreReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.documents_ = []
    self.has_status_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def documents_size(self): return len(self.documents_)
  def documents_list(self): return self.documents_

  def documents(self, i):
    return self.documents_[i]

  def mutable_documents(self, i):
    return self.documents_[i]

  def add_documents(self):
    x = DocumentProto()
    self.documents_.append(x)
    return x

  def clear_documents(self):
    self.documents_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    for i in xrange(x.documents_size()): self.add_documents().CopyFrom(x.documents(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.DocumentScoreReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.DocumentScoreReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.DocumentScoreReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.DocumentScoreReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.DocumentScoreReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if len(self.documents_) != len(x.documents_): return 0
    for e1, e2 in zip(self.documents_, x.documents_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    for i in xrange(len(self.documents_)):
      if (not self.documents_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    n += 1 * len(self.documents_)
    for i in xrange(len(self.documents_)): n += self.lengthString(self.documents_[i].ByteSize())
    return n + 1

  def Clear(self):
    self.clear_status()
    self.clear_documents()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    for i in xrange(len(self.documents_)):
      out.putVarInt32(18)
      out.putVarInt32(self.documents_[i].ByteSize())
      self.documents_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_documents().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    cnt=0
    for e in self.documents_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Documents%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

  kStatus = 1
  kDocuments = 2

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "Documents",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1d,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x53,
    0x63,
    0x6f,
    0x72,
    0x65,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x18,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class PrepareUserRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.application_ = 0
    self.trustlevel_ = 2
    self.has_user_ = 0
    self.has_application_ = 0
    self.has_trustlevel_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def trustlevel(self): return self.trustlevel_

  def set_trustlevel(self, x):
    self.has_trustlevel_ = 1
    self.trustlevel_ = x

  def clear_trustlevel(self):
    self.has_trustlevel_ = 0
    self.trustlevel_ = 2

  def has_trustlevel(self): return self.has_trustlevel_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_application()): self.set_application(x.application())
    if (x.has_trustlevel()): self.set_trustlevel(x.trustlevel())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.PrepareUserRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.PrepareUserRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.PrepareUserRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.PrepareUserRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.PrepareUserRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_trustlevel_ != x.has_trustlevel_: return 0
    if self.has_trustlevel_ and self.trustlevel_ != x.trustlevel_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += self.lengthVarInt64(self.application_)
    if (self.has_trustlevel_): n += 1 + self.lengthVarInt64(self.trustlevel_)
    return n + 2

  def Clear(self):
    self.clear_user()
    self.clear_application()
    self.clear_trustlevel()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)
    if (self.has_trustlevel_):
      out.putVarInt32(24)
      out.putVarInt32(self.trustlevel_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      if tt == 24:
        self.set_trustlevel(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_trustlevel_: res+=prefix+("TrustLevel: %s\n" % self.DebugFormatInt32(self.trustlevel_))
    return res

  kUser = 1
  kApplication = 2
  kTrustLevel = 3

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Application",  #   2
   "TrustLevel",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1d,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x50,
    0x72,
    0x65,
    0x70,
    0x61,
    0x72,
    0x65,
    0x55,
    0x73,
    0x65,
    0x72,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x32,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x32,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class PrepareUserReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.has_status_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.PrepareUserReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.PrepareUserReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.PrepareUserReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.PrepareUserReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.PrepareUserReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    return n + 1

  def Clear(self):
    self.clear_status()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    return res

  kStatus = 1

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1b,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x50,
    0x72,
    0x65,
    0x70,
    0x61,
    0x72,
    0x65,
    0x55,
    0x73,
    0x65,
    0x72,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchAnnotationsRequest_Restrictions(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.annotationtype_ = []
    self.label_ = []
    self.mintimestamp_ = 0
    self.minnewestindex_ = 0
    self.maxnewestindex_ = 0
    self.attributevaluepair_ = []
    self.urlsubstring_ = []
    self.minrating_ = 0.0
    self.maxrating_ = 0.0
    self.annotationnamespace_ = []
    self.has_mintimestamp_ = 0
    self.has_minnewestindex_ = 0
    self.has_maxnewestindex_ = 0
    self.has_minrating_ = 0
    self.has_maxrating_ = 0
    if contents is not None: self.MergeFromString(contents)

  def annotationtype_size(self): return len(self.annotationtype_)
  def annotationtype_list(self): return self.annotationtype_

  def annotationtype(self, i):
    return self.annotationtype_[i]

  def set_annotationtype(self, i, x):
    self.annotationtype_[i] = x

  def add_annotationtype(self, x):
    self.annotationtype_.append(x)

  def clear_annotationtype(self):
    self.annotationtype_ = []

  def label_size(self): return len(self.label_)
  def label_list(self): return self.label_

  def label(self, i):
    return self.label_[i]

  def set_label(self, i, x):
    self.label_[i] = x

  def add_label(self, x):
    self.label_.append(x)

  def clear_label(self):
    self.label_ = []

  def mintimestamp(self): return self.mintimestamp_

  def set_mintimestamp(self, x):
    self.has_mintimestamp_ = 1
    self.mintimestamp_ = x

  def clear_mintimestamp(self):
    self.has_mintimestamp_ = 0
    self.mintimestamp_ = 0

  def has_mintimestamp(self): return self.has_mintimestamp_

  def minnewestindex(self): return self.minnewestindex_

  def set_minnewestindex(self, x):
    self.has_minnewestindex_ = 1
    self.minnewestindex_ = x

  def clear_minnewestindex(self):
    self.has_minnewestindex_ = 0
    self.minnewestindex_ = 0

  def has_minnewestindex(self): return self.has_minnewestindex_

  def maxnewestindex(self): return self.maxnewestindex_

  def set_maxnewestindex(self, x):
    self.has_maxnewestindex_ = 1
    self.maxnewestindex_ = x

  def clear_maxnewestindex(self):
    self.has_maxnewestindex_ = 0
    self.maxnewestindex_ = 0

  def has_maxnewestindex(self): return self.has_maxnewestindex_

  def attributevaluepair_size(self): return len(self.attributevaluepair_)
  def attributevaluepair_list(self): return self.attributevaluepair_

  def attributevaluepair(self, i):
    return self.attributevaluepair_[i]

  def mutable_attributevaluepair(self, i):
    return self.attributevaluepair_[i]

  def add_attributevaluepair(self):
    x = AttributeValue()
    self.attributevaluepair_.append(x)
    return x

  def clear_attributevaluepair(self):
    self.attributevaluepair_ = []
  def urlsubstring_size(self): return len(self.urlsubstring_)
  def urlsubstring_list(self): return self.urlsubstring_

  def urlsubstring(self, i):
    return self.urlsubstring_[i]

  def set_urlsubstring(self, i, x):
    self.urlsubstring_[i] = x

  def add_urlsubstring(self, x):
    self.urlsubstring_.append(x)

  def clear_urlsubstring(self):
    self.urlsubstring_ = []

  def minrating(self): return self.minrating_

  def set_minrating(self, x):
    self.has_minrating_ = 1
    self.minrating_ = x

  def clear_minrating(self):
    self.has_minrating_ = 0
    self.minrating_ = 0.0

  def has_minrating(self): return self.has_minrating_

  def maxrating(self): return self.maxrating_

  def set_maxrating(self, x):
    self.has_maxrating_ = 1
    self.maxrating_ = x

  def clear_maxrating(self):
    self.has_maxrating_ = 0
    self.maxrating_ = 0.0

  def has_maxrating(self): return self.has_maxrating_

  def annotationnamespace_size(self): return len(self.annotationnamespace_)
  def annotationnamespace_list(self): return self.annotationnamespace_

  def annotationnamespace(self, i):
    return self.annotationnamespace_[i]

  def set_annotationnamespace(self, i, x):
    self.annotationnamespace_[i] = x

  def add_annotationnamespace(self, x):
    self.annotationnamespace_.append(x)

  def clear_annotationnamespace(self):
    self.annotationnamespace_ = []


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.annotationtype_size()): self.add_annotationtype(x.annotationtype(i))
    for i in xrange(x.label_size()): self.add_label(x.label(i))
    if (x.has_mintimestamp()): self.set_mintimestamp(x.mintimestamp())
    if (x.has_minnewestindex()): self.set_minnewestindex(x.minnewestindex())
    if (x.has_maxnewestindex()): self.set_maxnewestindex(x.maxnewestindex())
    for i in xrange(x.attributevaluepair_size()): self.add_attributevaluepair().CopyFrom(x.attributevaluepair(i))
    for i in xrange(x.urlsubstring_size()): self.add_urlsubstring(x.urlsubstring(i))
    if (x.has_minrating()): self.set_minrating(x.minrating())
    if (x.has_maxrating()): self.set_maxrating(x.maxrating())
    for i in xrange(x.annotationnamespace_size()): self.add_annotationnamespace(x.annotationnamespace(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchAnnotationsRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchAnnotationsRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchAnnotationsRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchAnnotationsRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchAnnotationsRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.annotationtype_) != len(x.annotationtype_): return 0
    for e1, e2 in zip(self.annotationtype_, x.annotationtype_):
      if e1 != e2: return 0
    if len(self.label_) != len(x.label_): return 0
    for e1, e2 in zip(self.label_, x.label_):
      if e1 != e2: return 0
    if self.has_mintimestamp_ != x.has_mintimestamp_: return 0
    if self.has_mintimestamp_ and self.mintimestamp_ != x.mintimestamp_: return 0
    if self.has_minnewestindex_ != x.has_minnewestindex_: return 0
    if self.has_minnewestindex_ and self.minnewestindex_ != x.minnewestindex_: return 0
    if self.has_maxnewestindex_ != x.has_maxnewestindex_: return 0
    if self.has_maxnewestindex_ and self.maxnewestindex_ != x.maxnewestindex_: return 0
    if len(self.attributevaluepair_) != len(x.attributevaluepair_): return 0
    for e1, e2 in zip(self.attributevaluepair_, x.attributevaluepair_):
      if e1 != e2: return 0
    if len(self.urlsubstring_) != len(x.urlsubstring_): return 0
    for e1, e2 in zip(self.urlsubstring_, x.urlsubstring_):
      if e1 != e2: return 0
    if self.has_minrating_ != x.has_minrating_: return 0
    if self.has_minrating_ and self.minrating_ != x.minrating_: return 0
    if self.has_maxrating_ != x.has_maxrating_: return 0
    if self.has_maxrating_ and self.maxrating_ != x.maxrating_: return 0
    if len(self.annotationnamespace_) != len(x.annotationnamespace_): return 0
    for e1, e2 in zip(self.annotationnamespace_, x.annotationnamespace_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.attributevaluepair_)):
      if (not self.attributevaluepair_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.annotationtype_)
    for i in xrange(len(self.annotationtype_)): n += self.lengthVarInt64(self.annotationtype_[i])
    n += 1 * len(self.label_)
    for i in xrange(len(self.label_)): n += self.lengthString(len(self.label_[i]))
    if (self.has_mintimestamp_): n += 1 + self.lengthVarInt64(self.mintimestamp_)
    if (self.has_minnewestindex_): n += 1 + self.lengthVarInt64(self.minnewestindex_)
    if (self.has_maxnewestindex_): n += 1 + self.lengthVarInt64(self.maxnewestindex_)
    n += 1 * len(self.attributevaluepair_)
    for i in xrange(len(self.attributevaluepair_)): n += self.lengthString(self.attributevaluepair_[i].ByteSize())
    n += 2 * len(self.urlsubstring_)
    for i in xrange(len(self.urlsubstring_)): n += self.lengthString(len(self.urlsubstring_[i]))
    if (self.has_minrating_): n += 6
    if (self.has_maxrating_): n += 6
    n += 2 * len(self.annotationnamespace_)
    for i in xrange(len(self.annotationnamespace_)): n += self.lengthString(len(self.annotationnamespace_[i]))
    return n + 0

  def Clear(self):
    self.clear_annotationtype()
    self.clear_label()
    self.clear_mintimestamp()
    self.clear_minnewestindex()
    self.clear_maxnewestindex()
    self.clear_attributevaluepair()
    self.clear_urlsubstring()
    self.clear_minrating()
    self.clear_maxrating()
    self.clear_annotationnamespace()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.annotationtype_)):
      out.putVarInt32(32)
      out.putVarInt32(self.annotationtype_[i])
    for i in xrange(len(self.label_)):
      out.putVarInt32(42)
      out.putPrefixedString(self.label_[i])
    if (self.has_mintimestamp_):
      out.putVarInt32(48)
      out.putVarInt64(self.mintimestamp_)
    if (self.has_minnewestindex_):
      out.putVarInt32(56)
      out.putVarInt32(self.minnewestindex_)
    if (self.has_maxnewestindex_):
      out.putVarInt32(64)
      out.putVarInt32(self.maxnewestindex_)
    for i in xrange(len(self.attributevaluepair_)):
      out.putVarInt32(74)
      out.putVarInt32(self.attributevaluepair_[i].ByteSize())
      self.attributevaluepair_[i].OutputUnchecked(out)
    for i in xrange(len(self.urlsubstring_)):
      out.putVarInt32(138)
      out.putPrefixedString(self.urlsubstring_[i])
    if (self.has_minrating_):
      out.putVarInt32(157)
      out.putFloat(self.minrating_)
    if (self.has_maxrating_):
      out.putVarInt32(165)
      out.putFloat(self.maxrating_)
    for i in xrange(len(self.annotationnamespace_)):
      out.putVarInt32(170)
      out.putPrefixedString(self.annotationnamespace_[i])

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 28: break
      if tt == 32:
        self.add_annotationtype(d.getVarInt32())
        continue
      if tt == 42:
        self.add_label(d.getPrefixedString())
        continue
      if tt == 48:
        self.set_mintimestamp(d.getVarInt64())
        continue
      if tt == 56:
        self.set_minnewestindex(d.getVarInt32())
        continue
      if tt == 64:
        self.set_maxnewestindex(d.getVarInt32())
        continue
      if tt == 74:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_attributevaluepair().TryMerge(tmp)
        continue
      if tt == 138:
        self.add_urlsubstring(d.getPrefixedString())
        continue
      if tt == 157:
        self.set_minrating(d.getFloat())
        continue
      if tt == 165:
        self.set_maxrating(d.getFloat())
        continue
      if tt == 170:
        self.add_annotationnamespace(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.annotationtype_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("AnnotationType%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    cnt=0
    for e in self.label_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Label%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_mintimestamp_: res+=prefix+("MinTimestamp: %s\n" % self.DebugFormatInt64(self.mintimestamp_))
    if self.has_minnewestindex_: res+=prefix+("MinNewestIndex: %s\n" % self.DebugFormatInt32(self.minnewestindex_))
    if self.has_maxnewestindex_: res+=prefix+("MaxNewestIndex: %s\n" % self.DebugFormatInt32(self.maxnewestindex_))
    cnt=0
    for e in self.attributevaluepair_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("AttributeValuePair%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.urlsubstring_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("UrlSubstring%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_minrating_: res+=prefix+("MinRating: %s\n" % self.DebugFormatFloat(self.minrating_))
    if self.has_maxrating_: res+=prefix+("MaxRating: %s\n" % self.DebugFormatFloat(self.maxrating_))
    cnt=0
    for e in self.annotationnamespace_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("AnnotationNamespace%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    return res

class FetchAnnotationsRequest_DataInclusionRestrictions(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.includerating_ = 0
    self.includelabel_ = 0
    self.includequery_ = 0
    self.includeattributevalue_ = 0
    self.includetimestamp_ = 0
    self.includeannotationnamespace_ = 0
    self.returnannotationscountonly_ = 0
    self.has_includerating_ = 0
    self.has_includelabel_ = 0
    self.has_includequery_ = 0
    self.has_includeattributevalue_ = 0
    self.has_includetimestamp_ = 0
    self.has_includeannotationnamespace_ = 0
    self.has_returnannotationscountonly_ = 0
    if contents is not None: self.MergeFromString(contents)

  def includerating(self): return self.includerating_

  def set_includerating(self, x):
    self.has_includerating_ = 1
    self.includerating_ = x

  def clear_includerating(self):
    self.has_includerating_ = 0
    self.includerating_ = 0

  def has_includerating(self): return self.has_includerating_

  def includelabel(self): return self.includelabel_

  def set_includelabel(self, x):
    self.has_includelabel_ = 1
    self.includelabel_ = x

  def clear_includelabel(self):
    self.has_includelabel_ = 0
    self.includelabel_ = 0

  def has_includelabel(self): return self.has_includelabel_

  def includequery(self): return self.includequery_

  def set_includequery(self, x):
    self.has_includequery_ = 1
    self.includequery_ = x

  def clear_includequery(self):
    self.has_includequery_ = 0
    self.includequery_ = 0

  def has_includequery(self): return self.has_includequery_

  def includeattributevalue(self): return self.includeattributevalue_

  def set_includeattributevalue(self, x):
    self.has_includeattributevalue_ = 1
    self.includeattributevalue_ = x

  def clear_includeattributevalue(self):
    self.has_includeattributevalue_ = 0
    self.includeattributevalue_ = 0

  def has_includeattributevalue(self): return self.has_includeattributevalue_

  def includetimestamp(self): return self.includetimestamp_

  def set_includetimestamp(self, x):
    self.has_includetimestamp_ = 1
    self.includetimestamp_ = x

  def clear_includetimestamp(self):
    self.has_includetimestamp_ = 0
    self.includetimestamp_ = 0

  def has_includetimestamp(self): return self.has_includetimestamp_

  def includeannotationnamespace(self): return self.includeannotationnamespace_

  def set_includeannotationnamespace(self, x):
    self.has_includeannotationnamespace_ = 1
    self.includeannotationnamespace_ = x

  def clear_includeannotationnamespace(self):
    self.has_includeannotationnamespace_ = 0
    self.includeannotationnamespace_ = 0

  def has_includeannotationnamespace(self): return self.has_includeannotationnamespace_

  def returnannotationscountonly(self): return self.returnannotationscountonly_

  def set_returnannotationscountonly(self, x):
    self.has_returnannotationscountonly_ = 1
    self.returnannotationscountonly_ = x

  def clear_returnannotationscountonly(self):
    self.has_returnannotationscountonly_ = 0
    self.returnannotationscountonly_ = 0

  def has_returnannotationscountonly(self): return self.has_returnannotationscountonly_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_includerating()): self.set_includerating(x.includerating())
    if (x.has_includelabel()): self.set_includelabel(x.includelabel())
    if (x.has_includequery()): self.set_includequery(x.includequery())
    if (x.has_includeattributevalue()): self.set_includeattributevalue(x.includeattributevalue())
    if (x.has_includetimestamp()): self.set_includetimestamp(x.includetimestamp())
    if (x.has_includeannotationnamespace()): self.set_includeannotationnamespace(x.includeannotationnamespace())
    if (x.has_returnannotationscountonly()): self.set_returnannotationscountonly(x.returnannotationscountonly())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchAnnotationsRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchAnnotationsRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchAnnotationsRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchAnnotationsRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchAnnotationsRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_includerating_ != x.has_includerating_: return 0
    if self.has_includerating_ and self.includerating_ != x.includerating_: return 0
    if self.has_includelabel_ != x.has_includelabel_: return 0
    if self.has_includelabel_ and self.includelabel_ != x.includelabel_: return 0
    if self.has_includequery_ != x.has_includequery_: return 0
    if self.has_includequery_ and self.includequery_ != x.includequery_: return 0
    if self.has_includeattributevalue_ != x.has_includeattributevalue_: return 0
    if self.has_includeattributevalue_ and self.includeattributevalue_ != x.includeattributevalue_: return 0
    if self.has_includetimestamp_ != x.has_includetimestamp_: return 0
    if self.has_includetimestamp_ and self.includetimestamp_ != x.includetimestamp_: return 0
    if self.has_includeannotationnamespace_ != x.has_includeannotationnamespace_: return 0
    if self.has_includeannotationnamespace_ and self.includeannotationnamespace_ != x.includeannotationnamespace_: return 0
    if self.has_returnannotationscountonly_ != x.has_returnannotationscountonly_: return 0
    if self.has_returnannotationscountonly_ and self.returnannotationscountonly_ != x.returnannotationscountonly_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_includerating_): n += 2
    if (self.has_includelabel_): n += 2
    if (self.has_includequery_): n += 2
    if (self.has_includeattributevalue_): n += 2
    if (self.has_includetimestamp_): n += 2
    if (self.has_includeannotationnamespace_): n += 3
    if (self.has_returnannotationscountonly_): n += 3
    return n + 0

  def Clear(self):
    self.clear_includerating()
    self.clear_includelabel()
    self.clear_includequery()
    self.clear_includeattributevalue()
    self.clear_includetimestamp()
    self.clear_includeannotationnamespace()
    self.clear_returnannotationscountonly()

  def OutputUnchecked(self, out):
    if (self.has_includerating_):
      out.putVarInt32(88)
      out.putBoolean(self.includerating_)
    if (self.has_includelabel_):
      out.putVarInt32(96)
      out.putBoolean(self.includelabel_)
    if (self.has_includequery_):
      out.putVarInt32(104)
      out.putBoolean(self.includequery_)
    if (self.has_includeattributevalue_):
      out.putVarInt32(112)
      out.putBoolean(self.includeattributevalue_)
    if (self.has_includetimestamp_):
      out.putVarInt32(120)
      out.putBoolean(self.includetimestamp_)
    if (self.has_returnannotationscountonly_):
      out.putVarInt32(128)
      out.putBoolean(self.returnannotationscountonly_)
    if (self.has_includeannotationnamespace_):
      out.putVarInt32(176)
      out.putBoolean(self.includeannotationnamespace_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 84: break
      if tt == 88:
        self.set_includerating(d.getBoolean())
        continue
      if tt == 96:
        self.set_includelabel(d.getBoolean())
        continue
      if tt == 104:
        self.set_includequery(d.getBoolean())
        continue
      if tt == 112:
        self.set_includeattributevalue(d.getBoolean())
        continue
      if tt == 120:
        self.set_includetimestamp(d.getBoolean())
        continue
      if tt == 128:
        self.set_returnannotationscountonly(d.getBoolean())
        continue
      if tt == 176:
        self.set_includeannotationnamespace(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_includerating_: res+=prefix+("IncludeRating: %s\n" % self.DebugFormatBool(self.includerating_))
    if self.has_includelabel_: res+=prefix+("IncludeLabel: %s\n" % self.DebugFormatBool(self.includelabel_))
    if self.has_includequery_: res+=prefix+("IncludeQuery: %s\n" % self.DebugFormatBool(self.includequery_))
    if self.has_includeattributevalue_: res+=prefix+("IncludeAttributeValue: %s\n" % self.DebugFormatBool(self.includeattributevalue_))
    if self.has_includetimestamp_: res+=prefix+("IncludeTimestamp: %s\n" % self.DebugFormatBool(self.includetimestamp_))
    if self.has_includeannotationnamespace_: res+=prefix+("IncludeAnnotationNamespace: %s\n" % self.DebugFormatBool(self.includeannotationnamespace_))
    if self.has_returnannotationscountonly_: res+=prefix+("ReturnAnnotationsCountOnly: %s\n" % self.DebugFormatBool(self.returnannotationscountonly_))
    return res

class FetchAnnotationsRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = []
    self.application_ = 0
    self.restrictions_ = None
    self.datainclusionrestrictions_ = None
    self.returnnodata_ = 0
    self.has_application_ = 0
    self.has_restrictions_ = 0
    self.has_datainclusionrestrictions_ = 0
    self.has_returnnodata_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def user_size(self): return len(self.user_)
  def user_list(self): return self.user_

  def user(self, i):
    return self.user_[i]

  def mutable_user(self, i):
    return self.user_[i]

  def add_user(self):
    x = UserKeyProto()
    self.user_.append(x)
    return x

  def clear_user(self):
    self.user_ = []
  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def restrictions(self):
    if self.restrictions_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.restrictions_ is None: self.restrictions_ = FetchAnnotationsRequest_Restrictions()
      finally:
        self.lazy_init_lock_.release()
    return self.restrictions_

  def mutable_restrictions(self): self.has_restrictions_ = 1; return self.restrictions()

  def clear_restrictions(self):
    #Warning: this method does not acquire the lock.
    self.has_restrictions_ = 0;
    if self.restrictions_ is not None: self.restrictions_.Clear()

  def has_restrictions(self): return self.has_restrictions_

  def datainclusionrestrictions(self):
    if self.datainclusionrestrictions_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.datainclusionrestrictions_ is None: self.datainclusionrestrictions_ = FetchAnnotationsRequest_DataInclusionRestrictions()
      finally:
        self.lazy_init_lock_.release()
    return self.datainclusionrestrictions_

  def mutable_datainclusionrestrictions(self): self.has_datainclusionrestrictions_ = 1; return self.datainclusionrestrictions()

  def clear_datainclusionrestrictions(self):
    #Warning: this method does not acquire the lock.
    self.has_datainclusionrestrictions_ = 0;
    if self.datainclusionrestrictions_ is not None: self.datainclusionrestrictions_.Clear()

  def has_datainclusionrestrictions(self): return self.has_datainclusionrestrictions_

  def returnnodata(self): return self.returnnodata_

  def set_returnnodata(self, x):
    self.has_returnnodata_ = 1
    self.returnnodata_ = x

  def clear_returnnodata(self):
    self.has_returnnodata_ = 0
    self.returnnodata_ = 0

  def has_returnnodata(self): return self.has_returnnodata_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.user_size()): self.add_user().CopyFrom(x.user(i))
    if (x.has_application()): self.set_application(x.application())
    if (x.has_restrictions()): self.mutable_restrictions().MergeFrom(x.restrictions())
    if (x.has_datainclusionrestrictions()): self.mutable_datainclusionrestrictions().MergeFrom(x.datainclusionrestrictions())
    if (x.has_returnnodata()): self.set_returnnodata(x.returnnodata())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchAnnotationsRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchAnnotationsRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchAnnotationsRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchAnnotationsRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchAnnotationsRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.user_) != len(x.user_): return 0
    for e1, e2 in zip(self.user_, x.user_):
      if e1 != e2: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_restrictions_ != x.has_restrictions_: return 0
    if self.has_restrictions_ and self.restrictions_ != x.restrictions_: return 0
    if self.has_datainclusionrestrictions_ != x.has_datainclusionrestrictions_: return 0
    if self.has_datainclusionrestrictions_ and self.datainclusionrestrictions_ != x.datainclusionrestrictions_: return 0
    if self.has_returnnodata_ != x.has_returnnodata_: return 0
    if self.has_returnnodata_ and self.returnnodata_ != x.returnnodata_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.user_)):
      if (not self.user_[i].IsInitialized(debug_strs)): initialized=0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    if (self.has_restrictions_ and not self.restrictions_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_datainclusionrestrictions_ and not self.datainclusionrestrictions_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.user_)
    for i in xrange(len(self.user_)): n += self.lengthString(self.user_[i].ByteSize())
    n += self.lengthVarInt64(self.application_)
    if (self.has_restrictions_): n += 2 + self.restrictions_.ByteSize()
    if (self.has_datainclusionrestrictions_): n += 2 + self.datainclusionrestrictions_.ByteSize()
    if (self.has_returnnodata_): n += 3
    return n + 1

  def Clear(self):
    self.clear_user()
    self.clear_application()
    self.clear_restrictions()
    self.clear_datainclusionrestrictions()
    self.clear_returnnodata()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.user_)):
      out.putVarInt32(10)
      out.putVarInt32(self.user_[i].ByteSize())
      self.user_[i].OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)
    if (self.has_restrictions_):
      out.putVarInt32(27)
      self.restrictions_.OutputUnchecked(out)
      out.putVarInt32(28)
    if (self.has_datainclusionrestrictions_):
      out.putVarInt32(83)
      self.datainclusionrestrictions_.OutputUnchecked(out)
      out.putVarInt32(84)
    if (self.has_returnnodata_):
      out.putVarInt32(144)
      out.putBoolean(self.returnnodata_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_user().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      if tt == 27:
        self.mutable_restrictions().TryMerge(d)
        continue
      if tt == 83:
        self.mutable_datainclusionrestrictions().TryMerge(d)
        continue
      if tt == 144:
        self.set_returnnodata(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.user_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("User%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_restrictions_:
      res+=prefix+"Restrictions {\n"
      res+=self.restrictions_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_datainclusionrestrictions_:
      res+=prefix+"DataInclusionRestrictions {\n"
      res+=self.datainclusionrestrictions_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_returnnodata_: res+=prefix+("ReturnNoData: %s\n" % self.DebugFormatBool(self.returnnodata_))
    return res

  kUser = 1
  kApplication = 2
  kRestrictionsGroup = 3
  kRestrictionsAnnotationType = 4
  kRestrictionsLabel = 5
  kRestrictionsMinTimestamp = 6
  kRestrictionsMinNewestIndex = 7
  kRestrictionsMaxNewestIndex = 8
  kRestrictionsAttributeValuePair = 9
  kRestrictionsUrlSubstring = 17
  kRestrictionsMinRating = 19
  kRestrictionsMaxRating = 20
  kRestrictionsAnnotationNamespace = 21
  kDataInclusionRestrictionsGroup = 10
  kDataInclusionRestrictionsIncludeRating = 11
  kDataInclusionRestrictionsIncludeLabel = 12
  kDataInclusionRestrictionsIncludeQuery = 13
  kDataInclusionRestrictionsIncludeAttributeValue = 14
  kDataInclusionRestrictionsIncludeTimestamp = 15
  kDataInclusionRestrictionsIncludeAnnotationNamespace = 22
  kDataInclusionRestrictionsReturnAnnotationsCountOnly = 16
  kReturnNoData = 18

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Application",  #   2
   "Restrictions",  #   3
   "AnnotationType",  #   4
   "Label",  #   5
   "MinTimestamp",  #   6
   "MinNewestIndex",  #   7
   "MaxNewestIndex",  #   8
   "AttributeValuePair",  #   9
   "DataInclusionRestrictions",  #  10
   "IncludeRating",  #  11
   "IncludeLabel",  #  12
   "IncludeQuery",  #  13
   "IncludeAttributeValue",  #  14
   "IncludeTimestamp",  #  15
   "ReturnAnnotationsCountOnly",  #  16
   "UrlSubstring",  #  17
   "ReturnNoData",  #  18
   "MinRating",  #  19
   "MaxRating",  #  20
   "AnnotationNamespace",  #  21
   "IncludeAnnotationNamespace",  #  22
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STARTGROUP,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.STARTGROUP,  #  10

   ProtocolBuffer.Encoder.NUMERIC,  #  11

   ProtocolBuffer.Encoder.NUMERIC,  #  12

   ProtocolBuffer.Encoder.NUMERIC,  #  13

   ProtocolBuffer.Encoder.NUMERIC,  #  14

   ProtocolBuffer.Encoder.NUMERIC,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

   ProtocolBuffer.Encoder.STRING,  #  17

   ProtocolBuffer.Encoder.NUMERIC,  #  18

   ProtocolBuffer.Encoder.FLOAT,  #  19

   ProtocolBuffer.Encoder.FLOAT,  #  20

   ProtocolBuffer.Encoder.STRING,  #  21

   ProtocolBuffer.Encoder.NUMERIC,  #  22

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x22,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x03,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x4d,
    0x69,
    0x6e,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x4d,
    0x69,
    0x6e,
    0x4e,
    0x65,
    0x77,
    0x65,
    0x73,
    0x74,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0x60,
    0x02,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x4d,
    0x61,
    0x78,
    0x4e,
    0x65,
    0x77,
    0x65,
    0x73,
    0x74,
    0x49,
    0x6e,
    0x64,
    0x65,
    0x78,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x1f,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x50,
    0x61,
    0x69,
    0x72,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x19,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x55,
    0x72,
    0x6c,
    0x53,
    0x75,
    0x62,
    0x73,
    0x74,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x11,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x4d,
    0x69,
    0x6e,
    0x52,
    0x61,
    0x74,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x13,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x42,
    0x03,
    0x30,
    0x2e,
    0x30,
    0x60,
    0x02,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x30,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x4d,
    0x61,
    0x78,
    0x52,
    0x61,
    0x74,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x14,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x20,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4e,
    0x61,
    0x6d,
    0x65,
    0x73,
    0x70,
    0x61,
    0x63,
    0x65,
    0x20,
    0x15,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x44,
    0x61,
    0x74,
    0x61,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x0a,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x27,
    0x44,
    0x61,
    0x74,
    0x61,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x52,
    0x61,
    0x74,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x0b,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x0d,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x26,
    0x44,
    0x61,
    0x74,
    0x61,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x0c,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x0d,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x26,
    0x44,
    0x61,
    0x74,
    0x61,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x51,
    0x75,
    0x65,
    0x72,
    0x79,
    0x20,
    0x0d,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x0d,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x2f,
    0x44,
    0x61,
    0x74,
    0x61,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x0e,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x0d,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x2a,
    0x44,
    0x61,
    0x74,
    0x61,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x0f,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x0d,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x34,
    0x44,
    0x61,
    0x74,
    0x61,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x64,
    0x65,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4e,
    0x61,
    0x6d,
    0x65,
    0x73,
    0x70,
    0x61,
    0x63,
    0x65,
    0x20,
    0x16,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x0d,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x34,
    0x44,
    0x61,
    0x74,
    0x61,
    0x49,
    0x6e,
    0x63,
    0x6c,
    0x75,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x52,
    0x65,
    0x74,
    0x75,
    0x72,
    0x6e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x4f,
    0x6e,
    0x6c,
    0x79,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x0d,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x52,
    0x65,
    0x74,
    0x75,
    0x72,
    0x6e,
    0x4e,
    0x6f,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x12,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchAnnotationsReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.annotations_ = []
    self.annotationscount_ = 0
    self.has_status_ = 0
    self.has_annotationscount_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def annotations_size(self): return len(self.annotations_)
  def annotations_list(self): return self.annotations_

  def annotations(self, i):
    return self.annotations_[i]

  def mutable_annotations(self, i):
    return self.annotations_[i]

  def add_annotations(self):
    x = AnnotationProto()
    self.annotations_.append(x)
    return x

  def clear_annotations(self):
    self.annotations_ = []
  def annotationscount(self): return self.annotationscount_

  def set_annotationscount(self, x):
    self.has_annotationscount_ = 1
    self.annotationscount_ = x

  def clear_annotationscount(self):
    self.has_annotationscount_ = 0
    self.annotationscount_ = 0

  def has_annotationscount(self): return self.has_annotationscount_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    for i in xrange(x.annotations_size()): self.add_annotations().CopyFrom(x.annotations(i))
    if (x.has_annotationscount()): self.set_annotationscount(x.annotationscount())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchAnnotationsReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchAnnotationsReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchAnnotationsReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchAnnotationsReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchAnnotationsReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if len(self.annotations_) != len(x.annotations_): return 0
    for e1, e2 in zip(self.annotations_, x.annotations_):
      if e1 != e2: return 0
    if self.has_annotationscount_ != x.has_annotationscount_: return 0
    if self.has_annotationscount_ and self.annotationscount_ != x.annotationscount_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    for i in xrange(len(self.annotations_)):
      if (not self.annotations_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    n += 1 * len(self.annotations_)
    for i in xrange(len(self.annotations_)): n += self.lengthString(self.annotations_[i].ByteSize())
    if (self.has_annotationscount_): n += 1 + self.lengthVarInt64(self.annotationscount_)
    return n + 1

  def Clear(self):
    self.clear_status()
    self.clear_annotations()
    self.clear_annotationscount()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    for i in xrange(len(self.annotations_)):
      out.putVarInt32(18)
      out.putVarInt32(self.annotations_[i].ByteSize())
      self.annotations_[i].OutputUnchecked(out)
    if (self.has_annotationscount_):
      out.putVarInt32(24)
      out.putVarInt32(self.annotationscount_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_annotations().TryMerge(tmp)
        continue
      if tt == 24:
        self.set_annotationscount(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    cnt=0
    for e in self.annotations_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Annotations%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_annotationscount_: res+=prefix+("AnnotationsCount: %s\n" % self.DebugFormatInt32(self.annotationscount_))
    return res

  kStatus = 1
  kAnnotations = 2
  kAnnotationsCount = 3

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "Annotations",  #   2
   "AnnotationsCount",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x20,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x1a,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchUrlAnnotationsRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.url_ = []
    self.application_ = 0
    self.trustlevel_ = 0
    self.has_user_ = 0
    self.has_application_ = 0
    self.has_trustlevel_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def url_size(self): return len(self.url_)
  def url_list(self): return self.url_

  def url(self, i):
    return self.url_[i]

  def set_url(self, i, x):
    self.url_[i] = x

  def add_url(self, x):
    self.url_.append(x)

  def clear_url(self):
    self.url_ = []

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def trustlevel(self): return self.trustlevel_

  def set_trustlevel(self, x):
    self.has_trustlevel_ = 1
    self.trustlevel_ = x

  def clear_trustlevel(self):
    self.has_trustlevel_ = 0
    self.trustlevel_ = 0

  def has_trustlevel(self): return self.has_trustlevel_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    for i in xrange(x.url_size()): self.add_url(x.url(i))
    if (x.has_application()): self.set_application(x.application())
    if (x.has_trustlevel()): self.set_trustlevel(x.trustlevel())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchUrlAnnotationsRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchUrlAnnotationsRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchUrlAnnotationsRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchUrlAnnotationsRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchUrlAnnotationsRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if len(self.url_) != len(x.url_): return 0
    for e1, e2 in zip(self.url_, x.url_):
      if e1 != e2: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_trustlevel_ != x.has_trustlevel_: return 0
    if self.has_trustlevel_ and self.trustlevel_ != x.trustlevel_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += 1 * len(self.url_)
    for i in xrange(len(self.url_)): n += self.lengthString(len(self.url_[i]))
    n += self.lengthVarInt64(self.application_)
    if (self.has_trustlevel_): n += 1 + self.lengthVarInt64(self.trustlevel_)
    return n + 2

  def Clear(self):
    self.clear_user()
    self.clear_url()
    self.clear_application()
    self.clear_trustlevel()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    for i in xrange(len(self.url_)):
      out.putVarInt32(18)
      out.putPrefixedString(self.url_[i])
    out.putVarInt32(24)
    out.putVarInt32(self.application_)
    if (self.has_trustlevel_):
      out.putVarInt32(32)
      out.putVarInt32(self.trustlevel_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 18:
        self.add_url(d.getPrefixedString())
        continue
      if tt == 24:
        self.set_application(d.getVarInt32())
        continue
      if tt == 32:
        self.set_trustlevel(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.url_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Url%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_trustlevel_: res+=prefix+("TrustLevel: %s\n" % self.DebugFormatInt32(self.trustlevel_))
    return res

  kUser = 1
  kUrl = 2
  kApplication = 3
  kTrustLevel = 4

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Url",  #   2
   "Application",  #   3
   "TrustLevel",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x25,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x55,
    0x72,
    0x6c,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x03,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchUrlAnnotationsReply_UrlAnnotation(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.url_ = ""
    self.annotation_ = []
    self.has_url_ = 0
    if contents is not None: self.MergeFromString(contents)

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def annotation_size(self): return len(self.annotation_)
  def annotation_list(self): return self.annotation_

  def annotation(self, i):
    return self.annotation_[i]

  def mutable_annotation(self, i):
    return self.annotation_[i]

  def add_annotation(self):
    x = AnnotationProto()
    self.annotation_.append(x)
    return x

  def clear_annotation(self):
    self.annotation_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_url()): self.set_url(x.url())
    for i in xrange(x.annotation_size()): self.add_annotation().CopyFrom(x.annotation(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchUrlAnnotationsReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchUrlAnnotationsReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchUrlAnnotationsReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchUrlAnnotationsReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchUrlAnnotationsReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if len(self.annotation_) != len(x.annotation_): return 0
    for e1, e2 in zip(self.annotation_, x.annotation_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_url_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: url not set.')
    for i in xrange(len(self.annotation_)):
      if (not self.annotation_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.url_))
    n += 1 * len(self.annotation_)
    for i in xrange(len(self.annotation_)): n += self.lengthString(self.annotation_[i].ByteSize())
    return n + 1

  def Clear(self):
    self.clear_url()
    self.clear_annotation()

  def OutputUnchecked(self, out):
    out.putVarInt32(26)
    out.putPrefixedString(self.url_)
    for i in xrange(len(self.annotation_)):
      out.putVarInt32(34)
      out.putVarInt32(self.annotation_[i].ByteSize())
      self.annotation_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 26:
        self.set_url(d.getPrefixedString())
        continue
      if tt == 34:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_annotation().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_url_: res+=prefix+("Url: %s\n" % self.DebugFormatString(self.url_))
    cnt=0
    for e in self.annotation_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Annotation%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

class FetchUrlAnnotationsReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.urlannotation_ = []
    self.has_status_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def urlannotation_size(self): return len(self.urlannotation_)
  def urlannotation_list(self): return self.urlannotation_

  def urlannotation(self, i):
    return self.urlannotation_[i]

  def mutable_urlannotation(self, i):
    return self.urlannotation_[i]

  def add_urlannotation(self):
    x = FetchUrlAnnotationsReply_UrlAnnotation()
    self.urlannotation_.append(x)
    return x

  def clear_urlannotation(self):
    self.urlannotation_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    for i in xrange(x.urlannotation_size()): self.add_urlannotation().CopyFrom(x.urlannotation(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchUrlAnnotationsReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchUrlAnnotationsReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchUrlAnnotationsReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchUrlAnnotationsReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchUrlAnnotationsReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if len(self.urlannotation_) != len(x.urlannotation_): return 0
    for e1, e2 in zip(self.urlannotation_, x.urlannotation_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    for i in xrange(len(self.urlannotation_)):
      if (not self.urlannotation_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    n += 2 * len(self.urlannotation_)
    for i in xrange(len(self.urlannotation_)): n += self.urlannotation_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_status()
    self.clear_urlannotation()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    for i in xrange(len(self.urlannotation_)):
      out.putVarInt32(19)
      self.urlannotation_[i].OutputUnchecked(out)
      out.putVarInt32(20)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 19:
        self.add_urlannotation().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    cnt=0
    for e in self.urlannotation_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("UrlAnnotation%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kStatus = 1
  kUrlAnnotationGroup = 2
  kUrlAnnotationUrl = 3
  kUrlAnnotationAnnotation = 4

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "UrlAnnotation",  #   2
   "Url",  #   3
   "Annotation",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x23,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x55,
    0x72,
    0x6c,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x55,
    0x72,
    0x6c,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x55,
    0x72,
    0x6c,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x55,
    0x72,
    0x6c,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x1a,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x60,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class TrustRelationRestrictions(ProtocolBuffer.ProtocolMessage):

  ONLY_USER_SPECIFIED =    1 
  ONLY_NON_USER_SPECIFIED =    2 
  BOTH_USER_AND_NON_USER_SPECIFIED =    3 

  _ExplicitlyStatedTypeValues_NAMES = {
    1: "ONLY_USER_SPECIFIED",
    2: "ONLY_NON_USER_SPECIFIED",
    3: "BOTH_USER_AND_NON_USER_SPECIFIED",
  }

  def ExplicitlyStatedTypeValues_Name(cls, x): return cls._ExplicitlyStatedTypeValues_NAMES.get(x, "")
  ExplicitlyStatedTypeValues_Name = classmethod(ExplicitlyStatedTypeValues_Name)

  def __init__(self, contents=None):
    self.explicitlystatedtype_ = 1
    self.trustrelationtype_ = 0
    self.returntrustrelationcountonly_ = 0
    self.has_explicitlystatedtype_ = 0
    self.has_trustrelationtype_ = 0
    self.has_returntrustrelationcountonly_ = 0
    if contents is not None: self.MergeFromString(contents)

  def explicitlystatedtype(self): return self.explicitlystatedtype_

  def set_explicitlystatedtype(self, x):
    self.has_explicitlystatedtype_ = 1
    self.explicitlystatedtype_ = x

  def clear_explicitlystatedtype(self):
    self.has_explicitlystatedtype_ = 0
    self.explicitlystatedtype_ = 1

  def has_explicitlystatedtype(self): return self.has_explicitlystatedtype_

  def trustrelationtype(self): return self.trustrelationtype_

  def set_trustrelationtype(self, x):
    self.has_trustrelationtype_ = 1
    self.trustrelationtype_ = x

  def clear_trustrelationtype(self):
    self.has_trustrelationtype_ = 0
    self.trustrelationtype_ = 0

  def has_trustrelationtype(self): return self.has_trustrelationtype_

  def returntrustrelationcountonly(self): return self.returntrustrelationcountonly_

  def set_returntrustrelationcountonly(self, x):
    self.has_returntrustrelationcountonly_ = 1
    self.returntrustrelationcountonly_ = x

  def clear_returntrustrelationcountonly(self):
    self.has_returntrustrelationcountonly_ = 0
    self.returntrustrelationcountonly_ = 0

  def has_returntrustrelationcountonly(self): return self.has_returntrustrelationcountonly_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_explicitlystatedtype()): self.set_explicitlystatedtype(x.explicitlystatedtype())
    if (x.has_trustrelationtype()): self.set_trustrelationtype(x.trustrelationtype())
    if (x.has_returntrustrelationcountonly()): self.set_returntrustrelationcountonly(x.returntrustrelationcountonly())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.TrustRelationRestrictions', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.TrustRelationRestrictions')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.TrustRelationRestrictions', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.TrustRelationRestrictions', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.TrustRelationRestrictions', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_explicitlystatedtype_ != x.has_explicitlystatedtype_: return 0
    if self.has_explicitlystatedtype_ and self.explicitlystatedtype_ != x.explicitlystatedtype_: return 0
    if self.has_trustrelationtype_ != x.has_trustrelationtype_: return 0
    if self.has_trustrelationtype_ and self.trustrelationtype_ != x.trustrelationtype_: return 0
    if self.has_returntrustrelationcountonly_ != x.has_returntrustrelationcountonly_: return 0
    if self.has_returntrustrelationcountonly_ and self.returntrustrelationcountonly_ != x.returntrustrelationcountonly_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_explicitlystatedtype_): n += 1 + self.lengthVarInt64(self.explicitlystatedtype_)
    if (self.has_trustrelationtype_): n += 1 + self.lengthVarInt64(self.trustrelationtype_)
    if (self.has_returntrustrelationcountonly_): n += 2
    return n + 0

  def Clear(self):
    self.clear_explicitlystatedtype()
    self.clear_trustrelationtype()
    self.clear_returntrustrelationcountonly()

  def OutputUnchecked(self, out):
    if (self.has_explicitlystatedtype_):
      out.putVarInt32(8)
      out.putVarInt32(self.explicitlystatedtype_)
    if (self.has_trustrelationtype_):
      out.putVarInt32(16)
      out.putVarInt32(self.trustrelationtype_)
    if (self.has_returntrustrelationcountonly_):
      out.putVarInt32(24)
      out.putBoolean(self.returntrustrelationcountonly_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_explicitlystatedtype(d.getVarInt32())
        continue
      if tt == 16:
        self.set_trustrelationtype(d.getVarInt32())
        continue
      if tt == 24:
        self.set_returntrustrelationcountonly(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_explicitlystatedtype_: res+=prefix+("ExplicitlyStatedType: %s\n" % self.DebugFormatInt32(self.explicitlystatedtype_))
    if self.has_trustrelationtype_: res+=prefix+("TrustRelationType: %s\n" % self.DebugFormatInt32(self.trustrelationtype_))
    if self.has_returntrustrelationcountonly_: res+=prefix+("ReturnTrustRelationCountOnly: %s\n" % self.DebugFormatBool(self.returntrustrelationcountonly_))
    return res

  kExplicitlyStatedType = 1
  kTrustRelationType = 2
  kReturnTrustRelationCountOnly = 3

  _TEXT = (
   "ErrorCode",  #   0
   "ExplicitlyStatedType",  #   1
   "TrustRelationType",  #   2
   "ReturnTrustRelationCountOnly",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x24,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x13,
    0x1a,
    0x14,
    0x45,
    0x78,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x69,
    0x74,
    0x6c,
    0x79,
    0x53,
    0x74,
    0x61,
    0x74,
    0x65,
    0x64,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x31,
    0x68,
    0x00,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x13,
    0x4f,
    0x4e,
    0x4c,
    0x59,
    0x5f,
    0x55,
    0x53,
    0x45,
    0x52,
    0x5f,
    0x53,
    0x50,
    0x45,
    0x43,
    0x49,
    0x46,
    0x49,
    0x45,
    0x44,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1c,
    0x52,
    0x65,
    0x74,
    0x75,
    0x72,
    0x6e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x4f,
    0x6e,
    0x6c,
    0x79,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x1a,
    0x45,
    0x78,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x69,
    0x74,
    0x6c,
    0x79,
    0x53,
    0x74,
    0x61,
    0x74,
    0x65,
    0x64,
    0x54,
    0x79,
    0x70,
    0x65,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x73,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x13,
    0x4f,
    0x4e,
    0x4c,
    0x59,
    0x5f,
    0x55,
    0x53,
    0x45,
    0x52,
    0x5f,
    0x53,
    0x50,
    0x45,
    0x43,
    0x49,
    0x46,
    0x49,
    0x45,
    0x44,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x17,
    0x4f,
    0x4e,
    0x4c,
    0x59,
    0x5f,
    0x4e,
    0x4f,
    0x4e,
    0x5f,
    0x55,
    0x53,
    0x45,
    0x52,
    0x5f,
    0x53,
    0x50,
    0x45,
    0x43,
    0x49,
    0x46,
    0x49,
    0x45,
    0x44,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x20,
    0x42,
    0x4f,
    0x54,
    0x48,
    0x5f,
    0x55,
    0x53,
    0x45,
    0x52,
    0x5f,
    0x41,
    0x4e,
    0x44,
    0x5f,
    0x4e,
    0x4f,
    0x4e,
    0x5f,
    0x55,
    0x53,
    0x45,
    0x52,
    0x5f,
    0x53,
    0x50,
    0x45,
    0x43,
    0x49,
    0x46,
    0x49,
    0x45,
    0x44,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchTrustRelationsRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = []
    self.application_ = 0
    self.has_application_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user_size(self): return len(self.user_)
  def user_list(self): return self.user_

  def user(self, i):
    return self.user_[i]

  def mutable_user(self, i):
    return self.user_[i]

  def add_user(self):
    x = UserKeyProto()
    self.user_.append(x)
    return x

  def clear_user(self):
    self.user_ = []
  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.user_size()): self.add_user().CopyFrom(x.user(i))
    if (x.has_application()): self.set_application(x.application())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchTrustRelationsRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchTrustRelationsRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchTrustRelationsRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchTrustRelationsRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchTrustRelationsRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.user_) != len(x.user_): return 0
    for e1, e2 in zip(self.user_, x.user_):
      if e1 != e2: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.user_)):
      if (not self.user_[i].IsInitialized(debug_strs)): initialized=0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.user_)
    for i in xrange(len(self.user_)): n += self.lengthString(self.user_[i].ByteSize())
    n += self.lengthVarInt64(self.application_)
    return n + 1

  def Clear(self):
    self.clear_user()
    self.clear_application()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.user_)):
      out.putVarInt32(10)
      out.putVarInt32(self.user_[i].ByteSize())
      self.user_[i].OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_user().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.user_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("User%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    return res

  kUser = 1
  kApplication = 2

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Application",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x25,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchTrustRelationsReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.trustrelations_ = []
    self.has_status_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def trustrelations_size(self): return len(self.trustrelations_)
  def trustrelations_list(self): return self.trustrelations_

  def trustrelations(self, i):
    return self.trustrelations_[i]

  def mutable_trustrelations(self, i):
    return self.trustrelations_[i]

  def add_trustrelations(self):
    x = TrustRelationProto()
    self.trustrelations_.append(x)
    return x

  def clear_trustrelations(self):
    self.trustrelations_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    for i in xrange(x.trustrelations_size()): self.add_trustrelations().CopyFrom(x.trustrelations(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchTrustRelationsReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchTrustRelationsReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchTrustRelationsReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchTrustRelationsReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchTrustRelationsReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if len(self.trustrelations_) != len(x.trustrelations_): return 0
    for e1, e2 in zip(self.trustrelations_, x.trustrelations_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    for i in xrange(len(self.trustrelations_)):
      if (not self.trustrelations_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    n += 1 * len(self.trustrelations_)
    for i in xrange(len(self.trustrelations_)): n += self.lengthString(self.trustrelations_[i].ByteSize())
    return n + 1

  def Clear(self):
    self.clear_status()
    self.clear_trustrelations()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    for i in xrange(len(self.trustrelations_)):
      out.putVarInt32(18)
      out.putVarInt32(self.trustrelations_[i].ByteSize())
      self.trustrelations_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_trustrelations().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    cnt=0
    for e in self.trustrelations_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("TrustRelations%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

  kStatus = 1
  kTrustRelations = 2

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "TrustRelations",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x23,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x1d,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchInverseTrustRelationsRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.application_ = 0
    self.restrictions_ = None
    self.has_user_ = 0
    self.has_application_ = 0
    self.has_restrictions_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def restrictions(self):
    if self.restrictions_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.restrictions_ is None: self.restrictions_ = TrustRelationRestrictions()
      finally:
        self.lazy_init_lock_.release()
    return self.restrictions_

  def mutable_restrictions(self): self.has_restrictions_ = 1; return self.restrictions()

  def clear_restrictions(self):
    #Warning: this method does not acquire the lock.
    self.has_restrictions_ = 0;
    if self.restrictions_ is not None: self.restrictions_.Clear()

  def has_restrictions(self): return self.has_restrictions_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_application()): self.set_application(x.application())
    if (x.has_restrictions()): self.mutable_restrictions().MergeFrom(x.restrictions())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchInverseTrustRelationsRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchInverseTrustRelationsRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchInverseTrustRelationsRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchInverseTrustRelationsRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchInverseTrustRelationsRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_restrictions_ != x.has_restrictions_: return 0
    if self.has_restrictions_ and self.restrictions_ != x.restrictions_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    if (self.has_restrictions_ and not self.restrictions_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += self.lengthVarInt64(self.application_)
    if (self.has_restrictions_): n += 1 + self.lengthString(self.restrictions_.ByteSize())
    return n + 2

  def Clear(self):
    self.clear_user()
    self.clear_application()
    self.clear_restrictions()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)
    if (self.has_restrictions_):
      out.putVarInt32(26)
      out.putVarInt32(self.restrictions_.ByteSize())
      self.restrictions_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_restrictions().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_restrictions_:
      res+=prefix+"Restrictions <\n"
      res+=self.restrictions_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

  kUser = 1
  kApplication = 2
  kRestrictions = 3

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Application",  #   2
   "Restrictions",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x49,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x73,
    0x65,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x24,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchInverseTrustRelationsReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.inversetrustrelations_ = []
    self.inversetrustrelationcount_ = 0
    self.has_status_ = 0
    self.has_inversetrustrelationcount_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def inversetrustrelations_size(self): return len(self.inversetrustrelations_)
  def inversetrustrelations_list(self): return self.inversetrustrelations_

  def inversetrustrelations(self, i):
    return self.inversetrustrelations_[i]

  def mutable_inversetrustrelations(self, i):
    return self.inversetrustrelations_[i]

  def add_inversetrustrelations(self):
    x = TrustRelationProto()
    self.inversetrustrelations_.append(x)
    return x

  def clear_inversetrustrelations(self):
    self.inversetrustrelations_ = []
  def inversetrustrelationcount(self): return self.inversetrustrelationcount_

  def set_inversetrustrelationcount(self, x):
    self.has_inversetrustrelationcount_ = 1
    self.inversetrustrelationcount_ = x

  def clear_inversetrustrelationcount(self):
    self.has_inversetrustrelationcount_ = 0
    self.inversetrustrelationcount_ = 0

  def has_inversetrustrelationcount(self): return self.has_inversetrustrelationcount_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    for i in xrange(x.inversetrustrelations_size()): self.add_inversetrustrelations().CopyFrom(x.inversetrustrelations(i))
    if (x.has_inversetrustrelationcount()): self.set_inversetrustrelationcount(x.inversetrustrelationcount())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchInverseTrustRelationsReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchInverseTrustRelationsReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchInverseTrustRelationsReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchInverseTrustRelationsReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchInverseTrustRelationsReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if len(self.inversetrustrelations_) != len(x.inversetrustrelations_): return 0
    for e1, e2 in zip(self.inversetrustrelations_, x.inversetrustrelations_):
      if e1 != e2: return 0
    if self.has_inversetrustrelationcount_ != x.has_inversetrustrelationcount_: return 0
    if self.has_inversetrustrelationcount_ and self.inversetrustrelationcount_ != x.inversetrustrelationcount_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    for i in xrange(len(self.inversetrustrelations_)):
      if (not self.inversetrustrelations_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    n += 1 * len(self.inversetrustrelations_)
    for i in xrange(len(self.inversetrustrelations_)): n += self.lengthString(self.inversetrustrelations_[i].ByteSize())
    if (self.has_inversetrustrelationcount_): n += 1 + self.lengthVarInt64(self.inversetrustrelationcount_)
    return n + 1

  def Clear(self):
    self.clear_status()
    self.clear_inversetrustrelations()
    self.clear_inversetrustrelationcount()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    for i in xrange(len(self.inversetrustrelations_)):
      out.putVarInt32(18)
      out.putVarInt32(self.inversetrustrelations_[i].ByteSize())
      self.inversetrustrelations_[i].OutputUnchecked(out)
    if (self.has_inversetrustrelationcount_):
      out.putVarInt32(24)
      out.putVarInt32(self.inversetrustrelationcount_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_inversetrustrelations().TryMerge(tmp)
        continue
      if tt == 24:
        self.set_inversetrustrelationcount(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    cnt=0
    for e in self.inversetrustrelations_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("InverseTrustRelations%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_inversetrustrelationcount_: res+=prefix+("InverseTrustRelationCount: %s\n" % self.DebugFormatInt32(self.inversetrustrelationcount_))
    return res

  kStatus = 1
  kInverseTrustRelations = 2
  kInverseTrustRelationCount = 3

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "InverseTrustRelations",  #   2
   "InverseTrustRelationCount",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x2a,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x49,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x73,
    0x65,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x49,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x73,
    0x65,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x1d,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x49,
    0x6e,
    0x76,
    0x65,
    0x72,
    0x73,
    0x65,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchTrustNetworkRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.application_ = 0
    self.trustlevel_ = 2
    self.restrictions_ = None
    self.has_user_ = 0
    self.has_application_ = 0
    self.has_trustlevel_ = 0
    self.has_restrictions_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def trustlevel(self): return self.trustlevel_

  def set_trustlevel(self, x):
    self.has_trustlevel_ = 1
    self.trustlevel_ = x

  def clear_trustlevel(self):
    self.has_trustlevel_ = 0
    self.trustlevel_ = 2

  def has_trustlevel(self): return self.has_trustlevel_

  def restrictions(self):
    if self.restrictions_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.restrictions_ is None: self.restrictions_ = TrustRelationRestrictions()
      finally:
        self.lazy_init_lock_.release()
    return self.restrictions_

  def mutable_restrictions(self): self.has_restrictions_ = 1; return self.restrictions()

  def clear_restrictions(self):
    #Warning: this method does not acquire the lock.
    self.has_restrictions_ = 0;
    if self.restrictions_ is not None: self.restrictions_.Clear()

  def has_restrictions(self): return self.has_restrictions_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_application()): self.set_application(x.application())
    if (x.has_trustlevel()): self.set_trustlevel(x.trustlevel())
    if (x.has_restrictions()): self.mutable_restrictions().MergeFrom(x.restrictions())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchTrustNetworkRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchTrustNetworkRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchTrustNetworkRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchTrustNetworkRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchTrustNetworkRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_trustlevel_ != x.has_trustlevel_: return 0
    if self.has_trustlevel_ and self.trustlevel_ != x.trustlevel_: return 0
    if self.has_restrictions_ != x.has_restrictions_: return 0
    if self.has_restrictions_ and self.restrictions_ != x.restrictions_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    if (self.has_restrictions_ and not self.restrictions_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += self.lengthVarInt64(self.application_)
    if (self.has_trustlevel_): n += 1 + self.lengthVarInt64(self.trustlevel_)
    if (self.has_restrictions_): n += 1 + self.lengthString(self.restrictions_.ByteSize())
    return n + 2

  def Clear(self):
    self.clear_user()
    self.clear_application()
    self.clear_trustlevel()
    self.clear_restrictions()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)
    if (self.has_trustlevel_):
      out.putVarInt32(24)
      out.putVarInt32(self.trustlevel_)
    if (self.has_restrictions_):
      out.putVarInt32(42)
      out.putVarInt32(self.restrictions_.ByteSize())
      self.restrictions_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      if tt == 24:
        self.set_trustlevel(d.getVarInt32())
        continue
      if tt == 42:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_restrictions().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_trustlevel_: res+=prefix+("TrustLevel: %s\n" % self.DebugFormatInt32(self.trustlevel_))
    if self.has_restrictions_:
      res+=prefix+"Restrictions <\n"
      res+=self.restrictions_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

  kUser = 1
  kApplication = 2
  kTrustLevel = 3
  kRestrictions = 5

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Application",  #   2
   "TrustLevel",  #   3
   None,  #   4
   "Restrictions",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.MAX_TYPE,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x23,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x4e,
    0x65,
    0x74,
    0x77,
    0x6f,
    0x72,
    0x6b,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x32,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x32,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x24,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchTrustNetworkReply_TrustedUsersTrusteeProfileData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.trustrelation_ = TrustRelationProto()
    self.has_trustrelation_ = 0
    if contents is not None: self.MergeFromString(contents)

  def trustrelation(self): return self.trustrelation_

  def mutable_trustrelation(self): self.has_trustrelation_ = 1; return self.trustrelation_

  def clear_trustrelation(self):self.has_trustrelation_ = 0; self.trustrelation_.Clear()

  def has_trustrelation(self): return self.has_trustrelation_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_trustrelation()): self.mutable_trustrelation().MergeFrom(x.trustrelation())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchTrustNetworkReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchTrustNetworkReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchTrustNetworkReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchTrustNetworkReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchTrustNetworkReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_trustrelation_ != x.has_trustrelation_: return 0
    if self.has_trustrelation_ and self.trustrelation_ != x.trustrelation_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_trustrelation_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: trustrelation not set.')
    elif not self.trustrelation_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.trustrelation_.ByteSize())
    return n + 1

  def Clear(self):
    self.clear_trustrelation()

  def OutputUnchecked(self, out):
    out.putVarInt32(34)
    out.putVarInt32(self.trustrelation_.ByteSize())
    self.trustrelation_.OutputUnchecked(out)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 28: break
      if tt == 34:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_trustrelation().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_trustrelation_:
      res+=prefix+"TrustRelation <\n"
      res+=self.trustrelation_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

class FetchTrustNetworkReply_TrustedUsers(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.trusteeprofiledata_ = []
    self.trustlevel_ = 0
    self.numtrustrelations_ = 0
    self.has_trustlevel_ = 0
    self.has_numtrustrelations_ = 0
    if contents is not None: self.MergeFromString(contents)

  def trusteeprofiledata_size(self): return len(self.trusteeprofiledata_)
  def trusteeprofiledata_list(self): return self.trusteeprofiledata_

  def trusteeprofiledata(self, i):
    return self.trusteeprofiledata_[i]

  def mutable_trusteeprofiledata(self, i):
    return self.trusteeprofiledata_[i]

  def add_trusteeprofiledata(self):
    x = FetchTrustNetworkReply_TrustedUsersTrusteeProfileData()
    self.trusteeprofiledata_.append(x)
    return x

  def clear_trusteeprofiledata(self):
    self.trusteeprofiledata_ = []
  def trustlevel(self): return self.trustlevel_

  def set_trustlevel(self, x):
    self.has_trustlevel_ = 1
    self.trustlevel_ = x

  def clear_trustlevel(self):
    self.has_trustlevel_ = 0
    self.trustlevel_ = 0

  def has_trustlevel(self): return self.has_trustlevel_

  def numtrustrelations(self): return self.numtrustrelations_

  def set_numtrustrelations(self, x):
    self.has_numtrustrelations_ = 1
    self.numtrustrelations_ = x

  def clear_numtrustrelations(self):
    self.has_numtrustrelations_ = 0
    self.numtrustrelations_ = 0

  def has_numtrustrelations(self): return self.has_numtrustrelations_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.trusteeprofiledata_size()): self.add_trusteeprofiledata().CopyFrom(x.trusteeprofiledata(i))
    if (x.has_trustlevel()): self.set_trustlevel(x.trustlevel())
    if (x.has_numtrustrelations()): self.set_numtrustrelations(x.numtrustrelations())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchTrustNetworkReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchTrustNetworkReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchTrustNetworkReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchTrustNetworkReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchTrustNetworkReply', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.trusteeprofiledata_) != len(x.trusteeprofiledata_): return 0
    for e1, e2 in zip(self.trusteeprofiledata_, x.trusteeprofiledata_):
      if e1 != e2: return 0
    if self.has_trustlevel_ != x.has_trustlevel_: return 0
    if self.has_trustlevel_ and self.trustlevel_ != x.trustlevel_: return 0
    if self.has_numtrustrelations_ != x.has_numtrustrelations_: return 0
    if self.has_numtrustrelations_ and self.numtrustrelations_ != x.numtrustrelations_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.trusteeprofiledata_)):
      if (not self.trusteeprofiledata_[i].IsInitialized(debug_strs)): initialized=0
    if (not self.has_trustlevel_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: trustlevel not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.trusteeprofiledata_)
    for i in xrange(len(self.trusteeprofiledata_)): n += self.trusteeprofiledata_[i].ByteSize()
    n += self.lengthVarInt64(self.trustlevel_)
    if (self.has_numtrustrelations_): n += 1 + self.lengthVarInt64(self.numtrustrelations_)
    return n + 1

  def Clear(self):
    self.clear_trusteeprofiledata()
    self.clear_trustlevel()
    self.clear_numtrustrelations()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.trusteeprofiledata_)):
      out.putVarInt32(27)
      self.trusteeprofiledata_[i].OutputUnchecked(out)
      out.putVarInt32(28)
    out.putVarInt32(48)
    out.putVarInt32(self.trustlevel_)
    if (self.has_numtrustrelations_):
      out.putVarInt32(56)
      out.putVarInt32(self.numtrustrelations_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 27:
        self.add_trusteeprofiledata().TryMerge(d)
        continue
      if tt == 48:
        self.set_trustlevel(d.getVarInt32())
        continue
      if tt == 56:
        self.set_numtrustrelations(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.trusteeprofiledata_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("TrusteeProfileData%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_trustlevel_: res+=prefix+("TrustLevel: %s\n" % self.DebugFormatInt32(self.trustlevel_))
    if self.has_numtrustrelations_: res+=prefix+("NumTrustRelations: %s\n" % self.DebugFormatInt32(self.numtrustrelations_))
    return res

class FetchTrustNetworkReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.trustedusers_ = []
    self.has_status_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def trustedusers_size(self): return len(self.trustedusers_)
  def trustedusers_list(self): return self.trustedusers_

  def trustedusers(self, i):
    return self.trustedusers_[i]

  def mutable_trustedusers(self, i):
    return self.trustedusers_[i]

  def add_trustedusers(self):
    x = FetchTrustNetworkReply_TrustedUsers()
    self.trustedusers_.append(x)
    return x

  def clear_trustedusers(self):
    self.trustedusers_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    for i in xrange(x.trustedusers_size()): self.add_trustedusers().CopyFrom(x.trustedusers(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchTrustNetworkReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchTrustNetworkReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchTrustNetworkReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchTrustNetworkReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchTrustNetworkReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if len(self.trustedusers_) != len(x.trustedusers_): return 0
    for e1, e2 in zip(self.trustedusers_, x.trustedusers_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    for i in xrange(len(self.trustedusers_)):
      if (not self.trustedusers_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    n += 2 * len(self.trustedusers_)
    for i in xrange(len(self.trustedusers_)): n += self.trustedusers_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_status()
    self.clear_trustedusers()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    for i in xrange(len(self.trustedusers_)):
      out.putVarInt32(19)
      self.trustedusers_[i].OutputUnchecked(out)
      out.putVarInt32(20)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 19:
        self.add_trustedusers().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    cnt=0
    for e in self.trustedusers_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("TrustedUsers%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kStatus = 1
  kTrustedUsersGroup = 2
  kTrustedUsersTrusteeProfileDataGroup = 3
  kTrustedUsersTrusteeProfileDataTrustRelation = 4
  kTrustedUsersTrustLevel = 6
  kTrustedUsersNumTrustRelations = 7

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "TrustedUsers",  #   2
   "TrusteeProfileData",  #   3
   "TrustRelation",  #   4
   None,  #   5
   "TrustLevel",  #   6
   "NumTrustRelations",  #   7
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STARTGROUP,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.MAX_TYPE,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x21,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x4e,
    0x65,
    0x74,
    0x77,
    0x6f,
    0x72,
    0x6b,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x65,
    0x64,
    0x55,
    0x73,
    0x65,
    0x72,
    0x73,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1f,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x65,
    0x64,
    0x55,
    0x73,
    0x65,
    0x72,
    0x73,
    0x2e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x65,
    0x65,
    0x50,
    0x72,
    0x6f,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x03,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x2d,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x65,
    0x64,
    0x55,
    0x73,
    0x65,
    0x72,
    0x73,
    0x2e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x65,
    0x65,
    0x50,
    0x72,
    0x6f,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x1d,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x65,
    0x64,
    0x55,
    0x73,
    0x65,
    0x72,
    0x73,
    0x2e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x65,
    0x64,
    0x55,
    0x73,
    0x65,
    0x72,
    0x73,
    0x2e,
    0x4e,
    0x75,
    0x6d,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class GetRecommendationsRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.label_ = ""
    self.application_ = 0
    self.numrecommendations_ = 0
    self.onlyhighlyrated_ = 0
    self.trustlevel_ = 1
    self.has_user_ = 0
    self.has_label_ = 0
    self.has_application_ = 0
    self.has_numrecommendations_ = 0
    self.has_onlyhighlyrated_ = 0
    self.has_trustlevel_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def label(self): return self.label_

  def set_label(self, x):
    self.has_label_ = 1
    self.label_ = x

  def clear_label(self):
    self.has_label_ = 0
    self.label_ = ""

  def has_label(self): return self.has_label_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def numrecommendations(self): return self.numrecommendations_

  def set_numrecommendations(self, x):
    self.has_numrecommendations_ = 1
    self.numrecommendations_ = x

  def clear_numrecommendations(self):
    self.has_numrecommendations_ = 0
    self.numrecommendations_ = 0

  def has_numrecommendations(self): return self.has_numrecommendations_

  def onlyhighlyrated(self): return self.onlyhighlyrated_

  def set_onlyhighlyrated(self, x):
    self.has_onlyhighlyrated_ = 1
    self.onlyhighlyrated_ = x

  def clear_onlyhighlyrated(self):
    self.has_onlyhighlyrated_ = 0
    self.onlyhighlyrated_ = 0

  def has_onlyhighlyrated(self): return self.has_onlyhighlyrated_

  def trustlevel(self): return self.trustlevel_

  def set_trustlevel(self, x):
    self.has_trustlevel_ = 1
    self.trustlevel_ = x

  def clear_trustlevel(self):
    self.has_trustlevel_ = 0
    self.trustlevel_ = 1

  def has_trustlevel(self): return self.has_trustlevel_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_label()): self.set_label(x.label())
    if (x.has_application()): self.set_application(x.application())
    if (x.has_numrecommendations()): self.set_numrecommendations(x.numrecommendations())
    if (x.has_onlyhighlyrated()): self.set_onlyhighlyrated(x.onlyhighlyrated())
    if (x.has_trustlevel()): self.set_trustlevel(x.trustlevel())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.GetRecommendationsRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.GetRecommendationsRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.GetRecommendationsRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.GetRecommendationsRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.GetRecommendationsRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_label_ != x.has_label_: return 0
    if self.has_label_ and self.label_ != x.label_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_numrecommendations_ != x.has_numrecommendations_: return 0
    if self.has_numrecommendations_ and self.numrecommendations_ != x.numrecommendations_: return 0
    if self.has_onlyhighlyrated_ != x.has_onlyhighlyrated_: return 0
    if self.has_onlyhighlyrated_ and self.onlyhighlyrated_ != x.onlyhighlyrated_: return 0
    if self.has_trustlevel_ != x.has_trustlevel_: return 0
    if self.has_trustlevel_ and self.trustlevel_ != x.trustlevel_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    if (self.has_label_): n += 1 + self.lengthString(len(self.label_))
    n += self.lengthVarInt64(self.application_)
    if (self.has_numrecommendations_): n += 1 + self.lengthVarInt64(self.numrecommendations_)
    if (self.has_onlyhighlyrated_): n += 2
    if (self.has_trustlevel_): n += 1 + self.lengthVarInt64(self.trustlevel_)
    return n + 2

  def Clear(self):
    self.clear_user()
    self.clear_label()
    self.clear_application()
    self.clear_numrecommendations()
    self.clear_onlyhighlyrated()
    self.clear_trustlevel()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    if (self.has_label_):
      out.putVarInt32(18)
      out.putPrefixedString(self.label_)
    out.putVarInt32(24)
    out.putVarInt32(self.application_)
    if (self.has_numrecommendations_):
      out.putVarInt32(32)
      out.putVarInt32(self.numrecommendations_)
    if (self.has_onlyhighlyrated_):
      out.putVarInt32(40)
      out.putBoolean(self.onlyhighlyrated_)
    if (self.has_trustlevel_):
      out.putVarInt32(48)
      out.putVarInt32(self.trustlevel_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 18:
        self.set_label(d.getPrefixedString())
        continue
      if tt == 24:
        self.set_application(d.getVarInt32())
        continue
      if tt == 32:
        self.set_numrecommendations(d.getVarInt32())
        continue
      if tt == 40:
        self.set_onlyhighlyrated(d.getBoolean())
        continue
      if tt == 48:
        self.set_trustlevel(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_label_: res+=prefix+("Label: %s\n" % self.DebugFormatString(self.label_))
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_numrecommendations_: res+=prefix+("NumRecommendations: %s\n" % self.DebugFormatInt32(self.numrecommendations_))
    if self.has_onlyhighlyrated_: res+=prefix+("OnlyHighlyRated: %s\n" % self.DebugFormatBool(self.onlyhighlyrated_))
    if self.has_trustlevel_: res+=prefix+("TrustLevel: %s\n" % self.DebugFormatInt32(self.trustlevel_))
    return res

  kUser = 1
  kLabel = 2
  kApplication = 3
  kNumRecommendations = 4
  kOnlyHighlyRated = 5
  kTrustLevel = 6

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Label",  #   2
   "Application",  #   3
   "NumRecommendations",  #   4
   "OnlyHighlyRated",  #   5
   "TrustLevel",  #   6
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x24,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x47,
    0x65,
    0x74,
    0x52,
    0x65,
    0x63,
    0x6f,
    0x6d,
    0x6d,
    0x65,
    0x6e,
    0x64,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x4e,
    0x75,
    0x6d,
    0x52,
    0x65,
    0x63,
    0x6f,
    0x6d,
    0x6d,
    0x65,
    0x6e,
    0x64,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x4f,
    0x6e,
    0x6c,
    0x79,
    0x48,
    0x69,
    0x67,
    0x68,
    0x6c,
    0x79,
    0x52,
    0x61,
    0x74,
    0x65,
    0x64,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x31,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x31,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class GetRecommendationsReply_Recommendations(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.url_ = ""
    self.annotations_ = None
    self.has_url_ = 0
    self.has_annotations_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def annotations(self):
    if self.annotations_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.annotations_ is None: self.annotations_ = AnnotationProto()
      finally:
        self.lazy_init_lock_.release()
    return self.annotations_

  def mutable_annotations(self): self.has_annotations_ = 1; return self.annotations()

  def clear_annotations(self):
    #Warning: this method does not acquire the lock.
    self.has_annotations_ = 0;
    if self.annotations_ is not None: self.annotations_.Clear()

  def has_annotations(self): return self.has_annotations_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_url()): self.set_url(x.url())
    if (x.has_annotations()): self.mutable_annotations().MergeFrom(x.annotations())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.GetRecommendationsReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.GetRecommendationsReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.GetRecommendationsReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.GetRecommendationsReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.GetRecommendationsReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if self.has_annotations_ != x.has_annotations_: return 0
    if self.has_annotations_ and self.annotations_ != x.annotations_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_url_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: url not set.')
    if (self.has_annotations_ and not self.annotations_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.url_))
    if (self.has_annotations_): n += 1 + self.lengthString(self.annotations_.ByteSize())
    return n + 1

  def Clear(self):
    self.clear_url()
    self.clear_annotations()

  def OutputUnchecked(self, out):
    out.putVarInt32(26)
    out.putPrefixedString(self.url_)
    if (self.has_annotations_):
      out.putVarInt32(34)
      out.putVarInt32(self.annotations_.ByteSize())
      self.annotations_.OutputUnchecked(out)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 26:
        self.set_url(d.getPrefixedString())
        continue
      if tt == 34:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_annotations().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_url_: res+=prefix+("Url: %s\n" % self.DebugFormatString(self.url_))
    if self.has_annotations_:
      res+=prefix+"Annotations <\n"
      res+=self.annotations_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

class GetRecommendationsReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.recommendations_ = []
    self.has_status_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def recommendations_size(self): return len(self.recommendations_)
  def recommendations_list(self): return self.recommendations_

  def recommendations(self, i):
    return self.recommendations_[i]

  def mutable_recommendations(self, i):
    return self.recommendations_[i]

  def add_recommendations(self):
    x = GetRecommendationsReply_Recommendations()
    self.recommendations_.append(x)
    return x

  def clear_recommendations(self):
    self.recommendations_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    for i in xrange(x.recommendations_size()): self.add_recommendations().CopyFrom(x.recommendations(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.GetRecommendationsReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.GetRecommendationsReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.GetRecommendationsReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.GetRecommendationsReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.GetRecommendationsReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if len(self.recommendations_) != len(x.recommendations_): return 0
    for e1, e2 in zip(self.recommendations_, x.recommendations_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    for i in xrange(len(self.recommendations_)):
      if (not self.recommendations_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    n += 2 * len(self.recommendations_)
    for i in xrange(len(self.recommendations_)): n += self.recommendations_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_status()
    self.clear_recommendations()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    for i in xrange(len(self.recommendations_)):
      out.putVarInt32(19)
      self.recommendations_[i].OutputUnchecked(out)
      out.putVarInt32(20)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 19:
        self.add_recommendations().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    cnt=0
    for e in self.recommendations_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Recommendations%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kStatus = 1
  kRecommendationsGroup = 2
  kRecommendationsUrl = 3
  kRecommendationsAnnotations = 4

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "Recommendations",  #   2
   "Url",  #   3
   "Annotations",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x22,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x47,
    0x65,
    0x74,
    0x52,
    0x65,
    0x63,
    0x6f,
    0x6d,
    0x6d,
    0x65,
    0x6e,
    0x64,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x52,
    0x65,
    0x63,
    0x6f,
    0x6d,
    0x6d,
    0x65,
    0x6e,
    0x64,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x52,
    0x65,
    0x63,
    0x6f,
    0x6d,
    0x6d,
    0x65,
    0x6e,
    0x64,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x52,
    0x65,
    0x63,
    0x6f,
    0x6d,
    0x6d,
    0x65,
    0x6e,
    0x64,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x1a,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x60,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchUserLabeledUrlsRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.label_ = []
    self.application_ = 0
    self.trustlevel_ = 0
    self.has_user_ = 0
    self.has_application_ = 0
    self.has_trustlevel_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def label_size(self): return len(self.label_)
  def label_list(self): return self.label_

  def label(self, i):
    return self.label_[i]

  def set_label(self, i, x):
    self.label_[i] = x

  def add_label(self, x):
    self.label_.append(x)

  def clear_label(self):
    self.label_ = []

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def trustlevel(self): return self.trustlevel_

  def set_trustlevel(self, x):
    self.has_trustlevel_ = 1
    self.trustlevel_ = x

  def clear_trustlevel(self):
    self.has_trustlevel_ = 0
    self.trustlevel_ = 0

  def has_trustlevel(self): return self.has_trustlevel_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    for i in xrange(x.label_size()): self.add_label(x.label(i))
    if (x.has_application()): self.set_application(x.application())
    if (x.has_trustlevel()): self.set_trustlevel(x.trustlevel())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchUserLabeledUrlsRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchUserLabeledUrlsRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchUserLabeledUrlsRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchUserLabeledUrlsRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchUserLabeledUrlsRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if len(self.label_) != len(x.label_): return 0
    for e1, e2 in zip(self.label_, x.label_):
      if e1 != e2: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_trustlevel_ != x.has_trustlevel_: return 0
    if self.has_trustlevel_ and self.trustlevel_ != x.trustlevel_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += 1 * len(self.label_)
    for i in xrange(len(self.label_)): n += self.lengthString(len(self.label_[i]))
    n += self.lengthVarInt64(self.application_)
    if (self.has_trustlevel_): n += 1 + self.lengthVarInt64(self.trustlevel_)
    return n + 2

  def Clear(self):
    self.clear_user()
    self.clear_label()
    self.clear_application()
    self.clear_trustlevel()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    for i in xrange(len(self.label_)):
      out.putVarInt32(18)
      out.putPrefixedString(self.label_[i])
    out.putVarInt32(24)
    out.putVarInt32(self.application_)
    if (self.has_trustlevel_):
      out.putVarInt32(32)
      out.putVarInt32(self.trustlevel_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 18:
        self.add_label(d.getPrefixedString())
        continue
      if tt == 24:
        self.set_application(d.getVarInt32())
        continue
      if tt == 32:
        self.set_trustlevel(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.label_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Label%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_trustlevel_: res+=prefix+("TrustLevel: %s\n" % self.DebugFormatInt32(self.trustlevel_))
    return res

  kUser = 1
  kLabel = 2
  kApplication = 3
  kTrustLevel = 4

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Label",  #   2
   "Application",  #   3
   "TrustLevel",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x26,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x65,
    0x64,
    0x55,
    0x72,
    0x6c,
    0x73,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchUserLabeledUrlsReply_LabelUrlSet(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.label_ = ""
    self.url_ = []
    self.has_label_ = 0
    if contents is not None: self.MergeFromString(contents)

  def label(self): return self.label_

  def set_label(self, x):
    self.has_label_ = 1
    self.label_ = x

  def clear_label(self):
    self.has_label_ = 0
    self.label_ = ""

  def has_label(self): return self.has_label_

  def url_size(self): return len(self.url_)
  def url_list(self): return self.url_

  def url(self, i):
    return self.url_[i]

  def set_url(self, i, x):
    self.url_[i] = x

  def add_url(self, x):
    self.url_.append(x)

  def clear_url(self):
    self.url_ = []


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_label()): self.set_label(x.label())
    for i in xrange(x.url_size()): self.add_url(x.url(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchUserLabeledUrlsReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchUserLabeledUrlsReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchUserLabeledUrlsReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchUserLabeledUrlsReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchUserLabeledUrlsReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_label_ != x.has_label_: return 0
    if self.has_label_ and self.label_ != x.label_: return 0
    if len(self.url_) != len(x.url_): return 0
    for e1, e2 in zip(self.url_, x.url_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_label_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: label not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.label_))
    n += 1 * len(self.url_)
    for i in xrange(len(self.url_)): n += self.lengthString(len(self.url_[i]))
    return n + 1

  def Clear(self):
    self.clear_label()
    self.clear_url()

  def OutputUnchecked(self, out):
    out.putVarInt32(26)
    out.putPrefixedString(self.label_)
    for i in xrange(len(self.url_)):
      out.putVarInt32(34)
      out.putPrefixedString(self.url_[i])

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 26:
        self.set_label(d.getPrefixedString())
        continue
      if tt == 34:
        self.add_url(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_label_: res+=prefix+("Label: %s\n" % self.DebugFormatString(self.label_))
    cnt=0
    for e in self.url_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Url%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    return res

class FetchUserLabeledUrlsReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.labelurlset_ = []
    self.has_status_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def labelurlset_size(self): return len(self.labelurlset_)
  def labelurlset_list(self): return self.labelurlset_

  def labelurlset(self, i):
    return self.labelurlset_[i]

  def mutable_labelurlset(self, i):
    return self.labelurlset_[i]

  def add_labelurlset(self):
    x = FetchUserLabeledUrlsReply_LabelUrlSet()
    self.labelurlset_.append(x)
    return x

  def clear_labelurlset(self):
    self.labelurlset_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    for i in xrange(x.labelurlset_size()): self.add_labelurlset().CopyFrom(x.labelurlset(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchUserLabeledUrlsReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchUserLabeledUrlsReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchUserLabeledUrlsReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchUserLabeledUrlsReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchUserLabeledUrlsReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if len(self.labelurlset_) != len(x.labelurlset_): return 0
    for e1, e2 in zip(self.labelurlset_, x.labelurlset_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    for i in xrange(len(self.labelurlset_)):
      if (not self.labelurlset_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    n += 2 * len(self.labelurlset_)
    for i in xrange(len(self.labelurlset_)): n += self.labelurlset_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_status()
    self.clear_labelurlset()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    for i in xrange(len(self.labelurlset_)):
      out.putVarInt32(19)
      self.labelurlset_[i].OutputUnchecked(out)
      out.putVarInt32(20)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 19:
        self.add_labelurlset().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    cnt=0
    for e in self.labelurlset_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("LabelUrlSet%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kStatus = 1
  kLabelUrlSetGroup = 2
  kLabelUrlSetLabel = 3
  kLabelUrlSetUrl = 4

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "LabelUrlSet",  #   2
   "Label",  #   3
   "Url",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x24,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x65,
    0x64,
    0x55,
    0x72,
    0x6c,
    0x73,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x55,
    0x72,
    0x6c,
    0x53,
    0x65,
    0x74,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x55,
    0x72,
    0x6c,
    0x53,
    0x65,
    0x74,
    0x2e,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x55,
    0x72,
    0x6c,
    0x53,
    0x65,
    0x74,
    0x2e,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x60,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class GetOneboxesRequest(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 2312880 

  _TypeId_NAMES = {
    2312880: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.query_ = ""
    self.platform_ = "web"
    self.output_style_ = ""
    self.application_ = 0
    self.language_ = "en"
    self.country_ = "us"
    self.ip_ = ""
    self.address_ = ""
    self.use_this_provider_only_ = 0
    self.get_debug_info_ = 0
    self.location_ = None
    self.search_type_ = ""
    self.additional_providers_ = []
    self.additional_platforms_ = []
    self.use_additional_providers_only_ = 0
    self.require_legacy_results_ = 0
    self.use_subscriptions_ = 1
    self.has_user_ = 0
    self.has_query_ = 0
    self.has_platform_ = 0
    self.has_output_style_ = 0
    self.has_application_ = 0
    self.has_language_ = 0
    self.has_country_ = 0
    self.has_ip_ = 0
    self.has_address_ = 0
    self.has_use_this_provider_only_ = 0
    self.has_get_debug_info_ = 0
    self.has_location_ = 0
    self.has_search_type_ = 0
    self.has_use_additional_providers_only_ = 0
    self.has_require_legacy_results_ = 0
    self.has_use_subscriptions_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def query(self): return self.query_

  def set_query(self, x):
    self.has_query_ = 1
    self.query_ = x

  def clear_query(self):
    self.has_query_ = 0
    self.query_ = ""

  def has_query(self): return self.has_query_

  def platform(self): return self.platform_

  def set_platform(self, x):
    self.has_platform_ = 1
    self.platform_ = x

  def clear_platform(self):
    self.has_platform_ = 0
    self.platform_ = "web"

  def has_platform(self): return self.has_platform_

  def output_style(self): return self.output_style_

  def set_output_style(self, x):
    self.has_output_style_ = 1
    self.output_style_ = x

  def clear_output_style(self):
    self.has_output_style_ = 0
    self.output_style_ = ""

  def has_output_style(self): return self.has_output_style_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def language(self): return self.language_

  def set_language(self, x):
    self.has_language_ = 1
    self.language_ = x

  def clear_language(self):
    self.has_language_ = 0
    self.language_ = "en"

  def has_language(self): return self.has_language_

  def country(self): return self.country_

  def set_country(self, x):
    self.has_country_ = 1
    self.country_ = x

  def clear_country(self):
    self.has_country_ = 0
    self.country_ = "us"

  def has_country(self): return self.has_country_

  def ip(self): return self.ip_

  def set_ip(self, x):
    self.has_ip_ = 1
    self.ip_ = x

  def clear_ip(self):
    self.has_ip_ = 0
    self.ip_ = ""

  def has_ip(self): return self.has_ip_

  def address(self): return self.address_

  def set_address(self, x):
    self.has_address_ = 1
    self.address_ = x

  def clear_address(self):
    self.has_address_ = 0
    self.address_ = ""

  def has_address(self): return self.has_address_

  def use_this_provider_only(self): return self.use_this_provider_only_

  def set_use_this_provider_only(self, x):
    self.has_use_this_provider_only_ = 1
    self.use_this_provider_only_ = x

  def clear_use_this_provider_only(self):
    self.has_use_this_provider_only_ = 0
    self.use_this_provider_only_ = 0

  def has_use_this_provider_only(self): return self.has_use_this_provider_only_

  def get_debug_info(self): return self.get_debug_info_

  def set_get_debug_info(self, x):
    self.has_get_debug_info_ = 1
    self.get_debug_info_ = x

  def clear_get_debug_info(self):
    self.has_get_debug_info_ = 0
    self.get_debug_info_ = 0

  def has_get_debug_info(self): return self.has_get_debug_info_

  def location(self):
    if self.location_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.location_ is None: self.location_ = LocationExtractionResponse()
      finally:
        self.lazy_init_lock_.release()
    return self.location_

  def mutable_location(self): self.has_location_ = 1; return self.location()

  def clear_location(self):
    #Warning: this method does not acquire the lock.
    self.has_location_ = 0;
    if self.location_ is not None: self.location_.Clear()

  def has_location(self): return self.has_location_

  def search_type(self): return self.search_type_

  def set_search_type(self, x):
    self.has_search_type_ = 1
    self.search_type_ = x

  def clear_search_type(self):
    self.has_search_type_ = 0
    self.search_type_ = ""

  def has_search_type(self): return self.has_search_type_

  def additional_providers_size(self): return len(self.additional_providers_)
  def additional_providers_list(self): return self.additional_providers_

  def additional_providers(self, i):
    return self.additional_providers_[i]

  def mutable_additional_providers(self, i):
    return self.additional_providers_[i]

  def add_additional_providers(self):
    x = UserKeyProto()
    self.additional_providers_.append(x)
    return x

  def clear_additional_providers(self):
    self.additional_providers_ = []
  def additional_platforms_size(self): return len(self.additional_platforms_)
  def additional_platforms_list(self): return self.additional_platforms_

  def additional_platforms(self, i):
    return self.additional_platforms_[i]

  def set_additional_platforms(self, i, x):
    self.additional_platforms_[i] = x

  def add_additional_platforms(self, x):
    self.additional_platforms_.append(x)

  def clear_additional_platforms(self):
    self.additional_platforms_ = []

  def use_additional_providers_only(self): return self.use_additional_providers_only_

  def set_use_additional_providers_only(self, x):
    self.has_use_additional_providers_only_ = 1
    self.use_additional_providers_only_ = x

  def clear_use_additional_providers_only(self):
    self.has_use_additional_providers_only_ = 0
    self.use_additional_providers_only_ = 0

  def has_use_additional_providers_only(self): return self.has_use_additional_providers_only_

  def require_legacy_results(self): return self.require_legacy_results_

  def set_require_legacy_results(self, x):
    self.has_require_legacy_results_ = 1
    self.require_legacy_results_ = x

  def clear_require_legacy_results(self):
    self.has_require_legacy_results_ = 0
    self.require_legacy_results_ = 0

  def has_require_legacy_results(self): return self.has_require_legacy_results_

  def use_subscriptions(self): return self.use_subscriptions_

  def set_use_subscriptions(self, x):
    self.has_use_subscriptions_ = 1
    self.use_subscriptions_ = x

  def clear_use_subscriptions(self):
    self.has_use_subscriptions_ = 0
    self.use_subscriptions_ = 1

  def has_use_subscriptions(self): return self.has_use_subscriptions_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_query()): self.set_query(x.query())
    if (x.has_platform()): self.set_platform(x.platform())
    if (x.has_output_style()): self.set_output_style(x.output_style())
    if (x.has_application()): self.set_application(x.application())
    if (x.has_language()): self.set_language(x.language())
    if (x.has_country()): self.set_country(x.country())
    if (x.has_ip()): self.set_ip(x.ip())
    if (x.has_address()): self.set_address(x.address())
    if (x.has_use_this_provider_only()): self.set_use_this_provider_only(x.use_this_provider_only())
    if (x.has_get_debug_info()): self.set_get_debug_info(x.get_debug_info())
    if (x.has_location()): self.mutable_location().MergeFrom(x.location())
    if (x.has_search_type()): self.set_search_type(x.search_type())
    for i in xrange(x.additional_providers_size()): self.add_additional_providers().CopyFrom(x.additional_providers(i))
    for i in xrange(x.additional_platforms_size()): self.add_additional_platforms(x.additional_platforms(i))
    if (x.has_use_additional_providers_only()): self.set_use_additional_providers_only(x.use_additional_providers_only())
    if (x.has_require_legacy_results()): self.set_require_legacy_results(x.require_legacy_results())
    if (x.has_use_subscriptions()): self.set_use_subscriptions(x.use_subscriptions())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.GetOneboxesRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.GetOneboxesRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.GetOneboxesRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.GetOneboxesRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.GetOneboxesRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_query_ != x.has_query_: return 0
    if self.has_query_ and self.query_ != x.query_: return 0
    if self.has_platform_ != x.has_platform_: return 0
    if self.has_platform_ and self.platform_ != x.platform_: return 0
    if self.has_output_style_ != x.has_output_style_: return 0
    if self.has_output_style_ and self.output_style_ != x.output_style_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_language_ != x.has_language_: return 0
    if self.has_language_ and self.language_ != x.language_: return 0
    if self.has_country_ != x.has_country_: return 0
    if self.has_country_ and self.country_ != x.country_: return 0
    if self.has_ip_ != x.has_ip_: return 0
    if self.has_ip_ and self.ip_ != x.ip_: return 0
    if self.has_address_ != x.has_address_: return 0
    if self.has_address_ and self.address_ != x.address_: return 0
    if self.has_use_this_provider_only_ != x.has_use_this_provider_only_: return 0
    if self.has_use_this_provider_only_ and self.use_this_provider_only_ != x.use_this_provider_only_: return 0
    if self.has_get_debug_info_ != x.has_get_debug_info_: return 0
    if self.has_get_debug_info_ and self.get_debug_info_ != x.get_debug_info_: return 0
    if self.has_location_ != x.has_location_: return 0
    if self.has_location_ and self.location_ != x.location_: return 0
    if self.has_search_type_ != x.has_search_type_: return 0
    if self.has_search_type_ and self.search_type_ != x.search_type_: return 0
    if len(self.additional_providers_) != len(x.additional_providers_): return 0
    for e1, e2 in zip(self.additional_providers_, x.additional_providers_):
      if e1 != e2: return 0
    if len(self.additional_platforms_) != len(x.additional_platforms_): return 0
    for e1, e2 in zip(self.additional_platforms_, x.additional_platforms_):
      if e1 != e2: return 0
    if self.has_use_additional_providers_only_ != x.has_use_additional_providers_only_: return 0
    if self.has_use_additional_providers_only_ and self.use_additional_providers_only_ != x.use_additional_providers_only_: return 0
    if self.has_require_legacy_results_ != x.has_require_legacy_results_: return 0
    if self.has_require_legacy_results_ and self.require_legacy_results_ != x.require_legacy_results_: return 0
    if self.has_use_subscriptions_ != x.has_use_subscriptions_: return 0
    if self.has_use_subscriptions_ and self.use_subscriptions_ != x.use_subscriptions_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_query_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: query not set.')
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    if (self.has_location_ and not self.location_.IsInitialized(debug_strs)): initialized = 0
    for i in xrange(len(self.additional_providers_)):
      if (not self.additional_providers_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += self.lengthString(len(self.query_))
    if (self.has_platform_): n += 1 + self.lengthString(len(self.platform_))
    if (self.has_output_style_): n += 1 + self.lengthString(len(self.output_style_))
    n += self.lengthVarInt64(self.application_)
    if (self.has_language_): n += 1 + self.lengthString(len(self.language_))
    if (self.has_country_): n += 1 + self.lengthString(len(self.country_))
    if (self.has_ip_): n += 1 + self.lengthString(len(self.ip_))
    if (self.has_address_): n += 1 + self.lengthString(len(self.address_))
    if (self.has_use_this_provider_only_): n += 2
    if (self.has_get_debug_info_): n += 2
    if (self.has_location_): n += 1 + self.lengthString(self.location_.ByteSize())
    if (self.has_search_type_): n += 1 + self.lengthString(len(self.search_type_))
    n += 1 * len(self.additional_providers_)
    for i in xrange(len(self.additional_providers_)): n += self.lengthString(self.additional_providers_[i].ByteSize())
    n += 1 * len(self.additional_platforms_)
    for i in xrange(len(self.additional_platforms_)): n += self.lengthString(len(self.additional_platforms_[i]))
    if (self.has_use_additional_providers_only_): n += 3
    if (self.has_require_legacy_results_): n += 3
    if (self.has_use_subscriptions_): n += 3
    return n + 3

  def Clear(self):
    self.clear_user()
    self.clear_query()
    self.clear_platform()
    self.clear_output_style()
    self.clear_application()
    self.clear_language()
    self.clear_country()
    self.clear_ip()
    self.clear_address()
    self.clear_use_this_provider_only()
    self.clear_get_debug_info()
    self.clear_location()
    self.clear_search_type()
    self.clear_additional_providers()
    self.clear_additional_platforms()
    self.clear_use_additional_providers_only()
    self.clear_require_legacy_results()
    self.clear_use_subscriptions()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    out.putVarInt32(18)
    out.putPrefixedString(self.query_)
    if (self.has_platform_):
      out.putVarInt32(26)
      out.putPrefixedString(self.platform_)
    out.putVarInt32(32)
    out.putVarInt32(self.application_)
    if (self.has_language_):
      out.putVarInt32(42)
      out.putPrefixedString(self.language_)
    if (self.has_use_this_provider_only_):
      out.putVarInt32(48)
      out.putBoolean(self.use_this_provider_only_)
    if (self.has_get_debug_info_):
      out.putVarInt32(56)
      out.putBoolean(self.get_debug_info_)
    if (self.has_location_):
      out.putVarInt32(66)
      out.putVarInt32(self.location_.ByteSize())
      self.location_.OutputUnchecked(out)
    if (self.has_search_type_):
      out.putVarInt32(74)
      out.putPrefixedString(self.search_type_)
    for i in xrange(len(self.additional_providers_)):
      out.putVarInt32(82)
      out.putVarInt32(self.additional_providers_[i].ByteSize())
      self.additional_providers_[i].OutputUnchecked(out)
    if (self.has_country_):
      out.putVarInt32(90)
      out.putPrefixedString(self.country_)
    for i in xrange(len(self.additional_platforms_)):
      out.putVarInt32(98)
      out.putPrefixedString(self.additional_platforms_[i])
    if (self.has_ip_):
      out.putVarInt32(106)
      out.putPrefixedString(self.ip_)
    if (self.has_address_):
      out.putVarInt32(114)
      out.putPrefixedString(self.address_)
    if (self.has_output_style_):
      out.putVarInt32(122)
      out.putPrefixedString(self.output_style_)
    if (self.has_use_additional_providers_only_):
      out.putVarInt32(128)
      out.putBoolean(self.use_additional_providers_only_)
    if (self.has_require_legacy_results_):
      out.putVarInt32(136)
      out.putBoolean(self.require_legacy_results_)
    if (self.has_use_subscriptions_):
      out.putVarInt32(144)
      out.putBoolean(self.use_subscriptions_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 18:
        self.set_query(d.getPrefixedString())
        continue
      if tt == 26:
        self.set_platform(d.getPrefixedString())
        continue
      if tt == 32:
        self.set_application(d.getVarInt32())
        continue
      if tt == 42:
        self.set_language(d.getPrefixedString())
        continue
      if tt == 48:
        self.set_use_this_provider_only(d.getBoolean())
        continue
      if tt == 56:
        self.set_get_debug_info(d.getBoolean())
        continue
      if tt == 66:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_location().TryMerge(tmp)
        continue
      if tt == 74:
        self.set_search_type(d.getPrefixedString())
        continue
      if tt == 82:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_additional_providers().TryMerge(tmp)
        continue
      if tt == 90:
        self.set_country(d.getPrefixedString())
        continue
      if tt == 98:
        self.add_additional_platforms(d.getPrefixedString())
        continue
      if tt == 106:
        self.set_ip(d.getPrefixedString())
        continue
      if tt == 114:
        self.set_address(d.getPrefixedString())
        continue
      if tt == 122:
        self.set_output_style(d.getPrefixedString())
        continue
      if tt == 128:
        self.set_use_additional_providers_only(d.getBoolean())
        continue
      if tt == 136:
        self.set_require_legacy_results(d.getBoolean())
        continue
      if tt == 144:
        self.set_use_subscriptions(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_query_: res+=prefix+("query: %s\n" % self.DebugFormatString(self.query_))
    if self.has_platform_: res+=prefix+("platform: %s\n" % self.DebugFormatString(self.platform_))
    if self.has_output_style_: res+=prefix+("output_style: %s\n" % self.DebugFormatString(self.output_style_))
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_language_: res+=prefix+("language: %s\n" % self.DebugFormatString(self.language_))
    if self.has_country_: res+=prefix+("country: %s\n" % self.DebugFormatString(self.country_))
    if self.has_ip_: res+=prefix+("ip: %s\n" % self.DebugFormatString(self.ip_))
    if self.has_address_: res+=prefix+("address: %s\n" % self.DebugFormatString(self.address_))
    if self.has_use_this_provider_only_: res+=prefix+("use_this_provider_only: %s\n" % self.DebugFormatBool(self.use_this_provider_only_))
    if self.has_get_debug_info_: res+=prefix+("get_debug_info: %s\n" % self.DebugFormatBool(self.get_debug_info_))
    if self.has_location_:
      res+=prefix+"location <\n"
      res+=self.location_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_search_type_: res+=prefix+("search_type: %s\n" % self.DebugFormatString(self.search_type_))
    cnt=0
    for e in self.additional_providers_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("additional_providers%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.additional_platforms_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("additional_platforms%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_use_additional_providers_only_: res+=prefix+("use_additional_providers_only: %s\n" % self.DebugFormatBool(self.use_additional_providers_only_))
    if self.has_require_legacy_results_: res+=prefix+("require_legacy_results: %s\n" % self.DebugFormatBool(self.require_legacy_results_))
    if self.has_use_subscriptions_: res+=prefix+("use_subscriptions: %s\n" % self.DebugFormatBool(self.use_subscriptions_))
    return res

  kUser = 1
  kquery = 2
  kplatform = 3
  koutput_style = 15
  kApplication = 4
  klanguage = 5
  kcountry = 11
  kip = 13
  kaddress = 14
  kuse_this_provider_only = 6
  kget_debug_info = 7
  klocation = 8
  ksearch_type = 9
  kadditional_providers = 10
  kadditional_platforms = 12
  kuse_additional_providers_only = 16
  krequire_legacy_results = 17
  kuse_subscriptions = 18

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "query",  #   2
   "platform",  #   3
   "Application",  #   4
   "language",  #   5
   "use_this_provider_only",  #   6
   "get_debug_info",  #   7
   "location",  #   8
   "search_type",  #   9
   "additional_providers",  #  10
   "country",  #  11
   "additional_platforms",  #  12
   "ip",  #  13
   "address",  #  14
   "output_style",  #  15
   "use_additional_providers_only",  #  16
   "require_legacy_results",  #  17
   "use_subscriptions",  #  18
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.STRING,  #  10

   ProtocolBuffer.Encoder.STRING,  #  11

   ProtocolBuffer.Encoder.STRING,  #  12

   ProtocolBuffer.Encoder.STRING,  #  13

   ProtocolBuffer.Encoder.STRING,  #  14

   ProtocolBuffer.Encoder.STRING,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

   ProtocolBuffer.Encoder.NUMERIC,  #  17

   ProtocolBuffer.Encoder.NUMERIC,  #  18

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1d,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x47,
    0x65,
    0x74,
    0x4f,
    0x6e,
    0x65,
    0x62,
    0x6f,
    0x78,
    0x65,
    0x73,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x71,
    0x75,
    0x65,
    0x72,
    0x79,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x70,
    0x6c,
    0x61,
    0x74,
    0x66,
    0x6f,
    0x72,
    0x6d,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x42,
    0x03,
    0x77,
    0x65,
    0x62,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x22,
    0x77,
    0x65,
    0x62,
    0x22,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x6f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x5f,
    0x73,
    0x74,
    0x79,
    0x6c,
    0x65,
    0x20,
    0x0f,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x6c,
    0x61,
    0x6e,
    0x67,
    0x75,
    0x61,
    0x67,
    0x65,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x42,
    0x02,
    0x65,
    0x6e,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x04,
    0x22,
    0x65,
    0x6e,
    0x22,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x63,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x72,
    0x79,
    0x20,
    0x0b,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x42,
    0x02,
    0x75,
    0x73,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x04,
    0x22,
    0x75,
    0x73,
    0x22,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x02,
    0x69,
    0x70,
    0x20,
    0x0d,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x61,
    0x64,
    0x64,
    0x72,
    0x65,
    0x73,
    0x73,
    0x20,
    0x0e,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x75,
    0x73,
    0x65,
    0x5f,
    0x74,
    0x68,
    0x69,
    0x73,
    0x5f,
    0x70,
    0x72,
    0x6f,
    0x76,
    0x69,
    0x64,
    0x65,
    0x72,
    0x5f,
    0x6f,
    0x6e,
    0x6c,
    0x79,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x67,
    0x65,
    0x74,
    0x5f,
    0x64,
    0x65,
    0x62,
    0x75,
    0x67,
    0x5f,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x6c,
    0x6f,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x2d,
    0x6c,
    0x6f,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x65,
    0x78,
    0x74,
    0x72,
    0x61,
    0x63,
    0x74,
    0x6f,
    0x72,
    0x2e,
    0x4c,
    0x6f,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x45,
    0x78,
    0x74,
    0x72,
    0x61,
    0x63,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x73,
    0x65,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x73,
    0x65,
    0x61,
    0x72,
    0x63,
    0x68,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x61,
    0x64,
    0x64,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x6c,
    0x5f,
    0x70,
    0x72,
    0x6f,
    0x76,
    0x69,
    0x64,
    0x65,
    0x72,
    0x73,
    0x20,
    0x0a,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x61,
    0x64,
    0x64,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x6c,
    0x5f,
    0x70,
    0x6c,
    0x61,
    0x74,
    0x66,
    0x6f,
    0x72,
    0x6d,
    0x73,
    0x20,
    0x0c,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x1d,
    0x75,
    0x73,
    0x65,
    0x5f,
    0x61,
    0x64,
    0x64,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x61,
    0x6c,
    0x5f,
    0x70,
    0x72,
    0x6f,
    0x76,
    0x69,
    0x64,
    0x65,
    0x72,
    0x73,
    0x5f,
    0x6f,
    0x6e,
    0x6c,
    0x79,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x72,
    0x65,
    0x71,
    0x75,
    0x69,
    0x72,
    0x65,
    0x5f,
    0x6c,
    0x65,
    0x67,
    0x61,
    0x63,
    0x79,
    0x5f,
    0x72,
    0x65,
    0x73,
    0x75,
    0x6c,
    0x74,
    0x73,
    0x20,
    0x11,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x75,
    0x73,
    0x65,
    0x5f,
    0x73,
    0x75,
    0x62,
    0x73,
    0x63,
    0x72,
    0x69,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x12,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xb0,
    0x95,
    0x8d,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ProseOneboxProviderReply_Output(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.value_ = ""
    self.has_name_ = 0
    self.has_value_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_value()): self.set_value(x.value())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.ProseOneboxProviderReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.ProseOneboxProviderReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.ProseOneboxProviderReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.ProseOneboxProviderReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.ProseOneboxProviderReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    n += self.lengthString(len(self.value_))
    return n + 2

  def Clear(self):
    self.clear_name()
    self.clear_value()

  def OutputUnchecked(self, out):
    out.putVarInt32(42)
    out.putPrefixedString(self.name_)
    out.putVarInt32(50)
    out.putPrefixedString(self.value_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 36: break
      if tt == 42:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 50:
        self.set_value(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_value_: res+=prefix+("value: %s\n" % self.DebugFormatString(self.value_))
    return res

class ProseOneboxProviderReply_UrlOutput(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.value_ = ""
    self.protocol_ = 0
    self.has_name_ = 0
    self.has_value_ = 0
    self.has_protocol_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_

  def protocol(self): return self.protocol_

  def set_protocol(self, x):
    self.has_protocol_ = 1
    self.protocol_ = x

  def clear_protocol(self):
    self.has_protocol_ = 0
    self.protocol_ = 0

  def has_protocol(self): return self.has_protocol_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_value()): self.set_value(x.value())
    if (x.has_protocol()): self.set_protocol(x.protocol())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.ProseOneboxProviderReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.ProseOneboxProviderReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.ProseOneboxProviderReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.ProseOneboxProviderReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.ProseOneboxProviderReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    if self.has_protocol_ != x.has_protocol_: return 0
    if self.has_protocol_ and self.protocol_ != x.protocol_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    n += self.lengthString(len(self.value_))
    if (self.has_protocol_): n += 1 + self.lengthVarInt64(self.protocol_)
    return n + 2

  def Clear(self):
    self.clear_name()
    self.clear_value()
    self.clear_protocol()

  def OutputUnchecked(self, out):
    out.putVarInt32(66)
    out.putPrefixedString(self.name_)
    out.putVarInt32(74)
    out.putPrefixedString(self.value_)
    if (self.has_protocol_):
      out.putVarInt32(80)
      out.putVarInt32(self.protocol_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 60: break
      if tt == 66:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 74:
        self.set_value(d.getPrefixedString())
        continue
      if tt == 80:
        self.set_protocol(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_value_: res+=prefix+("value: %s\n" % self.DebugFormatString(self.value_))
    if self.has_protocol_: res+=prefix+("protocol: %s\n" % self.DebugFormatInt32(self.protocol_))
    return res

class ProseOneboxProviderReply(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 6569000 

  _TypeId_NAMES = {
    6569000: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.provider_ = 0
    self.format_ = ""
    self.provider_name_ = ""
    self.output_ = []
    self.urloutput_ = []
    self.display_ui_ = ""
    self.display_position_ = ""
    self.location_interpretation_ = 0
    self.target_url_ = ""
    self.has_provider_ = 0
    self.has_format_ = 0
    self.has_provider_name_ = 0
    self.has_display_ui_ = 0
    self.has_display_position_ = 0
    self.has_location_interpretation_ = 0
    self.has_target_url_ = 0
    if contents is not None: self.MergeFromString(contents)

  def provider(self): return self.provider_

  def set_provider(self, x):
    self.has_provider_ = 1
    self.provider_ = x

  def clear_provider(self):
    self.has_provider_ = 0
    self.provider_ = 0

  def has_provider(self): return self.has_provider_

  def format(self): return self.format_

  def set_format(self, x):
    self.has_format_ = 1
    self.format_ = x

  def clear_format(self):
    self.has_format_ = 0
    self.format_ = ""

  def has_format(self): return self.has_format_

  def provider_name(self): return self.provider_name_

  def set_provider_name(self, x):
    self.has_provider_name_ = 1
    self.provider_name_ = x

  def clear_provider_name(self):
    self.has_provider_name_ = 0
    self.provider_name_ = ""

  def has_provider_name(self): return self.has_provider_name_

  def output_size(self): return len(self.output_)
  def output_list(self): return self.output_

  def output(self, i):
    return self.output_[i]

  def mutable_output(self, i):
    return self.output_[i]

  def add_output(self):
    x = ProseOneboxProviderReply_Output()
    self.output_.append(x)
    return x

  def clear_output(self):
    self.output_ = []
  def urloutput_size(self): return len(self.urloutput_)
  def urloutput_list(self): return self.urloutput_

  def urloutput(self, i):
    return self.urloutput_[i]

  def mutable_urloutput(self, i):
    return self.urloutput_[i]

  def add_urloutput(self):
    x = ProseOneboxProviderReply_UrlOutput()
    self.urloutput_.append(x)
    return x

  def clear_urloutput(self):
    self.urloutput_ = []
  def display_ui(self): return self.display_ui_

  def set_display_ui(self, x):
    self.has_display_ui_ = 1
    self.display_ui_ = x

  def clear_display_ui(self):
    self.has_display_ui_ = 0
    self.display_ui_ = ""

  def has_display_ui(self): return self.has_display_ui_

  def display_position(self): return self.display_position_

  def set_display_position(self, x):
    self.has_display_position_ = 1
    self.display_position_ = x

  def clear_display_position(self):
    self.has_display_position_ = 0
    self.display_position_ = ""

  def has_display_position(self): return self.has_display_position_

  def location_interpretation(self): return self.location_interpretation_

  def set_location_interpretation(self, x):
    self.has_location_interpretation_ = 1
    self.location_interpretation_ = x

  def clear_location_interpretation(self):
    self.has_location_interpretation_ = 0
    self.location_interpretation_ = 0

  def has_location_interpretation(self): return self.has_location_interpretation_

  def target_url(self): return self.target_url_

  def set_target_url(self, x):
    self.has_target_url_ = 1
    self.target_url_ = x

  def clear_target_url(self):
    self.has_target_url_ = 0
    self.target_url_ = ""

  def has_target_url(self): return self.has_target_url_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_provider()): self.set_provider(x.provider())
    if (x.has_format()): self.set_format(x.format())
    if (x.has_provider_name()): self.set_provider_name(x.provider_name())
    for i in xrange(x.output_size()): self.add_output().CopyFrom(x.output(i))
    for i in xrange(x.urloutput_size()): self.add_urloutput().CopyFrom(x.urloutput(i))
    if (x.has_display_ui()): self.set_display_ui(x.display_ui())
    if (x.has_display_position()): self.set_display_position(x.display_position())
    if (x.has_location_interpretation()): self.set_location_interpretation(x.location_interpretation())
    if (x.has_target_url()): self.set_target_url(x.target_url())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.ProseOneboxProviderReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.ProseOneboxProviderReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.ProseOneboxProviderReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.ProseOneboxProviderReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.ProseOneboxProviderReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_provider_ != x.has_provider_: return 0
    if self.has_provider_ and self.provider_ != x.provider_: return 0
    if self.has_format_ != x.has_format_: return 0
    if self.has_format_ and self.format_ != x.format_: return 0
    if self.has_provider_name_ != x.has_provider_name_: return 0
    if self.has_provider_name_ and self.provider_name_ != x.provider_name_: return 0
    if len(self.output_) != len(x.output_): return 0
    for e1, e2 in zip(self.output_, x.output_):
      if e1 != e2: return 0
    if len(self.urloutput_) != len(x.urloutput_): return 0
    for e1, e2 in zip(self.urloutput_, x.urloutput_):
      if e1 != e2: return 0
    if self.has_display_ui_ != x.has_display_ui_: return 0
    if self.has_display_ui_ and self.display_ui_ != x.display_ui_: return 0
    if self.has_display_position_ != x.has_display_position_: return 0
    if self.has_display_position_ and self.display_position_ != x.display_position_: return 0
    if self.has_location_interpretation_ != x.has_location_interpretation_: return 0
    if self.has_location_interpretation_ and self.location_interpretation_ != x.location_interpretation_: return 0
    if self.has_target_url_ != x.has_target_url_: return 0
    if self.has_target_url_ and self.target_url_ != x.target_url_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_provider_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: provider not set.')
    if (not self.has_format_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: format not set.')
    for i in xrange(len(self.output_)):
      if (not self.output_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.urloutput_)):
      if (not self.urloutput_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.provider_)
    n += self.lengthString(len(self.format_))
    if (self.has_provider_name_): n += 1 + self.lengthString(len(self.provider_name_))
    n += 2 * len(self.output_)
    for i in xrange(len(self.output_)): n += self.output_[i].ByteSize()
    n += 2 * len(self.urloutput_)
    for i in xrange(len(self.urloutput_)): n += self.urloutput_[i].ByteSize()
    if (self.has_display_ui_): n += 1 + self.lengthString(len(self.display_ui_))
    if (self.has_display_position_): n += 1 + self.lengthString(len(self.display_position_))
    if (self.has_location_interpretation_): n += 1 + self.lengthVarInt64(self.location_interpretation_)
    if (self.has_target_url_): n += 1 + self.lengthString(len(self.target_url_))
    return n + 2

  def Clear(self):
    self.clear_provider()
    self.clear_format()
    self.clear_provider_name()
    self.clear_output()
    self.clear_urloutput()
    self.clear_display_ui()
    self.clear_display_position()
    self.clear_location_interpretation()
    self.clear_target_url()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarUint64(self.provider_)
    out.putVarInt32(18)
    out.putPrefixedString(self.format_)
    if (self.has_provider_name_):
      out.putVarInt32(26)
      out.putPrefixedString(self.provider_name_)
    for i in xrange(len(self.output_)):
      out.putVarInt32(35)
      self.output_[i].OutputUnchecked(out)
      out.putVarInt32(36)
    for i in xrange(len(self.urloutput_)):
      out.putVarInt32(59)
      self.urloutput_[i].OutputUnchecked(out)
      out.putVarInt32(60)
    if (self.has_display_ui_):
      out.putVarInt32(90)
      out.putPrefixedString(self.display_ui_)
    if (self.has_display_position_):
      out.putVarInt32(98)
      out.putPrefixedString(self.display_position_)
    if (self.has_location_interpretation_):
      out.putVarInt32(104)
      out.putVarInt32(self.location_interpretation_)
    if (self.has_target_url_):
      out.putVarInt32(114)
      out.putPrefixedString(self.target_url_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_provider(d.getVarUint64())
        continue
      if tt == 18:
        self.set_format(d.getPrefixedString())
        continue
      if tt == 26:
        self.set_provider_name(d.getPrefixedString())
        continue
      if tt == 35:
        self.add_output().TryMerge(d)
        continue
      if tt == 59:
        self.add_urloutput().TryMerge(d)
        continue
      if tt == 90:
        self.set_display_ui(d.getPrefixedString())
        continue
      if tt == 98:
        self.set_display_position(d.getPrefixedString())
        continue
      if tt == 104:
        self.set_location_interpretation(d.getVarInt32())
        continue
      if tt == 114:
        self.set_target_url(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_provider_: res+=prefix+("provider: %s\n" % self.DebugFormatInt64(self.provider_))
    if self.has_format_: res+=prefix+("format: %s\n" % self.DebugFormatString(self.format_))
    if self.has_provider_name_: res+=prefix+("provider_name: %s\n" % self.DebugFormatString(self.provider_name_))
    cnt=0
    for e in self.output_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Output%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.urloutput_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("UrlOutput%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_display_ui_: res+=prefix+("display_ui: %s\n" % self.DebugFormatString(self.display_ui_))
    if self.has_display_position_: res+=prefix+("display_position: %s\n" % self.DebugFormatString(self.display_position_))
    if self.has_location_interpretation_: res+=prefix+("location_interpretation: %s\n" % self.DebugFormatInt32(self.location_interpretation_))
    if self.has_target_url_: res+=prefix+("target_url: %s\n" % self.DebugFormatString(self.target_url_))
    return res

  kprovider = 1
  kformat = 2
  kprovider_name = 3
  kOutputGroup = 4
  kOutputname = 5
  kOutputvalue = 6
  kUrlOutputGroup = 7
  kUrlOutputname = 8
  kUrlOutputvalue = 9
  kUrlOutputprotocol = 10
  kdisplay_ui = 11
  kdisplay_position = 12
  klocation_interpretation = 13
  ktarget_url = 14

  _TEXT = (
   "ErrorCode",  #   0
   "provider",  #   1
   "format",  #   2
   "provider_name",  #   3
   "Output",  #   4
   "name",  #   5
   "value",  #   6
   "UrlOutput",  #   7
   "name",  #   8
   "value",  #   9
   "protocol",  #  10
   "display_ui",  #  11
   "display_position",  #  12
   "location_interpretation",  #  13
   "target_url",  #  14
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STARTGROUP,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.STARTGROUP,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.NUMERIC,  #  10

   ProtocolBuffer.Encoder.STRING,  #  11

   ProtocolBuffer.Encoder.STRING,  #  12

   ProtocolBuffer.Encoder.NUMERIC,  #  13

   ProtocolBuffer.Encoder.STRING,  #  14

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x23,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x50,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x4f,
    0x6e,
    0x65,
    0x62,
    0x6f,
    0x78,
    0x50,
    0x72,
    0x6f,
    0x76,
    0x69,
    0x64,
    0x65,
    0x72,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x08,
    0x70,
    0x72,
    0x6f,
    0x76,
    0x69,
    0x64,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x66,
    0x6f,
    0x72,
    0x6d,
    0x61,
    0x74,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x70,
    0x72,
    0x6f,
    0x76,
    0x69,
    0x64,
    0x65,
    0x72,
    0x5f,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x42,
    0x00,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x22,
    0x22,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x20,
    0x04,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x55,
    0x72,
    0x6c,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x20,
    0x07,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x55,
    0x72,
    0x6c,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x06,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x55,
    0x72,
    0x6c,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x06,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x55,
    0x72,
    0x6c,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x63,
    0x6f,
    0x6c,
    0x20,
    0x0a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0x60,
    0x06,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x64,
    0x69,
    0x73,
    0x70,
    0x6c,
    0x61,
    0x79,
    0x5f,
    0x75,
    0x69,
    0x20,
    0x0b,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x64,
    0x69,
    0x73,
    0x70,
    0x6c,
    0x61,
    0x79,
    0x5f,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x0c,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x6c,
    0x6f,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x69,
    0x6e,
    0x74,
    0x65,
    0x72,
    0x70,
    0x72,
    0x65,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x0d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x74,
    0x61,
    0x72,
    0x67,
    0x65,
    0x74,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x0e,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xa8,
    0xf8,
    0x90,
    0x03,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class ProseOneboxResultGroup(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 5390737 

  _TypeId_NAMES = {
    5390737: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.results_ = []
    self.group_ui_ = ""
    self.group_display_position_ = ""
    self.group_impression_tag_ = ""
    self.has_group_ui_ = 0
    self.has_group_display_position_ = 0
    self.has_group_impression_tag_ = 0
    if contents is not None: self.MergeFromString(contents)

  def results_size(self): return len(self.results_)
  def results_list(self): return self.results_

  def results(self, i):
    return self.results_[i]

  def mutable_results(self, i):
    return self.results_[i]

  def add_results(self):
    x = ProseOneboxProviderReply()
    self.results_.append(x)
    return x

  def clear_results(self):
    self.results_ = []
  def group_ui(self): return self.group_ui_

  def set_group_ui(self, x):
    self.has_group_ui_ = 1
    self.group_ui_ = x

  def clear_group_ui(self):
    self.has_group_ui_ = 0
    self.group_ui_ = ""

  def has_group_ui(self): return self.has_group_ui_

  def group_display_position(self): return self.group_display_position_

  def set_group_display_position(self, x):
    self.has_group_display_position_ = 1
    self.group_display_position_ = x

  def clear_group_display_position(self):
    self.has_group_display_position_ = 0
    self.group_display_position_ = ""

  def has_group_display_position(self): return self.has_group_display_position_

  def group_impression_tag(self): return self.group_impression_tag_

  def set_group_impression_tag(self, x):
    self.has_group_impression_tag_ = 1
    self.group_impression_tag_ = x

  def clear_group_impression_tag(self):
    self.has_group_impression_tag_ = 0
    self.group_impression_tag_ = ""

  def has_group_impression_tag(self): return self.has_group_impression_tag_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.results_size()): self.add_results().CopyFrom(x.results(i))
    if (x.has_group_ui()): self.set_group_ui(x.group_ui())
    if (x.has_group_display_position()): self.set_group_display_position(x.group_display_position())
    if (x.has_group_impression_tag()): self.set_group_impression_tag(x.group_impression_tag())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.ProseOneboxResultGroup', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.ProseOneboxResultGroup')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.ProseOneboxResultGroup', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.ProseOneboxResultGroup', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.ProseOneboxResultGroup', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.results_) != len(x.results_): return 0
    for e1, e2 in zip(self.results_, x.results_):
      if e1 != e2: return 0
    if self.has_group_ui_ != x.has_group_ui_: return 0
    if self.has_group_ui_ and self.group_ui_ != x.group_ui_: return 0
    if self.has_group_display_position_ != x.has_group_display_position_: return 0
    if self.has_group_display_position_ and self.group_display_position_ != x.group_display_position_: return 0
    if self.has_group_impression_tag_ != x.has_group_impression_tag_: return 0
    if self.has_group_impression_tag_ and self.group_impression_tag_ != x.group_impression_tag_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.results_)):
      if (not self.results_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.results_)
    for i in xrange(len(self.results_)): n += self.lengthString(self.results_[i].ByteSize())
    if (self.has_group_ui_): n += 1 + self.lengthString(len(self.group_ui_))
    if (self.has_group_display_position_): n += 1 + self.lengthString(len(self.group_display_position_))
    if (self.has_group_impression_tag_): n += 1 + self.lengthString(len(self.group_impression_tag_))
    return n + 0

  def Clear(self):
    self.clear_results()
    self.clear_group_ui()
    self.clear_group_display_position()
    self.clear_group_impression_tag()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.results_)):
      out.putVarInt32(10)
      out.putVarInt32(self.results_[i].ByteSize())
      self.results_[i].OutputUnchecked(out)
    if (self.has_group_ui_):
      out.putVarInt32(18)
      out.putPrefixedString(self.group_ui_)
    if (self.has_group_display_position_):
      out.putVarInt32(26)
      out.putPrefixedString(self.group_display_position_)
    if (self.has_group_impression_tag_):
      out.putVarInt32(34)
      out.putPrefixedString(self.group_impression_tag_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_results().TryMerge(tmp)
        continue
      if tt == 18:
        self.set_group_ui(d.getPrefixedString())
        continue
      if tt == 26:
        self.set_group_display_position(d.getPrefixedString())
        continue
      if tt == 34:
        self.set_group_impression_tag(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.results_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("results%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_group_ui_: res+=prefix+("group_ui: %s\n" % self.DebugFormatString(self.group_ui_))
    if self.has_group_display_position_: res+=prefix+("group_display_position: %s\n" % self.DebugFormatString(self.group_display_position_))
    if self.has_group_impression_tag_: res+=prefix+("group_impression_tag: %s\n" % self.DebugFormatString(self.group_impression_tag_))
    return res

  kresults = 1
  kgroup_ui = 2
  kgroup_display_position = 3
  kgroup_impression_tag = 4

  _TEXT = (
   "ErrorCode",  #   0
   "results",  #   1
   "group_ui",  #   2
   "group_display_position",  #   3
   "group_impression_tag",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x21,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x50,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x4f,
    0x6e,
    0x65,
    0x62,
    0x6f,
    0x78,
    0x52,
    0x65,
    0x73,
    0x75,
    0x6c,
    0x74,
    0x47,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x13,
    0x1a,
    0x07,
    0x72,
    0x65,
    0x73,
    0x75,
    0x6c,
    0x74,
    0x73,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x23,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x50,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x4f,
    0x6e,
    0x65,
    0x62,
    0x6f,
    0x78,
    0x50,
    0x72,
    0x6f,
    0x76,
    0x69,
    0x64,
    0x65,
    0x72,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x67,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x5f,
    0x75,
    0x69,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x67,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x5f,
    0x64,
    0x69,
    0x73,
    0x70,
    0x6c,
    0x61,
    0x79,
    0x5f,
    0x70,
    0x6f,
    0x73,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x67,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x5f,
    0x69,
    0x6d,
    0x70,
    0x72,
    0x65,
    0x73,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x74,
    0x61,
    0x67,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0x91,
    0x83,
    0xc9,
    0x02,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class GetOneboxesReply_TextOutput(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.value_ = ""
    self.has_name_ = 0
    self.has_value_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_value()): self.set_value(x.value())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.GetOneboxesReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.GetOneboxesReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.GetOneboxesReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.GetOneboxesReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.GetOneboxesReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    n += self.lengthString(len(self.value_))
    return n + 2

  def Clear(self):
    self.clear_name()
    self.clear_value()

  def OutputUnchecked(self, out):
    out.putVarInt32(58)
    out.putPrefixedString(self.name_)
    out.putVarInt32(66)
    out.putPrefixedString(self.value_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 52: break
      if tt == 58:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 66:
        self.set_value(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_value_: res+=prefix+("value: %s\n" % self.DebugFormatString(self.value_))
    return res

class GetOneboxesReply_UrlOutput(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.name_ = ""
    self.value_ = ""
    self.protocol_ = 0
    self.has_name_ = 0
    self.has_value_ = 0
    self.has_protocol_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_

  def protocol(self): return self.protocol_

  def set_protocol(self, x):
    self.has_protocol_ = 1
    self.protocol_ = x

  def clear_protocol(self):
    self.has_protocol_ = 0
    self.protocol_ = 0

  def has_protocol(self): return self.has_protocol_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_value()): self.set_value(x.value())
    if (x.has_protocol()): self.set_protocol(x.protocol())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.GetOneboxesReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.GetOneboxesReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.GetOneboxesReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.GetOneboxesReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.GetOneboxesReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    if self.has_protocol_ != x.has_protocol_: return 0
    if self.has_protocol_ and self.protocol_ != x.protocol_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    n += self.lengthString(len(self.value_))
    if (self.has_protocol_): n += 1 + self.lengthVarInt64(self.protocol_)
    return n + 2

  def Clear(self):
    self.clear_name()
    self.clear_value()
    self.clear_protocol()

  def OutputUnchecked(self, out):
    out.putVarInt32(82)
    out.putPrefixedString(self.name_)
    out.putVarInt32(90)
    out.putPrefixedString(self.value_)
    if (self.has_protocol_):
      out.putVarInt32(104)
      out.putVarInt32(self.protocol_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 76: break
      if tt == 82:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 90:
        self.set_value(d.getPrefixedString())
        continue
      if tt == 104:
        self.set_protocol(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_value_: res+=prefix+("value: %s\n" % self.DebugFormatString(self.value_))
    if self.has_protocol_: res+=prefix+("protocol: %s\n" % self.DebugFormatInt32(self.protocol_))
    return res

class GetOneboxesReply(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 2311033 

  _TypeId_NAMES = {
    2311033: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)


  HTTP         =    0 
  HTTPS        =    1 
  MAILTO       =    2 
  NEWS         =    3 
  FTP          =    4 

  _UrlProtocol_NAMES = {
    0: "HTTP",
    1: "HTTPS",
    2: "MAILTO",
    3: "NEWS",
    4: "FTP",
  }

  def UrlProtocol_Name(cls, x): return cls._UrlProtocol_NAMES.get(x, "")
  UrlProtocol_Name = classmethod(UrlProtocol_Name)

  def __init__(self, contents=None):
    self.status_ = 0
    self.debug_info_ = None
    self.results_ = []
    self.result_groups_ = []
    self.output_ = ""
    self.provider_ = []
    self.format_ = "none"
    self.textoutput_ = []
    self.urloutput_ = []
    self.has_status_ = 0
    self.has_debug_info_ = 0
    self.has_output_ = 0
    self.has_format_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def debug_info(self):
    if self.debug_info_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.debug_info_ is None: self.debug_info_ = ProseOneboxDebugInfo()
      finally:
        self.lazy_init_lock_.release()
    return self.debug_info_

  def mutable_debug_info(self): self.has_debug_info_ = 1; return self.debug_info()

  def clear_debug_info(self):
    #Warning: this method does not acquire the lock.
    self.has_debug_info_ = 0;
    if self.debug_info_ is not None: self.debug_info_.Clear()

  def has_debug_info(self): return self.has_debug_info_

  def results_size(self): return len(self.results_)
  def results_list(self): return self.results_

  def results(self, i):
    return self.results_[i]

  def mutable_results(self, i):
    return self.results_[i]

  def add_results(self):
    x = ProseOneboxProviderReply()
    self.results_.append(x)
    return x

  def clear_results(self):
    self.results_ = []
  def result_groups_size(self): return len(self.result_groups_)
  def result_groups_list(self): return self.result_groups_

  def result_groups(self, i):
    return self.result_groups_[i]

  def mutable_result_groups(self, i):
    return self.result_groups_[i]

  def add_result_groups(self):
    x = ProseOneboxResultGroup()
    self.result_groups_.append(x)
    return x

  def clear_result_groups(self):
    self.result_groups_ = []
  def output(self): return self.output_

  def set_output(self, x):
    self.has_output_ = 1
    self.output_ = x

  def clear_output(self):
    self.has_output_ = 0
    self.output_ = ""

  def has_output(self): return self.has_output_

  def provider_size(self): return len(self.provider_)
  def provider_list(self): return self.provider_

  def provider(self, i):
    return self.provider_[i]

  def set_provider(self, i, x):
    self.provider_[i] = x

  def add_provider(self, x):
    self.provider_.append(x)

  def clear_provider(self):
    self.provider_ = []

  def format(self): return self.format_

  def set_format(self, x):
    self.has_format_ = 1
    self.format_ = x

  def clear_format(self):
    self.has_format_ = 0
    self.format_ = "none"

  def has_format(self): return self.has_format_

  def textoutput_size(self): return len(self.textoutput_)
  def textoutput_list(self): return self.textoutput_

  def textoutput(self, i):
    return self.textoutput_[i]

  def mutable_textoutput(self, i):
    return self.textoutput_[i]

  def add_textoutput(self):
    x = GetOneboxesReply_TextOutput()
    self.textoutput_.append(x)
    return x

  def clear_textoutput(self):
    self.textoutput_ = []
  def urloutput_size(self): return len(self.urloutput_)
  def urloutput_list(self): return self.urloutput_

  def urloutput(self, i):
    return self.urloutput_[i]

  def mutable_urloutput(self, i):
    return self.urloutput_[i]

  def add_urloutput(self):
    x = GetOneboxesReply_UrlOutput()
    self.urloutput_.append(x)
    return x

  def clear_urloutput(self):
    self.urloutput_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    if (x.has_debug_info()): self.mutable_debug_info().MergeFrom(x.debug_info())
    for i in xrange(x.results_size()): self.add_results().CopyFrom(x.results(i))
    for i in xrange(x.result_groups_size()): self.add_result_groups().CopyFrom(x.result_groups(i))
    if (x.has_output()): self.set_output(x.output())
    for i in xrange(x.provider_size()): self.add_provider(x.provider(i))
    if (x.has_format()): self.set_format(x.format())
    for i in xrange(x.textoutput_size()): self.add_textoutput().CopyFrom(x.textoutput(i))
    for i in xrange(x.urloutput_size()): self.add_urloutput().CopyFrom(x.urloutput(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.GetOneboxesReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.GetOneboxesReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.GetOneboxesReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.GetOneboxesReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.GetOneboxesReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if self.has_debug_info_ != x.has_debug_info_: return 0
    if self.has_debug_info_ and self.debug_info_ != x.debug_info_: return 0
    if len(self.results_) != len(x.results_): return 0
    for e1, e2 in zip(self.results_, x.results_):
      if e1 != e2: return 0
    if len(self.result_groups_) != len(x.result_groups_): return 0
    for e1, e2 in zip(self.result_groups_, x.result_groups_):
      if e1 != e2: return 0
    if self.has_output_ != x.has_output_: return 0
    if self.has_output_ and self.output_ != x.output_: return 0
    if len(self.provider_) != len(x.provider_): return 0
    for e1, e2 in zip(self.provider_, x.provider_):
      if e1 != e2: return 0
    if self.has_format_ != x.has_format_: return 0
    if self.has_format_ and self.format_ != x.format_: return 0
    if len(self.textoutput_) != len(x.textoutput_): return 0
    for e1, e2 in zip(self.textoutput_, x.textoutput_):
      if e1 != e2: return 0
    if len(self.urloutput_) != len(x.urloutput_): return 0
    for e1, e2 in zip(self.urloutput_, x.urloutput_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    if (self.has_debug_info_ and not self.debug_info_.IsInitialized(debug_strs)): initialized = 0
    for i in xrange(len(self.results_)):
      if (not self.results_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.result_groups_)):
      if (not self.result_groups_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.textoutput_)):
      if (not self.textoutput_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.urloutput_)):
      if (not self.urloutput_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    if (self.has_debug_info_): n += 1 + self.lengthString(self.debug_info_.ByteSize())
    n += 1 * len(self.results_)
    for i in xrange(len(self.results_)): n += self.lengthString(self.results_[i].ByteSize())
    n += 1 * len(self.result_groups_)
    for i in xrange(len(self.result_groups_)): n += self.lengthString(self.result_groups_[i].ByteSize())
    if (self.has_output_): n += 1 + self.lengthString(len(self.output_))
    n += 1 * len(self.provider_)
    for i in xrange(len(self.provider_)): n += self.lengthVarInt64(self.provider_[i])
    if (self.has_format_): n += 1 + self.lengthString(len(self.format_))
    n += 2 * len(self.textoutput_)
    for i in xrange(len(self.textoutput_)): n += self.textoutput_[i].ByteSize()
    n += 2 * len(self.urloutput_)
    for i in xrange(len(self.urloutput_)): n += self.urloutput_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_status()
    self.clear_debug_info()
    self.clear_results()
    self.clear_result_groups()
    self.clear_output()
    self.clear_provider()
    self.clear_format()
    self.clear_textoutput()
    self.clear_urloutput()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    if (self.has_output_):
      out.putVarInt32(18)
      out.putPrefixedString(self.output_)
    for i in xrange(len(self.provider_)):
      out.putVarInt32(24)
      out.putVarUint64(self.provider_[i])
    if (self.has_format_):
      out.putVarInt32(42)
      out.putPrefixedString(self.format_)
    for i in xrange(len(self.textoutput_)):
      out.putVarInt32(51)
      self.textoutput_[i].OutputUnchecked(out)
      out.putVarInt32(52)
    for i in xrange(len(self.urloutput_)):
      out.putVarInt32(75)
      self.urloutput_[i].OutputUnchecked(out)
      out.putVarInt32(76)
    if (self.has_debug_info_):
      out.putVarInt32(98)
      out.putVarInt32(self.debug_info_.ByteSize())
      self.debug_info_.OutputUnchecked(out)
    for i in xrange(len(self.results_)):
      out.putVarInt32(114)
      out.putVarInt32(self.results_[i].ByteSize())
      self.results_[i].OutputUnchecked(out)
    for i in xrange(len(self.result_groups_)):
      out.putVarInt32(122)
      out.putVarInt32(self.result_groups_[i].ByteSize())
      self.result_groups_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 18:
        self.set_output(d.getPrefixedString())
        continue
      if tt == 24:
        self.add_provider(d.getVarUint64())
        continue
      if tt == 42:
        self.set_format(d.getPrefixedString())
        continue
      if tt == 51:
        self.add_textoutput().TryMerge(d)
        continue
      if tt == 75:
        self.add_urloutput().TryMerge(d)
        continue
      if tt == 98:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_debug_info().TryMerge(tmp)
        continue
      if tt == 114:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_results().TryMerge(tmp)
        continue
      if tt == 122:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_result_groups().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    if self.has_debug_info_:
      res+=prefix+"debug_info <\n"
      res+=self.debug_info_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.results_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("results%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.result_groups_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("result_groups%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_output_: res+=prefix+("output: %s\n" % self.DebugFormatString(self.output_))
    cnt=0
    for e in self.provider_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("provider%s: %s\n" % (elm, self.DebugFormatInt64(e)))
      cnt+=1
    if self.has_format_: res+=prefix+("format: %s\n" % self.DebugFormatString(self.format_))
    cnt=0
    for e in self.textoutput_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("TextOutput%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.urloutput_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("UrlOutput%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kStatus = 1
  kdebug_info = 12
  kresults = 14
  kresult_groups = 15
  koutput = 2
  kprovider = 3
  kformat = 5
  kTextOutputGroup = 6
  kTextOutputname = 7
  kTextOutputvalue = 8
  kUrlOutputGroup = 9
  kUrlOutputname = 10
  kUrlOutputvalue = 11
  kUrlOutputprotocol = 13

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "output",  #   2
   "provider",  #   3
   None,  #   4
   "format",  #   5
   "TextOutput",  #   6
   "name",  #   7
   "value",  #   8
   "UrlOutput",  #   9
   "name",  #  10
   "value",  #  11
   "debug_info",  #  12
   "protocol",  #  13
   "results",  #  14
   "result_groups",  #  15
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.MAX_TYPE,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STARTGROUP,  #   6

   ProtocolBuffer.Encoder.STRING,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.STARTGROUP,  #   9

   ProtocolBuffer.Encoder.STRING,  #  10

   ProtocolBuffer.Encoder.STRING,  #  11

   ProtocolBuffer.Encoder.STRING,  #  12

   ProtocolBuffer.Encoder.NUMERIC,  #  13

   ProtocolBuffer.Encoder.STRING,  #  14

   ProtocolBuffer.Encoder.STRING,  #  15

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1b,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x47,
    0x65,
    0x74,
    0x4f,
    0x6e,
    0x65,
    0x62,
    0x6f,
    0x78,
    0x65,
    0x73,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x64,
    0x65,
    0x62,
    0x75,
    0x67,
    0x5f,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x0c,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x1f,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x50,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x4f,
    0x6e,
    0x65,
    0x62,
    0x6f,
    0x78,
    0x44,
    0x65,
    0x62,
    0x75,
    0x67,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x72,
    0x65,
    0x73,
    0x75,
    0x6c,
    0x74,
    0x73,
    0x20,
    0x0e,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x23,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x50,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x4f,
    0x6e,
    0x65,
    0x62,
    0x6f,
    0x78,
    0x50,
    0x72,
    0x6f,
    0x76,
    0x69,
    0x64,
    0x65,
    0x72,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x72,
    0x65,
    0x73,
    0x75,
    0x6c,
    0x74,
    0x5f,
    0x67,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x73,
    0x20,
    0x0f,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x21,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x50,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x4f,
    0x6e,
    0x65,
    0x62,
    0x6f,
    0x78,
    0x52,
    0x65,
    0x73,
    0x75,
    0x6c,
    0x74,
    0x47,
    0x72,
    0x6f,
    0x75,
    0x70,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x6f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x42,
    0x00,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x22,
    0x22,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x70,
    0x72,
    0x6f,
    0x76,
    0x69,
    0x64,
    0x65,
    0x72,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x04,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x66,
    0x6f,
    0x72,
    0x6d,
    0x61,
    0x74,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x42,
    0x04,
    0x6e,
    0x6f,
    0x6e,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x06,
    0x22,
    0x6e,
    0x6f,
    0x6e,
    0x65,
    0x22,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x54,
    0x65,
    0x78,
    0x74,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x20,
    0x06,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x54,
    0x65,
    0x78,
    0x74,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x07,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x07,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x54,
    0x65,
    0x78,
    0x74,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x07,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x55,
    0x72,
    0x6c,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x20,
    0x09,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x55,
    0x72,
    0x6c,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x2e,
    0x6e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x0a,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x55,
    0x72,
    0x6c,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x2e,
    0x76,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x0b,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x0a,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x55,
    0x72,
    0x6c,
    0x4f,
    0x75,
    0x74,
    0x70,
    0x75,
    0x74,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x63,
    0x6f,
    0x6c,
    0x20,
    0x0d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0x60,
    0x0a,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xf9,
    0x86,
    0x8d,
    0x01,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x0b,
    0x55,
    0x72,
    0x6c,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x63,
    0x6f,
    0x6c,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x04,
    0x48,
    0x54,
    0x54,
    0x50,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x05,
    0x48,
    0x54,
    0x54,
    0x50,
    0x53,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x06,
    0x4d,
    0x41,
    0x49,
    0x4c,
    0x54,
    0x4f,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x04,
    0x4e,
    0x45,
    0x57,
    0x53,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x03,
    0x46,
    0x54,
    0x50,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchAnnotationsForFieldRequest(ProtocolBuffer.ProtocolMessage):

  LABEL        =    0 
  URL          =    1 
  QUERY        =    2 

  _FIELD_TYPE_NAMES = {
    0: "LABEL",
    1: "URL",
    2: "QUERY",
  }

  def FIELD_TYPE_Name(cls, x): return cls._FIELD_TYPE_NAMES.get(x, "")
  FIELD_TYPE_Name = classmethod(FIELD_TYPE_Name)


  LABEL_POPULARITY =    0 
  TIMESTAMP    =    1 
  RATING       =    2 

  _ANNOTATION_SORT_CRITERIA_NAMES = {
    0: "LABEL_POPULARITY",
    1: "TIMESTAMP",
    2: "RATING",
  }

  def ANNOTATION_SORT_CRITERIA_Name(cls, x): return cls._ANNOTATION_SORT_CRITERIA_NAMES.get(x, "")
  ANNOTATION_SORT_CRITERIA_Name = classmethod(ANNOTATION_SORT_CRITERIA_Name)

  def __init__(self, contents=None):
    self.application_ = 0
    self.fieldtype_ = 0
    self.fieldvalue_ = ""
    self.numannotations_ = 100
    self.sortannotationby_ = 1
    self.has_application_ = 0
    self.has_fieldtype_ = 0
    self.has_fieldvalue_ = 0
    self.has_numannotations_ = 0
    self.has_sortannotationby_ = 0
    if contents is not None: self.MergeFromString(contents)

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def fieldtype(self): return self.fieldtype_

  def set_fieldtype(self, x):
    self.has_fieldtype_ = 1
    self.fieldtype_ = x

  def clear_fieldtype(self):
    self.has_fieldtype_ = 0
    self.fieldtype_ = 0

  def has_fieldtype(self): return self.has_fieldtype_

  def fieldvalue(self): return self.fieldvalue_

  def set_fieldvalue(self, x):
    self.has_fieldvalue_ = 1
    self.fieldvalue_ = x

  def clear_fieldvalue(self):
    self.has_fieldvalue_ = 0
    self.fieldvalue_ = ""

  def has_fieldvalue(self): return self.has_fieldvalue_

  def numannotations(self): return self.numannotations_

  def set_numannotations(self, x):
    self.has_numannotations_ = 1
    self.numannotations_ = x

  def clear_numannotations(self):
    self.has_numannotations_ = 0
    self.numannotations_ = 100

  def has_numannotations(self): return self.has_numannotations_

  def sortannotationby(self): return self.sortannotationby_

  def set_sortannotationby(self, x):
    self.has_sortannotationby_ = 1
    self.sortannotationby_ = x

  def clear_sortannotationby(self):
    self.has_sortannotationby_ = 0
    self.sortannotationby_ = 1

  def has_sortannotationby(self): return self.has_sortannotationby_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_application()): self.set_application(x.application())
    if (x.has_fieldtype()): self.set_fieldtype(x.fieldtype())
    if (x.has_fieldvalue()): self.set_fieldvalue(x.fieldvalue())
    if (x.has_numannotations()): self.set_numannotations(x.numannotations())
    if (x.has_sortannotationby()): self.set_sortannotationby(x.sortannotationby())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchAnnotationsForFieldRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchAnnotationsForFieldRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchAnnotationsForFieldRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchAnnotationsForFieldRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchAnnotationsForFieldRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_fieldtype_ != x.has_fieldtype_: return 0
    if self.has_fieldtype_ and self.fieldtype_ != x.fieldtype_: return 0
    if self.has_fieldvalue_ != x.has_fieldvalue_: return 0
    if self.has_fieldvalue_ and self.fieldvalue_ != x.fieldvalue_: return 0
    if self.has_numannotations_ != x.has_numannotations_: return 0
    if self.has_numannotations_ and self.numannotations_ != x.numannotations_: return 0
    if self.has_sortannotationby_ != x.has_sortannotationby_: return 0
    if self.has_sortannotationby_ and self.sortannotationby_ != x.sortannotationby_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    if (not self.has_fieldtype_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: fieldtype not set.')
    if (not self.has_fieldvalue_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: fieldvalue not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.application_)
    n += self.lengthVarInt64(self.fieldtype_)
    n += self.lengthString(len(self.fieldvalue_))
    if (self.has_numannotations_): n += 1 + self.lengthVarInt64(self.numannotations_)
    if (self.has_sortannotationby_): n += 1 + self.lengthVarInt64(self.sortannotationby_)
    return n + 3

  def Clear(self):
    self.clear_application()
    self.clear_fieldtype()
    self.clear_fieldvalue()
    self.clear_numannotations()
    self.clear_sortannotationby()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.application_)
    out.putVarInt32(16)
    out.putVarInt32(self.fieldtype_)
    out.putVarInt32(26)
    out.putPrefixedString(self.fieldvalue_)
    if (self.has_numannotations_):
      out.putVarInt32(32)
      out.putVarInt32(self.numannotations_)
    if (self.has_sortannotationby_):
      out.putVarInt32(40)
      out.putVarInt32(self.sortannotationby_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_application(d.getVarInt32())
        continue
      if tt == 16:
        self.set_fieldtype(d.getVarInt32())
        continue
      if tt == 26:
        self.set_fieldvalue(d.getPrefixedString())
        continue
      if tt == 32:
        self.set_numannotations(d.getVarInt32())
        continue
      if tt == 40:
        self.set_sortannotationby(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_fieldtype_: res+=prefix+("FieldType: %s\n" % self.DebugFormatInt32(self.fieldtype_))
    if self.has_fieldvalue_: res+=prefix+("FieldValue: %s\n" % self.DebugFormatString(self.fieldvalue_))
    if self.has_numannotations_: res+=prefix+("NumAnnotations: %s\n" % self.DebugFormatInt32(self.numannotations_))
    if self.has_sortannotationby_: res+=prefix+("SortAnnotationBy: %s\n" % self.DebugFormatInt32(self.sortannotationby_))
    return res

  kApplication = 1
  kFieldType = 2
  kFieldValue = 3
  kNumAnnotations = 4
  kSortAnnotationBy = 5

  _TEXT = (
   "ErrorCode",  #   0
   "Application",  #   1
   "FieldType",  #   2
   "FieldValue",  #   3
   "NumAnnotations",  #   4
   "SortAnnotationBy",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x2a,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x46,
    0x6f,
    0x72,
    0x46,
    0x69,
    0x65,
    0x6c,
    0x64,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x46,
    0x69,
    0x65,
    0x6c,
    0x64,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x68,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x46,
    0x69,
    0x65,
    0x6c,
    0x64,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x4e,
    0x75,
    0x6d,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x03,
    0x31,
    0x30,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x31,
    0x30,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x53,
    0x6f,
    0x72,
    0x74,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x42,
    0x79,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x31,
    0x68,
    0x01,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x09,
    0x54,
    0x49,
    0x4d,
    0x45,
    0x53,
    0x54,
    0x41,
    0x4d,
    0x50,
    0xa4,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x0a,
    0x46,
    0x49,
    0x45,
    0x4c,
    0x44,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x05,
    0x4c,
    0x41,
    0x42,
    0x45,
    0x4c,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x03,
    0x55,
    0x52,
    0x4c,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x05,
    0x51,
    0x55,
    0x45,
    0x52,
    0x59,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x18,
    0x41,
    0x4e,
    0x4e,
    0x4f,
    0x54,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x53,
    0x4f,
    0x52,
    0x54,
    0x5f,
    0x43,
    0x52,
    0x49,
    0x54,
    0x45,
    0x52,
    0x49,
    0x41,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x4c,
    0x41,
    0x42,
    0x45,
    0x4c,
    0x5f,
    0x50,
    0x4f,
    0x50,
    0x55,
    0x4c,
    0x41,
    0x52,
    0x49,
    0x54,
    0x59,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x54,
    0x49,
    0x4d,
    0x45,
    0x53,
    0x54,
    0x41,
    0x4d,
    0x50,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x06,
    0x52,
    0x41,
    0x54,
    0x49,
    0x4e,
    0x47,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchAnnotationsForFieldReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.annotations_ = []
    self.has_status_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def annotations_size(self): return len(self.annotations_)
  def annotations_list(self): return self.annotations_

  def annotations(self, i):
    return self.annotations_[i]

  def mutable_annotations(self, i):
    return self.annotations_[i]

  def add_annotations(self):
    x = AnnotationProto()
    self.annotations_.append(x)
    return x

  def clear_annotations(self):
    self.annotations_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    for i in xrange(x.annotations_size()): self.add_annotations().CopyFrom(x.annotations(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchAnnotationsForFieldReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchAnnotationsForFieldReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchAnnotationsForFieldReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchAnnotationsForFieldReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchAnnotationsForFieldReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if len(self.annotations_) != len(x.annotations_): return 0
    for e1, e2 in zip(self.annotations_, x.annotations_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    for i in xrange(len(self.annotations_)):
      if (not self.annotations_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    n += 1 * len(self.annotations_)
    for i in xrange(len(self.annotations_)): n += self.lengthString(self.annotations_[i].ByteSize())
    return n + 1

  def Clear(self):
    self.clear_status()
    self.clear_annotations()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    for i in xrange(len(self.annotations_)):
      out.putVarInt32(18)
      out.putVarInt32(self.annotations_[i].ByteSize())
      self.annotations_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_annotations().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    cnt=0
    for e in self.annotations_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Annotations%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

  kStatus = 1
  kAnnotations = 2

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "Annotations",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x28,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x46,
    0x6f,
    0x72,
    0x46,
    0x69,
    0x65,
    0x6c,
    0x64,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x1a,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class InvalidateUserRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.users_ = []
    self.application_ = 0
    self.shouldbroadcast_ = 0
    self.has_application_ = 0
    self.has_shouldbroadcast_ = 0
    if contents is not None: self.MergeFromString(contents)

  def users_size(self): return len(self.users_)
  def users_list(self): return self.users_

  def users(self, i):
    return self.users_[i]

  def mutable_users(self, i):
    return self.users_[i]

  def add_users(self):
    x = UserKeyProto()
    self.users_.append(x)
    return x

  def clear_users(self):
    self.users_ = []
  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def shouldbroadcast(self): return self.shouldbroadcast_

  def set_shouldbroadcast(self, x):
    self.has_shouldbroadcast_ = 1
    self.shouldbroadcast_ = x

  def clear_shouldbroadcast(self):
    self.has_shouldbroadcast_ = 0
    self.shouldbroadcast_ = 0

  def has_shouldbroadcast(self): return self.has_shouldbroadcast_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.users_size()): self.add_users().CopyFrom(x.users(i))
    if (x.has_application()): self.set_application(x.application())
    if (x.has_shouldbroadcast()): self.set_shouldbroadcast(x.shouldbroadcast())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.InvalidateUserRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.InvalidateUserRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.InvalidateUserRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.InvalidateUserRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.InvalidateUserRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.users_) != len(x.users_): return 0
    for e1, e2 in zip(self.users_, x.users_):
      if e1 != e2: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_shouldbroadcast_ != x.has_shouldbroadcast_: return 0
    if self.has_shouldbroadcast_ and self.shouldbroadcast_ != x.shouldbroadcast_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.users_)):
      if (not self.users_[i].IsInitialized(debug_strs)): initialized=0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.users_)
    for i in xrange(len(self.users_)): n += self.lengthString(self.users_[i].ByteSize())
    n += self.lengthVarInt64(self.application_)
    if (self.has_shouldbroadcast_): n += 2
    return n + 1

  def Clear(self):
    self.clear_users()
    self.clear_application()
    self.clear_shouldbroadcast()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.users_)):
      out.putVarInt32(10)
      out.putVarInt32(self.users_[i].ByteSize())
      self.users_[i].OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)
    if (self.has_shouldbroadcast_):
      out.putVarInt32(24)
      out.putBoolean(self.shouldbroadcast_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_users().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      if tt == 24:
        self.set_shouldbroadcast(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.users_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Users%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_shouldbroadcast_: res+=prefix+("ShouldBroadcast: %s\n" % self.DebugFormatBool(self.shouldbroadcast_))
    return res

  kUsers = 1
  kApplication = 2
  kShouldBroadcast = 3

  _TEXT = (
   "ErrorCode",  #   0
   "Users",  #   1
   "Application",  #   2
   "ShouldBroadcast",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x20,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x49,
    0x6e,
    0x76,
    0x61,
    0x6c,
    0x69,
    0x64,
    0x61,
    0x74,
    0x65,
    0x55,
    0x73,
    0x65,
    0x72,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x05,
    0x55,
    0x73,
    0x65,
    0x72,
    0x73,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x53,
    0x68,
    0x6f,
    0x75,
    0x6c,
    0x64,
    0x42,
    0x72,
    0x6f,
    0x61,
    0x64,
    0x63,
    0x61,
    0x73,
    0x74,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class InvalidateUserReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.has_status_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.InvalidateUserReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.InvalidateUserReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.InvalidateUserReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.InvalidateUserReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.InvalidateUserReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    return n + 1

  def Clear(self):
    self.clear_status()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    return res

  kStatus = 1

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1e,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x49,
    0x6e,
    0x76,
    0x61,
    0x6c,
    0x69,
    0x64,
    0x61,
    0x74,
    0x65,
    0x55,
    0x73,
    0x65,
    0x72,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class GetTrusteeDocumentDataRequest_Users(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.weight_ = 1.0
    self.has_user_ = 0
    self.has_weight_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def weight(self): return self.weight_

  def set_weight(self, x):
    self.has_weight_ = 1
    self.weight_ = x

  def clear_weight(self):
    self.has_weight_ = 0
    self.weight_ = 1.0

  def has_weight(self): return self.has_weight_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_weight()): self.set_weight(x.weight())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.GetTrusteeDocumentDataRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.GetTrusteeDocumentDataRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.GetTrusteeDocumentDataRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.GetTrusteeDocumentDataRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.GetTrusteeDocumentDataRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_weight_ != x.has_weight_: return 0
    if self.has_weight_ and self.weight_ != x.weight_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    if (self.has_weight_): n += 5
    return n + 1

  def Clear(self):
    self.clear_user()
    self.clear_weight()

  def OutputUnchecked(self, out):
    out.putVarInt32(18)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    if (self.has_weight_):
      out.putVarInt32(29)
      out.putFloat(self.weight_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 29:
        self.set_weight(d.getFloat())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_weight_: res+=prefix+("Weight: %s\n" % self.DebugFormatFloat(self.weight_))
    return res

class GetTrusteeDocumentDataRequest(ProtocolBuffer.ProtocolMessage):

  DOCUMENT_SCORES =    0 
  URL_ANNOTATIONS =    1 
  USER_LABELED_URLS =    2 

  _DataType_NAMES = {
    0: "DOCUMENT_SCORES",
    1: "URL_ANNOTATIONS",
    2: "USER_LABELED_URLS",
  }

  def DataType_Name(cls, x): return cls._DataType_NAMES.get(x, "")
  DataType_Name = classmethod(DataType_Name)

  def __init__(self, contents=None):
    self.users_ = []
    self.documents_ = []
    self.label_ = []
    self.application_ = 0
    self.datatype_ = 0
    self.trustlevel_ = 0
    self.has_application_ = 0
    self.has_datatype_ = 0
    self.has_trustlevel_ = 0
    if contents is not None: self.MergeFromString(contents)

  def users_size(self): return len(self.users_)
  def users_list(self): return self.users_

  def users(self, i):
    return self.users_[i]

  def mutable_users(self, i):
    return self.users_[i]

  def add_users(self):
    x = GetTrusteeDocumentDataRequest_Users()
    self.users_.append(x)
    return x

  def clear_users(self):
    self.users_ = []
  def documents_size(self): return len(self.documents_)
  def documents_list(self): return self.documents_

  def documents(self, i):
    return self.documents_[i]

  def mutable_documents(self, i):
    return self.documents_[i]

  def add_documents(self):
    x = DocumentProto()
    self.documents_.append(x)
    return x

  def clear_documents(self):
    self.documents_ = []
  def label_size(self): return len(self.label_)
  def label_list(self): return self.label_

  def label(self, i):
    return self.label_[i]

  def set_label(self, i, x):
    self.label_[i] = x

  def add_label(self, x):
    self.label_.append(x)

  def clear_label(self):
    self.label_ = []

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def datatype(self): return self.datatype_

  def set_datatype(self, x):
    self.has_datatype_ = 1
    self.datatype_ = x

  def clear_datatype(self):
    self.has_datatype_ = 0
    self.datatype_ = 0

  def has_datatype(self): return self.has_datatype_

  def trustlevel(self): return self.trustlevel_

  def set_trustlevel(self, x):
    self.has_trustlevel_ = 1
    self.trustlevel_ = x

  def clear_trustlevel(self):
    self.has_trustlevel_ = 0
    self.trustlevel_ = 0

  def has_trustlevel(self): return self.has_trustlevel_


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.users_size()): self.add_users().CopyFrom(x.users(i))
    for i in xrange(x.documents_size()): self.add_documents().CopyFrom(x.documents(i))
    for i in xrange(x.label_size()): self.add_label(x.label(i))
    if (x.has_application()): self.set_application(x.application())
    if (x.has_datatype()): self.set_datatype(x.datatype())
    if (x.has_trustlevel()): self.set_trustlevel(x.trustlevel())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.GetTrusteeDocumentDataRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.GetTrusteeDocumentDataRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.GetTrusteeDocumentDataRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.GetTrusteeDocumentDataRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.GetTrusteeDocumentDataRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.users_) != len(x.users_): return 0
    for e1, e2 in zip(self.users_, x.users_):
      if e1 != e2: return 0
    if len(self.documents_) != len(x.documents_): return 0
    for e1, e2 in zip(self.documents_, x.documents_):
      if e1 != e2: return 0
    if len(self.label_) != len(x.label_): return 0
    for e1, e2 in zip(self.label_, x.label_):
      if e1 != e2: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if self.has_datatype_ != x.has_datatype_: return 0
    if self.has_datatype_ and self.datatype_ != x.datatype_: return 0
    if self.has_trustlevel_ != x.has_trustlevel_: return 0
    if self.has_trustlevel_ and self.trustlevel_ != x.trustlevel_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.users_)):
      if (not self.users_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.documents_)):
      if (not self.documents_[i].IsInitialized(debug_strs)): initialized=0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    if (not self.has_datatype_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: datatype not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * len(self.users_)
    for i in xrange(len(self.users_)): n += self.users_[i].ByteSize()
    n += 1 * len(self.documents_)
    for i in xrange(len(self.documents_)): n += self.lengthString(self.documents_[i].ByteSize())
    n += 1 * len(self.label_)
    for i in xrange(len(self.label_)): n += self.lengthString(len(self.label_[i]))
    n += self.lengthVarInt64(self.application_)
    n += self.lengthVarInt64(self.datatype_)
    if (self.has_trustlevel_): n += 1 + self.lengthVarInt64(self.trustlevel_)
    return n + 2

  def Clear(self):
    self.clear_users()
    self.clear_documents()
    self.clear_label()
    self.clear_application()
    self.clear_datatype()
    self.clear_trustlevel()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.users_)):
      out.putVarInt32(11)
      self.users_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    for i in xrange(len(self.documents_)):
      out.putVarInt32(34)
      out.putVarInt32(self.documents_[i].ByteSize())
      self.documents_[i].OutputUnchecked(out)
    for i in xrange(len(self.label_)):
      out.putVarInt32(42)
      out.putPrefixedString(self.label_[i])
    out.putVarInt32(48)
    out.putVarInt32(self.application_)
    out.putVarInt32(56)
    out.putVarInt32(self.datatype_)
    if (self.has_trustlevel_):
      out.putVarInt32(64)
      out.putVarInt32(self.trustlevel_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_users().TryMerge(d)
        continue
      if tt == 34:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_documents().TryMerge(tmp)
        continue
      if tt == 42:
        self.add_label(d.getPrefixedString())
        continue
      if tt == 48:
        self.set_application(d.getVarInt32())
        continue
      if tt == 56:
        self.set_datatype(d.getVarInt32())
        continue
      if tt == 64:
        self.set_trustlevel(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.users_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Users%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.documents_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Documents%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.label_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Label%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    if self.has_datatype_: res+=prefix+("DataType: %s\n" % self.DebugFormatInt32(self.datatype_))
    if self.has_trustlevel_: res+=prefix+("TrustLevel: %s\n" % self.DebugFormatInt32(self.trustlevel_))
    return res

  kUsersGroup = 1
  kUsersUser = 2
  kUsersWeight = 3
  kDocuments = 4
  kLabel = 5
  kApplication = 6
  kDataType = 7
  kTrustLevel = 8

  _TEXT = (
   "ErrorCode",  #   0
   "Users",  #   1
   "User",  #   2
   "Weight",  #   3
   "Documents",  #   4
   "Label",  #   5
   "Application",  #   6
   "DataType",  #   7
   "TrustLevel",  #   8
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.FLOAT,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.NUMERIC,  #   8

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x28,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x47,
    0x65,
    0x74,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x65,
    0x65,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x44,
    0x61,
    0x74,
    0x61,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x05,
    0x55,
    0x73,
    0x65,
    0x72,
    0x73,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x55,
    0x73,
    0x65,
    0x72,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x60,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x55,
    0x73,
    0x65,
    0x72,
    0x73,
    0x2e,
    0x57,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x03,
    0x28,
    0x05,
    0x30,
    0x02,
    0x38,
    0x01,
    0x42,
    0x03,
    0x31,
    0x2e,
    0x30,
    0x60,
    0x00,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x03,
    0x31,
    0x2e,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x18,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x4c,
    0x61,
    0x62,
    0x65,
    0x6c,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x44,
    0x61,
    0x74,
    0x61,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x20,
    0x08,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x08,
    0x44,
    0x61,
    0x74,
    0x61,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x44,
    0x4f,
    0x43,
    0x55,
    0x4d,
    0x45,
    0x4e,
    0x54,
    0x5f,
    0x53,
    0x43,
    0x4f,
    0x52,
    0x45,
    0x53,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x55,
    0x52,
    0x4c,
    0x5f,
    0x41,
    0x4e,
    0x4e,
    0x4f,
    0x54,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x53,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x55,
    0x53,
    0x45,
    0x52,
    0x5f,
    0x4c,
    0x41,
    0x42,
    0x45,
    0x4c,
    0x45,
    0x44,
    0x5f,
    0x55,
    0x52,
    0x4c,
    0x53,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchDataForAnnotationsToDeleteReply_AnnotationData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.url_ = ""
    self.kansastimestamp_ = 0
    self.has_url_ = 0
    self.has_kansastimestamp_ = 0
    if contents is not None: self.MergeFromString(contents)

  def url(self): return self.url_

  def set_url(self, x):
    self.has_url_ = 1
    self.url_ = x

  def clear_url(self):
    self.has_url_ = 0
    self.url_ = ""

  def has_url(self): return self.has_url_

  def kansastimestamp(self): return self.kansastimestamp_

  def set_kansastimestamp(self, x):
    self.has_kansastimestamp_ = 1
    self.kansastimestamp_ = x

  def clear_kansastimestamp(self):
    self.has_kansastimestamp_ = 0
    self.kansastimestamp_ = 0

  def has_kansastimestamp(self): return self.has_kansastimestamp_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_url()): self.set_url(x.url())
    if (x.has_kansastimestamp()): self.set_kansastimestamp(x.kansastimestamp())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchDataForAnnotationsToDeleteReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchDataForAnnotationsToDeleteReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchDataForAnnotationsToDeleteReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchDataForAnnotationsToDeleteReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchDataForAnnotationsToDeleteReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_url_ != x.has_url_: return 0
    if self.has_url_ and self.url_ != x.url_: return 0
    if self.has_kansastimestamp_ != x.has_kansastimestamp_: return 0
    if self.has_kansastimestamp_ and self.kansastimestamp_ != x.kansastimestamp_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_url_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: url not set.')
    if (not self.has_kansastimestamp_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: kansastimestamp not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.url_))
    n += self.lengthVarInt64(self.kansastimestamp_)
    return n + 2

  def Clear(self):
    self.clear_url()
    self.clear_kansastimestamp()

  def OutputUnchecked(self, out):
    out.putVarInt32(34)
    out.putPrefixedString(self.url_)
    out.putVarInt32(40)
    out.putVarInt64(self.kansastimestamp_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 28: break
      if tt == 34:
        self.set_url(d.getPrefixedString())
        continue
      if tt == 40:
        self.set_kansastimestamp(d.getVarInt64())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_url_: res+=prefix+("Url: %s\n" % self.DebugFormatString(self.url_))
    if self.has_kansastimestamp_: res+=prefix+("KansasTimestamp: %s\n" % self.DebugFormatInt64(self.kansastimestamp_))
    return res

class FetchDataForAnnotationsToDeleteReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.application_ = 0
    self.annotationdata_ = []
    self.has_status_ = 0
    self.has_application_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def annotationdata_size(self): return len(self.annotationdata_)
  def annotationdata_list(self): return self.annotationdata_

  def annotationdata(self, i):
    return self.annotationdata_[i]

  def mutable_annotationdata(self, i):
    return self.annotationdata_[i]

  def add_annotationdata(self):
    x = FetchDataForAnnotationsToDeleteReply_AnnotationData()
    self.annotationdata_.append(x)
    return x

  def clear_annotationdata(self):
    self.annotationdata_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    if (x.has_application()): self.set_application(x.application())
    for i in xrange(x.annotationdata_size()): self.add_annotationdata().CopyFrom(x.annotationdata(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchDataForAnnotationsToDeleteReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchDataForAnnotationsToDeleteReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchDataForAnnotationsToDeleteReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchDataForAnnotationsToDeleteReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchDataForAnnotationsToDeleteReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if len(self.annotationdata_) != len(x.annotationdata_): return 0
    for e1, e2 in zip(self.annotationdata_, x.annotationdata_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    for i in xrange(len(self.annotationdata_)):
      if (not self.annotationdata_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    n += self.lengthVarInt64(self.application_)
    n += 2 * len(self.annotationdata_)
    for i in xrange(len(self.annotationdata_)): n += self.annotationdata_[i].ByteSize()
    return n + 2

  def Clear(self):
    self.clear_status()
    self.clear_application()
    self.clear_annotationdata()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)
    for i in xrange(len(self.annotationdata_)):
      out.putVarInt32(27)
      self.annotationdata_[i].OutputUnchecked(out)
      out.putVarInt32(28)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      if tt == 27:
        self.add_annotationdata().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    cnt=0
    for e in self.annotationdata_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("AnnotationData%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kStatus = 1
  kApplication = 2
  kAnnotationDataGroup = 3
  kAnnotationDataUrl = 4
  kAnnotationDataKansasTimestamp = 5

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "Application",  #   2
   "AnnotationData",  #   3
   "Url",  #   4
   "KansasTimestamp",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STARTGROUP,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x2f,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x44,
    0x61,
    0x74,
    0x61,
    0x46,
    0x6f,
    0x72,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x54,
    0x6f,
    0x44,
    0x65,
    0x6c,
    0x65,
    0x74,
    0x65,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x03,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x12,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x55,
    0x72,
    0x6c,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x41,
    0x6e,
    0x6e,
    0x6f,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x4b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x54,
    0x69,
    0x6d,
    0x65,
    0x73,
    0x74,
    0x61,
    0x6d,
    0x70,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class GetTrusteeDocumentDataReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.documents_ = []
    self.has_status_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def documents_size(self): return len(self.documents_)
  def documents_list(self): return self.documents_

  def documents(self, i):
    return self.documents_[i]

  def mutable_documents(self, i):
    return self.documents_[i]

  def add_documents(self):
    x = DocumentProto()
    self.documents_.append(x)
    return x

  def clear_documents(self):
    self.documents_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    for i in xrange(x.documents_size()): self.add_documents().CopyFrom(x.documents(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.GetTrusteeDocumentDataReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.GetTrusteeDocumentDataReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.GetTrusteeDocumentDataReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.GetTrusteeDocumentDataReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.GetTrusteeDocumentDataReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if len(self.documents_) != len(x.documents_): return 0
    for e1, e2 in zip(self.documents_, x.documents_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    for i in xrange(len(self.documents_)):
      if (not self.documents_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    n += 1 * len(self.documents_)
    for i in xrange(len(self.documents_)): n += self.lengthString(self.documents_[i].ByteSize())
    return n + 1

  def Clear(self):
    self.clear_status()
    self.clear_documents()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    for i in xrange(len(self.documents_)):
      out.putVarInt32(18)
      out.putVarInt32(self.documents_[i].ByteSize())
      self.documents_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_documents().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    cnt=0
    for e in self.documents_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Documents%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

  kStatus = 1
  kDocuments = 2

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "Documents",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x26,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x47,
    0x65,
    0x74,
    0x54,
    0x72,
    0x75,
    0x73,
    0x74,
    0x65,
    0x65,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x44,
    0x61,
    0x74,
    0x61,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x18,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class GetUserDebugStringRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.application_ = 0
    self.has_user_ = 0
    self.has_application_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    if (x.has_application()): self.set_application(x.application())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.GetUserDebugStringRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.GetUserDebugStringRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.GetUserDebugStringRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.GetUserDebugStringRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.GetUserDebugStringRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += self.lengthVarInt64(self.application_)
    return n + 2

  def Clear(self):
    self.clear_user()
    self.clear_application()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    return res

  kUser = 1
  kApplication = 2

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Application",  #   2
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x24,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x47,
    0x65,
    0x74,
    0x55,
    0x73,
    0x65,
    0x72,
    0x44,
    0x65,
    0x62,
    0x75,
    0x67,
    0x53,
    0x74,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class GetUserDebugStringReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.debugstring_ = ""
    self.has_debugstring_ = 0
    if contents is not None: self.MergeFromString(contents)

  def debugstring(self): return self.debugstring_

  def set_debugstring(self, x):
    self.has_debugstring_ = 1
    self.debugstring_ = x

  def clear_debugstring(self):
    self.has_debugstring_ = 0
    self.debugstring_ = ""

  def has_debugstring(self): return self.has_debugstring_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_debugstring()): self.set_debugstring(x.debugstring())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.GetUserDebugStringReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.GetUserDebugStringReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.GetUserDebugStringReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.GetUserDebugStringReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.GetUserDebugStringReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_debugstring_ != x.has_debugstring_: return 0
    if self.has_debugstring_ and self.debugstring_ != x.debugstring_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_debugstring_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: debugstring not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.debugstring_))
    return n + 1

  def Clear(self):
    self.clear_debugstring()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.debugstring_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_debugstring(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_debugstring_: res+=prefix+("DebugString: %s\n" % self.DebugFormatString(self.debugstring_))
    return res

  kDebugString = 1

  _TEXT = (
   "ErrorCode",  #   0
   "DebugString",  #   1
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x22,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x47,
    0x65,
    0x74,
    0x55,
    0x73,
    0x65,
    0x72,
    0x44,
    0x65,
    0x62,
    0x75,
    0x67,
    0x53,
    0x74,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x0b,
    0x44,
    0x65,
    0x62,
    0x75,
    0x67,
    0x53,
    0x74,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class VerboseFlagLevel(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.v_ = 0
    self.has_v_ = 0
    if contents is not None: self.MergeFromString(contents)

  def v(self): return self.v_

  def set_v(self, x):
    self.has_v_ = 1
    self.v_ = x

  def clear_v(self):
    self.has_v_ = 0
    self.v_ = 0

  def has_v(self): return self.has_v_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_v()): self.set_v(x.v())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.VerboseFlagLevel', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.VerboseFlagLevel')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.VerboseFlagLevel', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.VerboseFlagLevel', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.VerboseFlagLevel', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_v_ != x.has_v_: return 0
    if self.has_v_ and self.v_ != x.v_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_v_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: v not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.v_)
    return n + 1

  def Clear(self):
    self.clear_v()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.v_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_v(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_v_: res+=prefix+("v: %s\n" % self.DebugFormatInt32(self.v_))
    return res

  kv = 1

  _TEXT = (
   "ErrorCode",  #   0
   "v",  #   1
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x1b,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x56,
    0x65,
    0x72,
    0x62,
    0x6f,
    0x73,
    0x65,
    0x46,
    0x6c,
    0x61,
    0x67,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x13,
    0x1a,
    0x01,
    0x76,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchFocusProfileDataRequest(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = []
    self.application_ = 0
    self.datakey_ = []
    self.has_application_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user_size(self): return len(self.user_)
  def user_list(self): return self.user_

  def user(self, i):
    return self.user_[i]

  def mutable_user(self, i):
    return self.user_[i]

  def add_user(self):
    x = UserKeyProto()
    self.user_.append(x)
    return x

  def clear_user(self):
    self.user_ = []
  def application(self): return self.application_

  def set_application(self, x):
    self.has_application_ = 1
    self.application_ = x

  def clear_application(self):
    self.has_application_ = 0
    self.application_ = 0

  def has_application(self): return self.has_application_

  def datakey_size(self): return len(self.datakey_)
  def datakey_list(self): return self.datakey_

  def datakey(self, i):
    return self.datakey_[i]

  def set_datakey(self, i, x):
    self.datakey_[i] = x

  def add_datakey(self, x):
    self.datakey_.append(x)

  def clear_datakey(self):
    self.datakey_ = []


  def MergeFrom(self, x):
    assert x is not self
    for i in xrange(x.user_size()): self.add_user().CopyFrom(x.user(i))
    if (x.has_application()): self.set_application(x.application())
    for i in xrange(x.datakey_size()): self.add_datakey(x.datakey(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchFocusProfileDataRequest', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchFocusProfileDataRequest')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchFocusProfileDataRequest', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchFocusProfileDataRequest', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchFocusProfileDataRequest', s)


  def Equals(self, x):
    if x is self: return 1
    if len(self.user_) != len(x.user_): return 0
    for e1, e2 in zip(self.user_, x.user_):
      if e1 != e2: return 0
    if self.has_application_ != x.has_application_: return 0
    if self.has_application_ and self.application_ != x.application_: return 0
    if len(self.datakey_) != len(x.datakey_): return 0
    for e1, e2 in zip(self.datakey_, x.datakey_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.user_)):
      if (not self.user_[i].IsInitialized(debug_strs)): initialized=0
    if (not self.has_application_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: application not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * len(self.user_)
    for i in xrange(len(self.user_)): n += self.lengthString(self.user_[i].ByteSize())
    n += self.lengthVarInt64(self.application_)
    n += 1 * len(self.datakey_)
    for i in xrange(len(self.datakey_)): n += self.lengthString(len(self.datakey_[i]))
    return n + 1

  def Clear(self):
    self.clear_user()
    self.clear_application()
    self.clear_datakey()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.user_)):
      out.putVarInt32(10)
      out.putVarInt32(self.user_[i].ByteSize())
      self.user_[i].OutputUnchecked(out)
    out.putVarInt32(16)
    out.putVarInt32(self.application_)
    for i in xrange(len(self.datakey_)):
      out.putVarInt32(26)
      out.putPrefixedString(self.datakey_[i])

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_user().TryMerge(tmp)
        continue
      if tt == 16:
        self.set_application(d.getVarInt32())
        continue
      if tt == 26:
        self.add_datakey(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in self.user_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("User%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_application_: res+=prefix+("Application: %s\n" % self.DebugFormatInt32(self.application_))
    cnt=0
    for e in self.datakey_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("DataKey%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    return res

  kUser = 1
  kApplication = 2
  kDataKey = 3

  _TEXT = (
   "ErrorCode",  #   0
   "User",  #   1
   "Application",  #   2
   "DataKey",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x27,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x46,
    0x6f,
    0x63,
    0x75,
    0x73,
    0x50,
    0x72,
    0x6f,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x52,
    0x65,
    0x71,
    0x75,
    0x65,
    0x73,
    0x74,
    0x13,
    0x1a,
    0x04,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x41,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x44,
    0x61,
    0x74,
    0x61,
    0x4b,
    0x65,
    0x79,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class FetchFocusProfileDataReply_UserProfileData(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.user_ = UserKeyProto()
    self.profiledata_ = []
    self.has_user_ = 0
    if contents is not None: self.MergeFromString(contents)

  def user(self): return self.user_

  def mutable_user(self): self.has_user_ = 1; return self.user_

  def clear_user(self):self.has_user_ = 0; self.user_.Clear()

  def has_user(self): return self.has_user_

  def profiledata_size(self): return len(self.profiledata_)
  def profiledata_list(self): return self.profiledata_

  def profiledata(self, i):
    return self.profiledata_[i]

  def mutable_profiledata(self, i):
    return self.profiledata_[i]

  def add_profiledata(self):
    x = AttributeValue()
    self.profiledata_.append(x)
    return x

  def clear_profiledata(self):
    self.profiledata_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_user()): self.mutable_user().MergeFrom(x.user())
    for i in xrange(x.profiledata_size()): self.add_profiledata().CopyFrom(x.profiledata(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchFocusProfileDataReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchFocusProfileDataReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchFocusProfileDataReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchFocusProfileDataReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchFocusProfileDataReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_user_ != x.has_user_: return 0
    if self.has_user_ and self.user_ != x.user_: return 0
    if len(self.profiledata_) != len(x.profiledata_): return 0
    for e1, e2 in zip(self.profiledata_, x.profiledata_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_user_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: user not set.')
    elif not self.user_.IsInitialized(debug_strs): initialized = 0
    for i in xrange(len(self.profiledata_)):
      if (not self.profiledata_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.user_.ByteSize())
    n += 1 * len(self.profiledata_)
    for i in xrange(len(self.profiledata_)): n += self.lengthString(self.profiledata_[i].ByteSize())
    return n + 1

  def Clear(self):
    self.clear_user()
    self.clear_profiledata()

  def OutputUnchecked(self, out):
    out.putVarInt32(26)
    out.putVarInt32(self.user_.ByteSize())
    self.user_.OutputUnchecked(out)
    for i in xrange(len(self.profiledata_)):
      out.putVarInt32(34)
      out.putVarInt32(self.profiledata_[i].ByteSize())
      self.profiledata_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_user().TryMerge(tmp)
        continue
      if tt == 34:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_profiledata().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_user_:
      res+=prefix+"User <\n"
      res+=self.user_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    cnt=0
    for e in self.profiledata_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("ProfileData%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

class FetchFocusProfileDataReply(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.status_ = 0
    self.userprofiledata_ = []
    self.has_status_ = 0
    if contents is not None: self.MergeFromString(contents)

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def userprofiledata_size(self): return len(self.userprofiledata_)
  def userprofiledata_list(self): return self.userprofiledata_

  def userprofiledata(self, i):
    return self.userprofiledata_[i]

  def mutable_userprofiledata(self, i):
    return self.userprofiledata_[i]

  def add_userprofiledata(self):
    x = FetchFocusProfileDataReply_UserProfileData()
    self.userprofiledata_.append(x)
    return x

  def clear_userprofiledata(self):
    self.userprofiledata_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_status()): self.set_status(x.status())
    for i in xrange(x.userprofiledata_size()): self.add_userprofiledata().CopyFrom(x.userprofiledata(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'weboftrust.FetchFocusProfileDataReply', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'weboftrust.FetchFocusProfileDataReply')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'weboftrust.FetchFocusProfileDataReply', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'weboftrust.FetchFocusProfileDataReply', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'weboftrust.FetchFocusProfileDataReply', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if len(self.userprofiledata_) != len(x.userprofiledata_): return 0
    for e1, e2 in zip(self.userprofiledata_, x.userprofiledata_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_status_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: status not set.')
    for i in xrange(len(self.userprofiledata_)):
      if (not self.userprofiledata_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.status_)
    n += 2 * len(self.userprofiledata_)
    for i in xrange(len(self.userprofiledata_)): n += self.userprofiledata_[i].ByteSize()
    return n + 1

  def Clear(self):
    self.clear_status()
    self.clear_userprofiledata()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.status_)
    for i in xrange(len(self.userprofiledata_)):
      out.putVarInt32(19)
      self.userprofiledata_[i].OutputUnchecked(out)
      out.putVarInt32(20)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_status(d.getVarInt32())
        continue
      if tt == 19:
        self.add_userprofiledata().TryMerge(d)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    cnt=0
    for e in self.userprofiledata_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("UserProfileData%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kStatus = 1
  kUserProfileDataGroup = 2
  kUserProfileDataUser = 3
  kUserProfileDataProfileData = 4

  _TEXT = (
   "ErrorCode",  #   0
   "Status",  #   1
   "UserProfileData",  #   2
   "User",  #   3
   "ProfileData",  #   4
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2f,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2f,
    0x72,
    0x70,
    0x63,
    0x2f,
    0x62,
    0x61,
    0x73,
    0x65,
    0x2d,
    0x70,
    0x72,
    0x6f,
    0x73,
    0x65,
    0x2d,
    0x73,
    0x65,
    0x72,
    0x76,
    0x65,
    0x72,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x25,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x46,
    0x65,
    0x74,
    0x63,
    0x68,
    0x46,
    0x6f,
    0x63,
    0x75,
    0x73,
    0x50,
    0x72,
    0x6f,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x52,
    0x65,
    0x70,
    0x6c,
    0x79,
    0x13,
    0x1a,
    0x06,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x55,
    0x73,
    0x65,
    0x72,
    0x50,
    0x72,
    0x6f,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x55,
    0x73,
    0x65,
    0x72,
    0x50,
    0x72,
    0x6f,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x13,
    0x6b,
    0x61,
    0x6e,
    0x73,
    0x61,
    0x73,
    0x2e,
    0x55,
    0x73,
    0x65,
    0x72,
    0x4b,
    0x65,
    0x79,
    0x50,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x60,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x55,
    0x73,
    0x65,
    0x72,
    0x50,
    0x72,
    0x6f,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x2e,
    0x50,
    0x72,
    0x6f,
    0x66,
    0x69,
    0x6c,
    0x65,
    0x44,
    0x61,
    0x74,
    0x61,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x19,
    0x77,
    0x65,
    0x62,
    0x6f,
    0x66,
    0x74,
    0x72,
    0x75,
    0x73,
    0x74,
    0x2e,
    0x41,
    0x74,
    0x74,
    0x72,
    0x69,
    0x62,
    0x75,
    0x74,
    0x65,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x60,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['AddAnnotationRequest','BatchAddAnnotationRequest','DeleteAnnotationsRequest','DeleteAnnotationsRequest_DeleteAnnotations','RenameLabelsRequest','AddTrustRelationRequest','DeleteTrustRelationsRequest','ProseAnnotationTrustUpdateReply','DocumentProto','DocumentScoreRequest','DocumentScoreReply','PrepareUserRequest','PrepareUserReply','FetchAnnotationsRequest','FetchAnnotationsRequest_Restrictions','FetchAnnotationsRequest_DataInclusionRestrictions','FetchAnnotationsReply','FetchUrlAnnotationsRequest','FetchUrlAnnotationsReply','FetchUrlAnnotationsReply_UrlAnnotation','TrustRelationRestrictions','FetchTrustRelationsRequest','FetchTrustRelationsReply','FetchInverseTrustRelationsRequest','FetchInverseTrustRelationsReply','FetchTrustNetworkRequest','FetchTrustNetworkReply','FetchTrustNetworkReply_TrustedUsersTrusteeProfileData','FetchTrustNetworkReply_TrustedUsers','GetRecommendationsRequest','GetRecommendationsReply','GetRecommendationsReply_Recommendations','FetchUserLabeledUrlsRequest','FetchUserLabeledUrlsReply','FetchUserLabeledUrlsReply_LabelUrlSet','GetOneboxesRequest','ProseOneboxProviderReply','ProseOneboxProviderReply_Output','ProseOneboxProviderReply_UrlOutput','ProseOneboxResultGroup','GetOneboxesReply','GetOneboxesReply_TextOutput','GetOneboxesReply_UrlOutput','FetchAnnotationsForFieldRequest','FetchAnnotationsForFieldReply','InvalidateUserRequest','InvalidateUserReply','GetTrusteeDocumentDataRequest','GetTrusteeDocumentDataRequest_Users','FetchDataForAnnotationsToDeleteReply','FetchDataForAnnotationsToDeleteReply_AnnotationData','GetTrusteeDocumentDataReply','GetUserDebugStringRequest','GetUserDebugStringReply','VerboseFlagLevel','FetchFocusProfileDataRequest','FetchFocusProfileDataReply','FetchFocusProfileDataReply_UserProfileData']
