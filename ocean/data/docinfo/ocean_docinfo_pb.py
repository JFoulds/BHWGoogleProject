# This file automatically generated by protocol-compiler from ocean/data/docinfo/ocean_docinfo.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

from google3.ocean.data.docinfo.volume_viewability_pb import *
class OceanDocTag_BookSpecific(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.subject_ = ""
    self.imprint_ = ""
    self.publication_date_ = ""
    self.aux_bibkeys_ = []
    self.has_subject_ = 0
    self.has_imprint_ = 0
    self.has_publication_date_ = 0
    if contents is not None: self.MergeFromString(contents)

  def subject(self): return self.subject_

  def set_subject(self, x):
    self.has_subject_ = 1
    self.subject_ = x

  def clear_subject(self):
    self.has_subject_ = 0
    self.subject_ = ""

  def has_subject(self): return self.has_subject_

  def imprint(self): return self.imprint_

  def set_imprint(self, x):
    self.has_imprint_ = 1
    self.imprint_ = x

  def clear_imprint(self):
    self.has_imprint_ = 0
    self.imprint_ = ""

  def has_imprint(self): return self.has_imprint_

  def publication_date(self): return self.publication_date_

  def set_publication_date(self, x):
    self.has_publication_date_ = 1
    self.publication_date_ = x

  def clear_publication_date(self):
    self.has_publication_date_ = 0
    self.publication_date_ = ""

  def has_publication_date(self): return self.has_publication_date_

  def aux_bibkeys_size(self): return len(self.aux_bibkeys_)
  def aux_bibkeys_list(self): return self.aux_bibkeys_

  def aux_bibkeys(self, i):
    return self.aux_bibkeys_[i]

  def set_aux_bibkeys(self, i, x):
    self.aux_bibkeys_[i] = x

  def add_aux_bibkeys(self, x):
    self.aux_bibkeys_.append(x)

  def clear_aux_bibkeys(self):
    self.aux_bibkeys_ = []


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_subject()): self.set_subject(x.subject())
    if (x.has_imprint()): self.set_imprint(x.imprint())
    if (x.has_publication_date()): self.set_publication_date(x.publication_date())
    for i in xrange(x.aux_bibkeys_size()): self.add_aux_bibkeys(x.aux_bibkeys(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanDocTag', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanDocTag')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanDocTag', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanDocTag', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanDocTag', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_subject_ != x.has_subject_: return 0
    if self.has_subject_ and self.subject_ != x.subject_: return 0
    if self.has_imprint_ != x.has_imprint_: return 0
    if self.has_imprint_ and self.imprint_ != x.imprint_: return 0
    if self.has_publication_date_ != x.has_publication_date_: return 0
    if self.has_publication_date_ and self.publication_date_ != x.publication_date_: return 0
    if len(self.aux_bibkeys_) != len(x.aux_bibkeys_): return 0
    for e1, e2 in zip(self.aux_bibkeys_, x.aux_bibkeys_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_subject_): n += 2 + self.lengthString(len(self.subject_))
    if (self.has_imprint_): n += 2 + self.lengthString(len(self.imprint_))
    if (self.has_publication_date_): n += 2 + self.lengthString(len(self.publication_date_))
    n += 2 * len(self.aux_bibkeys_)
    for i in xrange(len(self.aux_bibkeys_)): n += self.lengthString(len(self.aux_bibkeys_[i]))
    return n + 0

  def Clear(self):
    self.clear_subject()
    self.clear_imprint()
    self.clear_publication_date()
    self.clear_aux_bibkeys()

  def OutputUnchecked(self, out):
    if (self.has_subject_):
      out.putVarInt32(130)
      out.putPrefixedString(self.subject_)
    if (self.has_imprint_):
      out.putVarInt32(138)
      out.putPrefixedString(self.imprint_)
    if (self.has_publication_date_):
      out.putVarInt32(146)
      out.putPrefixedString(self.publication_date_)
    for i in xrange(len(self.aux_bibkeys_)):
      out.putVarInt32(330)
      out.putPrefixedString(self.aux_bibkeys_[i])

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 124: break
      if tt == 130:
        self.set_subject(d.getPrefixedString())
        continue
      if tt == 138:
        self.set_imprint(d.getPrefixedString())
        continue
      if tt == 146:
        self.set_publication_date(d.getPrefixedString())
        continue
      if tt == 330:
        self.add_aux_bibkeys(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_subject_: res+=prefix+("subject: %s\n" % self.DebugFormatString(self.subject_))
    if self.has_imprint_: res+=prefix+("imprint: %s\n" % self.DebugFormatString(self.imprint_))
    if self.has_publication_date_: res+=prefix+("publication_date: %s\n" % self.DebugFormatString(self.publication_date_))
    cnt=0
    for e in self.aux_bibkeys_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("aux_bibkeys%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    return res

class OceanDocTag_PatentSpecific(ProtocolBuffer.ProtocolMessage):

  US_GRANTED_PATENT =    0 
  US_APPLICATION =    1 

  _PatentDocType_NAMES = {
    0: "US_GRANTED_PATENT",
    1: "US_APPLICATION",
  }

  def PatentDocType_Name(cls, x): return cls._PatentDocType_NAMES.get(x, "")
  PatentDocType_Name = classmethod(PatentDocType_Name)

  def __init__(self, contents=None):
    self.document_number_ = ""
    self.patent_assignee_ = ""
    self.application_date_ = ""
    self.issue_date_ = ""
    self.doc_type_ = 0
    self.publication_number_ = ""
    self.has_document_number_ = 0
    self.has_patent_assignee_ = 0
    self.has_application_date_ = 0
    self.has_issue_date_ = 0
    self.has_doc_type_ = 0
    self.has_publication_number_ = 0
    if contents is not None: self.MergeFromString(contents)

  def document_number(self): return self.document_number_

  def set_document_number(self, x):
    self.has_document_number_ = 1
    self.document_number_ = x

  def clear_document_number(self):
    self.has_document_number_ = 0
    self.document_number_ = ""

  def has_document_number(self): return self.has_document_number_

  def patent_assignee(self): return self.patent_assignee_

  def set_patent_assignee(self, x):
    self.has_patent_assignee_ = 1
    self.patent_assignee_ = x

  def clear_patent_assignee(self):
    self.has_patent_assignee_ = 0
    self.patent_assignee_ = ""

  def has_patent_assignee(self): return self.has_patent_assignee_

  def application_date(self): return self.application_date_

  def set_application_date(self, x):
    self.has_application_date_ = 1
    self.application_date_ = x

  def clear_application_date(self):
    self.has_application_date_ = 0
    self.application_date_ = ""

  def has_application_date(self): return self.has_application_date_

  def issue_date(self): return self.issue_date_

  def set_issue_date(self, x):
    self.has_issue_date_ = 1
    self.issue_date_ = x

  def clear_issue_date(self):
    self.has_issue_date_ = 0
    self.issue_date_ = ""

  def has_issue_date(self): return self.has_issue_date_

  def doc_type(self): return self.doc_type_

  def set_doc_type(self, x):
    self.has_doc_type_ = 1
    self.doc_type_ = x

  def clear_doc_type(self):
    self.has_doc_type_ = 0
    self.doc_type_ = 0

  def has_doc_type(self): return self.has_doc_type_

  def publication_number(self): return self.publication_number_

  def set_publication_number(self, x):
    self.has_publication_number_ = 1
    self.publication_number_ = x

  def clear_publication_number(self):
    self.has_publication_number_ = 0
    self.publication_number_ = ""

  def has_publication_number(self): return self.has_publication_number_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_document_number()): self.set_document_number(x.document_number())
    if (x.has_patent_assignee()): self.set_patent_assignee(x.patent_assignee())
    if (x.has_application_date()): self.set_application_date(x.application_date())
    if (x.has_issue_date()): self.set_issue_date(x.issue_date())
    if (x.has_doc_type()): self.set_doc_type(x.doc_type())
    if (x.has_publication_number()): self.set_publication_number(x.publication_number())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanDocTag', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanDocTag')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanDocTag', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanDocTag', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanDocTag', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_document_number_ != x.has_document_number_: return 0
    if self.has_document_number_ and self.document_number_ != x.document_number_: return 0
    if self.has_patent_assignee_ != x.has_patent_assignee_: return 0
    if self.has_patent_assignee_ and self.patent_assignee_ != x.patent_assignee_: return 0
    if self.has_application_date_ != x.has_application_date_: return 0
    if self.has_application_date_ and self.application_date_ != x.application_date_: return 0
    if self.has_issue_date_ != x.has_issue_date_: return 0
    if self.has_issue_date_ and self.issue_date_ != x.issue_date_: return 0
    if self.has_doc_type_ != x.has_doc_type_: return 0
    if self.has_doc_type_ and self.doc_type_ != x.doc_type_: return 0
    if self.has_publication_number_ != x.has_publication_number_: return 0
    if self.has_publication_number_ and self.publication_number_ != x.publication_number_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_document_number_): n += 2 + self.lengthString(len(self.document_number_))
    if (self.has_patent_assignee_): n += 2 + self.lengthString(len(self.patent_assignee_))
    if (self.has_application_date_): n += 2 + self.lengthString(len(self.application_date_))
    if (self.has_issue_date_): n += 2 + self.lengthString(len(self.issue_date_))
    if (self.has_doc_type_): n += 2 + self.lengthVarInt64(self.doc_type_)
    if (self.has_publication_number_): n += 2 + self.lengthString(len(self.publication_number_))
    return n + 0

  def Clear(self):
    self.clear_document_number()
    self.clear_patent_assignee()
    self.clear_application_date()
    self.clear_issue_date()
    self.clear_doc_type()
    self.clear_publication_number()

  def OutputUnchecked(self, out):
    if (self.has_document_number_):
      out.putVarInt32(338)
      out.putPrefixedString(self.document_number_)
    if (self.has_patent_assignee_):
      out.putVarInt32(346)
      out.putPrefixedString(self.patent_assignee_)
    if (self.has_application_date_):
      out.putVarInt32(354)
      out.putPrefixedString(self.application_date_)
    if (self.has_issue_date_):
      out.putVarInt32(362)
      out.putPrefixedString(self.issue_date_)
    if (self.has_doc_type_):
      out.putVarInt32(368)
      out.putVarInt32(self.doc_type_)
    if (self.has_publication_number_):
      out.putVarInt32(386)
      out.putPrefixedString(self.publication_number_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 156: break
      if tt == 338:
        self.set_document_number(d.getPrefixedString())
        continue
      if tt == 346:
        self.set_patent_assignee(d.getPrefixedString())
        continue
      if tt == 354:
        self.set_application_date(d.getPrefixedString())
        continue
      if tt == 362:
        self.set_issue_date(d.getPrefixedString())
        continue
      if tt == 368:
        self.set_doc_type(d.getVarInt32())
        continue
      if tt == 386:
        self.set_publication_number(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_document_number_: res+=prefix+("document_number: %s\n" % self.DebugFormatString(self.document_number_))
    if self.has_patent_assignee_: res+=prefix+("patent_assignee: %s\n" % self.DebugFormatString(self.patent_assignee_))
    if self.has_application_date_: res+=prefix+("application_date: %s\n" % self.DebugFormatString(self.application_date_))
    if self.has_issue_date_: res+=prefix+("issue_date: %s\n" % self.DebugFormatString(self.issue_date_))
    if self.has_doc_type_: res+=prefix+("doc_type: %s\n" % self.DebugFormatInt32(self.doc_type_))
    if self.has_publication_number_: res+=prefix+("publication_number: %s\n" % self.DebugFormatString(self.publication_number_))
    return res

class OceanDocTag_CatalogSpecific(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.publication_time_to_display_ = ""
    self.publication_date_ = 0
    self.latest_ = 0
    self.has_publication_time_to_display_ = 0
    self.has_publication_date_ = 0
    self.has_latest_ = 0
    if contents is not None: self.MergeFromString(contents)

  def publication_time_to_display(self): return self.publication_time_to_display_

  def set_publication_time_to_display(self, x):
    self.has_publication_time_to_display_ = 1
    self.publication_time_to_display_ = x

  def clear_publication_time_to_display(self):
    self.has_publication_time_to_display_ = 0
    self.publication_time_to_display_ = ""

  def has_publication_time_to_display(self): return self.has_publication_time_to_display_

  def publication_date(self): return self.publication_date_

  def set_publication_date(self, x):
    self.has_publication_date_ = 1
    self.publication_date_ = x

  def clear_publication_date(self):
    self.has_publication_date_ = 0
    self.publication_date_ = 0

  def has_publication_date(self): return self.has_publication_date_

  def latest(self): return self.latest_

  def set_latest(self, x):
    self.has_latest_ = 1
    self.latest_ = x

  def clear_latest(self):
    self.has_latest_ = 0
    self.latest_ = 0

  def has_latest(self): return self.has_latest_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_publication_time_to_display()): self.set_publication_time_to_display(x.publication_time_to_display())
    if (x.has_publication_date()): self.set_publication_date(x.publication_date())
    if (x.has_latest()): self.set_latest(x.latest())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanDocTag', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanDocTag')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanDocTag', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanDocTag', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanDocTag', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_publication_time_to_display_ != x.has_publication_time_to_display_: return 0
    if self.has_publication_time_to_display_ and self.publication_time_to_display_ != x.publication_time_to_display_: return 0
    if self.has_publication_date_ != x.has_publication_date_: return 0
    if self.has_publication_date_ and self.publication_date_ != x.publication_date_: return 0
    if self.has_latest_ != x.has_latest_: return 0
    if self.has_latest_ and self.latest_ != x.latest_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_publication_time_to_display_): n += 2 + self.lengthString(len(self.publication_time_to_display_))
    if (self.has_publication_date_): n += 2 + self.lengthVarInt64(self.publication_date_)
    if (self.has_latest_): n += 3
    return n + 0

  def Clear(self):
    self.clear_publication_time_to_display()
    self.clear_publication_date()
    self.clear_latest()

  def OutputUnchecked(self, out):
    if (self.has_publication_time_to_display_):
      out.putVarInt32(178)
      out.putPrefixedString(self.publication_time_to_display_)
    if (self.has_publication_date_):
      out.putVarInt32(184)
      out.putVarInt32(self.publication_date_)
    if (self.has_latest_):
      out.putVarInt32(264)
      out.putBoolean(self.latest_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 172: break
      if tt == 178:
        self.set_publication_time_to_display(d.getPrefixedString())
        continue
      if tt == 184:
        self.set_publication_date(d.getVarInt32())
        continue
      if tt == 264:
        self.set_latest(d.getBoolean())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_publication_time_to_display_: res+=prefix+("publication_time_to_display: %s\n" % self.DebugFormatString(self.publication_time_to_display_))
    if self.has_publication_date_: res+=prefix+("publication_date: %s\n" % self.DebugFormatInt32(self.publication_date_))
    if self.has_latest_: res+=prefix+("latest: %s\n" % self.DebugFormatBool(self.latest_))
    return res

class OceanDocTag_WorkCluster(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.work_id_ = 0
    self.cluster_size_ = 0
    self.has_work_id_ = 0
    self.has_cluster_size_ = 0
    if contents is not None: self.MergeFromString(contents)

  def work_id(self): return self.work_id_

  def set_work_id(self, x):
    self.has_work_id_ = 1
    self.work_id_ = x

  def clear_work_id(self):
    self.has_work_id_ = 0
    self.work_id_ = 0

  def has_work_id(self): return self.has_work_id_

  def cluster_size(self): return self.cluster_size_

  def set_cluster_size(self, x):
    self.has_cluster_size_ = 1
    self.cluster_size_ = x

  def clear_cluster_size(self):
    self.has_cluster_size_ = 0
    self.cluster_size_ = 0

  def has_cluster_size(self): return self.has_cluster_size_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_work_id()): self.set_work_id(x.work_id())
    if (x.has_cluster_size()): self.set_cluster_size(x.cluster_size())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanDocTag', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanDocTag')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanDocTag', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanDocTag', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanDocTag', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_work_id_ != x.has_work_id_: return 0
    if self.has_work_id_ and self.work_id_ != x.work_id_: return 0
    if self.has_cluster_size_ != x.has_cluster_size_: return 0
    if self.has_cluster_size_ and self.cluster_size_ != x.cluster_size_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_work_id_): n += 2 + self.lengthVarInt64(self.work_id_)
    if (self.has_cluster_size_): n += 2 + self.lengthVarInt64(self.cluster_size_)
    return n + 0

  def Clear(self):
    self.clear_work_id()
    self.clear_cluster_size()

  def OutputUnchecked(self, out):
    if (self.has_work_id_):
      out.putVarInt32(280)
      out.putVarInt64(self.work_id_)
    if (self.has_cluster_size_):
      out.putVarInt32(288)
      out.putVarInt32(self.cluster_size_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 276: break
      if tt == 280:
        self.set_work_id(d.getVarInt64())
        continue
      if tt == 288:
        self.set_cluster_size(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_work_id_: res+=prefix+("work_id: %s\n" % self.DebugFormatInt64(self.work_id_))
    if self.has_cluster_size_: res+=prefix+("cluster_size: %s\n" % self.DebugFormatInt32(self.cluster_size_))
    return res

class OceanDocTag(ProtocolBuffer.ProtocolMessage):

  BOOK         =    1 
  PATENT       =    2 
  CATALOG      =    3 
  MAGAZINE     =    4 
  MAGAZINE_SERIAL =    5 
  NEWSPAPER    =    6 

  _Type_NAMES = {
    1: "BOOK",
    2: "PATENT",
    3: "CATALOG",
    4: "MAGAZINE",
    5: "MAGAZINE_SERIAL",
    6: "NEWSPAPER",
  }

  def Type_Name(cls, x): return cls._Type_NAMES.get(x, "")
  Type_Name = classmethod(Type_Name)

  def __init__(self, contents=None):
    self.url_key_ = ""
    self.title_ = ""
    self.sub_title_ = ""
    self.authors_ = ""
    self.editors_ = ""
    self.workcluster_ = None
    self.num_pages_ = 0
    self.page_number_ = 0
    self.structured_page_number_ = ""
    self.geo_restrict_ = []
    self.viewability_ = None
    self.cover_page_ = ""
    self.cover_page_size_ = None
    self.metadata_cover_size_ = None
    self.metadata_cover_exists_ = 0
    self.source_type_ = 0
    self.content_type_ = 0
    self.volume_type_ = 0
    self.bookspecific_ = None
    self.patentspecific_ = None
    self.deprecated_patent_number_ = ""
    self.deprecated_patent_assignee_ = ""
    self.deprecated_application_date_ = ""
    self.deprecated_issue_date_ = ""
    self.catalogspecific_ = None
    self.pageid_ = 0
    self.printed_page_number_ = ""
    self.block_snippet_ = 0
    self.segment_time_ = -1
    self.page_type_bitmap_ = []
    self.deprecated_publisher_percent_visible_ = 0
    self.pagerank_ = 0.0
    self.is_landing_page_ = 0
    self.ref_page_url_ = ""
    self.thumbnail_url_ = ""
    self.has_url_key_ = 0
    self.has_title_ = 0
    self.has_sub_title_ = 0
    self.has_authors_ = 0
    self.has_editors_ = 0
    self.has_workcluster_ = 0
    self.has_num_pages_ = 0
    self.has_page_number_ = 0
    self.has_structured_page_number_ = 0
    self.has_viewability_ = 0
    self.has_cover_page_ = 0
    self.has_cover_page_size_ = 0
    self.has_metadata_cover_size_ = 0
    self.has_metadata_cover_exists_ = 0
    self.has_source_type_ = 0
    self.has_content_type_ = 0
    self.has_volume_type_ = 0
    self.has_bookspecific_ = 0
    self.has_patentspecific_ = 0
    self.has_deprecated_patent_number_ = 0
    self.has_deprecated_patent_assignee_ = 0
    self.has_deprecated_application_date_ = 0
    self.has_deprecated_issue_date_ = 0
    self.has_catalogspecific_ = 0
    self.has_pageid_ = 0
    self.has_printed_page_number_ = 0
    self.has_block_snippet_ = 0
    self.has_segment_time_ = 0
    self.has_deprecated_publisher_percent_visible_ = 0
    self.has_pagerank_ = 0
    self.has_is_landing_page_ = 0
    self.has_ref_page_url_ = 0
    self.has_thumbnail_url_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def url_key(self): return self.url_key_

  def set_url_key(self, x):
    self.has_url_key_ = 1
    self.url_key_ = x

  def clear_url_key(self):
    self.has_url_key_ = 0
    self.url_key_ = ""

  def has_url_key(self): return self.has_url_key_

  def title(self): return self.title_

  def set_title(self, x):
    self.has_title_ = 1
    self.title_ = x

  def clear_title(self):
    self.has_title_ = 0
    self.title_ = ""

  def has_title(self): return self.has_title_

  def sub_title(self): return self.sub_title_

  def set_sub_title(self, x):
    self.has_sub_title_ = 1
    self.sub_title_ = x

  def clear_sub_title(self):
    self.has_sub_title_ = 0
    self.sub_title_ = ""

  def has_sub_title(self): return self.has_sub_title_

  def authors(self): return self.authors_

  def set_authors(self, x):
    self.has_authors_ = 1
    self.authors_ = x

  def clear_authors(self):
    self.has_authors_ = 0
    self.authors_ = ""

  def has_authors(self): return self.has_authors_

  def editors(self): return self.editors_

  def set_editors(self, x):
    self.has_editors_ = 1
    self.editors_ = x

  def clear_editors(self):
    self.has_editors_ = 0
    self.editors_ = ""

  def has_editors(self): return self.has_editors_

  def workcluster(self):
    if self.workcluster_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.workcluster_ is None: self.workcluster_ = OceanDocTag_WorkCluster()
      finally:
        self.lazy_init_lock_.release()
    return self.workcluster_

  def mutable_workcluster(self): self.has_workcluster_ = 1; return self.workcluster()

  def clear_workcluster(self):
    #Warning: this method does not acquire the lock.
    self.has_workcluster_ = 0;
    if self.workcluster_ is not None: self.workcluster_.Clear()

  def has_workcluster(self): return self.has_workcluster_

  def num_pages(self): return self.num_pages_

  def set_num_pages(self, x):
    self.has_num_pages_ = 1
    self.num_pages_ = x

  def clear_num_pages(self):
    self.has_num_pages_ = 0
    self.num_pages_ = 0

  def has_num_pages(self): return self.has_num_pages_

  def page_number(self): return self.page_number_

  def set_page_number(self, x):
    self.has_page_number_ = 1
    self.page_number_ = x

  def clear_page_number(self):
    self.has_page_number_ = 0
    self.page_number_ = 0

  def has_page_number(self): return self.has_page_number_

  def structured_page_number(self): return self.structured_page_number_

  def set_structured_page_number(self, x):
    self.has_structured_page_number_ = 1
    self.structured_page_number_ = x

  def clear_structured_page_number(self):
    self.has_structured_page_number_ = 0
    self.structured_page_number_ = ""

  def has_structured_page_number(self): return self.has_structured_page_number_

  def geo_restrict_size(self): return len(self.geo_restrict_)
  def geo_restrict_list(self): return self.geo_restrict_

  def geo_restrict(self, i):
    return self.geo_restrict_[i]

  def set_geo_restrict(self, i, x):
    self.geo_restrict_[i] = x

  def add_geo_restrict(self, x):
    self.geo_restrict_.append(x)

  def clear_geo_restrict(self):
    self.geo_restrict_ = []

  def viewability(self):
    if self.viewability_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.viewability_ is None: self.viewability_ = VolumeViewability()
      finally:
        self.lazy_init_lock_.release()
    return self.viewability_

  def mutable_viewability(self): self.has_viewability_ = 1; return self.viewability()

  def clear_viewability(self):
    #Warning: this method does not acquire the lock.
    self.has_viewability_ = 0;
    if self.viewability_ is not None: self.viewability_.Clear()

  def has_viewability(self): return self.has_viewability_

  def cover_page(self): return self.cover_page_

  def set_cover_page(self, x):
    self.has_cover_page_ = 1
    self.cover_page_ = x

  def clear_cover_page(self):
    self.has_cover_page_ = 0
    self.cover_page_ = ""

  def has_cover_page(self): return self.has_cover_page_

  def cover_page_size(self):
    if self.cover_page_size_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.cover_page_size_ is None: self.cover_page_size_ = ImageSize()
      finally:
        self.lazy_init_lock_.release()
    return self.cover_page_size_

  def mutable_cover_page_size(self): self.has_cover_page_size_ = 1; return self.cover_page_size()

  def clear_cover_page_size(self):
    #Warning: this method does not acquire the lock.
    self.has_cover_page_size_ = 0;
    if self.cover_page_size_ is not None: self.cover_page_size_.Clear()

  def has_cover_page_size(self): return self.has_cover_page_size_

  def metadata_cover_size(self):
    if self.metadata_cover_size_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.metadata_cover_size_ is None: self.metadata_cover_size_ = ImageSize()
      finally:
        self.lazy_init_lock_.release()
    return self.metadata_cover_size_

  def mutable_metadata_cover_size(self): self.has_metadata_cover_size_ = 1; return self.metadata_cover_size()

  def clear_metadata_cover_size(self):
    #Warning: this method does not acquire the lock.
    self.has_metadata_cover_size_ = 0;
    if self.metadata_cover_size_ is not None: self.metadata_cover_size_.Clear()

  def has_metadata_cover_size(self): return self.has_metadata_cover_size_

  def metadata_cover_exists(self): return self.metadata_cover_exists_

  def set_metadata_cover_exists(self, x):
    self.has_metadata_cover_exists_ = 1
    self.metadata_cover_exists_ = x

  def clear_metadata_cover_exists(self):
    self.has_metadata_cover_exists_ = 0
    self.metadata_cover_exists_ = 0

  def has_metadata_cover_exists(self): return self.has_metadata_cover_exists_

  def source_type(self): return self.source_type_

  def set_source_type(self, x):
    self.has_source_type_ = 1
    self.source_type_ = x

  def clear_source_type(self):
    self.has_source_type_ = 0
    self.source_type_ = 0

  def has_source_type(self): return self.has_source_type_

  def content_type(self): return self.content_type_

  def set_content_type(self, x):
    self.has_content_type_ = 1
    self.content_type_ = x

  def clear_content_type(self):
    self.has_content_type_ = 0
    self.content_type_ = 0

  def has_content_type(self): return self.has_content_type_

  def volume_type(self): return self.volume_type_

  def set_volume_type(self, x):
    self.has_volume_type_ = 1
    self.volume_type_ = x

  def clear_volume_type(self):
    self.has_volume_type_ = 0
    self.volume_type_ = 0

  def has_volume_type(self): return self.has_volume_type_

  def bookspecific(self):
    if self.bookspecific_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.bookspecific_ is None: self.bookspecific_ = OceanDocTag_BookSpecific()
      finally:
        self.lazy_init_lock_.release()
    return self.bookspecific_

  def mutable_bookspecific(self): self.has_bookspecific_ = 1; return self.bookspecific()

  def clear_bookspecific(self):
    #Warning: this method does not acquire the lock.
    self.has_bookspecific_ = 0;
    if self.bookspecific_ is not None: self.bookspecific_.Clear()

  def has_bookspecific(self): return self.has_bookspecific_

  def patentspecific(self):
    if self.patentspecific_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.patentspecific_ is None: self.patentspecific_ = OceanDocTag_PatentSpecific()
      finally:
        self.lazy_init_lock_.release()
    return self.patentspecific_

  def mutable_patentspecific(self): self.has_patentspecific_ = 1; return self.patentspecific()

  def clear_patentspecific(self):
    #Warning: this method does not acquire the lock.
    self.has_patentspecific_ = 0;
    if self.patentspecific_ is not None: self.patentspecific_.Clear()

  def has_patentspecific(self): return self.has_patentspecific_

  def deprecated_patent_number(self): return self.deprecated_patent_number_

  def set_deprecated_patent_number(self, x):
    self.has_deprecated_patent_number_ = 1
    self.deprecated_patent_number_ = x

  def clear_deprecated_patent_number(self):
    self.has_deprecated_patent_number_ = 0
    self.deprecated_patent_number_ = ""

  def has_deprecated_patent_number(self): return self.has_deprecated_patent_number_

  def deprecated_patent_assignee(self): return self.deprecated_patent_assignee_

  def set_deprecated_patent_assignee(self, x):
    self.has_deprecated_patent_assignee_ = 1
    self.deprecated_patent_assignee_ = x

  def clear_deprecated_patent_assignee(self):
    self.has_deprecated_patent_assignee_ = 0
    self.deprecated_patent_assignee_ = ""

  def has_deprecated_patent_assignee(self): return self.has_deprecated_patent_assignee_

  def deprecated_application_date(self): return self.deprecated_application_date_

  def set_deprecated_application_date(self, x):
    self.has_deprecated_application_date_ = 1
    self.deprecated_application_date_ = x

  def clear_deprecated_application_date(self):
    self.has_deprecated_application_date_ = 0
    self.deprecated_application_date_ = ""

  def has_deprecated_application_date(self): return self.has_deprecated_application_date_

  def deprecated_issue_date(self): return self.deprecated_issue_date_

  def set_deprecated_issue_date(self, x):
    self.has_deprecated_issue_date_ = 1
    self.deprecated_issue_date_ = x

  def clear_deprecated_issue_date(self):
    self.has_deprecated_issue_date_ = 0
    self.deprecated_issue_date_ = ""

  def has_deprecated_issue_date(self): return self.has_deprecated_issue_date_

  def catalogspecific(self):
    if self.catalogspecific_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.catalogspecific_ is None: self.catalogspecific_ = OceanDocTag_CatalogSpecific()
      finally:
        self.lazy_init_lock_.release()
    return self.catalogspecific_

  def mutable_catalogspecific(self): self.has_catalogspecific_ = 1; return self.catalogspecific()

  def clear_catalogspecific(self):
    #Warning: this method does not acquire the lock.
    self.has_catalogspecific_ = 0;
    if self.catalogspecific_ is not None: self.catalogspecific_.Clear()

  def has_catalogspecific(self): return self.has_catalogspecific_

  def pageid(self): return self.pageid_

  def set_pageid(self, x):
    self.has_pageid_ = 1
    self.pageid_ = x

  def clear_pageid(self):
    self.has_pageid_ = 0
    self.pageid_ = 0

  def has_pageid(self): return self.has_pageid_

  def printed_page_number(self): return self.printed_page_number_

  def set_printed_page_number(self, x):
    self.has_printed_page_number_ = 1
    self.printed_page_number_ = x

  def clear_printed_page_number(self):
    self.has_printed_page_number_ = 0
    self.printed_page_number_ = ""

  def has_printed_page_number(self): return self.has_printed_page_number_

  def block_snippet(self): return self.block_snippet_

  def set_block_snippet(self, x):
    self.has_block_snippet_ = 1
    self.block_snippet_ = x

  def clear_block_snippet(self):
    self.has_block_snippet_ = 0
    self.block_snippet_ = 0

  def has_block_snippet(self): return self.has_block_snippet_

  def segment_time(self): return self.segment_time_

  def set_segment_time(self, x):
    self.has_segment_time_ = 1
    self.segment_time_ = x

  def clear_segment_time(self):
    self.has_segment_time_ = 0
    self.segment_time_ = -1

  def has_segment_time(self): return self.has_segment_time_

  def page_type_bitmap_size(self): return len(self.page_type_bitmap_)
  def page_type_bitmap_list(self): return self.page_type_bitmap_

  def page_type_bitmap(self, i):
    return self.page_type_bitmap_[i]

  def set_page_type_bitmap(self, i, x):
    self.page_type_bitmap_[i] = x

  def add_page_type_bitmap(self, x):
    self.page_type_bitmap_.append(x)

  def clear_page_type_bitmap(self):
    self.page_type_bitmap_ = []

  def deprecated_publisher_percent_visible(self): return self.deprecated_publisher_percent_visible_

  def set_deprecated_publisher_percent_visible(self, x):
    self.has_deprecated_publisher_percent_visible_ = 1
    self.deprecated_publisher_percent_visible_ = x

  def clear_deprecated_publisher_percent_visible(self):
    self.has_deprecated_publisher_percent_visible_ = 0
    self.deprecated_publisher_percent_visible_ = 0

  def has_deprecated_publisher_percent_visible(self): return self.has_deprecated_publisher_percent_visible_

  def pagerank(self): return self.pagerank_

  def set_pagerank(self, x):
    self.has_pagerank_ = 1
    self.pagerank_ = x

  def clear_pagerank(self):
    self.has_pagerank_ = 0
    self.pagerank_ = 0.0

  def has_pagerank(self): return self.has_pagerank_

  def is_landing_page(self): return self.is_landing_page_

  def set_is_landing_page(self, x):
    self.has_is_landing_page_ = 1
    self.is_landing_page_ = x

  def clear_is_landing_page(self):
    self.has_is_landing_page_ = 0
    self.is_landing_page_ = 0

  def has_is_landing_page(self): return self.has_is_landing_page_

  def ref_page_url(self): return self.ref_page_url_

  def set_ref_page_url(self, x):
    self.has_ref_page_url_ = 1
    self.ref_page_url_ = x

  def clear_ref_page_url(self):
    self.has_ref_page_url_ = 0
    self.ref_page_url_ = ""

  def has_ref_page_url(self): return self.has_ref_page_url_

  def thumbnail_url(self): return self.thumbnail_url_

  def set_thumbnail_url(self, x):
    self.has_thumbnail_url_ = 1
    self.thumbnail_url_ = x

  def clear_thumbnail_url(self):
    self.has_thumbnail_url_ = 0
    self.thumbnail_url_ = ""

  def has_thumbnail_url(self): return self.has_thumbnail_url_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_url_key()): self.set_url_key(x.url_key())
    if (x.has_title()): self.set_title(x.title())
    if (x.has_sub_title()): self.set_sub_title(x.sub_title())
    if (x.has_authors()): self.set_authors(x.authors())
    if (x.has_editors()): self.set_editors(x.editors())
    if (x.has_workcluster()): self.mutable_workcluster().MergeFrom(x.workcluster())
    if (x.has_num_pages()): self.set_num_pages(x.num_pages())
    if (x.has_page_number()): self.set_page_number(x.page_number())
    if (x.has_structured_page_number()): self.set_structured_page_number(x.structured_page_number())
    for i in xrange(x.geo_restrict_size()): self.add_geo_restrict(x.geo_restrict(i))
    if (x.has_viewability()): self.mutable_viewability().MergeFrom(x.viewability())
    if (x.has_cover_page()): self.set_cover_page(x.cover_page())
    if (x.has_cover_page_size()): self.mutable_cover_page_size().MergeFrom(x.cover_page_size())
    if (x.has_metadata_cover_size()): self.mutable_metadata_cover_size().MergeFrom(x.metadata_cover_size())
    if (x.has_metadata_cover_exists()): self.set_metadata_cover_exists(x.metadata_cover_exists())
    if (x.has_source_type()): self.set_source_type(x.source_type())
    if (x.has_content_type()): self.set_content_type(x.content_type())
    if (x.has_volume_type()): self.set_volume_type(x.volume_type())
    if (x.has_bookspecific()): self.mutable_bookspecific().MergeFrom(x.bookspecific())
    if (x.has_patentspecific()): self.mutable_patentspecific().MergeFrom(x.patentspecific())
    if (x.has_deprecated_patent_number()): self.set_deprecated_patent_number(x.deprecated_patent_number())
    if (x.has_deprecated_patent_assignee()): self.set_deprecated_patent_assignee(x.deprecated_patent_assignee())
    if (x.has_deprecated_application_date()): self.set_deprecated_application_date(x.deprecated_application_date())
    if (x.has_deprecated_issue_date()): self.set_deprecated_issue_date(x.deprecated_issue_date())
    if (x.has_catalogspecific()): self.mutable_catalogspecific().MergeFrom(x.catalogspecific())
    if (x.has_pageid()): self.set_pageid(x.pageid())
    if (x.has_printed_page_number()): self.set_printed_page_number(x.printed_page_number())
    if (x.has_block_snippet()): self.set_block_snippet(x.block_snippet())
    if (x.has_segment_time()): self.set_segment_time(x.segment_time())
    for i in xrange(x.page_type_bitmap_size()): self.add_page_type_bitmap(x.page_type_bitmap(i))
    if (x.has_deprecated_publisher_percent_visible()): self.set_deprecated_publisher_percent_visible(x.deprecated_publisher_percent_visible())
    if (x.has_pagerank()): self.set_pagerank(x.pagerank())
    if (x.has_is_landing_page()): self.set_is_landing_page(x.is_landing_page())
    if (x.has_ref_page_url()): self.set_ref_page_url(x.ref_page_url())
    if (x.has_thumbnail_url()): self.set_thumbnail_url(x.thumbnail_url())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanDocTag', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanDocTag')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanDocTag', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanDocTag', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanDocTag', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_url_key_ != x.has_url_key_: return 0
    if self.has_url_key_ and self.url_key_ != x.url_key_: return 0
    if self.has_title_ != x.has_title_: return 0
    if self.has_title_ and self.title_ != x.title_: return 0
    if self.has_sub_title_ != x.has_sub_title_: return 0
    if self.has_sub_title_ and self.sub_title_ != x.sub_title_: return 0
    if self.has_authors_ != x.has_authors_: return 0
    if self.has_authors_ and self.authors_ != x.authors_: return 0
    if self.has_editors_ != x.has_editors_: return 0
    if self.has_editors_ and self.editors_ != x.editors_: return 0
    if self.has_workcluster_ != x.has_workcluster_: return 0
    if self.has_workcluster_ and self.workcluster_ != x.workcluster_: return 0
    if self.has_num_pages_ != x.has_num_pages_: return 0
    if self.has_num_pages_ and self.num_pages_ != x.num_pages_: return 0
    if self.has_page_number_ != x.has_page_number_: return 0
    if self.has_page_number_ and self.page_number_ != x.page_number_: return 0
    if self.has_structured_page_number_ != x.has_structured_page_number_: return 0
    if self.has_structured_page_number_ and self.structured_page_number_ != x.structured_page_number_: return 0
    if len(self.geo_restrict_) != len(x.geo_restrict_): return 0
    for e1, e2 in zip(self.geo_restrict_, x.geo_restrict_):
      if e1 != e2: return 0
    if self.has_viewability_ != x.has_viewability_: return 0
    if self.has_viewability_ and self.viewability_ != x.viewability_: return 0
    if self.has_cover_page_ != x.has_cover_page_: return 0
    if self.has_cover_page_ and self.cover_page_ != x.cover_page_: return 0
    if self.has_cover_page_size_ != x.has_cover_page_size_: return 0
    if self.has_cover_page_size_ and self.cover_page_size_ != x.cover_page_size_: return 0
    if self.has_metadata_cover_size_ != x.has_metadata_cover_size_: return 0
    if self.has_metadata_cover_size_ and self.metadata_cover_size_ != x.metadata_cover_size_: return 0
    if self.has_metadata_cover_exists_ != x.has_metadata_cover_exists_: return 0
    if self.has_metadata_cover_exists_ and self.metadata_cover_exists_ != x.metadata_cover_exists_: return 0
    if self.has_source_type_ != x.has_source_type_: return 0
    if self.has_source_type_ and self.source_type_ != x.source_type_: return 0
    if self.has_content_type_ != x.has_content_type_: return 0
    if self.has_content_type_ and self.content_type_ != x.content_type_: return 0
    if self.has_volume_type_ != x.has_volume_type_: return 0
    if self.has_volume_type_ and self.volume_type_ != x.volume_type_: return 0
    if self.has_bookspecific_ != x.has_bookspecific_: return 0
    if self.has_bookspecific_ and self.bookspecific_ != x.bookspecific_: return 0
    if self.has_patentspecific_ != x.has_patentspecific_: return 0
    if self.has_patentspecific_ and self.patentspecific_ != x.patentspecific_: return 0
    if self.has_deprecated_patent_number_ != x.has_deprecated_patent_number_: return 0
    if self.has_deprecated_patent_number_ and self.deprecated_patent_number_ != x.deprecated_patent_number_: return 0
    if self.has_deprecated_patent_assignee_ != x.has_deprecated_patent_assignee_: return 0
    if self.has_deprecated_patent_assignee_ and self.deprecated_patent_assignee_ != x.deprecated_patent_assignee_: return 0
    if self.has_deprecated_application_date_ != x.has_deprecated_application_date_: return 0
    if self.has_deprecated_application_date_ and self.deprecated_application_date_ != x.deprecated_application_date_: return 0
    if self.has_deprecated_issue_date_ != x.has_deprecated_issue_date_: return 0
    if self.has_deprecated_issue_date_ and self.deprecated_issue_date_ != x.deprecated_issue_date_: return 0
    if self.has_catalogspecific_ != x.has_catalogspecific_: return 0
    if self.has_catalogspecific_ and self.catalogspecific_ != x.catalogspecific_: return 0
    if self.has_pageid_ != x.has_pageid_: return 0
    if self.has_pageid_ and self.pageid_ != x.pageid_: return 0
    if self.has_printed_page_number_ != x.has_printed_page_number_: return 0
    if self.has_printed_page_number_ and self.printed_page_number_ != x.printed_page_number_: return 0
    if self.has_block_snippet_ != x.has_block_snippet_: return 0
    if self.has_block_snippet_ and self.block_snippet_ != x.block_snippet_: return 0
    if self.has_segment_time_ != x.has_segment_time_: return 0
    if self.has_segment_time_ and self.segment_time_ != x.segment_time_: return 0
    if len(self.page_type_bitmap_) != len(x.page_type_bitmap_): return 0
    for e1, e2 in zip(self.page_type_bitmap_, x.page_type_bitmap_):
      if e1 != e2: return 0
    if self.has_deprecated_publisher_percent_visible_ != x.has_deprecated_publisher_percent_visible_: return 0
    if self.has_deprecated_publisher_percent_visible_ and self.deprecated_publisher_percent_visible_ != x.deprecated_publisher_percent_visible_: return 0
    if self.has_pagerank_ != x.has_pagerank_: return 0
    if self.has_pagerank_ and self.pagerank_ != x.pagerank_: return 0
    if self.has_is_landing_page_ != x.has_is_landing_page_: return 0
    if self.has_is_landing_page_ and self.is_landing_page_ != x.is_landing_page_: return 0
    if self.has_ref_page_url_ != x.has_ref_page_url_: return 0
    if self.has_ref_page_url_ and self.ref_page_url_ != x.ref_page_url_: return 0
    if self.has_thumbnail_url_ != x.has_thumbnail_url_: return 0
    if self.has_thumbnail_url_ and self.thumbnail_url_ != x.thumbnail_url_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (self.has_workcluster_ and not self.workcluster_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_viewability_ and not self.viewability_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_cover_page_size_ and not self.cover_page_size_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_metadata_cover_size_ and not self.metadata_cover_size_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_bookspecific_ and not self.bookspecific_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_patentspecific_ and not self.patentspecific_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_catalogspecific_ and not self.catalogspecific_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_url_key_): n += 2 + self.lengthString(len(self.url_key_))
    if (self.has_title_): n += 1 + self.lengthString(len(self.title_))
    if (self.has_sub_title_): n += 1 + self.lengthString(len(self.sub_title_))
    if (self.has_authors_): n += 1 + self.lengthString(len(self.authors_))
    if (self.has_editors_): n += 1 + self.lengthString(len(self.editors_))
    if (self.has_workcluster_): n += 4 + self.workcluster_.ByteSize()
    if (self.has_num_pages_): n += 1 + self.lengthVarInt64(self.num_pages_)
    if (self.has_page_number_): n += 1 + self.lengthVarInt64(self.page_number_)
    if (self.has_structured_page_number_): n += 1 + self.lengthString(len(self.structured_page_number_))
    n += 1 * len(self.geo_restrict_)
    for i in xrange(len(self.geo_restrict_)): n += self.lengthString(len(self.geo_restrict_[i]))
    if (self.has_viewability_): n += 2 + self.lengthString(self.viewability_.ByteSize())
    if (self.has_cover_page_): n += 2 + self.lengthString(len(self.cover_page_))
    if (self.has_cover_page_size_): n += 2 + self.lengthString(self.cover_page_size_.ByteSize())
    if (self.has_metadata_cover_size_): n += 2 + self.lengthString(self.metadata_cover_size_.ByteSize())
    if (self.has_metadata_cover_exists_): n += 3
    if (self.has_source_type_): n += 2 + self.lengthVarInt64(self.source_type_)
    if (self.has_content_type_): n += 2 + self.lengthVarInt64(self.content_type_)
    if (self.has_volume_type_): n += 1 + self.lengthVarInt64(self.volume_type_)
    if (self.has_bookspecific_): n += 2 + self.bookspecific_.ByteSize()
    if (self.has_patentspecific_): n += 4 + self.patentspecific_.ByteSize()
    if (self.has_deprecated_patent_number_): n += 1 + self.lengthString(len(self.deprecated_patent_number_))
    if (self.has_deprecated_patent_assignee_): n += 1 + self.lengthString(len(self.deprecated_patent_assignee_))
    if (self.has_deprecated_application_date_): n += 1 + self.lengthString(len(self.deprecated_application_date_))
    if (self.has_deprecated_issue_date_): n += 2 + self.lengthString(len(self.deprecated_issue_date_))
    if (self.has_catalogspecific_): n += 4 + self.catalogspecific_.ByteSize()
    if (self.has_pageid_): n += 1 + self.lengthVarInt64(self.pageid_)
    if (self.has_printed_page_number_): n += 1 + self.lengthString(len(self.printed_page_number_))
    if (self.has_block_snippet_): n += 3
    if (self.has_segment_time_): n += 2 + self.lengthVarInt64(self.segment_time_)
    n += 2 * len(self.page_type_bitmap_)
    for i in xrange(len(self.page_type_bitmap_)): n += self.lengthVarInt64(self.page_type_bitmap_[i])
    if (self.has_deprecated_publisher_percent_visible_): n += 2 + self.lengthVarInt64(self.deprecated_publisher_percent_visible_)
    if (self.has_pagerank_): n += 10
    if (self.has_is_landing_page_): n += 3
    if (self.has_ref_page_url_): n += 2 + self.lengthString(len(self.ref_page_url_))
    if (self.has_thumbnail_url_): n += 2 + self.lengthString(len(self.thumbnail_url_))
    return n + 0

  def Clear(self):
    self.clear_url_key()
    self.clear_title()
    self.clear_sub_title()
    self.clear_authors()
    self.clear_editors()
    self.clear_workcluster()
    self.clear_num_pages()
    self.clear_page_number()
    self.clear_structured_page_number()
    self.clear_geo_restrict()
    self.clear_viewability()
    self.clear_cover_page()
    self.clear_cover_page_size()
    self.clear_metadata_cover_size()
    self.clear_metadata_cover_exists()
    self.clear_source_type()
    self.clear_content_type()
    self.clear_volume_type()
    self.clear_bookspecific()
    self.clear_patentspecific()
    self.clear_deprecated_patent_number()
    self.clear_deprecated_patent_assignee()
    self.clear_deprecated_application_date()
    self.clear_deprecated_issue_date()
    self.clear_catalogspecific()
    self.clear_pageid()
    self.clear_printed_page_number()
    self.clear_block_snippet()
    self.clear_segment_time()
    self.clear_page_type_bitmap()
    self.clear_deprecated_publisher_percent_visible()
    self.clear_pagerank()
    self.clear_is_landing_page()
    self.clear_ref_page_url()
    self.clear_thumbnail_url()

  def OutputUnchecked(self, out):
    if (self.has_title_):
      out.putVarInt32(10)
      out.putPrefixedString(self.title_)
    if (self.has_authors_):
      out.putVarInt32(18)
      out.putPrefixedString(self.authors_)
    if (self.has_pageid_):
      out.putVarInt32(24)
      out.putVarInt32(self.pageid_)
    if (self.has_page_number_):
      out.putVarInt32(32)
      out.putVarInt32(self.page_number_)
    if (self.has_printed_page_number_):
      out.putVarInt32(42)
      out.putPrefixedString(self.printed_page_number_)
    for i in xrange(len(self.geo_restrict_)):
      out.putVarInt32(50)
      out.putPrefixedString(self.geo_restrict_[i])
    if (self.has_volume_type_):
      out.putVarInt32(56)
      out.putVarInt32(self.volume_type_)
    if (self.has_deprecated_patent_number_):
      out.putVarInt32(66)
      out.putPrefixedString(self.deprecated_patent_number_)
    if (self.has_deprecated_patent_assignee_):
      out.putVarInt32(74)
      out.putPrefixedString(self.deprecated_patent_assignee_)
    if (self.has_deprecated_application_date_):
      out.putVarInt32(82)
      out.putPrefixedString(self.deprecated_application_date_)
    if (self.has_sub_title_):
      out.putVarInt32(90)
      out.putPrefixedString(self.sub_title_)
    if (self.has_editors_):
      out.putVarInt32(98)
      out.putPrefixedString(self.editors_)
    if (self.has_structured_page_number_):
      out.putVarInt32(106)
      out.putPrefixedString(self.structured_page_number_)
    if (self.has_num_pages_):
      out.putVarInt32(112)
      out.putVarInt32(self.num_pages_)
    if (self.has_bookspecific_):
      out.putVarInt32(123)
      self.bookspecific_.OutputUnchecked(out)
      out.putVarInt32(124)
    if (self.has_patentspecific_):
      out.putVarInt32(155)
      self.patentspecific_.OutputUnchecked(out)
      out.putVarInt32(156)
    if (self.has_cover_page_):
      out.putVarInt32(162)
      out.putPrefixedString(self.cover_page_)
    if (self.has_catalogspecific_):
      out.putVarInt32(171)
      self.catalogspecific_.OutputUnchecked(out)
      out.putVarInt32(172)
    if (self.has_deprecated_issue_date_):
      out.putVarInt32(194)
      out.putPrefixedString(self.deprecated_issue_date_)
    if (self.has_url_key_):
      out.putVarInt32(202)
      out.putPrefixedString(self.url_key_)
    if (self.has_source_type_):
      out.putVarInt32(208)
      out.putVarInt32(self.source_type_)
    if (self.has_content_type_):
      out.putVarInt32(216)
      out.putVarInt32(self.content_type_)
    if (self.has_block_snippet_):
      out.putVarInt32(224)
      out.putBoolean(self.block_snippet_)
    if (self.has_segment_time_):
      out.putVarInt32(232)
      out.putVarInt32(self.segment_time_)
    for i in xrange(len(self.page_type_bitmap_)):
      out.putVarInt32(240)
      out.putVarInt32(self.page_type_bitmap_[i])
    if (self.has_deprecated_publisher_percent_visible_):
      out.putVarInt32(248)
      out.putVarInt32(self.deprecated_publisher_percent_visible_)
    if (self.has_pagerank_):
      out.putVarInt32(257)
      out.putDouble(self.pagerank_)
    if (self.has_workcluster_):
      out.putVarInt32(275)
      self.workcluster_.OutputUnchecked(out)
      out.putVarInt32(276)
    if (self.has_is_landing_page_):
      out.putVarInt32(296)
      out.putBoolean(self.is_landing_page_)
    if (self.has_viewability_):
      out.putVarInt32(306)
      out.putVarInt32(self.viewability_.ByteSize())
      self.viewability_.OutputUnchecked(out)
    if (self.has_metadata_cover_exists_):
      out.putVarInt32(312)
      out.putBoolean(self.metadata_cover_exists_)
    if (self.has_cover_page_size_):
      out.putVarInt32(378)
      out.putVarInt32(self.cover_page_size_.ByteSize())
      self.cover_page_size_.OutputUnchecked(out)
    if (self.has_ref_page_url_):
      out.putVarInt32(394)
      out.putPrefixedString(self.ref_page_url_)
    if (self.has_thumbnail_url_):
      out.putVarInt32(402)
      out.putPrefixedString(self.thumbnail_url_)
    if (self.has_metadata_cover_size_):
      out.putVarInt32(410)
      out.putVarInt32(self.metadata_cover_size_.ByteSize())
      self.metadata_cover_size_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_title(d.getPrefixedString())
        continue
      if tt == 18:
        self.set_authors(d.getPrefixedString())
        continue
      if tt == 24:
        self.set_pageid(d.getVarInt32())
        continue
      if tt == 32:
        self.set_page_number(d.getVarInt32())
        continue
      if tt == 42:
        self.set_printed_page_number(d.getPrefixedString())
        continue
      if tt == 50:
        self.add_geo_restrict(d.getPrefixedString())
        continue
      if tt == 56:
        self.set_volume_type(d.getVarInt32())
        continue
      if tt == 66:
        self.set_deprecated_patent_number(d.getPrefixedString())
        continue
      if tt == 74:
        self.set_deprecated_patent_assignee(d.getPrefixedString())
        continue
      if tt == 82:
        self.set_deprecated_application_date(d.getPrefixedString())
        continue
      if tt == 90:
        self.set_sub_title(d.getPrefixedString())
        continue
      if tt == 98:
        self.set_editors(d.getPrefixedString())
        continue
      if tt == 106:
        self.set_structured_page_number(d.getPrefixedString())
        continue
      if tt == 112:
        self.set_num_pages(d.getVarInt32())
        continue
      if tt == 123:
        self.mutable_bookspecific().TryMerge(d)
        continue
      if tt == 155:
        self.mutable_patentspecific().TryMerge(d)
        continue
      if tt == 162:
        self.set_cover_page(d.getPrefixedString())
        continue
      if tt == 171:
        self.mutable_catalogspecific().TryMerge(d)
        continue
      if tt == 194:
        self.set_deprecated_issue_date(d.getPrefixedString())
        continue
      if tt == 202:
        self.set_url_key(d.getPrefixedString())
        continue
      if tt == 208:
        self.set_source_type(d.getVarInt32())
        continue
      if tt == 216:
        self.set_content_type(d.getVarInt32())
        continue
      if tt == 224:
        self.set_block_snippet(d.getBoolean())
        continue
      if tt == 232:
        self.set_segment_time(d.getVarInt32())
        continue
      if tt == 240:
        self.add_page_type_bitmap(d.getVarInt32())
        continue
      if tt == 248:
        self.set_deprecated_publisher_percent_visible(d.getVarInt32())
        continue
      if tt == 257:
        self.set_pagerank(d.getDouble())
        continue
      if tt == 275:
        self.mutable_workcluster().TryMerge(d)
        continue
      if tt == 296:
        self.set_is_landing_page(d.getBoolean())
        continue
      if tt == 306:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_viewability().TryMerge(tmp)
        continue
      if tt == 312:
        self.set_metadata_cover_exists(d.getBoolean())
        continue
      if tt == 378:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_cover_page_size().TryMerge(tmp)
        continue
      if tt == 394:
        self.set_ref_page_url(d.getPrefixedString())
        continue
      if tt == 402:
        self.set_thumbnail_url(d.getPrefixedString())
        continue
      if tt == 410:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_metadata_cover_size().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_url_key_: res+=prefix+("url_key: %s\n" % self.DebugFormatString(self.url_key_))
    if self.has_title_: res+=prefix+("title: %s\n" % self.DebugFormatString(self.title_))
    if self.has_sub_title_: res+=prefix+("sub_title: %s\n" % self.DebugFormatString(self.sub_title_))
    if self.has_authors_: res+=prefix+("authors: %s\n" % self.DebugFormatString(self.authors_))
    if self.has_editors_: res+=prefix+("editors: %s\n" % self.DebugFormatString(self.editors_))
    if self.has_workcluster_:
      res+=prefix+"WorkCluster {\n"
      res+=self.workcluster_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_num_pages_: res+=prefix+("num_pages: %s\n" % self.DebugFormatInt32(self.num_pages_))
    if self.has_page_number_: res+=prefix+("page_number: %s\n" % self.DebugFormatInt32(self.page_number_))
    if self.has_structured_page_number_: res+=prefix+("structured_page_number: %s\n" % self.DebugFormatString(self.structured_page_number_))
    cnt=0
    for e in self.geo_restrict_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("geo_restrict%s: %s\n" % (elm, self.DebugFormatString(e)))
      cnt+=1
    if self.has_viewability_:
      res+=prefix+"viewability <\n"
      res+=self.viewability_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_cover_page_: res+=prefix+("cover_page: %s\n" % self.DebugFormatString(self.cover_page_))
    if self.has_cover_page_size_:
      res+=prefix+"cover_page_size <\n"
      res+=self.cover_page_size_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_metadata_cover_size_:
      res+=prefix+"metadata_cover_size <\n"
      res+=self.metadata_cover_size_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_metadata_cover_exists_: res+=prefix+("metadata_cover_exists: %s\n" % self.DebugFormatBool(self.metadata_cover_exists_))
    if self.has_source_type_: res+=prefix+("source_type: %s\n" % self.DebugFormatInt32(self.source_type_))
    if self.has_content_type_: res+=prefix+("content_type: %s\n" % self.DebugFormatInt32(self.content_type_))
    if self.has_volume_type_: res+=prefix+("volume_type: %s\n" % self.DebugFormatInt32(self.volume_type_))
    if self.has_bookspecific_:
      res+=prefix+"BookSpecific {\n"
      res+=self.bookspecific_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_patentspecific_:
      res+=prefix+"PatentSpecific {\n"
      res+=self.patentspecific_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_deprecated_patent_number_: res+=prefix+("DEPRECATED_patent_number: %s\n" % self.DebugFormatString(self.deprecated_patent_number_))
    if self.has_deprecated_patent_assignee_: res+=prefix+("DEPRECATED_patent_assignee: %s\n" % self.DebugFormatString(self.deprecated_patent_assignee_))
    if self.has_deprecated_application_date_: res+=prefix+("DEPRECATED_application_date: %s\n" % self.DebugFormatString(self.deprecated_application_date_))
    if self.has_deprecated_issue_date_: res+=prefix+("DEPRECATED_issue_date: %s\n" % self.DebugFormatString(self.deprecated_issue_date_))
    if self.has_catalogspecific_:
      res+=prefix+"CatalogSpecific {\n"
      res+=self.catalogspecific_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_pageid_: res+=prefix+("pageid: %s\n" % self.DebugFormatInt32(self.pageid_))
    if self.has_printed_page_number_: res+=prefix+("printed_page_number: %s\n" % self.DebugFormatString(self.printed_page_number_))
    if self.has_block_snippet_: res+=prefix+("block_snippet: %s\n" % self.DebugFormatBool(self.block_snippet_))
    if self.has_segment_time_: res+=prefix+("segment_time: %s\n" % self.DebugFormatInt32(self.segment_time_))
    cnt=0
    for e in self.page_type_bitmap_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("page_type_bitmap%s: %s\n" % (elm, self.DebugFormatInt32(e)))
      cnt+=1
    if self.has_deprecated_publisher_percent_visible_: res+=prefix+("DEPRECATED_publisher_percent_visible: %s\n" % self.DebugFormatInt32(self.deprecated_publisher_percent_visible_))
    if self.has_pagerank_: res+=prefix+("pagerank: %s\n" % self.DebugFormat(self.pagerank_))
    if self.has_is_landing_page_: res+=prefix+("is_landing_page: %s\n" % self.DebugFormatBool(self.is_landing_page_))
    if self.has_ref_page_url_: res+=prefix+("ref_page_url: %s\n" % self.DebugFormatString(self.ref_page_url_))
    if self.has_thumbnail_url_: res+=prefix+("thumbnail_url: %s\n" % self.DebugFormatString(self.thumbnail_url_))
    return res

  kurl_key = 25
  ktitle = 1
  ksub_title = 11
  kauthors = 2
  keditors = 12
  kWorkClusterGroup = 34
  kWorkClusterwork_id = 35
  kWorkClustercluster_size = 36
  knum_pages = 14
  kpage_number = 4
  kstructured_page_number = 13
  kgeo_restrict = 6
  kviewability = 38
  kcover_page = 20
  kcover_page_size = 47
  kmetadata_cover_size = 51
  kmetadata_cover_exists = 39
  ksource_type = 26
  kcontent_type = 27
  kvolume_type = 7
  kBookSpecificGroup = 15
  kBookSpecificsubject = 16
  kBookSpecificimprint = 17
  kBookSpecificpublication_date = 18
  kBookSpecificaux_bibkeys = 41
  kPatentSpecificGroup = 19
  kPatentSpecificdocument_number = 42
  kPatentSpecificpatent_assignee = 43
  kPatentSpecificapplication_date = 44
  kPatentSpecificissue_date = 45
  kPatentSpecificdoc_type = 46
  kPatentSpecificpublication_number = 48
  kDEPRECATED_patent_number = 8
  kDEPRECATED_patent_assignee = 9
  kDEPRECATED_application_date = 10
  kDEPRECATED_issue_date = 24
  kCatalogSpecificGroup = 21
  kCatalogSpecificpublication_time_to_display = 22
  kCatalogSpecificpublication_date = 23
  kCatalogSpecificlatest = 33
  kpageid = 3
  kprinted_page_number = 5
  kblock_snippet = 28
  ksegment_time = 29
  kpage_type_bitmap = 30
  kDEPRECATED_publisher_percent_visible = 31
  kpagerank = 32
  kis_landing_page = 37
  kref_page_url = 49
  kthumbnail_url = 50

  _TEXT = (
   "ErrorCode",  #   0
   "title",  #   1
   "authors",  #   2
   "pageid",  #   3
   "page_number",  #   4
   "printed_page_number",  #   5
   "geo_restrict",  #   6
   "volume_type",  #   7
   "DEPRECATED_patent_number",  #   8
   "DEPRECATED_patent_assignee",  #   9
   "DEPRECATED_application_date",  #  10
   "sub_title",  #  11
   "editors",  #  12
   "structured_page_number",  #  13
   "num_pages",  #  14
   "BookSpecific",  #  15
   "subject",  #  16
   "imprint",  #  17
   "publication_date",  #  18
   "PatentSpecific",  #  19
   "cover_page",  #  20
   "CatalogSpecific",  #  21
   "publication_time_to_display",  #  22
   "publication_date",  #  23
   "DEPRECATED_issue_date",  #  24
   "url_key",  #  25
   "source_type",  #  26
   "content_type",  #  27
   "block_snippet",  #  28
   "segment_time",  #  29
   "page_type_bitmap",  #  30
   "DEPRECATED_publisher_percent_visible",  #  31
   "pagerank",  #  32
   "latest",  #  33
   "WorkCluster",  #  34
   "work_id",  #  35
   "cluster_size",  #  36
   "is_landing_page",  #  37
   "viewability",  #  38
   "metadata_cover_exists",  #  39
   None,  #  40
   "aux_bibkeys",  #  41
   "document_number",  #  42
   "patent_assignee",  #  43
   "application_date",  #  44
   "issue_date",  #  45
   "doc_type",  #  46
   "cover_page_size",  #  47
   "publication_number",  #  48
   "ref_page_url",  #  49
   "thumbnail_url",  #  50
   "metadata_cover_size",  #  51
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STRING,  #   6

   ProtocolBuffer.Encoder.NUMERIC,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.STRING,  #   9

   ProtocolBuffer.Encoder.STRING,  #  10

   ProtocolBuffer.Encoder.STRING,  #  11

   ProtocolBuffer.Encoder.STRING,  #  12

   ProtocolBuffer.Encoder.STRING,  #  13

   ProtocolBuffer.Encoder.NUMERIC,  #  14

   ProtocolBuffer.Encoder.STARTGROUP,  #  15

   ProtocolBuffer.Encoder.STRING,  #  16

   ProtocolBuffer.Encoder.STRING,  #  17

   ProtocolBuffer.Encoder.STRING,  #  18

   ProtocolBuffer.Encoder.STARTGROUP,  #  19

   ProtocolBuffer.Encoder.STRING,  #  20

   ProtocolBuffer.Encoder.STARTGROUP,  #  21

   ProtocolBuffer.Encoder.STRING,  #  22

   ProtocolBuffer.Encoder.NUMERIC,  #  23

   ProtocolBuffer.Encoder.STRING,  #  24

   ProtocolBuffer.Encoder.STRING,  #  25

   ProtocolBuffer.Encoder.NUMERIC,  #  26

   ProtocolBuffer.Encoder.NUMERIC,  #  27

   ProtocolBuffer.Encoder.NUMERIC,  #  28

   ProtocolBuffer.Encoder.NUMERIC,  #  29

   ProtocolBuffer.Encoder.NUMERIC,  #  30

   ProtocolBuffer.Encoder.NUMERIC,  #  31

   ProtocolBuffer.Encoder.DOUBLE,  #  32

   ProtocolBuffer.Encoder.NUMERIC,  #  33

   ProtocolBuffer.Encoder.STARTGROUP,  #  34

   ProtocolBuffer.Encoder.NUMERIC,  #  35

   ProtocolBuffer.Encoder.NUMERIC,  #  36

   ProtocolBuffer.Encoder.NUMERIC,  #  37

   ProtocolBuffer.Encoder.STRING,  #  38

   ProtocolBuffer.Encoder.NUMERIC,  #  39

   ProtocolBuffer.Encoder.MAX_TYPE,  #  40

   ProtocolBuffer.Encoder.STRING,  #  41

   ProtocolBuffer.Encoder.STRING,  #  42

   ProtocolBuffer.Encoder.STRING,  #  43

   ProtocolBuffer.Encoder.STRING,  #  44

   ProtocolBuffer.Encoder.STRING,  #  45

   ProtocolBuffer.Encoder.NUMERIC,  #  46

   ProtocolBuffer.Encoder.STRING,  #  47

   ProtocolBuffer.Encoder.STRING,  #  48

   ProtocolBuffer.Encoder.STRING,  #  49

   ProtocolBuffer.Encoder.STRING,  #  50

   ProtocolBuffer.Encoder.STRING,  #  51

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x26,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x2f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2f,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x5f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0b,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x44,
    0x6f,
    0x63,
    0x54,
    0x61,
    0x67,
    0x13,
    0x1a,
    0x07,
    0x75,
    0x72,
    0x6c,
    0x5f,
    0x6b,
    0x65,
    0x79,
    0x20,
    0x19,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x74,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x73,
    0x75,
    0x62,
    0x5f,
    0x74,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x20,
    0x0b,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x61,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x65,
    0x64,
    0x69,
    0x74,
    0x6f,
    0x72,
    0x73,
    0x20,
    0x0c,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x57,
    0x6f,
    0x72,
    0x6b,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x20,
    0x22,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x57,
    0x6f,
    0x72,
    0x6b,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x77,
    0x6f,
    0x72,
    0x6b,
    0x5f,
    0x69,
    0x64,
    0x20,
    0x23,
    0x28,
    0x00,
    0x30,
    0x03,
    0x38,
    0x01,
    0x60,
    0x05,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x57,
    0x6f,
    0x72,
    0x6b,
    0x43,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x2e,
    0x63,
    0x6c,
    0x75,
    0x73,
    0x74,
    0x65,
    0x72,
    0x5f,
    0x73,
    0x69,
    0x7a,
    0x65,
    0x20,
    0x24,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x05,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x6e,
    0x75,
    0x6d,
    0x5f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x73,
    0x20,
    0x0e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x73,
    0x74,
    0x72,
    0x75,
    0x63,
    0x74,
    0x75,
    0x72,
    0x65,
    0x64,
    0x5f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x0d,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x67,
    0x65,
    0x6f,
    0x5f,
    0x72,
    0x65,
    0x73,
    0x74,
    0x72,
    0x69,
    0x63,
    0x74,
    0x20,
    0x06,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x76,
    0x69,
    0x65,
    0x77,
    0x61,
    0x62,
    0x69,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x20,
    0x26,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x17,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x2e,
    0x56,
    0x6f,
    0x6c,
    0x75,
    0x6d,
    0x65,
    0x56,
    0x69,
    0x65,
    0x77,
    0x61,
    0x62,
    0x69,
    0x6c,
    0x69,
    0x74,
    0x79,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x5f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x20,
    0x14,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x5f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x73,
    0x69,
    0x7a,
    0x65,
    0x20,
    0x2f,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0f,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x2e,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x53,
    0x69,
    0x7a,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x04,
    0x77,
    0x65,
    0x61,
    0x6b,
    0xb2,
    0x01,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x6d,
    0x65,
    0x74,
    0x61,
    0x64,
    0x61,
    0x74,
    0x61,
    0x5f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x5f,
    0x73,
    0x69,
    0x7a,
    0x65,
    0x20,
    0x33,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0f,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x2e,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x53,
    0x69,
    0x7a,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x04,
    0x77,
    0x65,
    0x61,
    0x6b,
    0xb2,
    0x01,
    0x04,
    0x74,
    0x72,
    0x75,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x6d,
    0x65,
    0x74,
    0x61,
    0x64,
    0x61,
    0x74,
    0x61,
    0x5f,
    0x63,
    0x6f,
    0x76,
    0x65,
    0x72,
    0x5f,
    0x65,
    0x78,
    0x69,
    0x73,
    0x74,
    0x73,
    0x20,
    0x27,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x73,
    0x6f,
    0x75,
    0x72,
    0x63,
    0x65,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x1a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x63,
    0x6f,
    0x6e,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x1b,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x76,
    0x6f,
    0x6c,
    0x75,
    0x6d,
    0x65,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x07,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x42,
    0x6f,
    0x6f,
    0x6b,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x20,
    0x0f,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x42,
    0x6f,
    0x6f,
    0x6b,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x73,
    0x75,
    0x62,
    0x6a,
    0x65,
    0x63,
    0x74,
    0x20,
    0x10,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x14,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x42,
    0x6f,
    0x6f,
    0x6b,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x69,
    0x6d,
    0x70,
    0x72,
    0x69,
    0x6e,
    0x74,
    0x20,
    0x11,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x14,
    0x14,
    0x13,
    0x1a,
    0x1d,
    0x42,
    0x6f,
    0x6f,
    0x6b,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x70,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x65,
    0x20,
    0x12,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x14,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x42,
    0x6f,
    0x6f,
    0x6b,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x61,
    0x75,
    0x78,
    0x5f,
    0x62,
    0x69,
    0x62,
    0x6b,
    0x65,
    0x79,
    0x73,
    0x20,
    0x29,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x03,
    0x60,
    0x14,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x50,
    0x61,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x20,
    0x13,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x50,
    0x61,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x64,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x2a,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x19,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x50,
    0x61,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x70,
    0x61,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x61,
    0x73,
    0x73,
    0x69,
    0x67,
    0x6e,
    0x65,
    0x65,
    0x20,
    0x2b,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x19,
    0x14,
    0x13,
    0x1a,
    0x1f,
    0x50,
    0x61,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x61,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x65,
    0x20,
    0x2c,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x19,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x50,
    0x61,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x69,
    0x73,
    0x73,
    0x75,
    0x65,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x65,
    0x20,
    0x2d,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x19,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x50,
    0x61,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x64,
    0x6f,
    0x63,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x2e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x19,
    0x14,
    0x13,
    0x1a,
    0x21,
    0x50,
    0x61,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x70,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x30,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x19,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x5f,
    0x70,
    0x61,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x5f,
    0x70,
    0x61,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x61,
    0x73,
    0x73,
    0x69,
    0x67,
    0x6e,
    0x65,
    0x65,
    0x20,
    0x09,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x5f,
    0x61,
    0x70,
    0x70,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x65,
    0x20,
    0x0a,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x5f,
    0x69,
    0x73,
    0x73,
    0x75,
    0x65,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x65,
    0x20,
    0x18,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x43,
    0x61,
    0x74,
    0x61,
    0x6c,
    0x6f,
    0x67,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x20,
    0x15,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x2b,
    0x43,
    0x61,
    0x74,
    0x61,
    0x6c,
    0x6f,
    0x67,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x70,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x74,
    0x69,
    0x6d,
    0x65,
    0x5f,
    0x74,
    0x6f,
    0x5f,
    0x64,
    0x69,
    0x73,
    0x70,
    0x6c,
    0x61,
    0x79,
    0x20,
    0x16,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x24,
    0x14,
    0x13,
    0x1a,
    0x20,
    0x43,
    0x61,
    0x74,
    0x61,
    0x6c,
    0x6f,
    0x67,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x70,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x63,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x5f,
    0x64,
    0x61,
    0x74,
    0x65,
    0x20,
    0x17,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x24,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x43,
    0x61,
    0x74,
    0x61,
    0x6c,
    0x6f,
    0x67,
    0x53,
    0x70,
    0x65,
    0x63,
    0x69,
    0x66,
    0x69,
    0x63,
    0x2e,
    0x6c,
    0x61,
    0x74,
    0x65,
    0x73,
    0x74,
    0x20,
    0x21,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0x60,
    0x24,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x70,
    0x61,
    0x67,
    0x65,
    0x69,
    0x64,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x70,
    0x72,
    0x69,
    0x6e,
    0x74,
    0x65,
    0x64,
    0x5f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x62,
    0x6c,
    0x6f,
    0x63,
    0x6b,
    0x5f,
    0x73,
    0x6e,
    0x69,
    0x70,
    0x70,
    0x65,
    0x74,
    0x20,
    0x1c,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x73,
    0x65,
    0x67,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x74,
    0x69,
    0x6d,
    0x65,
    0x20,
    0x1d,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x02,
    0x2d,
    0x31,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x02,
    0x2d,
    0x31,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x74,
    0x79,
    0x70,
    0x65,
    0x5f,
    0x62,
    0x69,
    0x74,
    0x6d,
    0x61,
    0x70,
    0x20,
    0x1e,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x24,
    0x44,
    0x45,
    0x50,
    0x52,
    0x45,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x5f,
    0x70,
    0x75,
    0x62,
    0x6c,
    0x69,
    0x73,
    0x68,
    0x65,
    0x72,
    0x5f,
    0x70,
    0x65,
    0x72,
    0x63,
    0x65,
    0x6e,
    0x74,
    0x5f,
    0x76,
    0x69,
    0x73,
    0x69,
    0x62,
    0x6c,
    0x65,
    0x20,
    0x1f,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x70,
    0x61,
    0x67,
    0x65,
    0x72,
    0x61,
    0x6e,
    0x6b,
    0x20,
    0x20,
    0x28,
    0x01,
    0x30,
    0x01,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x69,
    0x73,
    0x5f,
    0x6c,
    0x61,
    0x6e,
    0x64,
    0x69,
    0x6e,
    0x67,
    0x5f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x20,
    0x25,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x42,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x05,
    0x66,
    0x61,
    0x6c,
    0x73,
    0x65,
    0xa4,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0c,
    0x72,
    0x65,
    0x66,
    0x5f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x31,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x74,
    0x68,
    0x75,
    0x6d,
    0x62,
    0x6e,
    0x61,
    0x69,
    0x6c,
    0x5f,
    0x75,
    0x72,
    0x6c,
    0x20,
    0x32,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x04,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x04,
    0x42,
    0x4f,
    0x4f,
    0x4b,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x06,
    0x50,
    0x41,
    0x54,
    0x45,
    0x4e,
    0x54,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x43,
    0x41,
    0x54,
    0x41,
    0x4c,
    0x4f,
    0x47,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x4d,
    0x41,
    0x47,
    0x41,
    0x5a,
    0x49,
    0x4e,
    0x45,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x41,
    0x47,
    0x41,
    0x5a,
    0x49,
    0x4e,
    0x45,
    0x5f,
    0x53,
    0x45,
    0x52,
    0x49,
    0x41,
    0x4c,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x09,
    0x4e,
    0x45,
    0x57,
    0x53,
    0x50,
    0x41,
    0x50,
    0x45,
    0x52,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x0d,
    0x50,
    0x61,
    0x74,
    0x65,
    0x6e,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x54,
    0x79,
    0x70,
    0x65,
    0x80,
    0x01,
    0x19,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x55,
    0x53,
    0x5f,
    0x47,
    0x52,
    0x41,
    0x4e,
    0x54,
    0x45,
    0x44,
    0x5f,
    0x50,
    0x41,
    0x54,
    0x45,
    0x4e,
    0x54,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x55,
    0x53,
    0x5f,
    0x41,
    0x50,
    0x50,
    0x4c,
    0x49,
    0x43,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class OceanDocInfo(ProtocolBuffer.ProtocolMessage):

  MESSAGE_TYPE_ID = 1621593 

  _TypeId_NAMES = {
    1621593: "MESSAGE_TYPE_ID",
  }

  def TypeId_Name(cls, x): return cls._TypeId_NAMES.get(x, "")
  TypeId_Name = classmethod(TypeId_Name)

  def __init__(self, contents=None):
    self.doc_tag_ = OceanDocTag()
    self.has_doc_tag_ = 0
    if contents is not None: self.MergeFromString(contents)

  def doc_tag(self): return self.doc_tag_

  def mutable_doc_tag(self): self.has_doc_tag_ = 1; return self.doc_tag_

  def clear_doc_tag(self):self.has_doc_tag_ = 0; self.doc_tag_.Clear()

  def has_doc_tag(self): return self.has_doc_tag_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_doc_tag()): self.mutable_doc_tag().MergeFrom(x.doc_tag())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanDocInfo', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanDocInfo')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanDocInfo', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanDocInfo', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanDocInfo', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_doc_tag_ != x.has_doc_tag_: return 0
    if self.has_doc_tag_ and self.doc_tag_ != x.doc_tag_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_doc_tag_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: doc_tag not set.')
    elif not self.doc_tag_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(self.doc_tag_.ByteSize())
    return n + 1

  def Clear(self):
    self.clear_doc_tag()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putVarInt32(self.doc_tag_.ByteSize())
    self.doc_tag_.OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_doc_tag().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_doc_tag_:
      res+=prefix+"doc_tag <\n"
      res+=self.doc_tag_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

  kdoc_tag = 1

  _TEXT = (
   "ErrorCode",  #   0
   "doc_tag",  #   1
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x26,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x2f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2f,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x5f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0c,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x44,
    0x6f,
    0x63,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x13,
    0x1a,
    0x07,
    0x64,
    0x6f,
    0x63,
    0x5f,
    0x74,
    0x61,
    0x67,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x0b,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x44,
    0x6f,
    0x63,
    0x54,
    0x61,
    0x67,
    0x14,
    0x73,
    0x7a,
    0x06,
    0x54,
    0x79,
    0x70,
    0x65,
    0x49,
    0x64,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4d,
    0x45,
    0x53,
    0x53,
    0x41,
    0x47,
    0x45,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x5f,
    0x49,
    0x44,
    0x98,
    0x01,
    0xd9,
    0xfc,
    0x62,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class OceanImageBox(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.x_left_ = 0
    self.y_top_ = 0
    self.x_right_ = 0
    self.y_bottom_ = 0
    self.page_offset_ = 0
    self.has_x_left_ = 0
    self.has_y_top_ = 0
    self.has_x_right_ = 0
    self.has_y_bottom_ = 0
    self.has_page_offset_ = 0
    if contents is not None: self.MergeFromString(contents)

  def x_left(self): return self.x_left_

  def set_x_left(self, x):
    self.has_x_left_ = 1
    self.x_left_ = x

  def clear_x_left(self):
    self.has_x_left_ = 0
    self.x_left_ = 0

  def has_x_left(self): return self.has_x_left_

  def y_top(self): return self.y_top_

  def set_y_top(self, x):
    self.has_y_top_ = 1
    self.y_top_ = x

  def clear_y_top(self):
    self.has_y_top_ = 0
    self.y_top_ = 0

  def has_y_top(self): return self.has_y_top_

  def x_right(self): return self.x_right_

  def set_x_right(self, x):
    self.has_x_right_ = 1
    self.x_right_ = x

  def clear_x_right(self):
    self.has_x_right_ = 0
    self.x_right_ = 0

  def has_x_right(self): return self.has_x_right_

  def y_bottom(self): return self.y_bottom_

  def set_y_bottom(self, x):
    self.has_y_bottom_ = 1
    self.y_bottom_ = x

  def clear_y_bottom(self):
    self.has_y_bottom_ = 0
    self.y_bottom_ = 0

  def has_y_bottom(self): return self.has_y_bottom_

  def page_offset(self): return self.page_offset_

  def set_page_offset(self, x):
    self.has_page_offset_ = 1
    self.page_offset_ = x

  def clear_page_offset(self):
    self.has_page_offset_ = 0
    self.page_offset_ = 0

  def has_page_offset(self): return self.has_page_offset_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_x_left()): self.set_x_left(x.x_left())
    if (x.has_y_top()): self.set_y_top(x.y_top())
    if (x.has_x_right()): self.set_x_right(x.x_right())
    if (x.has_y_bottom()): self.set_y_bottom(x.y_bottom())
    if (x.has_page_offset()): self.set_page_offset(x.page_offset())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanImageBox', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanImageBox')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanImageBox', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanImageBox', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanImageBox', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_x_left_ != x.has_x_left_: return 0
    if self.has_x_left_ and self.x_left_ != x.x_left_: return 0
    if self.has_y_top_ != x.has_y_top_: return 0
    if self.has_y_top_ and self.y_top_ != x.y_top_: return 0
    if self.has_x_right_ != x.has_x_right_: return 0
    if self.has_x_right_ and self.x_right_ != x.x_right_: return 0
    if self.has_y_bottom_ != x.has_y_bottom_: return 0
    if self.has_y_bottom_ and self.y_bottom_ != x.y_bottom_: return 0
    if self.has_page_offset_ != x.has_page_offset_: return 0
    if self.has_page_offset_ and self.page_offset_ != x.page_offset_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_x_left_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: x_left not set.')
    if (not self.has_y_top_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: y_top not set.')
    if (not self.has_x_right_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: x_right not set.')
    if (not self.has_y_bottom_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: y_bottom not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.x_left_)
    n += self.lengthVarInt64(self.y_top_)
    n += self.lengthVarInt64(self.x_right_)
    n += self.lengthVarInt64(self.y_bottom_)
    if (self.has_page_offset_): n += 1 + self.lengthVarInt64(self.page_offset_)
    return n + 4

  def Clear(self):
    self.clear_x_left()
    self.clear_y_top()
    self.clear_x_right()
    self.clear_y_bottom()
    self.clear_page_offset()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.x_left_)
    out.putVarInt32(16)
    out.putVarInt32(self.y_top_)
    out.putVarInt32(24)
    out.putVarInt32(self.x_right_)
    out.putVarInt32(32)
    out.putVarInt32(self.y_bottom_)
    if (self.has_page_offset_):
      out.putVarInt32(40)
      out.putVarInt32(self.page_offset_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_x_left(d.getVarInt32())
        continue
      if tt == 16:
        self.set_y_top(d.getVarInt32())
        continue
      if tt == 24:
        self.set_x_right(d.getVarInt32())
        continue
      if tt == 32:
        self.set_y_bottom(d.getVarInt32())
        continue
      if tt == 40:
        self.set_page_offset(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_x_left_: res+=prefix+("x_left: %s\n" % self.DebugFormatInt32(self.x_left_))
    if self.has_y_top_: res+=prefix+("y_top: %s\n" % self.DebugFormatInt32(self.y_top_))
    if self.has_x_right_: res+=prefix+("x_right: %s\n" % self.DebugFormatInt32(self.x_right_))
    if self.has_y_bottom_: res+=prefix+("y_bottom: %s\n" % self.DebugFormatInt32(self.y_bottom_))
    if self.has_page_offset_: res+=prefix+("page_offset: %s\n" % self.DebugFormatInt32(self.page_offset_))
    return res

  kx_left = 1
  ky_top = 2
  kx_right = 3
  ky_bottom = 4
  kpage_offset = 5

  _TEXT = (
   "ErrorCode",  #   0
   "x_left",  #   1
   "y_top",  #   2
   "x_right",  #   3
   "y_bottom",  #   4
   "page_offset",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.NUMERIC,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x26,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x2f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2f,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x5f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0d,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x42,
    0x6f,
    0x78,
    0x13,
    0x1a,
    0x06,
    0x78,
    0x5f,
    0x6c,
    0x65,
    0x66,
    0x74,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x79,
    0x5f,
    0x74,
    0x6f,
    0x70,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x07,
    0x78,
    0x5f,
    0x72,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x79,
    0x5f,
    0x62,
    0x6f,
    0x74,
    0x74,
    0x6f,
    0x6d,
    0x20,
    0x04,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x6f,
    0x66,
    0x66,
    0x73,
    0x65,
    0x74,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x42,
    0x01,
    0x30,
    0xa3,
    0x01,
    0xaa,
    0x01,
    0x07,
    0x64,
    0x65,
    0x66,
    0x61,
    0x75,
    0x6c,
    0x74,
    0xb2,
    0x01,
    0x01,
    0x30,
    0xa4,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class OceanWordBoxes_Words(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.characters_ = ""
    self.boxes_ = []
    self.has_characters_ = 0
    if contents is not None: self.MergeFromString(contents)

  def characters(self): return self.characters_

  def set_characters(self, x):
    self.has_characters_ = 1
    self.characters_ = x

  def clear_characters(self):
    self.has_characters_ = 0
    self.characters_ = ""

  def has_characters(self): return self.has_characters_

  def boxes_size(self): return len(self.boxes_)
  def boxes_list(self): return self.boxes_

  def boxes(self, i):
    return self.boxes_[i]

  def mutable_boxes(self, i):
    return self.boxes_[i]

  def add_boxes(self):
    x = OceanImageBox()
    self.boxes_.append(x)
    return x

  def clear_boxes(self):
    self.boxes_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_characters()): self.set_characters(x.characters())
    for i in xrange(x.boxes_size()): self.add_boxes().CopyFrom(x.boxes(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanWordBoxes', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanWordBoxes')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanWordBoxes', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanWordBoxes', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanWordBoxes', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_characters_ != x.has_characters_: return 0
    if self.has_characters_ and self.characters_ != x.characters_: return 0
    if len(self.boxes_) != len(x.boxes_): return 0
    for e1, e2 in zip(self.boxes_, x.boxes_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_characters_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: characters not set.')
    for i in xrange(len(self.boxes_)):
      if (not self.boxes_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.characters_))
    n += 1 * len(self.boxes_)
    for i in xrange(len(self.boxes_)): n += self.lengthString(self.boxes_[i].ByteSize())
    return n + 1

  def Clear(self):
    self.clear_characters()
    self.clear_boxes()

  def OutputUnchecked(self, out):
    out.putVarInt32(18)
    out.putPrefixedString(self.characters_)
    for i in xrange(len(self.boxes_)):
      out.putVarInt32(26)
      out.putVarInt32(self.boxes_[i].ByteSize())
      self.boxes_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        self.set_characters(d.getPrefixedString())
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_boxes().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_characters_: res+=prefix+("characters: %s\n" % self.DebugFormatString(self.characters_))
    cnt=0
    for e in self.boxes_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Boxes%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

class OceanWordBoxes_PageDimensions(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.width_ = 0
    self.height_ = 0
    self.has_width_ = 0
    self.has_height_ = 0
    if contents is not None: self.MergeFromString(contents)

  def width(self): return self.width_

  def set_width(self, x):
    self.has_width_ = 1
    self.width_ = x

  def clear_width(self):
    self.has_width_ = 0
    self.width_ = 0

  def has_width(self): return self.has_width_

  def height(self): return self.height_

  def set_height(self, x):
    self.has_height_ = 1
    self.height_ = x

  def clear_height(self):
    self.has_height_ = 0
    self.height_ = 0

  def has_height(self): return self.has_height_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_width()): self.set_width(x.width())
    if (x.has_height()): self.set_height(x.height())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanWordBoxes', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanWordBoxes')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanWordBoxes', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanWordBoxes', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanWordBoxes', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_width_ != x.has_width_: return 0
    if self.has_width_ and self.width_ != x.width_: return 0
    if self.has_height_ != x.has_height_: return 0
    if self.has_height_ and self.height_ != x.height_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_width_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: width not set.')
    if (not self.has_height_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: height not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.width_)
    n += self.lengthVarInt64(self.height_)
    return n + 2

  def Clear(self):
    self.clear_width()
    self.clear_height()

  def OutputUnchecked(self, out):
    out.putVarInt32(40)
    out.putVarInt32(self.width_)
    out.putVarInt32(48)
    out.putVarInt32(self.height_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 36: break
      if tt == 40:
        self.set_width(d.getVarInt32())
        continue
      if tt == 48:
        self.set_height(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_width_: res+=prefix+("width: %s\n" % self.DebugFormatInt32(self.width_))
    if self.has_height_: res+=prefix+("height: %s\n" % self.DebugFormatInt32(self.height_))
    return res

class OceanWordBoxes(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.width_ = 0
    self.height_ = 0
    self.pagedimensions_ = []
    self.words_ = []
    self.has_width_ = 0
    self.has_height_ = 0
    if contents is not None: self.MergeFromString(contents)

  def width(self): return self.width_

  def set_width(self, x):
    self.has_width_ = 1
    self.width_ = x

  def clear_width(self):
    self.has_width_ = 0
    self.width_ = 0

  def has_width(self): return self.has_width_

  def height(self): return self.height_

  def set_height(self, x):
    self.has_height_ = 1
    self.height_ = x

  def clear_height(self):
    self.has_height_ = 0
    self.height_ = 0

  def has_height(self): return self.has_height_

  def pagedimensions_size(self): return len(self.pagedimensions_)
  def pagedimensions_list(self): return self.pagedimensions_

  def pagedimensions(self, i):
    return self.pagedimensions_[i]

  def mutable_pagedimensions(self, i):
    return self.pagedimensions_[i]

  def add_pagedimensions(self):
    x = OceanWordBoxes_PageDimensions()
    self.pagedimensions_.append(x)
    return x

  def clear_pagedimensions(self):
    self.pagedimensions_ = []
  def words_size(self): return len(self.words_)
  def words_list(self): return self.words_

  def words(self, i):
    return self.words_[i]

  def mutable_words(self, i):
    return self.words_[i]

  def add_words(self):
    x = OceanWordBoxes_Words()
    self.words_.append(x)
    return x

  def clear_words(self):
    self.words_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_width()): self.set_width(x.width())
    if (x.has_height()): self.set_height(x.height())
    for i in xrange(x.pagedimensions_size()): self.add_pagedimensions().CopyFrom(x.pagedimensions(i))
    for i in xrange(x.words_size()): self.add_words().CopyFrom(x.words(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanWordBoxes', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanWordBoxes')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanWordBoxes', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanWordBoxes', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanWordBoxes', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_width_ != x.has_width_: return 0
    if self.has_width_ and self.width_ != x.width_: return 0
    if self.has_height_ != x.has_height_: return 0
    if self.has_height_ and self.height_ != x.height_: return 0
    if len(self.pagedimensions_) != len(x.pagedimensions_): return 0
    for e1, e2 in zip(self.pagedimensions_, x.pagedimensions_):
      if e1 != e2: return 0
    if len(self.words_) != len(x.words_): return 0
    for e1, e2 in zip(self.words_, x.words_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_width_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: width not set.')
    if (not self.has_height_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: height not set.')
    for i in xrange(len(self.pagedimensions_)):
      if (not self.pagedimensions_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.words_)):
      if (not self.words_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.width_)
    n += self.lengthVarInt64(self.height_)
    n += 2 * len(self.pagedimensions_)
    for i in xrange(len(self.pagedimensions_)): n += self.pagedimensions_[i].ByteSize()
    n += 2 * len(self.words_)
    for i in xrange(len(self.words_)): n += self.words_[i].ByteSize()
    return n + 4

  def Clear(self):
    self.clear_width()
    self.clear_height()
    self.clear_pagedimensions()
    self.clear_words()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.words_)):
      out.putVarInt32(11)
      self.words_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    for i in xrange(len(self.pagedimensions_)):
      out.putVarInt32(35)
      self.pagedimensions_[i].OutputUnchecked(out)
      out.putVarInt32(36)
    out.putVarInt32(128)
    out.putVarInt32(self.width_)
    out.putVarInt32(136)
    out.putVarInt32(self.height_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_words().TryMerge(d)
        continue
      if tt == 35:
        self.add_pagedimensions().TryMerge(d)
        continue
      if tt == 128:
        self.set_width(d.getVarInt32())
        continue
      if tt == 136:
        self.set_height(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_width_: res+=prefix+("width: %s\n" % self.DebugFormatInt32(self.width_))
    if self.has_height_: res+=prefix+("height: %s\n" % self.DebugFormatInt32(self.height_))
    cnt=0
    for e in self.pagedimensions_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("PageDimensions%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    cnt=0
    for e in self.words_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Words%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kwidth = 16
  kheight = 17
  kPageDimensionsGroup = 4
  kPageDimensionswidth = 5
  kPageDimensionsheight = 6
  kWordsGroup = 1
  kWordscharacters = 2
  kWordsBoxes = 3

  _TEXT = (
   "ErrorCode",  #   0
   "Words",  #   1
   "characters",  #   2
   "Boxes",  #   3
   "PageDimensions",  #   4
   "width",  #   5
   "height",  #   6
   None,  #   7
   None,  #   8
   None,  #   9
   None,  #  10
   None,  #  11
   None,  #  12
   None,  #  13
   None,  #  14
   None,  #  15
   "width",  #  16
   "height",  #  17
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STARTGROUP,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.MAX_TYPE,  #   8

   ProtocolBuffer.Encoder.MAX_TYPE,  #   9

   ProtocolBuffer.Encoder.MAX_TYPE,  #  10

   ProtocolBuffer.Encoder.MAX_TYPE,  #  11

   ProtocolBuffer.Encoder.MAX_TYPE,  #  12

   ProtocolBuffer.Encoder.MAX_TYPE,  #  13

   ProtocolBuffer.Encoder.MAX_TYPE,  #  14

   ProtocolBuffer.Encoder.MAX_TYPE,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

   ProtocolBuffer.Encoder.NUMERIC,  #  17

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x26,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x2f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2f,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x5f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0e,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x57,
    0x6f,
    0x72,
    0x64,
    0x42,
    0x6f,
    0x78,
    0x65,
    0x73,
    0x13,
    0x1a,
    0x05,
    0x77,
    0x69,
    0x64,
    0x74,
    0x68,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x68,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x11,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x50,
    0x61,
    0x67,
    0x65,
    0x44,
    0x69,
    0x6d,
    0x65,
    0x6e,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x20,
    0x04,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x50,
    0x61,
    0x67,
    0x65,
    0x44,
    0x69,
    0x6d,
    0x65,
    0x6e,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x77,
    0x69,
    0x64,
    0x74,
    0x68,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x15,
    0x50,
    0x61,
    0x67,
    0x65,
    0x44,
    0x69,
    0x6d,
    0x65,
    0x6e,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x2e,
    0x68,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x57,
    0x6f,
    0x72,
    0x64,
    0x73,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x57,
    0x6f,
    0x72,
    0x64,
    0x73,
    0x2e,
    0x63,
    0x68,
    0x61,
    0x72,
    0x61,
    0x63,
    0x74,
    0x65,
    0x72,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x05,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x57,
    0x6f,
    0x72,
    0x64,
    0x73,
    0x2e,
    0x42,
    0x6f,
    0x78,
    0x65,
    0x73,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x0d,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x42,
    0x6f,
    0x78,
    0x60,
    0x05,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class OceanTOCLineBoxes_Lines(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.characters_ = ""
    self.title_page_number_ = 0
    self.box_ = OceanImageBox()
    self.is_chapter_title_ = 0
    self.physical_line_number_ = 0
    self.has_characters_ = 0
    self.has_title_page_number_ = 0
    self.has_box_ = 0
    self.has_is_chapter_title_ = 0
    self.has_physical_line_number_ = 0
    if contents is not None: self.MergeFromString(contents)

  def characters(self): return self.characters_

  def set_characters(self, x):
    self.has_characters_ = 1
    self.characters_ = x

  def clear_characters(self):
    self.has_characters_ = 0
    self.characters_ = ""

  def has_characters(self): return self.has_characters_

  def title_page_number(self): return self.title_page_number_

  def set_title_page_number(self, x):
    self.has_title_page_number_ = 1
    self.title_page_number_ = x

  def clear_title_page_number(self):
    self.has_title_page_number_ = 0
    self.title_page_number_ = 0

  def has_title_page_number(self): return self.has_title_page_number_

  def box(self): return self.box_

  def mutable_box(self): self.has_box_ = 1; return self.box_

  def clear_box(self):self.has_box_ = 0; self.box_.Clear()

  def has_box(self): return self.has_box_

  def is_chapter_title(self): return self.is_chapter_title_

  def set_is_chapter_title(self, x):
    self.has_is_chapter_title_ = 1
    self.is_chapter_title_ = x

  def clear_is_chapter_title(self):
    self.has_is_chapter_title_ = 0
    self.is_chapter_title_ = 0

  def has_is_chapter_title(self): return self.has_is_chapter_title_

  def physical_line_number(self): return self.physical_line_number_

  def set_physical_line_number(self, x):
    self.has_physical_line_number_ = 1
    self.physical_line_number_ = x

  def clear_physical_line_number(self):
    self.has_physical_line_number_ = 0
    self.physical_line_number_ = 0

  def has_physical_line_number(self): return self.has_physical_line_number_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_characters()): self.set_characters(x.characters())
    if (x.has_title_page_number()): self.set_title_page_number(x.title_page_number())
    if (x.has_box()): self.mutable_box().MergeFrom(x.box())
    if (x.has_is_chapter_title()): self.set_is_chapter_title(x.is_chapter_title())
    if (x.has_physical_line_number()): self.set_physical_line_number(x.physical_line_number())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanTOCLineBoxes', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanTOCLineBoxes')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanTOCLineBoxes', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanTOCLineBoxes', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanTOCLineBoxes', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_characters_ != x.has_characters_: return 0
    if self.has_characters_ and self.characters_ != x.characters_: return 0
    if self.has_title_page_number_ != x.has_title_page_number_: return 0
    if self.has_title_page_number_ and self.title_page_number_ != x.title_page_number_: return 0
    if self.has_box_ != x.has_box_: return 0
    if self.has_box_ and self.box_ != x.box_: return 0
    if self.has_is_chapter_title_ != x.has_is_chapter_title_: return 0
    if self.has_is_chapter_title_ and self.is_chapter_title_ != x.is_chapter_title_: return 0
    if self.has_physical_line_number_ != x.has_physical_line_number_: return 0
    if self.has_physical_line_number_ and self.physical_line_number_ != x.physical_line_number_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_characters_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: characters not set.')
    if (not self.has_title_page_number_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: title_page_number not set.')
    if (not self.has_box_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: box not set.')
    elif not self.box_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.characters_))
    n += self.lengthVarInt64(self.title_page_number_)
    n += self.lengthString(self.box_.ByteSize())
    if (self.has_is_chapter_title_): n += 2
    if (self.has_physical_line_number_): n += 1 + self.lengthVarInt64(self.physical_line_number_)
    return n + 3

  def Clear(self):
    self.clear_characters()
    self.clear_title_page_number()
    self.clear_box()
    self.clear_is_chapter_title()
    self.clear_physical_line_number()

  def OutputUnchecked(self, out):
    out.putVarInt32(18)
    out.putPrefixedString(self.characters_)
    out.putVarInt32(24)
    out.putVarInt32(self.title_page_number_)
    out.putVarInt32(34)
    out.putVarInt32(self.box_.ByteSize())
    self.box_.OutputUnchecked(out)
    if (self.has_is_chapter_title_):
      out.putVarInt32(40)
      out.putBoolean(self.is_chapter_title_)
    if (self.has_physical_line_number_):
      out.putVarInt32(48)
      out.putVarInt32(self.physical_line_number_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 18:
        self.set_characters(d.getPrefixedString())
        continue
      if tt == 24:
        self.set_title_page_number(d.getVarInt32())
        continue
      if tt == 34:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_box().TryMerge(tmp)
        continue
      if tt == 40:
        self.set_is_chapter_title(d.getBoolean())
        continue
      if tt == 48:
        self.set_physical_line_number(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_characters_: res+=prefix+("characters: %s\n" % self.DebugFormatString(self.characters_))
    if self.has_title_page_number_: res+=prefix+("title_page_number: %s\n" % self.DebugFormatInt32(self.title_page_number_))
    if self.has_box_:
      res+=prefix+"Box <\n"
      res+=self.box_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_is_chapter_title_: res+=prefix+("is_chapter_title: %s\n" % self.DebugFormatBool(self.is_chapter_title_))
    if self.has_physical_line_number_: res+=prefix+("physical_line_number: %s\n" % self.DebugFormatInt32(self.physical_line_number_))
    return res

class OceanTOCLineBoxes(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.width_ = 0
    self.height_ = 0
    self.lines_ = []
    self.has_width_ = 0
    self.has_height_ = 0
    if contents is not None: self.MergeFromString(contents)

  def width(self): return self.width_

  def set_width(self, x):
    self.has_width_ = 1
    self.width_ = x

  def clear_width(self):
    self.has_width_ = 0
    self.width_ = 0

  def has_width(self): return self.has_width_

  def height(self): return self.height_

  def set_height(self, x):
    self.has_height_ = 1
    self.height_ = x

  def clear_height(self):
    self.has_height_ = 0
    self.height_ = 0

  def has_height(self): return self.has_height_

  def lines_size(self): return len(self.lines_)
  def lines_list(self): return self.lines_

  def lines(self, i):
    return self.lines_[i]

  def mutable_lines(self, i):
    return self.lines_[i]

  def add_lines(self):
    x = OceanTOCLineBoxes_Lines()
    self.lines_.append(x)
    return x

  def clear_lines(self):
    self.lines_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_width()): self.set_width(x.width())
    if (x.has_height()): self.set_height(x.height())
    for i in xrange(x.lines_size()): self.add_lines().CopyFrom(x.lines(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanTOCLineBoxes', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanTOCLineBoxes')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanTOCLineBoxes', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanTOCLineBoxes', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanTOCLineBoxes', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_width_ != x.has_width_: return 0
    if self.has_width_ and self.width_ != x.width_: return 0
    if self.has_height_ != x.has_height_: return 0
    if self.has_height_ and self.height_ != x.height_: return 0
    if len(self.lines_) != len(x.lines_): return 0
    for e1, e2 in zip(self.lines_, x.lines_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_width_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: width not set.')
    if (not self.has_height_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: height not set.')
    for i in xrange(len(self.lines_)):
      if (not self.lines_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.width_)
    n += self.lengthVarInt64(self.height_)
    n += 2 * len(self.lines_)
    for i in xrange(len(self.lines_)): n += self.lines_[i].ByteSize()
    return n + 4

  def Clear(self):
    self.clear_width()
    self.clear_height()
    self.clear_lines()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.lines_)):
      out.putVarInt32(11)
      self.lines_[i].OutputUnchecked(out)
      out.putVarInt32(12)
    out.putVarInt32(128)
    out.putVarInt32(self.width_)
    out.putVarInt32(136)
    out.putVarInt32(self.height_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.add_lines().TryMerge(d)
        continue
      if tt == 128:
        self.set_width(d.getVarInt32())
        continue
      if tt == 136:
        self.set_height(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_width_: res+=prefix+("width: %s\n" % self.DebugFormatInt32(self.width_))
    if self.has_height_: res+=prefix+("height: %s\n" % self.DebugFormatInt32(self.height_))
    cnt=0
    for e in self.lines_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Lines%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

  kwidth = 16
  kheight = 17
  kLinesGroup = 1
  kLinescharacters = 2
  kLinestitle_page_number = 3
  kLinesBox = 4
  kLinesis_chapter_title = 5
  kLinesphysical_line_number = 6

  _TEXT = (
   "ErrorCode",  #   0
   "Lines",  #   1
   "characters",  #   2
   "title_page_number",  #   3
   "Box",  #   4
   "is_chapter_title",  #   5
   "physical_line_number",  #   6
   None,  #   7
   None,  #   8
   None,  #   9
   None,  #  10
   None,  #  11
   None,  #  12
   None,  #  13
   None,  #  14
   None,  #  15
   "width",  #  16
   "height",  #  17
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.NUMERIC,  #   5

   ProtocolBuffer.Encoder.NUMERIC,  #   6

   ProtocolBuffer.Encoder.MAX_TYPE,  #   7

   ProtocolBuffer.Encoder.MAX_TYPE,  #   8

   ProtocolBuffer.Encoder.MAX_TYPE,  #   9

   ProtocolBuffer.Encoder.MAX_TYPE,  #  10

   ProtocolBuffer.Encoder.MAX_TYPE,  #  11

   ProtocolBuffer.Encoder.MAX_TYPE,  #  12

   ProtocolBuffer.Encoder.MAX_TYPE,  #  13

   ProtocolBuffer.Encoder.MAX_TYPE,  #  14

   ProtocolBuffer.Encoder.MAX_TYPE,  #  15

   ProtocolBuffer.Encoder.NUMERIC,  #  16

   ProtocolBuffer.Encoder.NUMERIC,  #  17

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x26,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x2f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2f,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x5f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x11,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x54,
    0x4f,
    0x43,
    0x4c,
    0x69,
    0x6e,
    0x65,
    0x42,
    0x6f,
    0x78,
    0x65,
    0x73,
    0x13,
    0x1a,
    0x05,
    0x77,
    0x69,
    0x64,
    0x74,
    0x68,
    0x20,
    0x10,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x68,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x11,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x4c,
    0x69,
    0x6e,
    0x65,
    0x73,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x4c,
    0x69,
    0x6e,
    0x65,
    0x73,
    0x2e,
    0x63,
    0x68,
    0x61,
    0x72,
    0x61,
    0x63,
    0x74,
    0x65,
    0x72,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x4c,
    0x69,
    0x6e,
    0x65,
    0x73,
    0x2e,
    0x74,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x5f,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x4c,
    0x69,
    0x6e,
    0x65,
    0x73,
    0x2e,
    0x42,
    0x6f,
    0x78,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x0d,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x42,
    0x6f,
    0x78,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x4c,
    0x69,
    0x6e,
    0x65,
    0x73,
    0x2e,
    0x69,
    0x73,
    0x5f,
    0x63,
    0x68,
    0x61,
    0x70,
    0x74,
    0x65,
    0x72,
    0x5f,
    0x74,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x20,
    0x05,
    0x28,
    0x00,
    0x30,
    0x08,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x4c,
    0x69,
    0x6e,
    0x65,
    0x73,
    0x2e,
    0x70,
    0x68,
    0x79,
    0x73,
    0x69,
    0x63,
    0x61,
    0x6c,
    0x5f,
    0x6c,
    0x69,
    0x6e,
    0x65,
    0x5f,
    0x6e,
    0x75,
    0x6d,
    0x62,
    0x65,
    0x72,
    0x20,
    0x06,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x02,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class OceanCitationLinkBox(ProtocolBuffer.ProtocolMessage):

  GENERIC_CITATION =    0 
  SCHOLARLY_CITATION =    1 

  _CitationType_NAMES = {
    0: "GENERIC_CITATION",
    1: "SCHOLARLY_CITATION",
  }

  def CitationType_Name(cls, x): return cls._CitationType_NAMES.get(x, "")
  CitationType_Name = classmethod(CitationType_Name)

  def __init__(self, contents=None):
    self.type_ = 0
    self.box_ = OceanImageBox()
    self.target_ = ""
    self.title_ = ""
    self.author_ = ""
    self.has_type_ = 0
    self.has_box_ = 0
    self.has_target_ = 0
    self.has_title_ = 0
    self.has_author_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = 0

  def has_type(self): return self.has_type_

  def box(self): return self.box_

  def mutable_box(self): self.has_box_ = 1; return self.box_

  def clear_box(self):self.has_box_ = 0; self.box_.Clear()

  def has_box(self): return self.has_box_

  def target(self): return self.target_

  def set_target(self, x):
    self.has_target_ = 1
    self.target_ = x

  def clear_target(self):
    self.has_target_ = 0
    self.target_ = ""

  def has_target(self): return self.has_target_

  def title(self): return self.title_

  def set_title(self, x):
    self.has_title_ = 1
    self.title_ = x

  def clear_title(self):
    self.has_title_ = 0
    self.title_ = ""

  def has_title(self): return self.has_title_

  def author(self): return self.author_

  def set_author(self, x):
    self.has_author_ = 1
    self.author_ = x

  def clear_author(self):
    self.has_author_ = 0
    self.author_ = ""

  def has_author(self): return self.has_author_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_box()): self.mutable_box().MergeFrom(x.box())
    if (x.has_target()): self.set_target(x.target())
    if (x.has_title()): self.set_title(x.title())
    if (x.has_author()): self.set_author(x.author())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanCitationLinkBox', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanCitationLinkBox')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanCitationLinkBox', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanCitationLinkBox', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanCitationLinkBox', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_box_ != x.has_box_: return 0
    if self.has_box_ and self.box_ != x.box_: return 0
    if self.has_target_ != x.has_target_: return 0
    if self.has_target_ and self.target_ != x.target_: return 0
    if self.has_title_ != x.has_title_: return 0
    if self.has_title_ and self.title_ != x.title_: return 0
    if self.has_author_ != x.has_author_: return 0
    if self.has_author_ and self.author_ != x.author_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (not self.has_box_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: box not set.')
    elif not self.box_.IsInitialized(debug_strs): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.type_)
    n += self.lengthString(self.box_.ByteSize())
    if (self.has_target_): n += 1 + self.lengthString(len(self.target_))
    if (self.has_title_): n += 1 + self.lengthString(len(self.title_))
    if (self.has_author_): n += 1 + self.lengthString(len(self.author_))
    return n + 2

  def Clear(self):
    self.clear_type()
    self.clear_box()
    self.clear_target()
    self.clear_title()
    self.clear_author()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.type_)
    out.putVarInt32(18)
    out.putVarInt32(self.box_.ByteSize())
    self.box_.OutputUnchecked(out)
    if (self.has_target_):
      out.putVarInt32(26)
      out.putPrefixedString(self.target_)
    if (self.has_title_):
      out.putVarInt32(34)
      out.putPrefixedString(self.title_)
    if (self.has_author_):
      out.putVarInt32(42)
      out.putPrefixedString(self.author_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_type(d.getVarInt32())
        continue
      if tt == 18:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_box().TryMerge(tmp)
        continue
      if tt == 26:
        self.set_target(d.getPrefixedString())
        continue
      if tt == 34:
        self.set_title(d.getPrefixedString())
        continue
      if tt == 42:
        self.set_author(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("type: %s\n" % self.DebugFormatInt32(self.type_))
    if self.has_box_:
      res+=prefix+"box <\n"
      res+=self.box_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_target_: res+=prefix+("target: %s\n" % self.DebugFormatString(self.target_))
    if self.has_title_: res+=prefix+("title: %s\n" % self.DebugFormatString(self.title_))
    if self.has_author_: res+=prefix+("author: %s\n" % self.DebugFormatString(self.author_))
    return res

  ktype = 1
  kbox = 2
  ktarget = 3
  ktitle = 4
  kauthor = 5

  _TEXT = (
   "ErrorCode",  #   0
   "type",  #   1
   "box",  #   2
   "target",  #   3
   "title",  #   4
   "author",  #   5
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x26,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x2f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2f,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x5f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x14,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x43,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x42,
    0x6f,
    0x78,
    0x13,
    0x1a,
    0x04,
    0x74,
    0x79,
    0x70,
    0x65,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x68,
    0x00,
    0x14,
    0x13,
    0x1a,
    0x03,
    0x62,
    0x6f,
    0x78,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x02,
    0x4a,
    0x0d,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x49,
    0x6d,
    0x61,
    0x67,
    0x65,
    0x42,
    0x6f,
    0x78,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x74,
    0x61,
    0x72,
    0x67,
    0x65,
    0x74,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x74,
    0x69,
    0x74,
    0x6c,
    0x65,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x06,
    0x61,
    0x75,
    0x74,
    0x68,
    0x6f,
    0x72,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x73,
    0x7a,
    0x0c,
    0x43,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x47,
    0x45,
    0x4e,
    0x45,
    0x52,
    0x49,
    0x43,
    0x5f,
    0x43,
    0x49,
    0x54,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x53,
    0x43,
    0x48,
    0x4f,
    0x4c,
    0x41,
    0x52,
    0x4c,
    0x59,
    0x5f,
    0x43,
    0x49,
    0x54,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class OceanCitationLinks(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.page_width_ = 0
    self.page_height_ = 0
    self.links_ = []
    self.has_page_width_ = 0
    self.has_page_height_ = 0
    if contents is not None: self.MergeFromString(contents)

  def page_width(self): return self.page_width_

  def set_page_width(self, x):
    self.has_page_width_ = 1
    self.page_width_ = x

  def clear_page_width(self):
    self.has_page_width_ = 0
    self.page_width_ = 0

  def has_page_width(self): return self.has_page_width_

  def page_height(self): return self.page_height_

  def set_page_height(self, x):
    self.has_page_height_ = 1
    self.page_height_ = x

  def clear_page_height(self):
    self.has_page_height_ = 0
    self.page_height_ = 0

  def has_page_height(self): return self.has_page_height_

  def links_size(self): return len(self.links_)
  def links_list(self): return self.links_

  def links(self, i):
    return self.links_[i]

  def mutable_links(self, i):
    return self.links_[i]

  def add_links(self):
    x = OceanCitationLinkBox()
    self.links_.append(x)
    return x

  def clear_links(self):
    self.links_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_page_width()): self.set_page_width(x.page_width())
    if (x.has_page_height()): self.set_page_height(x.page_height())
    for i in xrange(x.links_size()): self.add_links().CopyFrom(x.links(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'OceanCitationLinks', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'OceanCitationLinks')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'OceanCitationLinks', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'OceanCitationLinks', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'OceanCitationLinks', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_page_width_ != x.has_page_width_: return 0
    if self.has_page_width_ and self.page_width_ != x.page_width_: return 0
    if self.has_page_height_ != x.has_page_height_: return 0
    if self.has_page_height_ and self.page_height_ != x.page_height_: return 0
    if len(self.links_) != len(x.links_): return 0
    for e1, e2 in zip(self.links_, x.links_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_page_width_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: page_width not set.')
    if (not self.has_page_height_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: page_height not set.')
    for i in xrange(len(self.links_)):
      if (not self.links_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.page_width_)
    n += self.lengthVarInt64(self.page_height_)
    n += 1 * len(self.links_)
    for i in xrange(len(self.links_)): n += self.lengthString(self.links_[i].ByteSize())
    return n + 2

  def Clear(self):
    self.clear_page_width()
    self.clear_page_height()
    self.clear_links()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.page_width_)
    out.putVarInt32(16)
    out.putVarInt32(self.page_height_)
    for i in xrange(len(self.links_)):
      out.putVarInt32(26)
      out.putVarInt32(self.links_[i].ByteSize())
      self.links_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_page_width(d.getVarInt32())
        continue
      if tt == 16:
        self.set_page_height(d.getVarInt32())
        continue
      if tt == 26:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_links().TryMerge(tmp)
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_page_width_: res+=prefix+("page_width: %s\n" % self.DebugFormatInt32(self.page_width_))
    if self.has_page_height_: res+=prefix+("page_height: %s\n" % self.DebugFormatInt32(self.page_height_))
    cnt=0
    for e in self.links_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("links%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

  kpage_width = 1
  kpage_height = 2
  klinks = 3

  _TEXT = (
   "ErrorCode",  #   0
   "page_width",  #   1
   "page_height",  #   2
   "links",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x26,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x2f,
    0x64,
    0x61,
    0x74,
    0x61,
    0x2f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2f,
    0x6f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x5f,
    0x64,
    0x6f,
    0x63,
    0x69,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x12,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x43,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x73,
    0x13,
    0x1a,
    0x0a,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x77,
    0x69,
    0x64,
    0x74,
    0x68,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x70,
    0x61,
    0x67,
    0x65,
    0x5f,
    0x68,
    0x65,
    0x69,
    0x67,
    0x68,
    0x74,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x6c,
    0x69,
    0x6e,
    0x6b,
    0x73,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x14,
    0x4f,
    0x63,
    0x65,
    0x61,
    0x6e,
    0x43,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x4c,
    0x69,
    0x6e,
    0x6b,
    0x42,
    0x6f,
    0x78,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['OceanDocTag','OceanDocTag_BookSpecific','OceanDocTag_PatentSpecific','OceanDocTag_CatalogSpecific','OceanDocTag_WorkCluster','OceanDocInfo','OceanImageBox','OceanWordBoxes','OceanWordBoxes_Words','OceanWordBoxes_PageDimensions','OceanTOCLineBoxes','OceanTOCLineBoxes_Lines','OceanCitationLinkBox','OceanCitationLinks']
