# This file automatically generated by protocol-compiler from science_search/citation/legal_citation.proto
# DO NOT EDIT!

from google3.net.proto import ProtocolBuffer
import array
import thread
from google3.net.proto import _net_proto___parse__python

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

class LegalPerson(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.lastname_ = ""
    self.othernames_ = ""
    self.description_ = ""
    self.has_lastname_ = 0
    self.has_othernames_ = 0
    self.has_description_ = 0
    if contents is not None: self.MergeFromString(contents)

  def lastname(self): return self.lastname_

  def set_lastname(self, x):
    self.has_lastname_ = 1
    self.lastname_ = x

  def clear_lastname(self):
    self.has_lastname_ = 0
    self.lastname_ = ""

  def has_lastname(self): return self.has_lastname_

  def othernames(self): return self.othernames_

  def set_othernames(self, x):
    self.has_othernames_ = 1
    self.othernames_ = x

  def clear_othernames(self):
    self.has_othernames_ = 0
    self.othernames_ = ""

  def has_othernames(self): return self.has_othernames_

  def description(self): return self.description_

  def set_description(self, x):
    self.has_description_ = 1
    self.description_ = x

  def clear_description(self):
    self.has_description_ = 0
    self.description_ = ""

  def has_description(self): return self.has_description_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_lastname()): self.set_lastname(x.lastname())
    if (x.has_othernames()): self.set_othernames(x.othernames())
    if (x.has_description()): self.set_description(x.description())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'LegalPerson', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'LegalPerson')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'LegalPerson', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'LegalPerson', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'LegalPerson', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_lastname_ != x.has_lastname_: return 0
    if self.has_lastname_ and self.lastname_ != x.lastname_: return 0
    if self.has_othernames_ != x.has_othernames_: return 0
    if self.has_othernames_ and self.othernames_ != x.othernames_: return 0
    if self.has_description_ != x.has_description_: return 0
    if self.has_description_ and self.description_ != x.description_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_lastname_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: lastname not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.lastname_))
    if (self.has_othernames_): n += 1 + self.lengthString(len(self.othernames_))
    if (self.has_description_): n += 1 + self.lengthString(len(self.description_))
    return n + 1

  def Clear(self):
    self.clear_lastname()
    self.clear_othernames()
    self.clear_description()

  def OutputUnchecked(self, out):
    out.putVarInt32(10)
    out.putPrefixedString(self.lastname_)
    if (self.has_othernames_):
      out.putVarInt32(18)
      out.putPrefixedString(self.othernames_)
    if (self.has_description_):
      out.putVarInt32(26)
      out.putPrefixedString(self.description_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 10:
        self.set_lastname(d.getPrefixedString())
        continue
      if tt == 18:
        self.set_othernames(d.getPrefixedString())
        continue
      if tt == 26:
        self.set_description(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_lastname_: res+=prefix+("LastName: %s\n" % self.DebugFormatString(self.lastname_))
    if self.has_othernames_: res+=prefix+("OtherNames: %s\n" % self.DebugFormatString(self.othernames_))
    if self.has_description_: res+=prefix+("Description: %s\n" % self.DebugFormatString(self.description_))
    return res

  kLastName = 1
  kOtherNames = 2
  kDescription = 3

  _TEXT = (
   "ErrorCode",  #   0
   "LastName",  #   1
   "OtherNames",  #   2
   "Description",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STRING,  #   1

   ProtocolBuffer.Encoder.STRING,  #   2

   ProtocolBuffer.Encoder.STRING,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x73,
    0x63,
    0x69,
    0x65,
    0x6e,
    0x63,
    0x65,
    0x5f,
    0x73,
    0x65,
    0x61,
    0x72,
    0x63,
    0x68,
    0x2f,
    0x63,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2f,
    0x6c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x5f,
    0x63,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0b,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x50,
    0x65,
    0x72,
    0x73,
    0x6f,
    0x6e,
    0x13,
    0x1a,
    0x08,
    0x4c,
    0x61,
    0x73,
    0x74,
    0x4e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x01,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x4f,
    0x74,
    0x68,
    0x65,
    0x72,
    0x4e,
    0x61,
    0x6d,
    0x65,
    0x73,
    0x20,
    0x02,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x44,
    0x65,
    0x73,
    0x63,
    0x72,
    0x69,
    0x70,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x20,
    0x03,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class LegalDate(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.year_ = 0
    self.month_ = 0
    self.day_ = 0
    self.has_year_ = 0
    self.has_month_ = 0
    self.has_day_ = 0
    if contents is not None: self.MergeFromString(contents)

  def year(self): return self.year_

  def set_year(self, x):
    self.has_year_ = 1
    self.year_ = x

  def clear_year(self):
    self.has_year_ = 0
    self.year_ = 0

  def has_year(self): return self.has_year_

  def month(self): return self.month_

  def set_month(self, x):
    self.has_month_ = 1
    self.month_ = x

  def clear_month(self):
    self.has_month_ = 0
    self.month_ = 0

  def has_month(self): return self.has_month_

  def day(self): return self.day_

  def set_day(self, x):
    self.has_day_ = 1
    self.day_ = x

  def clear_day(self):
    self.has_day_ = 0
    self.day_ = 0

  def has_day(self): return self.has_day_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_year()): self.set_year(x.year())
    if (x.has_month()): self.set_month(x.month())
    if (x.has_day()): self.set_day(x.day())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'LegalDate', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'LegalDate')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'LegalDate', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'LegalDate', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'LegalDate', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_year_ != x.has_year_: return 0
    if self.has_year_ and self.year_ != x.year_: return 0
    if self.has_month_ != x.has_month_: return 0
    if self.has_month_ and self.month_ != x.month_: return 0
    if self.has_day_ != x.has_day_: return 0
    if self.has_day_ and self.day_ != x.day_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_year_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: year not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.year_)
    if (self.has_month_): n += 1 + self.lengthVarInt64(self.month_)
    if (self.has_day_): n += 1 + self.lengthVarInt64(self.day_)
    return n + 1

  def Clear(self):
    self.clear_year()
    self.clear_month()
    self.clear_day()

  def OutputUnchecked(self, out):
    out.putVarInt32(8)
    out.putVarInt32(self.year_)
    if (self.has_month_):
      out.putVarInt32(16)
      out.putVarInt32(self.month_)
    if (self.has_day_):
      out.putVarInt32(24)
      out.putVarInt32(self.day_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 8:
        self.set_year(d.getVarInt32())
        continue
      if tt == 16:
        self.set_month(d.getVarInt32())
        continue
      if tt == 24:
        self.set_day(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_year_: res+=prefix+("Year: %s\n" % self.DebugFormatInt32(self.year_))
    if self.has_month_: res+=prefix+("Month: %s\n" % self.DebugFormatInt32(self.month_))
    if self.has_day_: res+=prefix+("Day: %s\n" % self.DebugFormatInt32(self.day_))
    return res

  kYear = 1
  kMonth = 2
  kDay = 3

  _TEXT = (
   "ErrorCode",  #   0
   "Year",  #   1
   "Month",  #   2
   "Day",  #   3
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.NUMERIC,  #   1

   ProtocolBuffer.Encoder.NUMERIC,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x73,
    0x63,
    0x69,
    0x65,
    0x6e,
    0x63,
    0x65,
    0x5f,
    0x73,
    0x65,
    0x61,
    0x72,
    0x63,
    0x68,
    0x2f,
    0x63,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2f,
    0x6c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x5f,
    0x63,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x09,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x44,
    0x61,
    0x74,
    0x65,
    0x13,
    0x1a,
    0x04,
    0x59,
    0x65,
    0x61,
    0x72,
    0x20,
    0x01,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x4d,
    0x6f,
    0x6e,
    0x74,
    0x68,
    0x20,
    0x02,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x03,
    0x44,
    0x61,
    0x79,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())
class LegalCitation_CourtDocumentPub(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.volume_ = 0
    self.reporter_ = ""
    self.page_ = ""
    self.year_ = 0
    self.has_volume_ = 0
    self.has_reporter_ = 0
    self.has_page_ = 0
    self.has_year_ = 0
    if contents is not None: self.MergeFromString(contents)

  def volume(self): return self.volume_

  def set_volume(self, x):
    self.has_volume_ = 1
    self.volume_ = x

  def clear_volume(self):
    self.has_volume_ = 0
    self.volume_ = 0

  def has_volume(self): return self.has_volume_

  def reporter(self): return self.reporter_

  def set_reporter(self, x):
    self.has_reporter_ = 1
    self.reporter_ = x

  def clear_reporter(self):
    self.has_reporter_ = 0
    self.reporter_ = ""

  def has_reporter(self): return self.has_reporter_

  def page(self): return self.page_

  def set_page(self, x):
    self.has_page_ = 1
    self.page_ = x

  def clear_page(self):
    self.has_page_ = 0
    self.page_ = ""

  def has_page(self): return self.has_page_

  def year(self): return self.year_

  def set_year(self, x):
    self.has_year_ = 1
    self.year_ = x

  def clear_year(self):
    self.has_year_ = 0
    self.year_ = 0

  def has_year(self): return self.has_year_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_volume()): self.set_volume(x.volume())
    if (x.has_reporter()): self.set_reporter(x.reporter())
    if (x.has_page()): self.set_page(x.page())
    if (x.has_year()): self.set_year(x.year())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'LegalCitation', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'LegalCitation')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'LegalCitation', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'LegalCitation', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'LegalCitation', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_volume_ != x.has_volume_: return 0
    if self.has_volume_ and self.volume_ != x.volume_: return 0
    if self.has_reporter_ != x.has_reporter_: return 0
    if self.has_reporter_ and self.reporter_ != x.reporter_: return 0
    if self.has_page_ != x.has_page_: return 0
    if self.has_page_ and self.page_ != x.page_: return 0
    if self.has_year_ != x.has_year_: return 0
    if self.has_year_ and self.year_ != x.year_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_volume_): n += 1 + self.lengthVarInt64(self.volume_)
    if (self.has_reporter_): n += 1 + self.lengthString(len(self.reporter_))
    if (self.has_page_): n += 1 + self.lengthString(len(self.page_))
    if (self.has_year_): n += 2 + self.lengthVarInt64(self.year_)
    return n + 0

  def Clear(self):
    self.clear_volume()
    self.clear_reporter()
    self.clear_page()
    self.clear_year()

  def OutputUnchecked(self, out):
    if (self.has_volume_):
      out.putVarInt32(24)
      out.putVarInt32(self.volume_)
    if (self.has_reporter_):
      out.putVarInt32(34)
      out.putPrefixedString(self.reporter_)
    if (self.has_page_):
      out.putVarInt32(42)
      out.putPrefixedString(self.page_)
    if (self.has_year_):
      out.putVarInt32(168)
      out.putVarInt32(self.year_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 20: break
      if tt == 24:
        self.set_volume(d.getVarInt32())
        continue
      if tt == 34:
        self.set_reporter(d.getPrefixedString())
        continue
      if tt == 42:
        self.set_page(d.getPrefixedString())
        continue
      if tt == 168:
        self.set_year(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_volume_: res+=prefix+("Volume: %s\n" % self.DebugFormatInt32(self.volume_))
    if self.has_reporter_: res+=prefix+("Reporter: %s\n" % self.DebugFormatString(self.reporter_))
    if self.has_page_: res+=prefix+("Page: %s\n" % self.DebugFormatString(self.page_))
    if self.has_year_: res+=prefix+("Year: %s\n" % self.DebugFormatInt32(self.year_))
    return res

class LegalCitation_CourtDocumentPerDocketInfo(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.docketid_ = ""
    self.respondent_ = []
    self.petitioner_ = []
    self.topic_ = ""
    self.respondentcounsel_ = []
    self.petitionercounsel_ = []
    self.has_docketid_ = 0
    self.has_topic_ = 0
    if contents is not None: self.MergeFromString(contents)

  def docketid(self): return self.docketid_

  def set_docketid(self, x):
    self.has_docketid_ = 1
    self.docketid_ = x

  def clear_docketid(self):
    self.has_docketid_ = 0
    self.docketid_ = ""

  def has_docketid(self): return self.has_docketid_

  def respondent_size(self): return len(self.respondent_)
  def respondent_list(self): return self.respondent_

  def respondent(self, i):
    return self.respondent_[i]

  def mutable_respondent(self, i):
    return self.respondent_[i]

  def add_respondent(self):
    x = LegalPerson()
    self.respondent_.append(x)
    return x

  def clear_respondent(self):
    self.respondent_ = []
  def petitioner_size(self): return len(self.petitioner_)
  def petitioner_list(self): return self.petitioner_

  def petitioner(self, i):
    return self.petitioner_[i]

  def mutable_petitioner(self, i):
    return self.petitioner_[i]

  def add_petitioner(self):
    x = LegalPerson()
    self.petitioner_.append(x)
    return x

  def clear_petitioner(self):
    self.petitioner_ = []
  def topic(self): return self.topic_

  def set_topic(self, x):
    self.has_topic_ = 1
    self.topic_ = x

  def clear_topic(self):
    self.has_topic_ = 0
    self.topic_ = ""

  def has_topic(self): return self.has_topic_

  def respondentcounsel_size(self): return len(self.respondentcounsel_)
  def respondentcounsel_list(self): return self.respondentcounsel_

  def respondentcounsel(self, i):
    return self.respondentcounsel_[i]

  def mutable_respondentcounsel(self, i):
    return self.respondentcounsel_[i]

  def add_respondentcounsel(self):
    x = LegalPerson()
    self.respondentcounsel_.append(x)
    return x

  def clear_respondentcounsel(self):
    self.respondentcounsel_ = []
  def petitionercounsel_size(self): return len(self.petitionercounsel_)
  def petitionercounsel_list(self): return self.petitionercounsel_

  def petitionercounsel(self, i):
    return self.petitionercounsel_[i]

  def mutable_petitionercounsel(self, i):
    return self.petitionercounsel_[i]

  def add_petitionercounsel(self):
    x = LegalPerson()
    self.petitionercounsel_.append(x)
    return x

  def clear_petitionercounsel(self):
    self.petitionercounsel_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_docketid()): self.set_docketid(x.docketid())
    for i in xrange(x.respondent_size()): self.add_respondent().CopyFrom(x.respondent(i))
    for i in xrange(x.petitioner_size()): self.add_petitioner().CopyFrom(x.petitioner(i))
    if (x.has_topic()): self.set_topic(x.topic())
    for i in xrange(x.respondentcounsel_size()): self.add_respondentcounsel().CopyFrom(x.respondentcounsel(i))
    for i in xrange(x.petitionercounsel_size()): self.add_petitionercounsel().CopyFrom(x.petitionercounsel(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'LegalCitation', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'LegalCitation')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'LegalCitation', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'LegalCitation', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'LegalCitation', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_docketid_ != x.has_docketid_: return 0
    if self.has_docketid_ and self.docketid_ != x.docketid_: return 0
    if len(self.respondent_) != len(x.respondent_): return 0
    for e1, e2 in zip(self.respondent_, x.respondent_):
      if e1 != e2: return 0
    if len(self.petitioner_) != len(x.petitioner_): return 0
    for e1, e2 in zip(self.petitioner_, x.petitioner_):
      if e1 != e2: return 0
    if self.has_topic_ != x.has_topic_: return 0
    if self.has_topic_ and self.topic_ != x.topic_: return 0
    if len(self.respondentcounsel_) != len(x.respondentcounsel_): return 0
    for e1, e2 in zip(self.respondentcounsel_, x.respondentcounsel_):
      if e1 != e2: return 0
    if len(self.petitionercounsel_) != len(x.petitionercounsel_): return 0
    for e1, e2 in zip(self.petitionercounsel_, x.petitionercounsel_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.respondent_)):
      if (not self.respondent_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.petitioner_)):
      if (not self.petitioner_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.respondentcounsel_)):
      if (not self.respondentcounsel_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.petitionercounsel_)):
      if (not self.petitionercounsel_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_docketid_): n += 2 + self.lengthString(len(self.docketid_))
    n += 1 * len(self.respondent_)
    for i in xrange(len(self.respondent_)): n += self.lengthString(self.respondent_[i].ByteSize())
    n += 1 * len(self.petitioner_)
    for i in xrange(len(self.petitioner_)): n += self.lengthString(self.petitioner_[i].ByteSize())
    if (self.has_topic_): n += 2 + self.lengthString(len(self.topic_))
    n += 2 * len(self.respondentcounsel_)
    for i in xrange(len(self.respondentcounsel_)): n += self.lengthString(self.respondentcounsel_[i].ByteSize())
    n += 2 * len(self.petitionercounsel_)
    for i in xrange(len(self.petitionercounsel_)): n += self.lengthString(self.petitionercounsel_[i].ByteSize())
    return n + 0

  def Clear(self):
    self.clear_docketid()
    self.clear_respondent()
    self.clear_petitioner()
    self.clear_topic()
    self.clear_respondentcounsel()
    self.clear_petitionercounsel()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.respondent_)):
      out.putVarInt32(58)
      out.putVarInt32(self.respondent_[i].ByteSize())
      self.respondent_[i].OutputUnchecked(out)
    for i in xrange(len(self.petitioner_)):
      out.putVarInt32(66)
      out.putVarInt32(self.petitioner_[i].ByteSize())
      self.petitioner_[i].OutputUnchecked(out)
    if (self.has_docketid_):
      out.putVarInt32(210)
      out.putPrefixedString(self.docketid_)
    for i in xrange(len(self.respondentcounsel_)):
      out.putVarInt32(218)
      out.putVarInt32(self.respondentcounsel_[i].ByteSize())
      self.respondentcounsel_[i].OutputUnchecked(out)
    for i in xrange(len(self.petitionercounsel_)):
      out.putVarInt32(226)
      out.putVarInt32(self.petitionercounsel_[i].ByteSize())
      self.petitionercounsel_[i].OutputUnchecked(out)
    if (self.has_topic_):
      out.putVarInt32(394)
      out.putPrefixedString(self.topic_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 52: break
      if tt == 58:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_respondent().TryMerge(tmp)
        continue
      if tt == 66:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_petitioner().TryMerge(tmp)
        continue
      if tt == 210:
        self.set_docketid(d.getPrefixedString())
        continue
      if tt == 218:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_respondentcounsel().TryMerge(tmp)
        continue
      if tt == 226:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_petitionercounsel().TryMerge(tmp)
        continue
      if tt == 394:
        self.set_topic(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_docketid_: res+=prefix+("DocketID: %s\n" % self.DebugFormatString(self.docketid_))
    cnt=0
    for e in self.respondent_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Respondent%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.petitioner_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Petitioner%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    if self.has_topic_: res+=prefix+("Topic: %s\n" % self.DebugFormatString(self.topic_))
    cnt=0
    for e in self.respondentcounsel_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("RespondentCounsel%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.petitionercounsel_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("PetitionerCounsel%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res

class LegalCitation_CourtDocumentCourt(ProtocolBuffer.ProtocolMessage):

  UNKNOWN_COURT =    0 
  LOWER_COURT  =    1 
  APPEALS_COURT =   10 
  SUPREME_COURT =  100 

  _CourtLevel_NAMES = {
    0: "UNKNOWN_COURT",
    1: "LOWER_COURT",
    10: "APPEALS_COURT",
    100: "SUPREME_COURT",
  }

  def CourtLevel_Name(cls, x): return cls._CourtLevel_NAMES.get(x, "")
  CourtLevel_Name = classmethod(CourtLevel_Name)

  def __init__(self, contents=None):
    self.name_ = ""
    self.level_ = 0
    self.has_name_ = 0
    self.has_level_ = 0
    if contents is not None: self.MergeFromString(contents)

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_

  def level(self): return self.level_

  def set_level(self, x):
    self.has_level_ = 1
    self.level_ = x

  def clear_level(self):
    self.has_level_ = 0
    self.level_ = 0

  def has_level(self): return self.has_level_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_name()): self.set_name(x.name())
    if (x.has_level()): self.set_level(x.level())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'LegalCitation', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'LegalCitation')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'LegalCitation', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'LegalCitation', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'LegalCitation', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    if self.has_level_ != x.has_level_: return 0
    if self.has_level_ and self.level_ != x.level_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_name_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: name not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthString(len(self.name_))
    if (self.has_level_): n += 2 + self.lengthVarInt64(self.level_)
    return n + 2

  def Clear(self):
    self.clear_name()
    self.clear_level()

  def OutputUnchecked(self, out):
    out.putVarInt32(186)
    out.putPrefixedString(self.name_)
    if (self.has_level_):
      out.putVarInt32(192)
      out.putVarInt32(self.level_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 180: break
      if tt == 186:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 192:
        self.set_level(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_name_: res+=prefix+("Name: %s\n" % self.DebugFormatString(self.name_))
    if self.has_level_: res+=prefix+("Level: %s\n" % self.DebugFormatInt32(self.level_))
    return res

class LegalCitation_CourtDocumentOpinionInfo(ProtocolBuffer.ProtocolMessage):

  PRIMARY      =    1 
  DISSENTING   =    2 
  CONCURRING   =    3 
  PER_CURIAM   =    4 

  _OpinionType_NAMES = {
    1: "PRIMARY",
    2: "DISSENTING",
    3: "CONCURRING",
    4: "PER_CURIAM",
  }

  def OpinionType_Name(cls, x): return cls._OpinionType_NAMES.get(x, "")
  OpinionType_Name = classmethod(OpinionType_Name)


  PANEL_BENCH  =    1 
  FULL_BENCH   =    2 

  _BenchType_NAMES = {
    1: "PANEL_BENCH",
    2: "FULL_BENCH",
  }

  def BenchType_Name(cls, x): return cls._BenchType_NAMES.get(x, "")
  BenchType_Name = classmethod(BenchType_Name)

  def __init__(self, contents=None):
    self.type_ = 0
    self.bench_ = 0
    self.deliveredby_ = None
    self.joinedby_ = None
    self.has_type_ = 0
    self.has_bench_ = 0
    self.has_deliveredby_ = 0
    self.has_joinedby_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = 0

  def has_type(self): return self.has_type_

  def bench(self): return self.bench_

  def set_bench(self, x):
    self.has_bench_ = 1
    self.bench_ = x

  def clear_bench(self):
    self.has_bench_ = 0
    self.bench_ = 0

  def has_bench(self): return self.has_bench_

  def deliveredby(self):
    if self.deliveredby_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.deliveredby_ is None: self.deliveredby_ = LegalPerson()
      finally:
        self.lazy_init_lock_.release()
    return self.deliveredby_

  def mutable_deliveredby(self): self.has_deliveredby_ = 1; return self.deliveredby()

  def clear_deliveredby(self):
    #Warning: this method does not acquire the lock.
    self.has_deliveredby_ = 0;
    if self.deliveredby_ is not None: self.deliveredby_.Clear()

  def has_deliveredby(self): return self.has_deliveredby_

  def joinedby(self):
    if self.joinedby_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.joinedby_ is None: self.joinedby_ = LegalPerson()
      finally:
        self.lazy_init_lock_.release()
    return self.joinedby_

  def mutable_joinedby(self): self.has_joinedby_ = 1; return self.joinedby()

  def clear_joinedby(self):
    #Warning: this method does not acquire the lock.
    self.has_joinedby_ = 0;
    if self.joinedby_ is not None: self.joinedby_.Clear()

  def has_joinedby(self): return self.has_joinedby_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_bench()): self.set_bench(x.bench())
    if (x.has_deliveredby()): self.mutable_deliveredby().MergeFrom(x.deliveredby())
    if (x.has_joinedby()): self.mutable_joinedby().MergeFrom(x.joinedby())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'LegalCitation', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'LegalCitation')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'LegalCitation', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'LegalCitation', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'LegalCitation', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_bench_ != x.has_bench_: return 0
    if self.has_bench_ and self.bench_ != x.bench_: return 0
    if self.has_deliveredby_ != x.has_deliveredby_: return 0
    if self.has_deliveredby_ and self.deliveredby_ != x.deliveredby_: return 0
    if self.has_joinedby_ != x.has_joinedby_: return 0
    if self.has_joinedby_ and self.joinedby_ != x.joinedby_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (self.has_deliveredby_ and not self.deliveredby_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_joinedby_ and not self.joinedby_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.type_)
    if (self.has_bench_): n += 2 + self.lengthVarInt64(self.bench_)
    if (self.has_deliveredby_): n += 2 + self.lengthString(self.deliveredby_.ByteSize())
    if (self.has_joinedby_): n += 2 + self.lengthString(self.joinedby_.ByteSize())
    return n + 2

  def Clear(self):
    self.clear_type()
    self.clear_bench()
    self.clear_deliveredby()
    self.clear_joinedby()

  def OutputUnchecked(self, out):
    out.putVarInt32(296)
    out.putVarInt32(self.type_)
    if (self.has_deliveredby_):
      out.putVarInt32(306)
      out.putVarInt32(self.deliveredby_.ByteSize())
      self.deliveredby_.OutputUnchecked(out)
    if (self.has_joinedby_):
      out.putVarInt32(314)
      out.putVarInt32(self.joinedby_.ByteSize())
      self.joinedby_.OutputUnchecked(out)
    if (self.has_bench_):
      out.putVarInt32(384)
      out.putVarInt32(self.bench_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 292: break
      if tt == 296:
        self.set_type(d.getVarInt32())
        continue
      if tt == 306:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_deliveredby().TryMerge(tmp)
        continue
      if tt == 314:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_joinedby().TryMerge(tmp)
        continue
      if tt == 384:
        self.set_bench(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatInt32(self.type_))
    if self.has_bench_: res+=prefix+("Bench: %s\n" % self.DebugFormatInt32(self.bench_))
    if self.has_deliveredby_:
      res+=prefix+"DeliveredBy <\n"
      res+=self.deliveredby_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_joinedby_:
      res+=prefix+"JoinedBy <\n"
      res+=self.joinedby_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res

class LegalCitation_LawLevel(ProtocolBuffer.ProtocolMessage):
  def __init__(self, contents=None):
    self.type_ = 0
    self.leveltypestring_ = ""
    self.value_ = ""
    self.name_ = ""
    self.has_type_ = 0
    self.has_leveltypestring_ = 0
    self.has_value_ = 0
    self.has_name_ = 0
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = 0

  def has_type(self): return self.has_type_

  def leveltypestring(self): return self.leveltypestring_

  def set_leveltypestring(self, x):
    self.has_leveltypestring_ = 1
    self.leveltypestring_ = x

  def clear_leveltypestring(self):
    self.has_leveltypestring_ = 0
    self.leveltypestring_ = ""

  def has_leveltypestring(self): return self.has_leveltypestring_

  def value(self): return self.value_

  def set_value(self, x):
    self.has_value_ = 1
    self.value_ = x

  def clear_value(self):
    self.has_value_ = 0
    self.value_ = ""

  def has_value(self): return self.has_value_

  def name(self): return self.name_

  def set_name(self, x):
    self.has_name_ = 1
    self.name_ = x

  def clear_name(self):
    self.has_name_ = 0
    self.name_ = ""

  def has_name(self): return self.has_name_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_leveltypestring()): self.set_leveltypestring(x.leveltypestring())
    if (x.has_value()): self.set_value(x.value())
    if (x.has_name()): self.set_name(x.name())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'LegalCitation', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'LegalCitation')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'LegalCitation', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'LegalCitation', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'LegalCitation', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_leveltypestring_ != x.has_leveltypestring_: return 0
    if self.has_leveltypestring_ and self.leveltypestring_ != x.leveltypestring_: return 0
    if self.has_value_ != x.has_value_: return 0
    if self.has_value_ and self.value_ != x.value_: return 0
    if self.has_name_ != x.has_name_: return 0
    if self.has_name_ and self.name_ != x.name_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not self.has_type_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: type not set.')
    if (not self.has_value_):
      initialized = 0
      if debug_strs is not None:
        debug_strs.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += self.lengthVarInt64(self.type_)
    if (self.has_leveltypestring_): n += 2 + self.lengthString(len(self.leveltypestring_))
    n += self.lengthString(len(self.value_))
    if (self.has_name_): n += 2 + self.lengthString(len(self.name_))
    return n + 4

  def Clear(self):
    self.clear_type()
    self.clear_leveltypestring()
    self.clear_value()
    self.clear_name()

  def OutputUnchecked(self, out):
    out.putVarInt32(336)
    out.putVarInt32(self.type_)
    out.putVarInt32(346)
    out.putPrefixedString(self.value_)
    if (self.has_name_):
      out.putVarInt32(362)
      out.putPrefixedString(self.name_)
    if (self.has_leveltypestring_):
      out.putVarInt32(410)
      out.putPrefixedString(self.leveltypestring_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 332: break
      if tt == 336:
        self.set_type(d.getVarInt32())
        continue
      if tt == 346:
        self.set_value(d.getPrefixedString())
        continue
      if tt == 362:
        self.set_name(d.getPrefixedString())
        continue
      if tt == 410:
        self.set_leveltypestring(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatInt32(self.type_))
    if self.has_leveltypestring_: res+=prefix+("LevelTypeString: %s\n" % self.DebugFormatString(self.leveltypestring_))
    if self.has_value_: res+=prefix+("Value: %s\n" % self.DebugFormatString(self.value_))
    if self.has_name_: res+=prefix+("Name: %s\n" % self.DebugFormatString(self.name_))
    return res

class LegalCitation_CourtDocument(ProtocolBuffer.ProtocolMessage):

  AFFIRMED     =    0 
  REVERSED     =    1 
  PARTIALLY_REVERSED =    2 
  CERT_DENIED  =    3 
  VACATED      =    4 
  NUM_RELATIONSHIPS =    5 

  _CertiorariRelationships_NAMES = {
    0: "AFFIRMED",
    1: "REVERSED",
    2: "PARTIALLY_REVERSED",
    3: "CERT_DENIED",
    4: "VACATED",
    5: "NUM_RELATIONSHIPS",
  }

  def CertiorariRelationships_Name(cls, x): return cls._CertiorariRelationships_NAMES.get(x, "")
  CertiorariRelationships_Name = classmethod(CertiorariRelationships_Name)

  def __init__(self, contents=None):
    self.syllabus_ = ""
    self.pub_ = []
    self.court_ = None
    self.certioraricourtname_ = ""
    self.certiorarirelationship_ = 0
    self.perdocketinfo_ = []
    self.memoid_ = ""
    self.decideddate_ = None
    self.fileddate_ = None
    self.argueddate_ = None
    self.modifieddate_ = None
    self.courtterm_ = ""
    self.arguedbefore_ = []
    self.opinioninfo_ = []
    self.has_syllabus_ = 0
    self.has_court_ = 0
    self.has_certioraricourtname_ = 0
    self.has_certiorarirelationship_ = 0
    self.has_memoid_ = 0
    self.has_decideddate_ = 0
    self.has_fileddate_ = 0
    self.has_argueddate_ = 0
    self.has_modifieddate_ = 0
    self.has_courtterm_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def syllabus(self): return self.syllabus_

  def set_syllabus(self, x):
    self.has_syllabus_ = 1
    self.syllabus_ = x

  def clear_syllabus(self):
    self.has_syllabus_ = 0
    self.syllabus_ = ""

  def has_syllabus(self): return self.has_syllabus_

  def pub_size(self): return len(self.pub_)
  def pub_list(self): return self.pub_

  def pub(self, i):
    return self.pub_[i]

  def mutable_pub(self, i):
    return self.pub_[i]

  def add_pub(self):
    x = LegalCitation_CourtDocumentPub()
    self.pub_.append(x)
    return x

  def clear_pub(self):
    self.pub_ = []
  def court(self):
    if self.court_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.court_ is None: self.court_ = LegalCitation_CourtDocumentCourt()
      finally:
        self.lazy_init_lock_.release()
    return self.court_

  def mutable_court(self): self.has_court_ = 1; return self.court()

  def clear_court(self):
    #Warning: this method does not acquire the lock.
    self.has_court_ = 0;
    if self.court_ is not None: self.court_.Clear()

  def has_court(self): return self.has_court_

  def certioraricourtname(self): return self.certioraricourtname_

  def set_certioraricourtname(self, x):
    self.has_certioraricourtname_ = 1
    self.certioraricourtname_ = x

  def clear_certioraricourtname(self):
    self.has_certioraricourtname_ = 0
    self.certioraricourtname_ = ""

  def has_certioraricourtname(self): return self.has_certioraricourtname_

  def certiorarirelationship(self): return self.certiorarirelationship_

  def set_certiorarirelationship(self, x):
    self.has_certiorarirelationship_ = 1
    self.certiorarirelationship_ = x

  def clear_certiorarirelationship(self):
    self.has_certiorarirelationship_ = 0
    self.certiorarirelationship_ = 0

  def has_certiorarirelationship(self): return self.has_certiorarirelationship_

  def perdocketinfo_size(self): return len(self.perdocketinfo_)
  def perdocketinfo_list(self): return self.perdocketinfo_

  def perdocketinfo(self, i):
    return self.perdocketinfo_[i]

  def mutable_perdocketinfo(self, i):
    return self.perdocketinfo_[i]

  def add_perdocketinfo(self):
    x = LegalCitation_CourtDocumentPerDocketInfo()
    self.perdocketinfo_.append(x)
    return x

  def clear_perdocketinfo(self):
    self.perdocketinfo_ = []
  def memoid(self): return self.memoid_

  def set_memoid(self, x):
    self.has_memoid_ = 1
    self.memoid_ = x

  def clear_memoid(self):
    self.has_memoid_ = 0
    self.memoid_ = ""

  def has_memoid(self): return self.has_memoid_

  def decideddate(self):
    if self.decideddate_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.decideddate_ is None: self.decideddate_ = LegalDate()
      finally:
        self.lazy_init_lock_.release()
    return self.decideddate_

  def mutable_decideddate(self): self.has_decideddate_ = 1; return self.decideddate()

  def clear_decideddate(self):
    #Warning: this method does not acquire the lock.
    self.has_decideddate_ = 0;
    if self.decideddate_ is not None: self.decideddate_.Clear()

  def has_decideddate(self): return self.has_decideddate_

  def fileddate(self):
    if self.fileddate_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.fileddate_ is None: self.fileddate_ = LegalDate()
      finally:
        self.lazy_init_lock_.release()
    return self.fileddate_

  def mutable_fileddate(self): self.has_fileddate_ = 1; return self.fileddate()

  def clear_fileddate(self):
    #Warning: this method does not acquire the lock.
    self.has_fileddate_ = 0;
    if self.fileddate_ is not None: self.fileddate_.Clear()

  def has_fileddate(self): return self.has_fileddate_

  def argueddate(self):
    if self.argueddate_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.argueddate_ is None: self.argueddate_ = LegalDate()
      finally:
        self.lazy_init_lock_.release()
    return self.argueddate_

  def mutable_argueddate(self): self.has_argueddate_ = 1; return self.argueddate()

  def clear_argueddate(self):
    #Warning: this method does not acquire the lock.
    self.has_argueddate_ = 0;
    if self.argueddate_ is not None: self.argueddate_.Clear()

  def has_argueddate(self): return self.has_argueddate_

  def modifieddate(self):
    if self.modifieddate_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.modifieddate_ is None: self.modifieddate_ = LegalDate()
      finally:
        self.lazy_init_lock_.release()
    return self.modifieddate_

  def mutable_modifieddate(self): self.has_modifieddate_ = 1; return self.modifieddate()

  def clear_modifieddate(self):
    #Warning: this method does not acquire the lock.
    self.has_modifieddate_ = 0;
    if self.modifieddate_ is not None: self.modifieddate_.Clear()

  def has_modifieddate(self): return self.has_modifieddate_

  def courtterm(self): return self.courtterm_

  def set_courtterm(self, x):
    self.has_courtterm_ = 1
    self.courtterm_ = x

  def clear_courtterm(self):
    self.has_courtterm_ = 0
    self.courtterm_ = ""

  def has_courtterm(self): return self.has_courtterm_

  def arguedbefore_size(self): return len(self.arguedbefore_)
  def arguedbefore_list(self): return self.arguedbefore_

  def arguedbefore(self, i):
    return self.arguedbefore_[i]

  def mutable_arguedbefore(self, i):
    return self.arguedbefore_[i]

  def add_arguedbefore(self):
    x = LegalPerson()
    self.arguedbefore_.append(x)
    return x

  def clear_arguedbefore(self):
    self.arguedbefore_ = []
  def opinioninfo_size(self): return len(self.opinioninfo_)
  def opinioninfo_list(self): return self.opinioninfo_

  def opinioninfo(self, i):
    return self.opinioninfo_[i]

  def mutable_opinioninfo(self, i):
    return self.opinioninfo_[i]

  def add_opinioninfo(self):
    x = LegalCitation_CourtDocumentOpinionInfo()
    self.opinioninfo_.append(x)
    return x

  def clear_opinioninfo(self):
    self.opinioninfo_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_syllabus()): self.set_syllabus(x.syllabus())
    for i in xrange(x.pub_size()): self.add_pub().CopyFrom(x.pub(i))
    if (x.has_court()): self.mutable_court().MergeFrom(x.court())
    if (x.has_certioraricourtname()): self.set_certioraricourtname(x.certioraricourtname())
    if (x.has_certiorarirelationship()): self.set_certiorarirelationship(x.certiorarirelationship())
    for i in xrange(x.perdocketinfo_size()): self.add_perdocketinfo().CopyFrom(x.perdocketinfo(i))
    if (x.has_memoid()): self.set_memoid(x.memoid())
    if (x.has_decideddate()): self.mutable_decideddate().MergeFrom(x.decideddate())
    if (x.has_fileddate()): self.mutable_fileddate().MergeFrom(x.fileddate())
    if (x.has_argueddate()): self.mutable_argueddate().MergeFrom(x.argueddate())
    if (x.has_modifieddate()): self.mutable_modifieddate().MergeFrom(x.modifieddate())
    if (x.has_courtterm()): self.set_courtterm(x.courtterm())
    for i in xrange(x.arguedbefore_size()): self.add_arguedbefore().CopyFrom(x.arguedbefore(i))
    for i in xrange(x.opinioninfo_size()): self.add_opinioninfo().CopyFrom(x.opinioninfo(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'LegalCitation', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'LegalCitation')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'LegalCitation', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'LegalCitation', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'LegalCitation', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_syllabus_ != x.has_syllabus_: return 0
    if self.has_syllabus_ and self.syllabus_ != x.syllabus_: return 0
    if len(self.pub_) != len(x.pub_): return 0
    for e1, e2 in zip(self.pub_, x.pub_):
      if e1 != e2: return 0
    if self.has_court_ != x.has_court_: return 0
    if self.has_court_ and self.court_ != x.court_: return 0
    if self.has_certioraricourtname_ != x.has_certioraricourtname_: return 0
    if self.has_certioraricourtname_ and self.certioraricourtname_ != x.certioraricourtname_: return 0
    if self.has_certiorarirelationship_ != x.has_certiorarirelationship_: return 0
    if self.has_certiorarirelationship_ and self.certiorarirelationship_ != x.certiorarirelationship_: return 0
    if len(self.perdocketinfo_) != len(x.perdocketinfo_): return 0
    for e1, e2 in zip(self.perdocketinfo_, x.perdocketinfo_):
      if e1 != e2: return 0
    if self.has_memoid_ != x.has_memoid_: return 0
    if self.has_memoid_ and self.memoid_ != x.memoid_: return 0
    if self.has_decideddate_ != x.has_decideddate_: return 0
    if self.has_decideddate_ and self.decideddate_ != x.decideddate_: return 0
    if self.has_fileddate_ != x.has_fileddate_: return 0
    if self.has_fileddate_ and self.fileddate_ != x.fileddate_: return 0
    if self.has_argueddate_ != x.has_argueddate_: return 0
    if self.has_argueddate_ and self.argueddate_ != x.argueddate_: return 0
    if self.has_modifieddate_ != x.has_modifieddate_: return 0
    if self.has_modifieddate_ and self.modifieddate_ != x.modifieddate_: return 0
    if self.has_courtterm_ != x.has_courtterm_: return 0
    if self.has_courtterm_ and self.courtterm_ != x.courtterm_: return 0
    if len(self.arguedbefore_) != len(x.arguedbefore_): return 0
    for e1, e2 in zip(self.arguedbefore_, x.arguedbefore_):
      if e1 != e2: return 0
    if len(self.opinioninfo_) != len(x.opinioninfo_): return 0
    for e1, e2 in zip(self.opinioninfo_, x.opinioninfo_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for i in xrange(len(self.pub_)):
      if (not self.pub_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_court_ and not self.court_.IsInitialized(debug_strs)): initialized = 0
    for i in xrange(len(self.perdocketinfo_)):
      if (not self.perdocketinfo_[i].IsInitialized(debug_strs)): initialized=0
    if (self.has_decideddate_ and not self.decideddate_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_fileddate_ and not self.fileddate_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_argueddate_ and not self.argueddate_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_modifieddate_ and not self.modifieddate_.IsInitialized(debug_strs)): initialized = 0
    for i in xrange(len(self.arguedbefore_)):
      if (not self.arguedbefore_[i].IsInitialized(debug_strs)): initialized=0
    for i in xrange(len(self.opinioninfo_)):
      if (not self.opinioninfo_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_syllabus_): n += 2 + self.lengthString(len(self.syllabus_))
    n += 2 * len(self.pub_)
    for i in xrange(len(self.pub_)): n += self.pub_[i].ByteSize()
    if (self.has_court_): n += 4 + self.court_.ByteSize()
    if (self.has_certioraricourtname_): n += 2 + self.lengthString(len(self.certioraricourtname_))
    if (self.has_certiorarirelationship_): n += 2 + self.lengthVarInt64(self.certiorarirelationship_)
    n += 2 * len(self.perdocketinfo_)
    for i in xrange(len(self.perdocketinfo_)): n += self.perdocketinfo_[i].ByteSize()
    if (self.has_memoid_): n += 2 + self.lengthString(len(self.memoid_))
    if (self.has_decideddate_): n += 2 + self.lengthString(self.decideddate_.ByteSize())
    if (self.has_fileddate_): n += 2 + self.lengthString(self.fileddate_.ByteSize())
    if (self.has_argueddate_): n += 2 + self.lengthString(self.argueddate_.ByteSize())
    if (self.has_modifieddate_): n += 2 + self.lengthString(self.modifieddate_.ByteSize())
    if (self.has_courtterm_): n += 2 + self.lengthString(len(self.courtterm_))
    n += 2 * len(self.arguedbefore_)
    for i in xrange(len(self.arguedbefore_)): n += self.lengthString(self.arguedbefore_[i].ByteSize())
    n += 4 * len(self.opinioninfo_)
    for i in xrange(len(self.opinioninfo_)): n += self.opinioninfo_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_syllabus()
    self.clear_pub()
    self.clear_court()
    self.clear_certioraricourtname()
    self.clear_certiorarirelationship()
    self.clear_perdocketinfo()
    self.clear_memoid()
    self.clear_decideddate()
    self.clear_fileddate()
    self.clear_argueddate()
    self.clear_modifieddate()
    self.clear_courtterm()
    self.clear_arguedbefore()
    self.clear_opinioninfo()

  def OutputUnchecked(self, out):
    for i in xrange(len(self.pub_)):
      out.putVarInt32(19)
      self.pub_[i].OutputUnchecked(out)
      out.putVarInt32(20)
    for i in xrange(len(self.perdocketinfo_)):
      out.putVarInt32(51)
      self.perdocketinfo_[i].OutputUnchecked(out)
      out.putVarInt32(52)
    if (self.has_court_):
      out.putVarInt32(179)
      self.court_.OutputUnchecked(out)
      out.putVarInt32(180)
    if (self.has_certioraricourtname_):
      out.putVarInt32(202)
      out.putPrefixedString(self.certioraricourtname_)
    if (self.has_memoid_):
      out.putVarInt32(234)
      out.putPrefixedString(self.memoid_)
    if (self.has_decideddate_):
      out.putVarInt32(242)
      out.putVarInt32(self.decideddate_.ByteSize())
      self.decideddate_.OutputUnchecked(out)
    if (self.has_fileddate_):
      out.putVarInt32(250)
      out.putVarInt32(self.fileddate_.ByteSize())
      self.fileddate_.OutputUnchecked(out)
    if (self.has_argueddate_):
      out.putVarInt32(258)
      out.putVarInt32(self.argueddate_.ByteSize())
      self.argueddate_.OutputUnchecked(out)
    if (self.has_modifieddate_):
      out.putVarInt32(266)
      out.putVarInt32(self.modifieddate_.ByteSize())
      self.modifieddate_.OutputUnchecked(out)
    if (self.has_courtterm_):
      out.putVarInt32(274)
      out.putPrefixedString(self.courtterm_)
    for i in xrange(len(self.arguedbefore_)):
      out.putVarInt32(282)
      out.putVarInt32(self.arguedbefore_[i].ByteSize())
      self.arguedbefore_[i].OutputUnchecked(out)
    for i in xrange(len(self.opinioninfo_)):
      out.putVarInt32(291)
      self.opinioninfo_[i].OutputUnchecked(out)
      out.putVarInt32(292)
    if (self.has_certiorarirelationship_):
      out.putVarInt32(376)
      out.putVarInt32(self.certiorarirelationship_)
    if (self.has_syllabus_):
      out.putVarInt32(418)
      out.putPrefixedString(self.syllabus_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 12: break
      if tt == 19:
        self.add_pub().TryMerge(d)
        continue
      if tt == 51:
        self.add_perdocketinfo().TryMerge(d)
        continue
      if tt == 179:
        self.mutable_court().TryMerge(d)
        continue
      if tt == 202:
        self.set_certioraricourtname(d.getPrefixedString())
        continue
      if tt == 234:
        self.set_memoid(d.getPrefixedString())
        continue
      if tt == 242:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_decideddate().TryMerge(tmp)
        continue
      if tt == 250:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_fileddate().TryMerge(tmp)
        continue
      if tt == 258:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_argueddate().TryMerge(tmp)
        continue
      if tt == 266:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_modifieddate().TryMerge(tmp)
        continue
      if tt == 274:
        self.set_courtterm(d.getPrefixedString())
        continue
      if tt == 282:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.add_arguedbefore().TryMerge(tmp)
        continue
      if tt == 291:
        self.add_opinioninfo().TryMerge(d)
        continue
      if tt == 376:
        self.set_certiorarirelationship(d.getVarInt32())
        continue
      if tt == 418:
        self.set_syllabus(d.getPrefixedString())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_syllabus_: res+=prefix+("Syllabus: %s\n" % self.DebugFormatString(self.syllabus_))
    cnt=0
    for e in self.pub_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Pub%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_court_:
      res+=prefix+"Court {\n"
      res+=self.court_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_certioraricourtname_: res+=prefix+("CertiorariCourtName: %s\n" % self.DebugFormatString(self.certioraricourtname_))
    if self.has_certiorarirelationship_: res+=prefix+("CertiorariRelationship: %s\n" % self.DebugFormatInt32(self.certiorarirelationship_))
    cnt=0
    for e in self.perdocketinfo_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("PerDocketInfo%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if self.has_memoid_: res+=prefix+("MemoID: %s\n" % self.DebugFormatString(self.memoid_))
    if self.has_decideddate_:
      res+=prefix+"DecidedDate <\n"
      res+=self.decideddate_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_fileddate_:
      res+=prefix+"FiledDate <\n"
      res+=self.fileddate_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_argueddate_:
      res+=prefix+"ArguedDate <\n"
      res+=self.argueddate_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_modifieddate_:
      res+=prefix+"ModifiedDate <\n"
      res+=self.modifieddate_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_courtterm_: res+=prefix+("CourtTerm: %s\n" % self.DebugFormatString(self.courtterm_))
    cnt=0
    for e in self.arguedbefore_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("ArguedBefore%s <\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    cnt=0
    for e in self.opinioninfo_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("OpinionInfo%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

class LegalCitation_Law(ProtocolBuffer.ProtocolMessage):

  LAW_NONE     =    0 
  LAW_CONSTITUTION =    1 
  LAW_LEGISLATIVE =    2 
  LAW_EXECUTIVE =    3 
  NUM_LAW_TYPES =    4 

  _LawType_NAMES = {
    0: "LAW_NONE",
    1: "LAW_CONSTITUTION",
    2: "LAW_LEGISLATIVE",
    3: "LAW_EXECUTIVE",
    4: "NUM_LAW_TYPES",
  }

  def LawType_Name(cls, x): return cls._LawType_NAMES.get(x, "")
  LawType_Name = classmethod(LawType_Name)


  LAW_STATUS_NORMAL =    0 
  LAW_STATUS_REPEALED =    1 
  LAW_STATUS_RESERVED =    2 

  _LawStatus_NAMES = {
    0: "LAW_STATUS_NORMAL",
    1: "LAW_STATUS_REPEALED",
    2: "LAW_STATUS_RESERVED",
  }

  def LawStatus_Name(cls, x): return cls._LawStatus_NAMES.get(x, "")
  LawStatus_Name = classmethod(LawStatus_Name)


  LEVEL_NONE   =    0 
  LEVEL_TITLE  =    1 
  LEVEL_CHAPTER =    2 
  LEVEL_SECTION =    3 
  LEVEL_ARTICLE =    4 
  LEVEL_AMENDMENT =    5 
  LEVEL_PART   =    6 
  LEVEL_ROOT   =    7 
  LEVEL_SUBCHAPTER =    8 
  LEVEL_SUBTITLE =    9 
  LEVEL_NO_LABEL =   10 
  LEVEL_GENERAL =   11 
  NUM_LEVEL_TYPES =   12 

  _LevelType_NAMES = {
    0: "LEVEL_NONE",
    1: "LEVEL_TITLE",
    2: "LEVEL_CHAPTER",
    3: "LEVEL_SECTION",
    4: "LEVEL_ARTICLE",
    5: "LEVEL_AMENDMENT",
    6: "LEVEL_PART",
    7: "LEVEL_ROOT",
    8: "LEVEL_SUBCHAPTER",
    9: "LEVEL_SUBTITLE",
    10: "LEVEL_NO_LABEL",
    11: "LEVEL_GENERAL",
    12: "NUM_LEVEL_TYPES",
  }

  def LevelType_Name(cls, x): return cls._LevelType_NAMES.get(x, "")
  LevelType_Name = classmethod(LevelType_Name)

  def __init__(self, contents=None):
    self.revisiondate_ = None
    self.type_ = 0
    self.status_ = 0
    self.level_ = []
    self.has_revisiondate_ = 0
    self.has_type_ = 0
    self.has_status_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def revisiondate(self):
    if self.revisiondate_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.revisiondate_ is None: self.revisiondate_ = LegalDate()
      finally:
        self.lazy_init_lock_.release()
    return self.revisiondate_

  def mutable_revisiondate(self): self.has_revisiondate_ = 1; return self.revisiondate()

  def clear_revisiondate(self):
    #Warning: this method does not acquire the lock.
    self.has_revisiondate_ = 0;
    if self.revisiondate_ is not None: self.revisiondate_.Clear()

  def has_revisiondate(self): return self.has_revisiondate_

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = 0

  def has_type(self): return self.has_type_

  def status(self): return self.status_

  def set_status(self, x):
    self.has_status_ = 1
    self.status_ = x

  def clear_status(self):
    self.has_status_ = 0
    self.status_ = 0

  def has_status(self): return self.has_status_

  def level_size(self): return len(self.level_)
  def level_list(self): return self.level_

  def level(self, i):
    return self.level_[i]

  def mutable_level(self, i):
    return self.level_[i]

  def add_level(self):
    x = LegalCitation_LawLevel()
    self.level_.append(x)
    return x

  def clear_level(self):
    self.level_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (x.has_revisiondate()): self.mutable_revisiondate().MergeFrom(x.revisiondate())
    if (x.has_type()): self.set_type(x.type())
    if (x.has_status()): self.set_status(x.status())
    for i in xrange(x.level_size()): self.add_level().CopyFrom(x.level(i))

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'LegalCitation', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'LegalCitation')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'LegalCitation', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'LegalCitation', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'LegalCitation', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_revisiondate_ != x.has_revisiondate_: return 0
    if self.has_revisiondate_ and self.revisiondate_ != x.revisiondate_: return 0
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_status_ != x.has_status_: return 0
    if self.has_status_ and self.status_ != x.status_: return 0
    if len(self.level_) != len(x.level_): return 0
    for e1, e2 in zip(self.level_, x.level_):
      if e1 != e2: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (self.has_revisiondate_ and not self.revisiondate_.IsInitialized(debug_strs)): initialized = 0
    for i in xrange(len(self.level_)):
      if (not self.level_[i].IsInitialized(debug_strs)): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_revisiondate_): n += 2 + self.lengthString(self.revisiondate_.ByteSize())
    if (self.has_type_): n += 2 + self.lengthVarInt64(self.type_)
    if (self.has_status_): n += 2 + self.lengthVarInt64(self.status_)
    n += 4 * len(self.level_)
    for i in xrange(len(self.level_)): n += self.level_[i].ByteSize()
    return n + 0

  def Clear(self):
    self.clear_revisiondate()
    self.clear_type()
    self.clear_status()
    self.clear_level()

  def OutputUnchecked(self, out):
    if (self.has_type_):
      out.putVarInt32(320)
      out.putVarInt32(self.type_)
    for i in xrange(len(self.level_)):
      out.putVarInt32(331)
      self.level_[i].OutputUnchecked(out)
      out.putVarInt32(332)
    if (self.has_revisiondate_):
      out.putVarInt32(354)
      out.putVarInt32(self.revisiondate_.ByteSize())
      self.revisiondate_.OutputUnchecked(out)
    if (self.has_status_):
      out.putVarInt32(400)
      out.putVarInt32(self.status_)

  def TryMerge(self, d):
    while 1:
      tt = d.getVarInt32()
      if tt == 164: break
      if tt == 320:
        self.set_type(d.getVarInt32())
        continue
      if tt == 331:
        self.add_level().TryMerge(d)
        continue
      if tt == 354:
        length = d.getVarInt32()
        tmp = ProtocolBuffer.Decoder(d.buffer(), d.pos(), d.pos() + length)
        d.skip(length)
        self.mutable_revisiondate().TryMerge(tmp)
        continue
      if tt == 400:
        self.set_status(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_revisiondate_:
      res+=prefix+"RevisionDate <\n"
      res+=self.revisiondate_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatInt32(self.type_))
    if self.has_status_: res+=prefix+("Status: %s\n" % self.DebugFormatInt32(self.status_))
    cnt=0
    for e in self.level_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Level%s {\n" % elm)
      res+=e.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res

class LegalCitation(ProtocolBuffer.ProtocolMessage):

  FIRST_DOC_TYPE =    0 
  STATUTE      =    1 
  OPINION      =    2 
  NUM_DOC_TYPES =    3 

  _DocType_NAMES = {
    0: "FIRST_DOC_TYPE",
    1: "STATUTE",
    2: "OPINION",
    3: "NUM_DOC_TYPES",
  }

  def DocType_Name(cls, x): return cls._DocType_NAMES.get(x, "")
  DocType_Name = classmethod(DocType_Name)


  INVALID_CITATION_TYPE =    0 
  FULL_CITATION =    1 
  SINGLE_PARTY_CITATION =    2 
  IBID_CITATION =    3 
  NOPARTY_CITATION =    4 
  ORDER_CITATION =    5 
  TRAILING_ORDER_CITATION =    6 
  ADMIN_CITATION =    7 

  _CitationParseType_NAMES = {
    0: "INVALID_CITATION_TYPE",
    1: "FULL_CITATION",
    2: "SINGLE_PARTY_CITATION",
    3: "IBID_CITATION",
    4: "NOPARTY_CITATION",
    5: "ORDER_CITATION",
    6: "TRAILING_ORDER_CITATION",
    7: "ADMIN_CITATION",
  }

  def CitationParseType_Name(cls, x): return cls._CitationParseType_NAMES.get(x, "")
  CitationParseType_Name = classmethod(CitationParseType_Name)

  def __init__(self, contents=None):
    self.type_ = 0
    self.parsetype_ = 0
    self.countrycode_ = ""
    self.state_ = ""
    self.law_ = None
    self.courtdocument_ = None
    self.has_type_ = 0
    self.has_parsetype_ = 0
    self.has_countrycode_ = 0
    self.has_state_ = 0
    self.has_law_ = 0
    self.has_courtdocument_ = 0
    self.lazy_init_lock_ = thread.allocate_lock()
    if contents is not None: self.MergeFromString(contents)

  def type(self): return self.type_

  def set_type(self, x):
    self.has_type_ = 1
    self.type_ = x

  def clear_type(self):
    self.has_type_ = 0
    self.type_ = 0

  def has_type(self): return self.has_type_

  def parsetype(self): return self.parsetype_

  def set_parsetype(self, x):
    self.has_parsetype_ = 1
    self.parsetype_ = x

  def clear_parsetype(self):
    self.has_parsetype_ = 0
    self.parsetype_ = 0

  def has_parsetype(self): return self.has_parsetype_

  def countrycode(self): return self.countrycode_

  def set_countrycode(self, x):
    self.has_countrycode_ = 1
    self.countrycode_ = x

  def clear_countrycode(self):
    self.has_countrycode_ = 0
    self.countrycode_ = ""

  def has_countrycode(self): return self.has_countrycode_

  def state(self): return self.state_

  def set_state(self, x):
    self.has_state_ = 1
    self.state_ = x

  def clear_state(self):
    self.has_state_ = 0
    self.state_ = ""

  def has_state(self): return self.has_state_

  def law(self):
    if self.law_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.law_ is None: self.law_ = LegalCitation_Law()
      finally:
        self.lazy_init_lock_.release()
    return self.law_

  def mutable_law(self): self.has_law_ = 1; return self.law()

  def clear_law(self):
    #Warning: this method does not acquire the lock.
    self.has_law_ = 0;
    if self.law_ is not None: self.law_.Clear()

  def has_law(self): return self.has_law_

  def courtdocument(self):
    if self.courtdocument_ is None:
      self.lazy_init_lock_.acquire()
      try:
        if self.courtdocument_ is None: self.courtdocument_ = LegalCitation_CourtDocument()
      finally:
        self.lazy_init_lock_.release()
    return self.courtdocument_

  def mutable_courtdocument(self): self.has_courtdocument_ = 1; return self.courtdocument()

  def clear_courtdocument(self):
    #Warning: this method does not acquire the lock.
    self.has_courtdocument_ = 0;
    if self.courtdocument_ is not None: self.courtdocument_.Clear()

  def has_courtdocument(self): return self.has_courtdocument_


  def MergeFrom(self, x):
    assert x is not self
    if (x.has_type()): self.set_type(x.type())
    if (x.has_parsetype()): self.set_parsetype(x.parsetype())
    if (x.has_countrycode()): self.set_countrycode(x.countrycode())
    if (x.has_state()): self.set_state(x.state())
    if (x.has_law()): self.mutable_law().MergeFrom(x.law())
    if (x.has_courtdocument()): self.mutable_courtdocument().MergeFrom(x.courtdocument())

  def _CMergeFromString(self, s):
    _net_proto___parse__python.MergeFromString(self, 'LegalCitation', s)

  def _CEncode(self):
    return _net_proto___parse__python.Encode(self, 'LegalCitation')

  def _CToASCII(self, output_format):
    return _net_proto___parse__python.ToASCII(self, 'LegalCitation', output_format)


  def ParseASCII(self, s):
    _net_proto___parse__python.ParseASCII(self, 'LegalCitation', s)


  def ParseASCIIIgnoreUnknown(self, s):
    _net_proto___parse__python.ParseASCIIIgnoreUnknown(self, 'LegalCitation', s)


  def Equals(self, x):
    if x is self: return 1
    if self.has_type_ != x.has_type_: return 0
    if self.has_type_ and self.type_ != x.type_: return 0
    if self.has_parsetype_ != x.has_parsetype_: return 0
    if self.has_parsetype_ and self.parsetype_ != x.parsetype_: return 0
    if self.has_countrycode_ != x.has_countrycode_: return 0
    if self.has_countrycode_ and self.countrycode_ != x.countrycode_: return 0
    if self.has_state_ != x.has_state_: return 0
    if self.has_state_ and self.state_ != x.state_: return 0
    if self.has_law_ != x.has_law_: return 0
    if self.has_law_ and self.law_ != x.law_: return 0
    if self.has_courtdocument_ != x.has_courtdocument_: return 0
    if self.has_courtdocument_ and self.courtdocument_ != x.courtdocument_: return 0
    return 1

  def __eq__(self, other):
    return (other is not None) and (other.__class__ == self.__class__) and self.Equals(other)

  def __ne__(self, other):
    return not (self == other)

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (self.has_law_ and not self.law_.IsInitialized(debug_strs)): initialized = 0
    if (self.has_courtdocument_ and not self.courtdocument_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    if (self.has_type_): n += 2 + self.lengthVarInt64(self.type_)
    if (self.has_parsetype_): n += 2 + self.lengthVarInt64(self.parsetype_)
    if (self.has_countrycode_): n += 2 + self.lengthString(len(self.countrycode_))
    if (self.has_state_): n += 2 + self.lengthString(len(self.state_))
    if (self.has_law_): n += 4 + self.law_.ByteSize()
    if (self.has_courtdocument_): n += 2 + self.courtdocument_.ByteSize()
    return n + 0

  def Clear(self):
    self.clear_type()
    self.clear_parsetype()
    self.clear_countrycode()
    self.clear_state()
    self.clear_law()
    self.clear_courtdocument()

  def OutputUnchecked(self, out):
    if (self.has_courtdocument_):
      out.putVarInt32(11)
      self.courtdocument_.OutputUnchecked(out)
      out.putVarInt32(12)
    if (self.has_type_):
      out.putVarInt32(136)
      out.putVarInt32(self.type_)
    if (self.has_countrycode_):
      out.putVarInt32(146)
      out.putPrefixedString(self.countrycode_)
    if (self.has_state_):
      out.putVarInt32(154)
      out.putPrefixedString(self.state_)
    if (self.has_law_):
      out.putVarInt32(163)
      self.law_.OutputUnchecked(out)
      out.putVarInt32(164)
    if (self.has_parsetype_):
      out.putVarInt32(424)
      out.putVarInt32(self.parsetype_)

  def TryMerge(self, d):
    while d.avail() > 0:
      tt = d.getVarInt32()
      if tt == 11:
        self.mutable_courtdocument().TryMerge(d)
        continue
      if tt == 136:
        self.set_type(d.getVarInt32())
        continue
      if tt == 146:
        self.set_countrycode(d.getPrefixedString())
        continue
      if tt == 154:
        self.set_state(d.getPrefixedString())
        continue
      if tt == 163:
        self.mutable_law().TryMerge(d)
        continue
      if tt == 424:
        self.set_parsetype(d.getVarInt32())
        continue
      # tag 0 is special: it's used to indicate an error.
      # so if we see it we raise an exception.
      if (tt == 0): raise ProtocolBuffer.ProtocolBufferDecodeError
      d.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if self.has_type_: res+=prefix+("Type: %s\n" % self.DebugFormatInt32(self.type_))
    if self.has_parsetype_: res+=prefix+("ParseType: %s\n" % self.DebugFormatInt32(self.parsetype_))
    if self.has_countrycode_: res+=prefix+("CountryCode: %s\n" % self.DebugFormatString(self.countrycode_))
    if self.has_state_: res+=prefix+("State: %s\n" % self.DebugFormatString(self.state_))
    if self.has_law_:
      res+=prefix+"Law {\n"
      res+=self.law_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    if self.has_courtdocument_:
      res+=prefix+"CourtDocument {\n"
      res+=self.courtdocument_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
    return res

  kType = 17
  kParseType = 53
  kCountryCode = 18
  kState = 19
  kLawGroup = 20
  kLawRevisionDate = 44
  kLawType = 40
  kLawStatus = 50
  kLawLevelGroup = 41
  kLawLevelType = 42
  kLawLevelLevelTypeString = 51
  kLawLevelValue = 43
  kLawLevelName = 45
  kCourtDocumentGroup = 1
  kCourtDocumentSyllabus = 52
  kCourtDocumentPubGroup = 2
  kCourtDocumentPubVolume = 3
  kCourtDocumentPubReporter = 4
  kCourtDocumentPubPage = 5
  kCourtDocumentPubYear = 21
  kCourtDocumentCourtGroup = 22
  kCourtDocumentCourtName = 23
  kCourtDocumentCourtLevel = 24
  kCourtDocumentCertiorariCourtName = 25
  kCourtDocumentCertiorariRelationship = 47
  kCourtDocumentPerDocketInfoGroup = 6
  kCourtDocumentPerDocketInfoDocketID = 26
  kCourtDocumentPerDocketInfoRespondent = 7
  kCourtDocumentPerDocketInfoPetitioner = 8
  kCourtDocumentPerDocketInfoTopic = 49
  kCourtDocumentPerDocketInfoRespondentCounsel = 27
  kCourtDocumentPerDocketInfoPetitionerCounsel = 28
  kCourtDocumentMemoID = 29
  kCourtDocumentDecidedDate = 30
  kCourtDocumentFiledDate = 31
  kCourtDocumentArguedDate = 32
  kCourtDocumentModifiedDate = 33
  kCourtDocumentCourtTerm = 34
  kCourtDocumentArguedBefore = 35
  kCourtDocumentOpinionInfoGroup = 36
  kCourtDocumentOpinionInfoType = 37
  kCourtDocumentOpinionInfoBench = 48
  kCourtDocumentOpinionInfoDeliveredBy = 38
  kCourtDocumentOpinionInfoJoinedBy = 39

  _TEXT = (
   "ErrorCode",  #   0
   "CourtDocument",  #   1
   "Pub",  #   2
   "Volume",  #   3
   "Reporter",  #   4
   "Page",  #   5
   "PerDocketInfo",  #   6
   "Respondent",  #   7
   "Petitioner",  #   8
   None,  #   9
   None,  #  10
   None,  #  11
   None,  #  12
   None,  #  13
   None,  #  14
   None,  #  15
   None,  #  16
   "Type",  #  17
   "CountryCode",  #  18
   "State",  #  19
   "Law",  #  20
   "Year",  #  21
   "Court",  #  22
   "Name",  #  23
   "Level",  #  24
   "CertiorariCourtName",  #  25
   "DocketID",  #  26
   "RespondentCounsel",  #  27
   "PetitionerCounsel",  #  28
   "MemoID",  #  29
   "DecidedDate",  #  30
   "FiledDate",  #  31
   "ArguedDate",  #  32
   "ModifiedDate",  #  33
   "CourtTerm",  #  34
   "ArguedBefore",  #  35
   "OpinionInfo",  #  36
   "Type",  #  37
   "DeliveredBy",  #  38
   "JoinedBy",  #  39
   "Type",  #  40
   "Level",  #  41
   "Type",  #  42
   "Value",  #  43
   "RevisionDate",  #  44
   "Name",  #  45
   None,  #  46
   "CertiorariRelationship",  #  47
   "Bench",  #  48
   "Topic",  #  49
   "Status",  #  50
   "LevelTypeString",  #  51
   "Syllabus",  #  52
   "ParseType",  #  53
  )

  _TYPES = (
   ProtocolBuffer.Encoder.NUMERIC,  #   0
   ProtocolBuffer.Encoder.STARTGROUP,  #   1

   ProtocolBuffer.Encoder.STARTGROUP,  #   2

   ProtocolBuffer.Encoder.NUMERIC,  #   3

   ProtocolBuffer.Encoder.STRING,  #   4

   ProtocolBuffer.Encoder.STRING,  #   5

   ProtocolBuffer.Encoder.STARTGROUP,  #   6

   ProtocolBuffer.Encoder.STRING,  #   7

   ProtocolBuffer.Encoder.STRING,  #   8

   ProtocolBuffer.Encoder.MAX_TYPE,  #   9

   ProtocolBuffer.Encoder.MAX_TYPE,  #  10

   ProtocolBuffer.Encoder.MAX_TYPE,  #  11

   ProtocolBuffer.Encoder.MAX_TYPE,  #  12

   ProtocolBuffer.Encoder.MAX_TYPE,  #  13

   ProtocolBuffer.Encoder.MAX_TYPE,  #  14

   ProtocolBuffer.Encoder.MAX_TYPE,  #  15

   ProtocolBuffer.Encoder.MAX_TYPE,  #  16

   ProtocolBuffer.Encoder.NUMERIC,  #  17

   ProtocolBuffer.Encoder.STRING,  #  18

   ProtocolBuffer.Encoder.STRING,  #  19

   ProtocolBuffer.Encoder.STARTGROUP,  #  20

   ProtocolBuffer.Encoder.NUMERIC,  #  21

   ProtocolBuffer.Encoder.STARTGROUP,  #  22

   ProtocolBuffer.Encoder.STRING,  #  23

   ProtocolBuffer.Encoder.NUMERIC,  #  24

   ProtocolBuffer.Encoder.STRING,  #  25

   ProtocolBuffer.Encoder.STRING,  #  26

   ProtocolBuffer.Encoder.STRING,  #  27

   ProtocolBuffer.Encoder.STRING,  #  28

   ProtocolBuffer.Encoder.STRING,  #  29

   ProtocolBuffer.Encoder.STRING,  #  30

   ProtocolBuffer.Encoder.STRING,  #  31

   ProtocolBuffer.Encoder.STRING,  #  32

   ProtocolBuffer.Encoder.STRING,  #  33

   ProtocolBuffer.Encoder.STRING,  #  34

   ProtocolBuffer.Encoder.STRING,  #  35

   ProtocolBuffer.Encoder.STARTGROUP,  #  36

   ProtocolBuffer.Encoder.NUMERIC,  #  37

   ProtocolBuffer.Encoder.STRING,  #  38

   ProtocolBuffer.Encoder.STRING,  #  39

   ProtocolBuffer.Encoder.NUMERIC,  #  40

   ProtocolBuffer.Encoder.STARTGROUP,  #  41

   ProtocolBuffer.Encoder.NUMERIC,  #  42

   ProtocolBuffer.Encoder.STRING,  #  43

   ProtocolBuffer.Encoder.STRING,  #  44

   ProtocolBuffer.Encoder.STRING,  #  45

   ProtocolBuffer.Encoder.MAX_TYPE,  #  46

   ProtocolBuffer.Encoder.NUMERIC,  #  47

   ProtocolBuffer.Encoder.NUMERIC,  #  48

   ProtocolBuffer.Encoder.STRING,  #  49

   ProtocolBuffer.Encoder.NUMERIC,  #  50

   ProtocolBuffer.Encoder.STRING,  #  51

   ProtocolBuffer.Encoder.STRING,  #  52

   ProtocolBuffer.Encoder.NUMERIC,  #  53

  )

  # stylesheet for XML output
  _STYLE = \
   """"""
  _STYLE_CONTENT_TYPE = \
   """"""
  _SERIALIZED_DESCRIPTOR = array.array('B', [
    0x5a,
    0x2c,
    0x73,
    0x63,
    0x69,
    0x65,
    0x6e,
    0x63,
    0x65,
    0x5f,
    0x73,
    0x65,
    0x61,
    0x72,
    0x63,
    0x68,
    0x2f,
    0x63,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2f,
    0x6c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x5f,
    0x63,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x2e,
    0x70,
    0x72,
    0x6f,
    0x74,
    0x6f,
    0x0a,
    0x0d,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x43,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x13,
    0x1a,
    0x04,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x11,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x50,
    0x61,
    0x72,
    0x73,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x35,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x0b,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x74,
    0x72,
    0x79,
    0x43,
    0x6f,
    0x64,
    0x65,
    0x20,
    0x12,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x05,
    0x53,
    0x74,
    0x61,
    0x74,
    0x65,
    0x20,
    0x13,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x03,
    0x4c,
    0x61,
    0x77,
    0x20,
    0x14,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x10,
    0x4c,
    0x61,
    0x77,
    0x2e,
    0x52,
    0x65,
    0x76,
    0x69,
    0x73,
    0x69,
    0x6f,
    0x6e,
    0x44,
    0x61,
    0x74,
    0x65,
    0x20,
    0x2c,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x09,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x44,
    0x61,
    0x74,
    0x65,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x08,
    0x4c,
    0x61,
    0x77,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x28,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x0a,
    0x4c,
    0x61,
    0x77,
    0x2e,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x20,
    0x32,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x09,
    0x4c,
    0x61,
    0x77,
    0x2e,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x20,
    0x29,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x04,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x4c,
    0x61,
    0x77,
    0x2e,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x2a,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x08,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x4c,
    0x61,
    0x77,
    0x2e,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x2e,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x54,
    0x79,
    0x70,
    0x65,
    0x53,
    0x74,
    0x72,
    0x69,
    0x6e,
    0x67,
    0x20,
    0x33,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x08,
    0x14,
    0x13,
    0x1a,
    0x0f,
    0x4c,
    0x61,
    0x77,
    0x2e,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x2e,
    0x56,
    0x61,
    0x6c,
    0x75,
    0x65,
    0x20,
    0x2b,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x08,
    0x14,
    0x13,
    0x1a,
    0x0e,
    0x4c,
    0x61,
    0x77,
    0x2e,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x2e,
    0x4e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x2d,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x08,
    0x14,
    0x13,
    0x1a,
    0x0d,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x01,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x53,
    0x79,
    0x6c,
    0x6c,
    0x61,
    0x62,
    0x75,
    0x73,
    0x20,
    0x34,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x11,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x75,
    0x62,
    0x20,
    0x02,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x75,
    0x62,
    0x2e,
    0x56,
    0x6f,
    0x6c,
    0x75,
    0x6d,
    0x65,
    0x20,
    0x03,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x0f,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x75,
    0x62,
    0x2e,
    0x52,
    0x65,
    0x70,
    0x6f,
    0x72,
    0x74,
    0x65,
    0x72,
    0x20,
    0x04,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x0f,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x75,
    0x62,
    0x2e,
    0x50,
    0x61,
    0x67,
    0x65,
    0x20,
    0x05,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x0f,
    0x14,
    0x13,
    0x1a,
    0x16,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x75,
    0x62,
    0x2e,
    0x59,
    0x65,
    0x61,
    0x72,
    0x20,
    0x15,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x0f,
    0x14,
    0x13,
    0x1a,
    0x13,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x20,
    0x16,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x01,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x2e,
    0x4e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x17,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x02,
    0x60,
    0x14,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x2e,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x20,
    0x18,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x14,
    0x14,
    0x13,
    0x1a,
    0x21,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x65,
    0x72,
    0x74,
    0x69,
    0x6f,
    0x72,
    0x61,
    0x72,
    0x69,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x4e,
    0x61,
    0x6d,
    0x65,
    0x20,
    0x19,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x24,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x65,
    0x72,
    0x74,
    0x69,
    0x6f,
    0x72,
    0x61,
    0x72,
    0x69,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x68,
    0x69,
    0x70,
    0x20,
    0x2f,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x1b,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x6b,
    0x65,
    0x74,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x06,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x24,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x6b,
    0x65,
    0x74,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x44,
    0x6f,
    0x63,
    0x6b,
    0x65,
    0x74,
    0x49,
    0x44,
    0x20,
    0x1a,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x19,
    0x14,
    0x13,
    0x1a,
    0x26,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x6b,
    0x65,
    0x74,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x64,
    0x65,
    0x6e,
    0x74,
    0x20,
    0x07,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x0b,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x50,
    0x65,
    0x72,
    0x73,
    0x6f,
    0x6e,
    0x60,
    0x19,
    0x14,
    0x13,
    0x1a,
    0x26,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x6b,
    0x65,
    0x74,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x50,
    0x65,
    0x74,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x65,
    0x72,
    0x20,
    0x08,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x0b,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x50,
    0x65,
    0x72,
    0x73,
    0x6f,
    0x6e,
    0x60,
    0x19,
    0x14,
    0x13,
    0x1a,
    0x21,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x6b,
    0x65,
    0x74,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x54,
    0x6f,
    0x70,
    0x69,
    0x63,
    0x20,
    0x31,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x19,
    0x14,
    0x13,
    0x1a,
    0x2d,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x6b,
    0x65,
    0x74,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x52,
    0x65,
    0x73,
    0x70,
    0x6f,
    0x6e,
    0x64,
    0x65,
    0x6e,
    0x74,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x73,
    0x65,
    0x6c,
    0x20,
    0x1b,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x0b,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x50,
    0x65,
    0x72,
    0x73,
    0x6f,
    0x6e,
    0x60,
    0x19,
    0x14,
    0x13,
    0x1a,
    0x2d,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x50,
    0x65,
    0x72,
    0x44,
    0x6f,
    0x63,
    0x6b,
    0x65,
    0x74,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x50,
    0x65,
    0x74,
    0x69,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x65,
    0x72,
    0x43,
    0x6f,
    0x75,
    0x6e,
    0x73,
    0x65,
    0x6c,
    0x20,
    0x1c,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x0b,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x50,
    0x65,
    0x72,
    0x73,
    0x6f,
    0x6e,
    0x60,
    0x19,
    0x14,
    0x13,
    0x1a,
    0x14,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x4d,
    0x65,
    0x6d,
    0x6f,
    0x49,
    0x44,
    0x20,
    0x1d,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x44,
    0x65,
    0x63,
    0x69,
    0x64,
    0x65,
    0x64,
    0x44,
    0x61,
    0x74,
    0x65,
    0x20,
    0x1e,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x09,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x44,
    0x61,
    0x74,
    0x65,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x46,
    0x69,
    0x6c,
    0x65,
    0x64,
    0x44,
    0x61,
    0x74,
    0x65,
    0x20,
    0x1f,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x09,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x44,
    0x61,
    0x74,
    0x65,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x18,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x41,
    0x72,
    0x67,
    0x75,
    0x65,
    0x64,
    0x44,
    0x61,
    0x74,
    0x65,
    0x20,
    0x20,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x09,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x44,
    0x61,
    0x74,
    0x65,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x4d,
    0x6f,
    0x64,
    0x69,
    0x66,
    0x69,
    0x65,
    0x64,
    0x44,
    0x61,
    0x74,
    0x65,
    0x20,
    0x21,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x09,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x44,
    0x61,
    0x74,
    0x65,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x17,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x54,
    0x65,
    0x72,
    0x6d,
    0x20,
    0x22,
    0x28,
    0x02,
    0x30,
    0x09,
    0x38,
    0x01,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x1a,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x41,
    0x72,
    0x67,
    0x75,
    0x65,
    0x64,
    0x42,
    0x65,
    0x66,
    0x6f,
    0x72,
    0x65,
    0x20,
    0x23,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x03,
    0x4a,
    0x0b,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x50,
    0x65,
    0x72,
    0x73,
    0x6f,
    0x6e,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x19,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x4f,
    0x70,
    0x69,
    0x6e,
    0x69,
    0x6f,
    0x6e,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x20,
    0x24,
    0x28,
    0x03,
    0x30,
    0x0a,
    0x38,
    0x03,
    0x60,
    0x0d,
    0x14,
    0x13,
    0x1a,
    0x1e,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x4f,
    0x70,
    0x69,
    0x6e,
    0x69,
    0x6f,
    0x6e,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x20,
    0x25,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x02,
    0x60,
    0x27,
    0x14,
    0x13,
    0x1a,
    0x1f,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x4f,
    0x70,
    0x69,
    0x6e,
    0x69,
    0x6f,
    0x6e,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x42,
    0x65,
    0x6e,
    0x63,
    0x68,
    0x20,
    0x30,
    0x28,
    0x00,
    0x30,
    0x05,
    0x38,
    0x01,
    0x60,
    0x27,
    0x14,
    0x13,
    0x1a,
    0x25,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x4f,
    0x70,
    0x69,
    0x6e,
    0x69,
    0x6f,
    0x6e,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x44,
    0x65,
    0x6c,
    0x69,
    0x76,
    0x65,
    0x72,
    0x65,
    0x64,
    0x42,
    0x79,
    0x20,
    0x26,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0b,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x50,
    0x65,
    0x72,
    0x73,
    0x6f,
    0x6e,
    0x60,
    0x27,
    0x14,
    0x13,
    0x1a,
    0x22,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x44,
    0x6f,
    0x63,
    0x75,
    0x6d,
    0x65,
    0x6e,
    0x74,
    0x2e,
    0x4f,
    0x70,
    0x69,
    0x6e,
    0x69,
    0x6f,
    0x6e,
    0x49,
    0x6e,
    0x66,
    0x6f,
    0x2e,
    0x4a,
    0x6f,
    0x69,
    0x6e,
    0x65,
    0x64,
    0x42,
    0x79,
    0x20,
    0x27,
    0x28,
    0x02,
    0x30,
    0x0b,
    0x38,
    0x01,
    0x4a,
    0x0b,
    0x4c,
    0x65,
    0x67,
    0x61,
    0x6c,
    0x50,
    0x65,
    0x72,
    0x73,
    0x6f,
    0x6e,
    0x60,
    0x27,
    0x14,
    0x73,
    0x7a,
    0x07,
    0x44,
    0x6f,
    0x63,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x46,
    0x49,
    0x52,
    0x53,
    0x54,
    0x5f,
    0x44,
    0x4f,
    0x43,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x53,
    0x54,
    0x41,
    0x54,
    0x55,
    0x54,
    0x45,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x4f,
    0x50,
    0x49,
    0x4e,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x4e,
    0x55,
    0x4d,
    0x5f,
    0x44,
    0x4f,
    0x43,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x53,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x11,
    0x43,
    0x69,
    0x74,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x50,
    0x61,
    0x72,
    0x73,
    0x65,
    0x54,
    0x79,
    0x70,
    0x65,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x15,
    0x49,
    0x4e,
    0x56,
    0x41,
    0x4c,
    0x49,
    0x44,
    0x5f,
    0x43,
    0x49,
    0x54,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x46,
    0x55,
    0x4c,
    0x4c,
    0x5f,
    0x43,
    0x49,
    0x54,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x15,
    0x53,
    0x49,
    0x4e,
    0x47,
    0x4c,
    0x45,
    0x5f,
    0x50,
    0x41,
    0x52,
    0x54,
    0x59,
    0x5f,
    0x43,
    0x49,
    0x54,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x49,
    0x42,
    0x49,
    0x44,
    0x5f,
    0x43,
    0x49,
    0x54,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x4e,
    0x4f,
    0x50,
    0x41,
    0x52,
    0x54,
    0x59,
    0x5f,
    0x43,
    0x49,
    0x54,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x4f,
    0x52,
    0x44,
    0x45,
    0x52,
    0x5f,
    0x43,
    0x49,
    0x54,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x17,
    0x54,
    0x52,
    0x41,
    0x49,
    0x4c,
    0x49,
    0x4e,
    0x47,
    0x5f,
    0x4f,
    0x52,
    0x44,
    0x45,
    0x52,
    0x5f,
    0x43,
    0x49,
    0x54,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x41,
    0x44,
    0x4d,
    0x49,
    0x4e,
    0x5f,
    0x43,
    0x49,
    0x54,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x07,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x07,
    0x4c,
    0x61,
    0x77,
    0x54,
    0x79,
    0x70,
    0x65,
    0x80,
    0x01,
    0x04,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x4c,
    0x41,
    0x57,
    0x5f,
    0x4e,
    0x4f,
    0x4e,
    0x45,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x4c,
    0x41,
    0x57,
    0x5f,
    0x43,
    0x4f,
    0x4e,
    0x53,
    0x54,
    0x49,
    0x54,
    0x55,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4c,
    0x41,
    0x57,
    0x5f,
    0x4c,
    0x45,
    0x47,
    0x49,
    0x53,
    0x4c,
    0x41,
    0x54,
    0x49,
    0x56,
    0x45,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x4c,
    0x41,
    0x57,
    0x5f,
    0x45,
    0x58,
    0x45,
    0x43,
    0x55,
    0x54,
    0x49,
    0x56,
    0x45,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x4e,
    0x55,
    0x4d,
    0x5f,
    0x4c,
    0x41,
    0x57,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x53,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x09,
    0x4c,
    0x61,
    0x77,
    0x53,
    0x74,
    0x61,
    0x74,
    0x75,
    0x73,
    0x80,
    0x01,
    0x04,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x4c,
    0x41,
    0x57,
    0x5f,
    0x53,
    0x54,
    0x41,
    0x54,
    0x55,
    0x53,
    0x5f,
    0x4e,
    0x4f,
    0x52,
    0x4d,
    0x41,
    0x4c,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x13,
    0x4c,
    0x41,
    0x57,
    0x5f,
    0x53,
    0x54,
    0x41,
    0x54,
    0x55,
    0x53,
    0x5f,
    0x52,
    0x45,
    0x50,
    0x45,
    0x41,
    0x4c,
    0x45,
    0x44,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x13,
    0x4c,
    0x41,
    0x57,
    0x5f,
    0x53,
    0x54,
    0x41,
    0x54,
    0x55,
    0x53,
    0x5f,
    0x52,
    0x45,
    0x53,
    0x45,
    0x52,
    0x56,
    0x45,
    0x44,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x09,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x54,
    0x79,
    0x70,
    0x65,
    0x80,
    0x01,
    0x04,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x4e,
    0x4f,
    0x4e,
    0x45,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x54,
    0x49,
    0x54,
    0x4c,
    0x45,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x43,
    0x48,
    0x41,
    0x50,
    0x54,
    0x45,
    0x52,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x53,
    0x45,
    0x43,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x41,
    0x52,
    0x54,
    0x49,
    0x43,
    0x4c,
    0x45,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x41,
    0x4d,
    0x45,
    0x4e,
    0x44,
    0x4d,
    0x45,
    0x4e,
    0x54,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x50,
    0x41,
    0x52,
    0x54,
    0x98,
    0x01,
    0x06,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x52,
    0x4f,
    0x4f,
    0x54,
    0x98,
    0x01,
    0x07,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x10,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x53,
    0x55,
    0x42,
    0x43,
    0x48,
    0x41,
    0x50,
    0x54,
    0x45,
    0x52,
    0x98,
    0x01,
    0x08,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x53,
    0x55,
    0x42,
    0x54,
    0x49,
    0x54,
    0x4c,
    0x45,
    0x98,
    0x01,
    0x09,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0e,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x4e,
    0x4f,
    0x5f,
    0x4c,
    0x41,
    0x42,
    0x45,
    0x4c,
    0x98,
    0x01,
    0x0a,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x47,
    0x45,
    0x4e,
    0x45,
    0x52,
    0x41,
    0x4c,
    0x98,
    0x01,
    0x0b,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0f,
    0x4e,
    0x55,
    0x4d,
    0x5f,
    0x4c,
    0x45,
    0x56,
    0x45,
    0x4c,
    0x5f,
    0x54,
    0x59,
    0x50,
    0x45,
    0x53,
    0x98,
    0x01,
    0x0c,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x17,
    0x43,
    0x65,
    0x72,
    0x74,
    0x69,
    0x6f,
    0x72,
    0x61,
    0x72,
    0x69,
    0x52,
    0x65,
    0x6c,
    0x61,
    0x74,
    0x69,
    0x6f,
    0x6e,
    0x73,
    0x68,
    0x69,
    0x70,
    0x73,
    0x80,
    0x01,
    0x0d,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x41,
    0x46,
    0x46,
    0x49,
    0x52,
    0x4d,
    0x45,
    0x44,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x08,
    0x52,
    0x45,
    0x56,
    0x45,
    0x52,
    0x53,
    0x45,
    0x44,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x12,
    0x50,
    0x41,
    0x52,
    0x54,
    0x49,
    0x41,
    0x4c,
    0x4c,
    0x59,
    0x5f,
    0x52,
    0x45,
    0x56,
    0x45,
    0x52,
    0x53,
    0x45,
    0x44,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x43,
    0x45,
    0x52,
    0x54,
    0x5f,
    0x44,
    0x45,
    0x4e,
    0x49,
    0x45,
    0x44,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x56,
    0x41,
    0x43,
    0x41,
    0x54,
    0x45,
    0x44,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x11,
    0x4e,
    0x55,
    0x4d,
    0x5f,
    0x52,
    0x45,
    0x4c,
    0x41,
    0x54,
    0x49,
    0x4f,
    0x4e,
    0x53,
    0x48,
    0x49,
    0x50,
    0x53,
    0x98,
    0x01,
    0x05,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x0a,
    0x43,
    0x6f,
    0x75,
    0x72,
    0x74,
    0x4c,
    0x65,
    0x76,
    0x65,
    0x6c,
    0x80,
    0x01,
    0x14,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x55,
    0x4e,
    0x4b,
    0x4e,
    0x4f,
    0x57,
    0x4e,
    0x5f,
    0x43,
    0x4f,
    0x55,
    0x52,
    0x54,
    0x98,
    0x01,
    0x00,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x4c,
    0x4f,
    0x57,
    0x45,
    0x52,
    0x5f,
    0x43,
    0x4f,
    0x55,
    0x52,
    0x54,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x41,
    0x50,
    0x50,
    0x45,
    0x41,
    0x4c,
    0x53,
    0x5f,
    0x43,
    0x4f,
    0x55,
    0x52,
    0x54,
    0x98,
    0x01,
    0x0a,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0d,
    0x53,
    0x55,
    0x50,
    0x52,
    0x45,
    0x4d,
    0x45,
    0x5f,
    0x43,
    0x4f,
    0x55,
    0x52,
    0x54,
    0x98,
    0x01,
    0x64,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x0b,
    0x4f,
    0x70,
    0x69,
    0x6e,
    0x69,
    0x6f,
    0x6e,
    0x54,
    0x79,
    0x70,
    0x65,
    0x80,
    0x01,
    0x27,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x07,
    0x50,
    0x52,
    0x49,
    0x4d,
    0x41,
    0x52,
    0x59,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x44,
    0x49,
    0x53,
    0x53,
    0x45,
    0x4e,
    0x54,
    0x49,
    0x4e,
    0x47,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x43,
    0x4f,
    0x4e,
    0x43,
    0x55,
    0x52,
    0x52,
    0x49,
    0x4e,
    0x47,
    0x98,
    0x01,
    0x03,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x50,
    0x45,
    0x52,
    0x5f,
    0x43,
    0x55,
    0x52,
    0x49,
    0x41,
    0x4d,
    0x98,
    0x01,
    0x04,
    0x8c,
    0x01,
    0x74,
    0x73,
    0x7a,
    0x09,
    0x42,
    0x65,
    0x6e,
    0x63,
    0x68,
    0x54,
    0x79,
    0x70,
    0x65,
    0x80,
    0x01,
    0x27,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0b,
    0x50,
    0x41,
    0x4e,
    0x45,
    0x4c,
    0x5f,
    0x42,
    0x45,
    0x4e,
    0x43,
    0x48,
    0x98,
    0x01,
    0x01,
    0x8c,
    0x01,
    0x8b,
    0x01,
    0x92,
    0x01,
    0x0a,
    0x46,
    0x55,
    0x4c,
    0x4c,
    0x5f,
    0x42,
    0x45,
    0x4e,
    0x43,
    0x48,
    0x98,
    0x01,
    0x02,
    0x8c,
    0x01,
    0x74,
    ])
  _net_proto___parse__python.RegisterType(_SERIALIZED_DESCRIPTOR.tostring())

__all__ = ['LegalPerson','LegalDate','LegalCitation','LegalCitation_CourtDocumentPub','LegalCitation_CourtDocumentPerDocketInfo','LegalCitation_CourtDocumentCourt','LegalCitation_CourtDocumentOpinionInfo','LegalCitation_LawLevel','LegalCitation_CourtDocument','LegalCitation_Law']
